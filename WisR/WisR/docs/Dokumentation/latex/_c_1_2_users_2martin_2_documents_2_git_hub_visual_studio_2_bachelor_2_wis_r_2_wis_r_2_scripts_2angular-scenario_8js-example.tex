\hypertarget{_c_1_2_users_2martin_2_documents_2_git_hub_visual_studio_2_bachelor_2_wis_r_2_wis_r_2_scripts_2angular-scenario_8js-example}{}\section{C\+:/\+Users/martin/\+Documents/\+Git\+Hub\+Visual\+Studio/\+Bachelor/\+Wis\+R/\+Wis\+R/\+Scripts/angular-\/scenario.\+js}
$<$file name=\char`\"{}index.\+html\char`\"{}$>$  $<$form novalidate=\char`\"{}\char`\"{} class=\char`\"{}simple-\/form\char`\"{}$>$ Name\+: $<$input type=\char`\"{}text\char`\"{} ng-\/model=\char`\"{}user.\+name\char`\"{}$>$~\newline
 E-\/mail\+: $<$input type=\char`\"{}email\char`\"{} ng-\/model=\char`\"{}user.\+email\char`\"{}$>$~\newline
 Gender\+: $<$input type=\char`\"{}radio\char`\"{} ng-\/model=\char`\"{}user.\+gender\char`\"{} value=\char`\"{}male\char`\"{}$>$male $<$input type=\char`\"{}radio\char`\"{} ng-\/model=\char`\"{}user.\+gender\char`\"{} value=\char`\"{}female\char`\"{}$>$female~\newline
 $<$button ng-\/click=\char`\"{}reset()\char`\"{}$>$R\+E\+S\+E\+T$<$/button$>$ $<$button ng-\/click=\char`\"{}update(user)\char`\"{}$>$S\+A\+V\+E$<$/button$>$ $<$/form$>$ 
\begin{DoxyPre}form = \{\{user | json\}\}\end{DoxyPre}
 
\begin{DoxyPre}master = \{\{master | json\}\}\end{DoxyPre}
 

$<$script$>$ angular.\+module(\textquotesingle{}copy\+Example\textquotesingle{}, \mbox{[}\mbox{]}) .controller(\textquotesingle{}Example\+Controller\textquotesingle{}, \mbox{[}\textquotesingle{}\$scope\textquotesingle{}, function(\$scope) \{ \$scope.\+master= \{\};

\$scope.\+update = function(user) \{ // Example with 1 argument \$scope.\+master= angular.\+copy(user); \};

\$scope.\+reset = function() \{ // Example with 2 arguments angular.\+copy(\$scope.\+master, \$scope.\+user); \};

\$scope.\+reset(); \}\mbox{]}); $<$/script$>$ $<$/file$>$ 

$\ast$/ function copy(source, destination, stack\+Source, stack\+Dest) \{ if (is\+Window(source) $\vert$$\vert$ is\+Scope(source)) \{ throw ng\+Min\+Err(\textquotesingle{}cpws\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Making copies of Window or Scope instances is not supported.\char`\"{}); \} if (is\+Typed\+Array(destination)) \{ throw ng\+Min\+Err(\textquotesingle{}cpta\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Typed\+Array destination cannot be mutated.\char`\"{}); \}

if (!destination) \{ destination = source; if (is\+Object(source)) \{ var index; if (stack\+Source \&\& (index = stack\+Source.\+index\+Of(source)) !== -\/1) \{ return stack\+Dest\mbox{[}index\mbox{]}; \}

// Typed\+Array, Date and Reg\+Exp have specific copy functionality and must be // pushed onto the stack before returning. // Array and other objects create the base object and recurse to copy child // objects. The array/object will be pushed onto the stack when recursed. if (is\+Array(source)) \{ return copy(source, \mbox{[}$\,$\mbox{]}, stack\+Source, stack\+Dest); \} else if (is\+Typed\+Array(source)) \{ destination = new source.\+constructor(source); \} else if (is\+Date(source)) \{ destination = new Date(source.\+get\+Time()); \} else if (is\+Reg\+Exp(source)) \{ destination = new Reg\+Exp(source.\+source, source.\+to\+String().match(/\mbox{[}$^\wedge$\textbackslash{}/\mbox{]}$\ast$\$/)\mbox{[}0\mbox{]}); destination.\+last\+Index = source.\+last\+Index; \} else \{ var empty\+Object = Object.\+create(get\+Prototype\+Of(source)); return copy(source, empty\+Object, stack\+Source, stack\+Dest); \}

if (stack\+Dest) \{ stack\+Source.\+push(source); stack\+Dest.\+push(destination); \} \} \} else \{ if (source === destination) throw ng\+Min\+Err(\textquotesingle{}cpi\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Source and destination are identical.\char`\"{});

stack\+Source = stack\+Source $\vert$$\vert$ \mbox{[}\mbox{]}; stack\+Dest = stack\+Dest $\vert$$\vert$ \mbox{[}\mbox{]};

if (is\+Object(source)) \{ stack\+Source.\+push(source); stack\+Dest.\+push(destination); \}

var result, key; if (is\+Array(source)) \{ destination.\+length = 0; for (var i = 0; i $<$ source.\+length; i++) \{ destination.\+push(copy(source\mbox{[}i\mbox{]}, null, stack\+Source, stack\+Dest)); \} \} else \{ var h = destination.\$\$hash\+Key; if (is\+Array(destination)) \{ destination.\+length = 0; \} else \{ for\+Each(destination, function(value, key) \{ delete destination\mbox{[}key\mbox{]}; \}); \} if (is\+Blank\+Object(source)) \{ // create\+Map() fast path --- Safe to avoid has\+Own\+Property check because prototype chain is empty for (key in source) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} else if (source \&\& typeof source.\+has\+Own\+Property === \textquotesingle{}function\textquotesingle{}) \{ // Slow path, which must rely on has\+Own\+Property for (key in source) \{ if (source.\+has\+Own\+Property(key)) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} \} else \{ // Slowest path --- has\+Own\+Property can\textquotesingle{}t be called as a method for (key in source) \{ if (has\+Own\+Property.\+call(source, key)) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} \} set\+Hash\+Key(destination,h); \} \} return destination; \}

/$\ast$$\ast$ Creates a shallow copy of an object, an array or a primitive.

Assumes that there are no proto properties for objects. $\ast$/ function shallow\+Copy(src, dst) \{ if (is\+Array(src)) \{ dst = dst $\vert$$\vert$ \mbox{[}\mbox{]};

for (var i = 0, ii = src.\+length; i $<$ ii; i++) \{ dst\mbox{[}i\mbox{]} = src\mbox{[}i\mbox{]}; \} \} else if (is\+Object(src)) \{ dst = dst $\vert$$\vert$ \{\};

for (var key in src) \{ if (!(key.\+char\+At(0) === \textquotesingle{}\$\textquotesingle{} \&\& key.\+char\+At(1) === \textquotesingle{}\$\textquotesingle{})) \{ dst\mbox{[}key\mbox{]} = src\mbox{[}key\mbox{]}; \} \} \}

return dst $\vert$$\vert$ src; \}

/$\ast$$\ast$  function


\begin{DoxyCodeInclude}

(\textcolor{keyword}{function}( global, factory ) \{\textcolor{stringliteral}{'use strict'};

    \textcolor{keywordflow}{if} ( typeof module === \textcolor{stringliteral}{"object"} && typeof module.exports === \textcolor{stringliteral}{"object"} ) \{
        \textcolor{comment}{// For CommonJS and CommonJS-like environments where a proper window is present,}
        \textcolor{comment}{// execute the factory and get jQuery}
        \textcolor{comment}{// For environments that do not inherently posses a window with a document}
        \textcolor{comment}{// (such as Node.js), expose a jQuery-making factory as module.exports}
        \textcolor{comment}{// This accentuates the need for the creation of a real window}
        \textcolor{comment}{// e.g. var jQuery = require("jquery")(window);}
        \textcolor{comment}{// See ticket #14549 for more info}
        module.exports = global.document ?
            factory( global, \textcolor{keyword}{true} ) :
            \textcolor{keyword}{function}( w ) \{
                \textcolor{keywordflow}{if} ( !w.document ) \{
                    \textcolor{keywordflow}{throw} \textcolor{keyword}{new} Error( \textcolor{stringliteral}{"jQuery requires a window with a document"} );
                \}
                \textcolor{keywordflow}{return} factory( w );
            \};
    \} \textcolor{keywordflow}{else} \{
        factory( global );
    \}

\textcolor{comment}{// Pass this if window is not defined yet}
\}(typeof window !== \textcolor{stringliteral}{"undefined"} ? window : \textcolor{keyword}{this}, \textcolor{keyword}{function}( window, noGlobal ) \{

\textcolor{comment}{// Can't do this because several apps including ASP.NET trace}
\textcolor{comment}{// the stack via arguments.caller.callee and Firefox dies if}
\textcolor{comment}{// you try to trace through "use strict" call chains. (#13335)}
\textcolor{comment}{// Support: Firefox 18+}
\textcolor{comment}{//}

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = \{\};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = \{\};



var
    \textcolor{comment}{// Use the correct document accordingly with window argument (sandbox)}
    document = window.document,

    version = \textcolor{stringliteral}{"2.1.1"},

    \textcolor{comment}{// Define a local copy of jQuery}
    jQuery = \textcolor{keyword}{function}( selector, context ) \{
        \textcolor{comment}{// The jQuery object is actually just the init constructor 'enhanced'}
        \textcolor{comment}{// Need init if jQuery is called (just allow error to be thrown if not included)}
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} jQuery.fn.init( selector, context );
    \},

    \textcolor{comment}{// Support: Android<4.1}
    \textcolor{comment}{// Make sure we trim BOM and NBSP}
    rtrim = /^[\(\backslash\)s\(\backslash\)uFEFF\(\backslash\)xA0]+|[\(\backslash\)s\(\backslash\)uFEFF\(\backslash\)xA0]+$/g,

    \textcolor{comment}{// Matches dashed string for camelizing}
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\(\backslash\)da-z])/gi,

    \textcolor{comment}{// Used by jQuery.camelCase as callback to replace()}
    fcamelCase = \textcolor{keyword}{function}( all, letter ) \{
        \textcolor{keywordflow}{return} letter.toUpperCase();
    \};

jQuery.fn = jQuery.prototype = \{
    \textcolor{comment}{// The current version of jQuery being used}
    jquery: version,

    constructor: jQuery,

    \textcolor{comment}{// Start with an empty selector}
    selector: \textcolor{stringliteral}{""},

    \textcolor{comment}{// The default length of a jQuery object is 0}
    length: 0,

    toArray: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} slice.call( \textcolor{keyword}{this} );
    \},

    \textcolor{comment}{// Get the Nth element in the matched element set OR}
    \textcolor{comment}{// Get the whole matched element set as a clean array}
    \textcolor{keyword}{get}: \textcolor{keyword}{function}( num ) \{
        \textcolor{keywordflow}{return} num != null ?

            \textcolor{comment}{// Return just the one element from the set}
            ( num < 0 ? \textcolor{keyword}{this}[ num + this.length ] : \textcolor{keyword}{this}[ num ] ) :

            \textcolor{comment}{// Return all the elements in a clean array}
            slice.call( \textcolor{keyword}{this} );
    \},

    \textcolor{comment}{// Take an array of elements and push it onto the stack}
    \textcolor{comment}{// (returning the new matched element set)}
    pushStack: \textcolor{keyword}{function}( elems ) \{

        \textcolor{comment}{// Build a new jQuery matched element set}
        var ret = jQuery.merge( this.constructor(), elems );

        \textcolor{comment}{// Add the old object onto the stack (as a reference)}
        ret.prevObject = \textcolor{keyword}{this};
        ret.context = this.context;

        \textcolor{comment}{// Return the newly-formed element set}
        \textcolor{keywordflow}{return} ret;
    \},

    \textcolor{comment}{// Execute a callback for every element in the matched set.}
    \textcolor{comment}{// (You can seed the arguments with an array of args, but this is}
    \textcolor{comment}{// only used internally.)}
    each: \textcolor{keyword}{function}( callback, args ) \{
        \textcolor{keywordflow}{return} jQuery.each( \textcolor{keyword}{this}, callback, args );
    \},

    map: \textcolor{keyword}{function}( callback ) \{
        \textcolor{keywordflow}{return} this.pushStack( jQuery.map(\textcolor{keyword}{this}, \textcolor{keyword}{function}( elem, i ) \{
            return callback.call( elem, i, elem );
        \}));
    \},

    slice: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.pushStack( slice.apply( \textcolor{keyword}{this}, arguments ) );
    \},

    first: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.eq( 0 );
    \},

    last: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.eq( -1 );
    \},

    eq: \textcolor{keyword}{function}( i ) \{
        var len = this.length,
            j = +i + ( i < 0 ? len : 0 );
        \textcolor{keywordflow}{return} this.pushStack( j >= 0 && j < len ? [ \textcolor{keyword}{this}[j] ] : [] );
    \},

    end: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.prevObject || this.constructor(null);
    \},

    \textcolor{comment}{// For internal use only.}
    \textcolor{comment}{// Behaves like an Array's method, not like a jQuery method.}
    push: push,
    sort: arr.sort,
    splice: arr.splice
\};

jQuery.extend = jQuery.fn.extend = \textcolor{keyword}{function}() \{
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || \{\},
        i = 1,
        length = arguments.length,
        deep = \textcolor{keyword}{false};

    \textcolor{comment}{// Handle a deep copy situation}
    \textcolor{keywordflow}{if} ( typeof target === \textcolor{stringliteral}{"boolean"} ) \{
        deep = target;

        \textcolor{comment}{// skip the boolean and the target}
        target = arguments[ i ] || \{\};
        i++;
    \}

    \textcolor{comment}{// Handle case when target is a string or something (possible in deep copy)}
    \textcolor{keywordflow}{if} ( typeof target !== \textcolor{stringliteral}{"object"} && !jQuery.isFunction(target) ) \{
        target = \{\};
    \}

    \textcolor{comment}{// extend jQuery itself if only one argument is passed}
    \textcolor{keywordflow}{if} ( i === length ) \{
        target = \textcolor{keyword}{this};
        i--;
    \}

    \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
        \textcolor{comment}{// Only deal with non-null/undefined values}
        \textcolor{keywordflow}{if} ( (options = arguments[ i ]) != null ) \{
            \textcolor{comment}{// Extend the base object}
            \textcolor{keywordflow}{for} ( name in options ) \{
                src = target[ name ];
                copy = options[ name ];

                \textcolor{comment}{// Prevent never-ending loop}
                \textcolor{keywordflow}{if} ( target === copy ) \{
                    \textcolor{keywordflow}{continue};
                \}

                \textcolor{comment}{// Recurse if we're merging plain objects or arrays}
                \textcolor{keywordflow}{if} ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) )
       ) \{
                    \textcolor{keywordflow}{if} ( copyIsArray ) \{
                        copyIsArray = \textcolor{keyword}{false};
                        clone = src && jQuery.isArray(src) ? src : [];

                    \} \textcolor{keywordflow}{else} \{
                        clone = src && jQuery.isPlainObject(src) ? src : \{\};
                    \}

                    \textcolor{comment}{// Never move original objects, clone them}
                    target[ name ] = jQuery.extend( deep, clone, copy );

                \textcolor{comment}{// Don't bring in undefined values}
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( copy !== undefined ) \{
                    target[ name ] = copy;
                \}
            \}
        \}
    \}

    \textcolor{comment}{// Return the modified object}
    \textcolor{keywordflow}{return} target;
\};

jQuery.extend(\{
    \textcolor{comment}{// Unique for each copy of jQuery on the page}
    expando: \textcolor{stringliteral}{"jQuery"} + ( version + Math.random() ).replace( /\(\backslash\)D/g, \textcolor{stringliteral}{""} ),

    \textcolor{comment}{// Assume jQuery is ready without the ready module}
    isReady: \textcolor{keyword}{true},

    error: \textcolor{keyword}{function}( msg ) \{
        \textcolor{keywordflow}{throw} \textcolor{keyword}{new} Error( msg );
    \},

    noop: \textcolor{keyword}{function}() \{\},

    \textcolor{comment}{// See test/unit/core.js for details concerning isFunction.}
    \textcolor{comment}{// Since version 1.3, DOM methods and functions like alert}
    \textcolor{comment}{// aren't supported. They return false on IE (#2968).}
    isFunction: \textcolor{keyword}{function}( obj ) \{
        \textcolor{keywordflow}{return} jQuery.type(obj) === \textcolor{stringliteral}{"function"};
    \},

    isArray: Array.isArray,

    isWindow: \textcolor{keyword}{function}( obj ) \{
        \textcolor{keywordflow}{return} obj != null && obj === obj.window;
    \},

    isNumeric: \textcolor{keyword}{function}( obj ) \{
        \textcolor{comment}{// parseFloat NaNs numeric-cast false positives (null|true|false|"")}
        \textcolor{comment}{// ...but misinterprets leading-number strings, particularly hex literals ("0x...")}
        \textcolor{comment}{// subtraction forces infinities to NaN}
        \textcolor{keywordflow}{return} !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
    \},

    isPlainObject: \textcolor{keyword}{function}( obj ) \{
        \textcolor{comment}{// Not plain objects:}
        \textcolor{comment}{// - Any object or value whose internal [[Class]] property is not "[object Object]"}
        \textcolor{comment}{// - DOM nodes}
        \textcolor{comment}{// - window}
        \textcolor{keywordflow}{if} ( jQuery.type( obj ) !== \textcolor{stringliteral}{"object"} || obj.nodeType || jQuery.isWindow( obj ) ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{keywordflow}{if} ( obj.constructor &&
                !hasOwn.call( obj.constructor.prototype, \textcolor{stringliteral}{"isPrototypeOf"} ) ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{comment}{// If the function hasn't returned already, we're confident that}
        \textcolor{comment}{// |obj| is a plain object, created by \{\} or constructed with new Object}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \},

    isEmptyObject: \textcolor{keyword}{function}( obj ) \{
        var name;
        \textcolor{keywordflow}{for} ( name in obj ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \},

    type: \textcolor{keyword}{function}( obj ) \{
        \textcolor{keywordflow}{if} ( obj == null ) \{
            \textcolor{keywordflow}{return} obj + \textcolor{stringliteral}{""};
        \}
        \textcolor{comment}{// Support: Android < 4.0, iOS < 6 (functionish RegExp)}
        \textcolor{keywordflow}{return} typeof obj === \textcolor{stringliteral}{"object"} || typeof obj === \textcolor{stringliteral}{"function"} ?
            class2type[ toString.call(obj) ] || \textcolor{stringliteral}{"object"} :
            typeof obj;
    \},

    \textcolor{comment}{// Evaluates a script in a global context}
    globalEval: \textcolor{keyword}{function}( code ) \{
        var script,
            indirect = eval;

        code = jQuery.trim( code );

        \textcolor{keywordflow}{if} ( code ) \{
            \textcolor{comment}{// If the code includes a valid, prologue position}
            \textcolor{comment}{// strict mode pragma, execute code by injecting a}
            \textcolor{comment}{// script tag into the document.}
            \textcolor{keywordflow}{if} ( code.indexOf(\textcolor{stringliteral}{"use strict"}) === 1 ) \{
                script = document.createElement(\textcolor{stringliteral}{"script"});
                script.text = code;
                document.head.appendChild( script ).parentNode.removeChild( script );
            \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// Otherwise, avoid the DOM node creation, insertion}
            \textcolor{comment}{// and removal by using an indirect global eval}
                indirect( code );
            \}
        \}
    \},

    \textcolor{comment}{// Convert dashed to camelCase; used by the css and data modules}
    \textcolor{comment}{// Microsoft forgot to hump their vendor prefix (#9572)}
    camelCase: \textcolor{keyword}{function}( string ) \{
        \textcolor{keywordflow}{return} \textcolor{keywordtype}{string}.replace( rmsPrefix, \textcolor{stringliteral}{"ms-"} ).replace( rdashAlpha, fcamelCase );
    \},

    nodeName: \textcolor{keyword}{function}( elem, name ) \{
        \textcolor{keywordflow}{return} elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    \},

    \textcolor{comment}{// args is for internal usage only}
    each: \textcolor{keyword}{function}( obj, callback, args ) \{
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

        \textcolor{keywordflow}{if} ( args ) \{
            \textcolor{keywordflow}{if} ( isArray ) \{
                \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
                    value = callback.apply( obj[ i ], args );

                    \textcolor{keywordflow}{if} ( value === \textcolor{keyword}{false} ) \{
                        \textcolor{keywordflow}{break};
                    \}
                \}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{for} ( i in obj ) \{
                    value = callback.apply( obj[ i ], args );

                    \textcolor{keywordflow}{if} ( value === \textcolor{keyword}{false} ) \{
                        \textcolor{keywordflow}{break};
                    \}
                \}
            \}

        \textcolor{comment}{// A special, fast, case for the most common use of each}
        \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} ( isArray ) \{
                \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    \textcolor{keywordflow}{if} ( value === \textcolor{keyword}{false} ) \{
                        \textcolor{keywordflow}{break};
                    \}
                \}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{for} ( i in obj ) \{
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    \textcolor{keywordflow}{if} ( value === \textcolor{keyword}{false} ) \{
                        \textcolor{keywordflow}{break};
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} obj;
    \},

    \textcolor{comment}{// Support: Android<4.1}
    trim: \textcolor{keyword}{function}( text ) \{
        \textcolor{keywordflow}{return} text == null ?
            \textcolor{stringliteral}{""} :
            ( text + \textcolor{stringliteral}{""} ).replace( rtrim, \textcolor{stringliteral}{""} );
    \},

    \textcolor{comment}{// results is for internal usage only}
    makeArray: \textcolor{keyword}{function}( arr, results ) \{
        var ret = results || [];

        \textcolor{keywordflow}{if} ( arr != null ) \{
            \textcolor{keywordflow}{if} ( isArraylike( Object(arr) ) ) \{
                jQuery.merge( ret,
                    typeof arr === \textcolor{stringliteral}{"string"} ?
                    [ arr ] : arr
                );
            \} \textcolor{keywordflow}{else} \{
                push.call( ret, arr );
            \}
        \}

        \textcolor{keywordflow}{return} ret;
    \},

    inArray: \textcolor{keyword}{function}( elem, arr, i ) \{
        \textcolor{keywordflow}{return} arr == null ? -1 : indexOf.call( arr, elem, i );
    \},

    merge: \textcolor{keyword}{function}( first, second ) \{
        var len = +second.length,
            j = 0,
            i = first.length;

        \textcolor{keywordflow}{for} ( ; j < len; j++ ) \{
            first[ i++ ] = second[ j ];
        \}

        first.length = i;

        \textcolor{keywordflow}{return} first;
    \},

    grep: \textcolor{keyword}{function}( elems, callback, invert ) \{
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

        \textcolor{comment}{// Go through the array, only saving the items}
        \textcolor{comment}{// that pass the validator function}
        \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
            callbackInverse = !callback( elems[ i ], i );
            \textcolor{keywordflow}{if} ( callbackInverse !== callbackExpect ) \{
                matches.push( elems[ i ] );
            \}
        \}

        \textcolor{keywordflow}{return} matches;
    \},

    \textcolor{comment}{// arg is for internal usage only}
    map: \textcolor{keyword}{function}( elems, callback, arg ) \{
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        \textcolor{comment}{// Go through the array, translating each of the items to their new values}
        \textcolor{keywordflow}{if} ( isArray ) \{
            \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
                value = callback( elems[ i ], i, arg );

                \textcolor{keywordflow}{if} ( value != null ) \{
                    ret.push( value );
                \}
            \}

        \textcolor{comment}{// Go through every key on the object,}
        \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{for} ( i in elems ) \{
                value = callback( elems[ i ], i, arg );

                \textcolor{keywordflow}{if} ( value != null ) \{
                    ret.push( value );
                \}
            \}
        \}

        \textcolor{comment}{// Flatten any nested arrays}
        \textcolor{keywordflow}{return} concat.apply( [], ret );
    \},

    \textcolor{comment}{// A global GUID counter for objects}
    guid: 1,

    \textcolor{comment}{// Bind a function to a context, optionally partially applying any}
    \textcolor{comment}{// arguments.}
    proxy: \textcolor{keyword}{function}( fn, context ) \{
        var tmp, args, proxy;

        \textcolor{keywordflow}{if} ( typeof context === \textcolor{stringliteral}{"string"} ) \{
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        \}

        \textcolor{comment}{// Quick check to determine if target is callable, in the spec}
        \textcolor{comment}{// this throws a TypeError, but we will just return undefined.}
        \textcolor{keywordflow}{if} ( !jQuery.isFunction( fn ) ) \{
            \textcolor{keywordflow}{return} undefined;
        \}

        \textcolor{comment}{// Simulated bind}
        args = slice.call( arguments, 2 );
        proxy = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} fn.apply( context || \textcolor{keyword}{this}, args.concat( slice.call( arguments ) ) );
        \};

        \textcolor{comment}{// Set the guid of unique handler to the same of original handler, so it can be removed}
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        \textcolor{keywordflow}{return} proxy;
    \},

    now: Date.now,

    \textcolor{comment}{// jQuery.support is not used in Core but other projects attach their}
    \textcolor{comment}{// properties to it so it needs to exist.}
    support: support
\});

\textcolor{comment}{// Populate the class2type map}
jQuery.each(\textcolor{stringliteral}{"Boolean Number String Function Array Date RegExp Object Error"}.split(\textcolor{stringliteral}{" "}), \textcolor{keyword}{function}(i, name) \{
    class2type[ \textcolor{stringliteral}{"[object "} + name + \textcolor{stringliteral}{"]"} ] = name.toLowerCase();
\});

\textcolor{keyword}{function} isArraylike( obj ) \{
    var length = obj.length,
        type = jQuery.type( obj );

    \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"function"} || jQuery.isWindow( obj ) ) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}

    \textcolor{keywordflow}{if} ( obj.nodeType === 1 && length ) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    \textcolor{keywordflow}{return} type === \textcolor{stringliteral}{"array"} || length === 0 ||
        typeof length === \textcolor{stringliteral}{"number"} && length > 0 && ( length - 1 ) in obj;
\}
var Sizzle =
(\textcolor{keyword}{function}( window ) \{

var i,
    support,
    Expr,
    getText,
    isXML,
    tokenize,
    compile,
    select,
    outermostContext,
    sortInput,
    hasDuplicate,

    \textcolor{comment}{// Local document vars}
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,

    \textcolor{comment}{// Instance-specific data}
    expando = \textcolor{stringliteral}{"sizzle"} + -(\textcolor{keyword}{new} Date()),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    sortOrder = \textcolor{keyword}{function}( a, b ) \{
        \textcolor{keywordflow}{if} ( a === b ) \{
            hasDuplicate = \textcolor{keyword}{true};
        \}
        \textcolor{keywordflow}{return} 0;
    \},

    \textcolor{comment}{// General-purpose constants}
    strundefined = typeof undefined,
    MAX\_NEGATIVE = 1 << 31,

    \textcolor{comment}{// Instance methods}
    hasOwn = (\{\}).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push\_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    \textcolor{comment}{// Use a stripped-down indexOf if we can't use a native one}
    indexOf = arr.indexOf || \textcolor{keyword}{function}( elem ) \{
        var i = 0,
            len = this.length;
        \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
            \textcolor{keywordflow}{if} ( \textcolor{keyword}{this}[i] === elem ) \{
                \textcolor{keywordflow}{return} i;
            \}
        \}
        \textcolor{keywordflow}{return} -1;
    \},

    booleans = \textcolor{stringliteral}{"
      checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped"},

    \textcolor{comment}{// Regular expressions}

    \textcolor{comment}{// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace}
    whitespace = \textcolor{stringliteral}{"[\(\backslash\)\(\backslash\)x20\(\backslash\)\(\backslash\)t\(\backslash\)\(\backslash\)r\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)f]"},
    \textcolor{comment}{// http://www.w3.org/TR/css3-syntax/#characters}
    characterEncoding = \textcolor{stringliteral}{"(?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[\(\backslash\)\(\backslash\)w-]|[^\(\backslash\)\(\backslash\)x00-\(\backslash\)\(\backslash\)xa0])+"},

    \textcolor{comment}{// Loosely modeled on CSS identifier characters}
    \textcolor{comment}{// An unquoted value should be a CSS identifier
       http://www.w3.org/TR/css3-selectors/#attribute-selectors}
    \textcolor{comment}{// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier}
    identifier = characterEncoding.replace( \textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"w#"} ),

    \textcolor{comment}{// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors}
    attributes = \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)["} + whitespace + \textcolor{stringliteral}{"*("} + characterEncoding + \textcolor{stringliteral}{")(?:"} + whitespace +
        \textcolor{comment}{// Operator (capture 2)}
        \textcolor{stringliteral}{"*([*^$|!~]?=)"} + whitespace +
        \textcolor{comment}{// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"}
        \textcolor{stringliteral}{"*(?:'((?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)'])*)'|\(\backslash\)"((?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"])*)\(\backslash\)"|("} + identifier + \textcolor{stringliteral}{"))|)"} + whitespace +
        \textcolor{stringliteral}{"*\(\backslash\)\(\backslash\)]"},

    pseudos = \textcolor{stringliteral}{":("} + characterEncoding + \textcolor{stringliteral}{")(?:\(\backslash\)\(\backslash\)(("} +
        \textcolor{comment}{// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:}
        \textcolor{comment}{// 1. quoted (capture 3; capture 4 or capture 5)}
        \textcolor{stringliteral}{"('((?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)'])*)'|\(\backslash\)"((?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"])*)\(\backslash\)")|"} +
        \textcolor{comment}{// 2. simple (capture 6)}
        \textcolor{stringliteral}{"((?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)()[\(\backslash\)\(\backslash\)]]|"} + attributes + \textcolor{stringliteral}{")*)|"} +
        \textcolor{comment}{// 3. anything else (capture 2)}
        \textcolor{stringliteral}{".*"} +
        \textcolor{stringliteral}{")\(\backslash\)\(\backslash\))|)"},

    \textcolor{comment}{// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the
       latter}
    rtrim = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + whitespace + \textcolor{stringliteral}{"+|((?:^|[^\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)])(?:\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\).)*)"} + whitespace + \textcolor{stringliteral}{"+$"}, \textcolor{stringliteral}{"g"} ),

    rcomma = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + whitespace + \textcolor{stringliteral}{"*,"} + whitespace + \textcolor{stringliteral}{"*"} ),
    rcombinators = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + whitespace + \textcolor{stringliteral}{"*([>+~]|"} + whitespace + \textcolor{stringliteral}{")"} + whitespace + \textcolor{stringliteral}{"*"} ),

    rattributeQuotes = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"="} + whitespace + \textcolor{stringliteral}{"*([^\(\backslash\)\(\backslash\)]'\(\backslash\)"]*?)"} + whitespace + \textcolor{stringliteral}{"*\(\backslash\)\(\backslash\)]"}, \textcolor{stringliteral}{"g"} ),

    rpseudo = \textcolor{keyword}{new} RegExp( pseudos ),
    ridentifier = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + identifier + \textcolor{stringliteral}{"$"} ),

    matchExpr = \{
        \textcolor{stringliteral}{"ID"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^#("} + characterEncoding + \textcolor{stringliteral}{")"} ),
        \textcolor{stringliteral}{"CLASS"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^\(\backslash\)\(\backslash\).("} + characterEncoding + \textcolor{stringliteral}{")"} ),
        \textcolor{stringliteral}{"TAG"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^("} + characterEncoding.replace( \textcolor{stringliteral}{"w"}, \textcolor{stringliteral}{"w*"} ) + \textcolor{stringliteral}{")"} ),
        \textcolor{stringliteral}{"ATTR"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + attributes ),
        \textcolor{stringliteral}{"PSEUDO"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + pseudos ),
        \textcolor{stringliteral}{"CHILD"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\(\backslash\)\(\backslash\)("} + whitespace +
            \textcolor{stringliteral}{"*(even|odd|(([+-]|)(\(\backslash\)\(\backslash\)d*)n|)"} + whitespace + \textcolor{stringliteral}{"*(?:([+-]|)"} + whitespace +
            \textcolor{stringliteral}{"*(\(\backslash\)\(\backslash\)d+)|))"} + whitespace + \textcolor{stringliteral}{"*\(\backslash\)\(\backslash\))|)"}, \textcolor{stringliteral}{"i"} ),
        \textcolor{stringliteral}{"bool"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^(?:"} + booleans + \textcolor{stringliteral}{")$"}, \textcolor{stringliteral}{"i"} ),
        \textcolor{comment}{// For use in libraries implementing .is()}
        \textcolor{comment}{// We use this for POS matching in `select`}
        \textcolor{stringliteral}{"needsContext"}: \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^"} + whitespace + \textcolor{stringliteral}{"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\(\backslash\)\(\backslash\)("} +
            whitespace + \textcolor{stringliteral}{"*((?:-\(\backslash\)\(\backslash\)d)?\(\backslash\)\(\backslash\)d*)"} + whitespace + \textcolor{stringliteral}{"*\(\backslash\)\(\backslash\))|)(?=[^-]|$)"}, \textcolor{stringliteral}{"i"} )
    \},

    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\(\backslash\)d$/i,

    rnative = /^[^\{]+\(\backslash\)\{\(\backslash\)s*\(\backslash\)[native \(\backslash\)w/,

    \textcolor{comment}{// Easily-parseable/retrievable ID or TAG or CLASS selectors}
    rquickExpr = /^(?:#([\(\backslash\)w-]+)|(\(\backslash\)w+)|\(\backslash\).([\(\backslash\)w-]+))$/,

    rsibling = /[+~]/,
    rescape = /\textcolor{stringliteral}{'|\(\backslash\)\(\backslash\)/g,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters}
\textcolor{stringliteral}{    runescape = new RegExp( "\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)([\(\backslash\)\(\backslash\)da-f]\{1,6\}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),}
\textcolor{stringliteral}{    funescape = function( \_, escaped, escapedWhitespace ) \{}
\textcolor{stringliteral}{        var high = "0x" + escaped - 0x10000;}
\textcolor{stringliteral}{        // NaN means non-codepoint}
\textcolor{stringliteral}{        // Support: Firefox<24}
\textcolor{stringliteral}{        // Workaround erroneous numeric interpretation of +"0x"}
\textcolor{stringliteral}{        return high !== high || escapedWhitespace ?}
\textcolor{stringliteral}{            escaped :}
\textcolor{stringliteral}{            high < 0 ?}
\textcolor{stringliteral}{                // BMP codepoint}
\textcolor{stringliteral}{                String.fromCharCode( high + 0x10000 ) :}
\textcolor{stringliteral}{                // Supplemental Plane codepoint (surrogate pair)}
\textcolor{stringliteral}{                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );}
\textcolor{stringliteral}{    \};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{// Optimize for push.apply( \_, NodeList )}
\textcolor{stringliteral}{try \{}
\textcolor{stringliteral}{    push.apply(}
\textcolor{stringliteral}{        (arr = slice.call( preferredDoc.childNodes )),}
\textcolor{stringliteral}{        preferredDoc.childNodes}
\textcolor{stringliteral}{    );}
\textcolor{stringliteral}{    // Support: Android<4.0}
\textcolor{stringliteral}{    // Detect silently failing push.apply}
\textcolor{stringliteral}{    arr[ preferredDoc.childNodes.length ].nodeType;}
\textcolor{stringliteral}{\} catch ( e ) \{}
\textcolor{stringliteral}{    push = \{ apply: arr.length ?}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{        // Leverage slice if possible}
\textcolor{stringliteral}{        function( target, els ) \{}
\textcolor{stringliteral}{            push\_native.apply( target, slice.call(els) );}
\textcolor{stringliteral}{        \} :}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{        // Support: IE<9}
\textcolor{stringliteral}{        // Otherwise append directly}
\textcolor{stringliteral}{        function( target, els ) \{}
\textcolor{stringliteral}{            var j = target.length,}
\textcolor{stringliteral}{                i = 0;}
\textcolor{stringliteral}{            // Can'}t trust NodeList.length
            \textcolor{keywordflow}{while} ( (target[j++] = els[i++]) ) \{\}
            target.length = j - 1;
        \}
    \};
\}

\textcolor{keyword}{function} Sizzle( selector, context, results, seed ) \{
    var match, elem, m, nodeType,
        \textcolor{comment}{// QSA vars}
        i, groups, old, nid, newContext, newSelector;

    \textcolor{keywordflow}{if} ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) \{
        setDocument( context );
    \}

    context = context || document;
    results = results || [];

    \textcolor{keywordflow}{if} ( !selector || typeof selector !== \textcolor{stringliteral}{"string"} ) \{
        \textcolor{keywordflow}{return} results;
    \}

    \textcolor{keywordflow}{if} ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) \{
        \textcolor{keywordflow}{return} [];
    \}

    \textcolor{keywordflow}{if} ( documentIsHTML && !seed ) \{

        \textcolor{comment}{// Shortcuts}
        \textcolor{keywordflow}{if} ( (match = rquickExpr.exec( selector )) ) \{
            \textcolor{comment}{// Speed-up: Sizzle("#ID")}
            \textcolor{keywordflow}{if} ( (m = match[1]) ) \{
                \textcolor{keywordflow}{if} ( nodeType === 9 ) \{
                    elem = context.getElementById( m );
                    \textcolor{comment}{// Check parentNode to catch when Blackberry 4.6 returns}
                    \textcolor{comment}{// nodes that are no longer in the document (jQuery #6963)}
                    \textcolor{keywordflow}{if} ( elem && elem.parentNode ) \{
                        \textcolor{comment}{// Handle the case where IE, Opera, and Webkit return items}
                        \textcolor{comment}{// by name instead of ID}
                        \textcolor{keywordflow}{if} ( elem.id === m ) \{
                            results.push( elem );
                            \textcolor{keywordflow}{return} results;
                        \}
                    \} \textcolor{keywordflow}{else} \{
                        \textcolor{keywordflow}{return} results;
                    \}
                \} \textcolor{keywordflow}{else} \{
                    \textcolor{comment}{// Context is not a document}
                    \textcolor{keywordflow}{if} ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                        contains( context, elem ) && elem.id === m ) \{
                        results.push( elem );
                        \textcolor{keywordflow}{return} results;
                    \}
                \}

            \textcolor{comment}{// Speed-up: Sizzle("TAG")}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( match[2] ) \{
                push.apply( results, context.getElementsByTagName( selector ) );
                \textcolor{keywordflow}{return} results;

            \textcolor{comment}{// Speed-up: Sizzle(".CLASS")}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName 
      ) \{
                push.apply( results, context.getElementsByClassName( m ) );
                \textcolor{keywordflow}{return} results;
            \}
        \}

        \textcolor{comment}{// QSA path}
        \textcolor{keywordflow}{if} ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) \{
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 && selector;

            \textcolor{comment}{// qSA works strangely on Element-rooted queries}
            \textcolor{comment}{// We can work around this by specifying an extra ID on the root}
            \textcolor{comment}{// and working up from there (Thanks to Andrew Dupont for the technique)}
            \textcolor{comment}{// IE 8 doesn't work on object elements}
            \textcolor{keywordflow}{if} ( nodeType === 1 && context.nodeName.toLowerCase() !== \textcolor{stringliteral}{"object"} ) \{
                groups = tokenize( selector );

                \textcolor{keywordflow}{if} ( (old = context.getAttribute(\textcolor{stringliteral}{"id"})) ) \{
                    nid = old.replace( rescape, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)$&"} );
                \} \textcolor{keywordflow}{else} \{
                    context.setAttribute( \textcolor{stringliteral}{"id"}, nid );
                \}
                nid = \textcolor{stringliteral}{"[id='"} + nid + \textcolor{stringliteral}{"'] "};

                i = groups.length;
                \textcolor{keywordflow}{while} ( i-- ) \{
                    groups[i] = nid + toSelector( groups[i] );
                \}
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                newSelector = groups.join(\textcolor{stringliteral}{","});
            \}

            \textcolor{keywordflow}{if} ( newSelector ) \{
                \textcolor{keywordflow}{try} \{
                    push.apply( results,
                        newContext.querySelectorAll( newSelector )
                    );
                    \textcolor{keywordflow}{return} results;
                \} \textcolor{keywordflow}{catch}(qsaError) \{
                \} \textcolor{keywordflow}{finally} \{
                    \textcolor{keywordflow}{if} ( !old ) \{
                        context.removeAttribute(\textcolor{stringliteral}{"id"});
                    \}
                \}
            \}
        \}
    \}

    \textcolor{comment}{// All others}
    \textcolor{keywordflow}{return} select( selector.replace( rtrim, \textcolor{stringliteral}{"$1"} ), context, results, seed );
\}

\textcolor{keyword}{function} createCache() \{
    var keys = [];

    \textcolor{keyword}{function} cache( key, value ) \{
        \textcolor{comment}{// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)}
        \textcolor{keywordflow}{if} ( keys.push( key + \textcolor{stringliteral}{" "} ) > Expr.cacheLength ) \{
            \textcolor{comment}{// Only keep the most recent entries}
            \textcolor{keyword}{delete} cache[ keys.shift() ];
        \}
        \textcolor{keywordflow}{return} (cache[ key + \textcolor{stringliteral}{" "} ] = value);
    \}
    \textcolor{keywordflow}{return} cache;
\}

\textcolor{keyword}{function} markFunction( fn ) \{
    fn[ expando ] = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} fn;
\}

\textcolor{keyword}{function} assert( fn ) \{
    var div = document.createElement(\textcolor{stringliteral}{"div"});

    \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{return} !!fn( div );
    \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{finally} \{
        \textcolor{comment}{// Remove from its parent by default}
        \textcolor{keywordflow}{if} ( div.parentNode ) \{
            div.parentNode.removeChild( div );
        \}
        \textcolor{comment}{// release memory in IE}
        div = null;
    \}
\}

\textcolor{keyword}{function} addHandle( attrs, handler ) \{
    var arr = attrs.split(\textcolor{stringliteral}{"|"}),
        i = attrs.length;

    \textcolor{keywordflow}{while} ( i-- ) \{
        Expr.attrHandle[ arr[i] ] = handler;
    \}
\}

\textcolor{keyword}{function} siblingCheck( a, b ) \{
    var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
            ( ~b.sourceIndex || MAX\_NEGATIVE ) -
            ( ~a.sourceIndex || MAX\_NEGATIVE );

    \textcolor{comment}{// Use IE sourceIndex if available on both nodes}
    \textcolor{keywordflow}{if} ( diff ) \{
        \textcolor{keywordflow}{return} diff;
    \}

    \textcolor{comment}{// Check if b follows a}
    \textcolor{keywordflow}{if} ( cur ) \{
        \textcolor{keywordflow}{while} ( (cur = cur.nextSibling) ) \{
            \textcolor{keywordflow}{if} ( cur === b ) \{
                \textcolor{keywordflow}{return} -1;
            \}
        \}
    \}

    \textcolor{keywordflow}{return} a ? 1 : -1;
\}

\textcolor{keyword}{function} createInputPseudo( type ) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
        var name = elem.nodeName.toLowerCase();
        \textcolor{keywordflow}{return} name === \textcolor{stringliteral}{"input"} && elem.type === type;
    \};
\}

\textcolor{keyword}{function} createButtonPseudo( type ) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
        var name = elem.nodeName.toLowerCase();
        \textcolor{keywordflow}{return} (name === \textcolor{stringliteral}{"input"} || name === \textcolor{stringliteral}{"button"}) && elem.type === type;
    \};
\}

\textcolor{keyword}{function} createPositionalPseudo( fn ) \{
    \textcolor{keywordflow}{return} markFunction(\textcolor{keyword}{function}( argument ) \{
        argument = +argument;
        \textcolor{keywordflow}{return} markFunction(\textcolor{keyword}{function}( seed, matches ) \{
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            \textcolor{comment}{// Match elements found at the specified indexes}
            \textcolor{keywordflow}{while} ( i-- ) \{
                \textcolor{keywordflow}{if} ( seed[ (j = matchIndexes[i]) ] ) \{
                    seed[j] = !(matches[j] = seed[j]);
                \}
            \}
        \});
    \});
\}

\textcolor{keyword}{function} testContext( context ) \{
    \textcolor{keywordflow}{return} context && typeof context.getElementsByTagName !== strundefined && context;
\}

\textcolor{comment}{// Expose support vars for convenience}
support = Sizzle.support = \{\};

isXML = Sizzle.isXML = \textcolor{keyword}{function}( elem ) \{
    \textcolor{comment}{// documentElement is verified for cases where it doesn't yet exist}
    \textcolor{comment}{// (such as loading iframes in IE - #4833)}
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    \textcolor{keywordflow}{return} documentElement ? documentElement.nodeName !== \textcolor{stringliteral}{"HTML"} : \textcolor{keyword}{false};
\};

setDocument = Sizzle.setDocument = \textcolor{keyword}{function}( node ) \{
    var hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

    \textcolor{comment}{// If no document and documentElement is available, return}
    \textcolor{keywordflow}{if} ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) \{
        \textcolor{keywordflow}{return} document;
    \}

    \textcolor{comment}{// Set our document}
    document = doc;
    docElem = doc.documentElement;

    \textcolor{comment}{// Support tests}
    documentIsHTML = !isXML( doc );

    \textcolor{comment}{// Support: IE>8}
    \textcolor{comment}{// If iframe document is assigned to "document" variable and if iframe has been reloaded,}
    \textcolor{comment}{// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936}
    \textcolor{comment}{// IE6-8 do not support the defaultView property so parent will be undefined}
    \textcolor{keywordflow}{if} ( parent && parent !== parent.top ) \{
        \textcolor{comment}{// IE11 does not have attachEvent, so all must suffer}
        \textcolor{keywordflow}{if} ( parent.addEventListener ) \{
            parent.addEventListener( \textcolor{stringliteral}{"unload"}, \textcolor{keyword}{function}() \{
                setDocument();
            \}, false );
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( parent.attachEvent ) \{
            parent.attachEvent( \textcolor{stringliteral}{"onunload"}, \textcolor{keyword}{function}() \{
                setDocument();
            \});
        \}
    \}

    \textcolor{comment}{/* Attributes}
\textcolor{comment}{    ---------------------------------------------------------------------- */}

    \textcolor{comment}{// Support: IE<8}
    \textcolor{comment}{// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)}
    support.attributes = assert(\textcolor{keyword}{function}( div ) \{
        div.className = \textcolor{stringliteral}{"i"};
        \textcolor{keywordflow}{return} !div.getAttribute(\textcolor{stringliteral}{"className"});
    \});

    \textcolor{comment}{/* getElement(s)By*}
\textcolor{comment}{    ---------------------------------------------------------------------- */}

    \textcolor{comment}{// Check if getElementsByTagName("*") returns only elements}
    support.getElementsByTagName = assert(\textcolor{keyword}{function}( div ) \{
        div.appendChild( doc.createComment(\textcolor{stringliteral}{""}) );
        \textcolor{keywordflow}{return} !div.getElementsByTagName(\textcolor{stringliteral}{"*"}).length;
    \});

    \textcolor{comment}{// Check if getElementsByClassName can be trusted}
    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(\textcolor{keyword}{function}( div ) \{
        div.innerHTML = \textcolor{stringliteral}{"<div class='a'></div><div class='a i'></div>"};

        \textcolor{comment}{// Support: Safari<4}
        \textcolor{comment}{// Catch class over-caching}
        div.firstChild.className = \textcolor{stringliteral}{"i"};
        \textcolor{comment}{// Support: Opera<10}
        \textcolor{comment}{// Catch gEBCN failure to find non-leading classes}
        \textcolor{keywordflow}{return} div.getElementsByClassName(\textcolor{stringliteral}{"i"}).length === 2;
    \});

    \textcolor{comment}{// Support: IE<10}
    \textcolor{comment}{// Check if getElementById returns elements by name}
    \textcolor{comment}{// The broken getElementById methods don't pick up programatically-set names,}
    \textcolor{comment}{// so use a roundabout getElementsByName test}
    support.getById = assert(\textcolor{keyword}{function}( div ) \{
        docElem.appendChild( div ).id = expando;
        \textcolor{keywordflow}{return} !doc.getElementsByName || !doc.getElementsByName( expando ).length;
    \});

    \textcolor{comment}{// ID find and filter}
    \textcolor{keywordflow}{if} ( support.getById ) \{
        Expr.find[\textcolor{stringliteral}{"ID"}] = \textcolor{keyword}{function}( id, context ) \{
            \textcolor{keywordflow}{if} ( typeof context.getElementById !== strundefined && documentIsHTML ) \{
                var m = context.getElementById( \textcolor{keywordtype}{id} );
                \textcolor{comment}{// Check parentNode to catch when Blackberry 4.6 returns}
                \textcolor{comment}{// nodes that are no longer in the document #6963}
                \textcolor{keywordflow}{return} m && m.parentNode ? [ m ] : [];
            \}
        \};
        Expr.filter[\textcolor{stringliteral}{"ID"}] = \textcolor{keyword}{function}( id ) \{
            var attrId = \textcolor{keywordtype}{id}.replace( runescape, funescape );
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                \textcolor{keywordflow}{return} elem.getAttribute(\textcolor{stringliteral}{"id"}) === attrId;
            \};
        \};
    \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Support: IE6/7}
        \textcolor{comment}{// getElementById is not reliable as a find shortcut}
        \textcolor{keyword}{delete} Expr.find[\textcolor{stringliteral}{"ID"}];

        Expr.filter[\textcolor{stringliteral}{"ID"}] =  \textcolor{keyword}{function}( id ) \{
            var attrId = \textcolor{keywordtype}{id}.replace( runescape, funescape );
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\textcolor{stringliteral}{"id"});
                \textcolor{keywordflow}{return} node && node.value === attrId;
            \};
        \};
    \}

    \textcolor{comment}{// Tag}
    Expr.find[\textcolor{stringliteral}{"TAG"}] = support.getElementsByTagName ?
        \textcolor{keyword}{function}( tag, context ) \{
            \textcolor{keywordflow}{if} ( typeof context.getElementsByTagName !== strundefined ) \{
                \textcolor{keywordflow}{return} context.getElementsByTagName( tag );
            \}
        \} :
        \textcolor{keyword}{function}( tag, context ) \{
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName( tag );

            \textcolor{comment}{// Filter out possible comments}
            \textcolor{keywordflow}{if} ( tag === \textcolor{stringliteral}{"*"} ) \{
                \textcolor{keywordflow}{while} ( (elem = results[i++]) ) \{
                    \textcolor{keywordflow}{if} ( elem.nodeType === 1 ) \{
                        tmp.push( elem );
                    \}
                \}

                \textcolor{keywordflow}{return} tmp;
            \}
            \textcolor{keywordflow}{return} results;
        \};

    \textcolor{comment}{// Class}
    Expr.find[\textcolor{stringliteral}{"CLASS"}] = support.getElementsByClassName && \textcolor{keyword}{function}( className, context ) \{
        \textcolor{keywordflow}{if} ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) \{
            \textcolor{keywordflow}{return} context.getElementsByClassName( className );
        \}
    \};

    \textcolor{comment}{/* QSA/matchesSelector}
\textcolor{comment}{    ---------------------------------------------------------------------- */}

    \textcolor{comment}{// QSA and matchesSelector support}

    \textcolor{comment}{// matchesSelector(:active) reports false when true (IE9/Opera 11.5)}
    rbuggyMatches = [];

    \textcolor{comment}{// qSa(:focus) reports false when true (Chrome 21)}
    \textcolor{comment}{// We allow this because of a bug in IE8/9 that throws an error}
    \textcolor{comment}{// whenever `document.activeElement` is accessed on an iframe}
    \textcolor{comment}{// So, we allow :focus to pass through QSA all the time to avoid the IE error}
    \textcolor{comment}{// See http://bugs.jquery.com/ticket/13378}
    rbuggyQSA = [];

    \textcolor{keywordflow}{if} ( (support.qsa = rnative.test( doc.querySelectorAll )) ) \{
        \textcolor{comment}{// Build QSA regex}
        \textcolor{comment}{// Regex strategy adopted from Diego Perini}
        assert(\textcolor{keyword}{function}( div ) \{
            \textcolor{comment}{// Select is set to empty string on purpose}
            \textcolor{comment}{// This is to test IE's treatment of not explicitly}
            \textcolor{comment}{// setting a boolean content attribute,}
            \textcolor{comment}{// since its presence should be enough}
            \textcolor{comment}{// http://bugs.jquery.com/ticket/12359}
            div.innerHTML = \textcolor{stringliteral}{"<select msallowclip=''><option selected=''></option></select>"};

            \textcolor{comment}{// Support: IE8, Opera 11-12.16}
            \textcolor{comment}{// Nothing should be selected when empty strings follow ^= or $= or *=}
            \textcolor{comment}{// The test attribute must be unknown in Opera but "safe" for WinRT}
            \textcolor{comment}{// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute\_section}
            \textcolor{keywordflow}{if} ( div.querySelectorAll(\textcolor{stringliteral}{"[msallowclip^='']"}).length ) \{
                rbuggyQSA.push( \textcolor{stringliteral}{"[*^$]="} + whitespace + \textcolor{stringliteral}{"*(?:''|\(\backslash\)"\(\backslash\)")"} );
            \}

            \textcolor{comment}{// Support: IE8}
            \textcolor{comment}{// Boolean attributes and "value" are not treated correctly}
            \textcolor{keywordflow}{if} ( !div.querySelectorAll(\textcolor{stringliteral}{"[selected]"}).length ) \{
                rbuggyQSA.push( \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)["} + whitespace + \textcolor{stringliteral}{"*(?:value|"} + booleans + \textcolor{stringliteral}{")"} );
            \}

            \textcolor{comment}{// Webkit/Opera - :checked should return selected option elements}
            \textcolor{comment}{// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked}
            \textcolor{comment}{// IE8 throws error here and will not see later tests}
            \textcolor{keywordflow}{if} ( !div.querySelectorAll(\textcolor{stringliteral}{":checked"}).length ) \{
                rbuggyQSA.push(\textcolor{stringliteral}{":checked"});
            \}
        \});

        assert(\textcolor{keyword}{function}( div ) \{
            \textcolor{comment}{// Support: Windows 8 Native Apps}
            \textcolor{comment}{// The type and name attributes are restricted during .innerHTML assignment}
            var input = doc.createElement(\textcolor{stringliteral}{"input"});
            input.setAttribute( \textcolor{stringliteral}{"type"}, \textcolor{stringliteral}{"hidden"} );
            div.appendChild( input ).setAttribute( \textcolor{stringliteral}{"name"}, \textcolor{stringliteral}{"D"} );

            \textcolor{comment}{// Support: IE8}
            \textcolor{comment}{// Enforce case-sensitivity of name attribute}
            \textcolor{keywordflow}{if} ( div.querySelectorAll(\textcolor{stringliteral}{"[name=d]"}).length ) \{
                rbuggyQSA.push( \textcolor{stringliteral}{"name"} + whitespace + \textcolor{stringliteral}{"*[*^$|!~]?="} );
            \}

            \textcolor{comment}{// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)}
            \textcolor{comment}{// IE8 throws error here and will not see later tests}
            \textcolor{keywordflow}{if} ( !div.querySelectorAll(\textcolor{stringliteral}{":enabled"}).length ) \{
                rbuggyQSA.push( \textcolor{stringliteral}{":enabled"}, \textcolor{stringliteral}{":disabled"} );
            \}

            \textcolor{comment}{// Opera 10-11 does not throw on post-comma invalid pseudos}
            div.querySelectorAll(\textcolor{stringliteral}{"*,:x"});
            rbuggyQSA.push(\textcolor{stringliteral}{",.*:"});
        \});
    \}

    \textcolor{keywordflow}{if} ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
        docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) \{

        assert(\textcolor{keyword}{function}( div ) \{
            \textcolor{comment}{// Check to see if it's possible to do matchesSelector}
            \textcolor{comment}{// on a disconnected node (IE 9)}
            support.disconnectedMatch = matches.call( div, \textcolor{stringliteral}{"div"} );

            \textcolor{comment}{// This should fail with an exception}
            \textcolor{comment}{// Gecko does not error, returns false instead}
            matches.call( div, \textcolor{stringliteral}{"[s!='']:x"} );
            rbuggyMatches.push( \textcolor{stringliteral}{"!="}, pseudos );
        \});
    \}

    rbuggyQSA = rbuggyQSA.length && \textcolor{keyword}{new} RegExp( rbuggyQSA.join(\textcolor{stringliteral}{"|"}) );
    rbuggyMatches = rbuggyMatches.length && \textcolor{keyword}{new} RegExp( rbuggyMatches.join(\textcolor{stringliteral}{"|"}) );

    \textcolor{comment}{/* Contains}
\textcolor{comment}{    ---------------------------------------------------------------------- */}
    hasCompare = rnative.test( docElem.compareDocumentPosition );

    \textcolor{comment}{// Element contains another}
    \textcolor{comment}{// Purposefully does not implement inclusive descendent}
    \textcolor{comment}{// As in, an element does not contain itself}
    contains = hasCompare || rnative.test( docElem.contains ) ?
        \textcolor{keyword}{function}( a, b ) \{
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            \textcolor{keywordflow}{return} a === bup || !!( bup && bup.nodeType === 1 && (
                adown.contains ?
                    adown.contains( bup ) :
                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
            ));
        \} :
        \textcolor{keyword}{function}( a, b ) \{
            \textcolor{keywordflow}{if} ( b ) \{
                \textcolor{keywordflow}{while} ( (b = b.parentNode) ) \{
                    \textcolor{keywordflow}{if} ( b === a ) \{
                        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                    \}
                \}
            \}
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \};

    \textcolor{comment}{/* Sorting}
\textcolor{comment}{    ---------------------------------------------------------------------- */}

    \textcolor{comment}{// Document order sorting}
    sortOrder = hasCompare ?
    \textcolor{keyword}{function}( a, b ) \{

        \textcolor{comment}{// Flag for duplicate removal}
        \textcolor{keywordflow}{if} ( a === b ) \{
            hasDuplicate = \textcolor{keyword}{true};
            \textcolor{keywordflow}{return} 0;
        \}

        \textcolor{comment}{// Sort on method existence if only one input has compareDocumentPosition}
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        \textcolor{keywordflow}{if} ( compare ) \{
            \textcolor{keywordflow}{return} compare;
        \}

        \textcolor{comment}{// Calculate position if both inputs belong to the same document}
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
            a.compareDocumentPosition( b ) :

            \textcolor{comment}{// Otherwise we know they are disconnected}
            1;

        \textcolor{comment}{// Disconnected nodes}
        \textcolor{keywordflow}{if} ( compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) \{

            \textcolor{comment}{// Choose the first element that is related to our preferred document}
            \textcolor{keywordflow}{if} ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) \{
                \textcolor{keywordflow}{return} -1;
            \}
            \textcolor{keywordflow}{if} ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) \{
                \textcolor{keywordflow}{return} 1;
            \}

            \textcolor{comment}{// Maintain original order}
            \textcolor{keywordflow}{return} sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;
        \}

        \textcolor{keywordflow}{return} compare & 4 ? -1 : 1;
    \} :
    \textcolor{keyword}{function}( a, b ) \{
        \textcolor{comment}{// Exit early if the nodes are identical}
        \textcolor{keywordflow}{if} ( a === b ) \{
            hasDuplicate = \textcolor{keyword}{true};
            \textcolor{keywordflow}{return} 0;
        \}

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

        \textcolor{comment}{// Parentless nodes are either documents or disconnected}
        \textcolor{keywordflow}{if} ( !aup || !bup ) \{
            \textcolor{keywordflow}{return} a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;

        \textcolor{comment}{// If the nodes are siblings, we can do a quick check}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( aup === bup ) \{
            \textcolor{keywordflow}{return} siblingCheck( a, b );
        \}

        \textcolor{comment}{// Otherwise we need full lists of their ancestors for comparison}
        cur = a;
        \textcolor{keywordflow}{while} ( (cur = cur.parentNode) ) \{
            ap.unshift( cur );
        \}
        cur = b;
        \textcolor{keywordflow}{while} ( (cur = cur.parentNode) ) \{
            bp.unshift( cur );
        \}

        \textcolor{comment}{// Walk down the tree looking for a discrepancy}
        \textcolor{keywordflow}{while} ( ap[i] === bp[i] ) \{
            i++;
        \}

        \textcolor{keywordflow}{return} i ?
            \textcolor{comment}{// Do a sibling check if the nodes have a common ancestor}
            siblingCheck( ap[i], bp[i] ) :

            \textcolor{comment}{// Otherwise nodes in our document sort first}
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
    \};

    \textcolor{keywordflow}{return} doc;
\};

Sizzle.matches = \textcolor{keyword}{function}( expr, elements ) \{
    \textcolor{keywordflow}{return} Sizzle( expr, null, null, elements );
\};

Sizzle.matchesSelector = \textcolor{keyword}{function}( elem, expr ) \{
    \textcolor{comment}{// Set document vars if needed}
    \textcolor{keywordflow}{if} ( ( elem.ownerDocument || elem ) !== document ) \{
        setDocument( elem );
    \}

    \textcolor{comment}{// Make sure that attribute selectors are quoted}
    expr = expr.replace( rattributeQuotes, \textcolor{stringliteral}{"='$1']"} );

    \textcolor{keywordflow}{if} ( support.matchesSelector && documentIsHTML &&
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) \{

        \textcolor{keywordflow}{try} \{
            var ret = matches.call( elem, expr );

            \textcolor{comment}{// IE 9's matchesSelector returns false on disconnected nodes}
            \textcolor{keywordflow}{if} ( ret || support.disconnectedMatch ||
                    \textcolor{comment}{// As well, disconnected nodes are said to be in a document}
                    \textcolor{comment}{// fragment in IE 9}
                    elem.document && elem.document.nodeType !== 11 ) \{
                \textcolor{keywordflow}{return} ret;
            \}
        \} \textcolor{keywordflow}{catch}(e) \{\}
    \}

    \textcolor{keywordflow}{return} Sizzle( expr, document, null, [ elem ] ).length > 0;
\};

Sizzle.contains = \textcolor{keyword}{function}( context, elem ) \{
    \textcolor{comment}{// Set document vars if needed}
    \textcolor{keywordflow}{if} ( ( context.ownerDocument || context ) !== document ) \{
        setDocument( context );
    \}
    \textcolor{keywordflow}{return} contains( context, elem );
\};

Sizzle.attr = \textcolor{keyword}{function}( elem, name ) \{
    \textcolor{comment}{// Set document vars if needed}
    \textcolor{keywordflow}{if} ( ( elem.ownerDocument || elem ) !== document ) \{
        setDocument( elem );
    \}

    var fn = Expr.attrHandle[ name.toLowerCase() ],
        \textcolor{comment}{// Don't get fooled by Object.prototype properties (jQuery #13807)}
        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

    \textcolor{keywordflow}{return} val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) && val.specified ?
                val.value :
                null;
\};

Sizzle.error = \textcolor{keyword}{function}( msg ) \{
    \textcolor{keywordflow}{throw} \textcolor{keyword}{new} Error( \textcolor{stringliteral}{"Syntax error, unrecognized expression: "} + msg );
\};

Sizzle.uniqueSort = \textcolor{keyword}{function}( results ) \{
    var elem,
        duplicates = [],
        j = 0,
        i = 0;

    \textcolor{comment}{// Unless we *know* we can detect duplicates, assume their presence}
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice( 0 );
    results.sort( sortOrder );

    \textcolor{keywordflow}{if} ( hasDuplicate ) \{
        \textcolor{keywordflow}{while} ( (elem = results[i++]) ) \{
            \textcolor{keywordflow}{if} ( elem === results[ i ] ) \{
                j = duplicates.push( i );
            \}
        \}
        \textcolor{keywordflow}{while} ( j-- ) \{
            results.splice( duplicates[ j ], 1 );
        \}
    \}

    \textcolor{comment}{// Clear input after sorting to release objects}
    \textcolor{comment}{// See https://github.com/jquery/sizzle/pull/225}
    sortInput = null;

    \textcolor{keywordflow}{return} results;
\};

getText = Sizzle.getText = \textcolor{keyword}{function}( elem ) \{
    var node,
        ret = \textcolor{stringliteral}{""},
        i = 0,
        nodeType = elem.nodeType;

    \textcolor{keywordflow}{if} ( !nodeType ) \{
        \textcolor{comment}{// If no nodeType, this is expected to be an array}
        \textcolor{keywordflow}{while} ( (node = elem[i++]) ) \{
            \textcolor{comment}{// Do not traverse comment nodes}
            ret += getText( node );
        \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) \{
        \textcolor{comment}{// Use textContent for elements}
        \textcolor{comment}{// innerText usage removed for consistency of new lines (jQuery #11153)}
        \textcolor{keywordflow}{if} ( typeof elem.textContent === \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{return} elem.textContent;
        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// Traverse its children}
            \textcolor{keywordflow}{for} ( elem = elem.firstChild; elem; elem = elem.nextSibling ) \{
                ret += getText( elem );
            \}
        \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( nodeType === 3 || nodeType === 4 ) \{
        \textcolor{keywordflow}{return} elem.nodeValue;
    \}
    \textcolor{comment}{// Do not include comment or processing instruction nodes}

    \textcolor{keywordflow}{return} ret;
\};

Expr = Sizzle.selectors = \{

    \textcolor{comment}{// Can be adjusted by the user}
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: \{\},

    find: \{\},

    relative: \{
        \textcolor{stringliteral}{">"}: \{ dir: \textcolor{stringliteral}{"parentNode"}, first: \textcolor{keyword}{true} \},
        \textcolor{stringliteral}{" "}: \{ dir: \textcolor{stringliteral}{"parentNode"} \},
        \textcolor{stringliteral}{"+"}: \{ dir: \textcolor{stringliteral}{"previousSibling"}, first: \textcolor{keyword}{true} \},
        \textcolor{stringliteral}{"~"}: \{ dir: \textcolor{stringliteral}{"previousSibling"} \}
    \},

    preFilter: \{
        \textcolor{stringliteral}{"ATTR"}: \textcolor{keyword}{function}( match ) \{
            match[1] = match[1].replace( runescape, funescape );

            \textcolor{comment}{// Move the given value to match[3] whether quoted or unquoted}
            match[3] = ( match[3] || match[4] || match[5] || \textcolor{stringliteral}{""} ).replace( runescape, funescape );

            \textcolor{keywordflow}{if} ( match[2] === \textcolor{stringliteral}{"~="} ) \{
                match[3] = \textcolor{stringliteral}{" "} + match[3] + \textcolor{stringliteral}{" "};
            \}

            \textcolor{keywordflow}{return} match.slice( 0, 4 );
        \},

        \textcolor{stringliteral}{"CHILD"}: \textcolor{keyword}{function}( match ) \{
            \textcolor{comment}{/* matches from matchExpr["CHILD"]}
\textcolor{comment}{                1 type (only|nth|...)}
\textcolor{comment}{                2 what (child|of-type)}
\textcolor{comment}{                3 argument (even|odd|\(\backslash\)d*|\(\backslash\)d*n([+-]\(\backslash\)d+)?|...)}
\textcolor{comment}{                4 xn-component of xn+y argument ([+-]?\(\backslash\)d*n|)}
\textcolor{comment}{                5 sign of xn-component}
\textcolor{comment}{                6 x of xn-component}
\textcolor{comment}{                7 sign of y-component}
\textcolor{comment}{                8 y of y-component}
\textcolor{comment}{            */}
            match[1] = match[1].toLowerCase();

            \textcolor{keywordflow}{if} ( match[1].slice( 0, 3 ) === \textcolor{stringliteral}{"nth"} ) \{
                \textcolor{comment}{// nth-* requires argument}
                \textcolor{keywordflow}{if} ( !match[3] ) \{
                    Sizzle.error( match[0] );
                \}

                \textcolor{comment}{// numeric x and y parameters for Expr.filter.CHILD}
                \textcolor{comment}{// remember that false/true cast respectively to 0/1}
                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \textcolor{stringliteral}{"even"} || match[3]
       === \textcolor{stringliteral}{"odd"} ) );
                match[5] = +( ( match[7] + match[8] ) || match[3] === \textcolor{stringliteral}{"odd"} );

            \textcolor{comment}{// other types prohibit arguments}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( match[3] ) \{
                Sizzle.error( match[0] );
            \}

            \textcolor{keywordflow}{return} match;
        \},

        \textcolor{stringliteral}{"PSEUDO"}: \textcolor{keyword}{function}( match ) \{
            var excess,
                unquoted = !match[6] && match[2];

            \textcolor{keywordflow}{if} ( matchExpr[\textcolor{stringliteral}{"CHILD"}].test( match[0] ) ) \{
                \textcolor{keywordflow}{return} null;
            \}

            \textcolor{comment}{// Accept quoted arguments as-is}
            \textcolor{keywordflow}{if} ( match[3] ) \{
                match[2] = match[4] || match[5] || \textcolor{stringliteral}{""};

            \textcolor{comment}{// Strip excess characters from unquoted arguments}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( unquoted && rpseudo.test( unquoted ) &&
                \textcolor{comment}{// Get excess from tokenize (recursively)}
                (excess = tokenize( unquoted, \textcolor{keyword}{true} )) &&
                \textcolor{comment}{// advance to the next closing parenthesis}
                (excess = unquoted.indexOf( \textcolor{stringliteral}{")"}, unquoted.length - excess ) - unquoted.length) ) \{

                \textcolor{comment}{// excess is a negative index}
                match[0] = match[0].slice( 0, excess );
                match[2] = unquoted.slice( 0, excess );
            \}

            \textcolor{comment}{// Return only captures needed by the pseudo filter method (type and argument)}
            \textcolor{keywordflow}{return} match.slice( 0, 3 );
        \}
    \},

    filter: \{

        \textcolor{stringliteral}{"TAG"}: \textcolor{keyword}{function}( nodeNameSelector ) \{
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            \textcolor{keywordflow}{return} nodeNameSelector === \textcolor{stringliteral}{"*"} ?
                \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \} :
                \textcolor{keyword}{function}( elem ) \{
                    \textcolor{keywordflow}{return} elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                \};
        \},

        \textcolor{stringliteral}{"CLASS"}: \textcolor{keyword}{function}( className ) \{
            var pattern = classCache[ className + \textcolor{stringliteral}{" "} ];

            \textcolor{keywordflow}{return} pattern ||
                (pattern = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"(^|"} + whitespace + \textcolor{stringliteral}{")"} + className + \textcolor{stringliteral}{"("} + whitespace + \textcolor{stringliteral}{"|$)"} )) 
      &&
                classCache( className, \textcolor{keyword}{function}( elem ) \{
                    \textcolor{keywordflow}{return} pattern.test( typeof elem.className === \textcolor{stringliteral}{"string"} && elem.className || typeof 
      elem.getAttribute !== strundefined && elem.getAttribute(\textcolor{stringliteral}{"class"}) || \textcolor{stringliteral}{""} );
                \});
        \},

        \textcolor{stringliteral}{"ATTR"}: \textcolor{keyword}{function}( name, \textcolor{keyword}{operator}, check ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                var result = Sizzle.attr( elem, name );

                \textcolor{keywordflow}{if} ( result == null ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{operator} === \textcolor{stringliteral}{"!="};
                \}
                \textcolor{keywordflow}{if} ( !\textcolor{keyword}{operator} ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                \}

                result += \textcolor{stringliteral}{""};

                \textcolor{keywordflow}{return} \textcolor{keyword}{operator} === \textcolor{stringliteral}{"="} ? result === check :
                    \textcolor{keyword}{operator} === \textcolor{stringliteral}{"!="} ? result !== check :
                    \textcolor{keyword}{operator} === \textcolor{stringliteral}{"^="} ? check && result.indexOf( check ) === 0 :
                    \textcolor{keyword}{operator} === \textcolor{stringliteral}{"*="} ? check && result.indexOf( check ) > -1 :
                    \textcolor{keyword}{operator} === \textcolor{stringliteral}{"$="} ? check && result.slice( -check.length ) === check :
                    operator === "~=" ? ( \textcolor{stringliteral}{" "} + result + \textcolor{stringliteral}{" "} ).indexOf( check ) > -1 :
                    \textcolor{keyword}{operator} === \textcolor{stringliteral}{"|="} ? result === check || result.slice( 0, check.length + 1 ) === check +
       \textcolor{stringliteral}{"-"} :
                    \textcolor{keyword}{false};
            \};
        \},

        \textcolor{stringliteral}{"CHILD"}: \textcolor{keyword}{function}( type, what, argument, first, last ) \{
            var simple = type.slice( 0, 3 ) !== \textcolor{stringliteral}{"nth"},
                forward = type.slice( -4 ) !== \textcolor{stringliteral}{"last"},
                ofType = what === \textcolor{stringliteral}{"of-type"};

            \textcolor{keywordflow}{return} first === 1 && last === 0 ?

                \textcolor{comment}{// Shortcut for :nth-*(n)}
                \textcolor{keyword}{function}( elem ) \{
                    \textcolor{keywordflow}{return} !!elem.parentNode;
                \} :

                \textcolor{keyword}{function}( elem, context, xml ) \{
                    var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? \textcolor{stringliteral}{"nextSibling"} : \textcolor{stringliteral}{"previousSibling"},
                        parent = elem.parentNode,
                        name = ofType && elem.nodeName.toLowerCase(),
                        useCache = !xml && !ofType;

                    \textcolor{keywordflow}{if} ( parent ) \{

                        \textcolor{comment}{// :(first|last|only)-(child|of-type)}
                        \textcolor{keywordflow}{if} ( simple ) \{
                            \textcolor{keywordflow}{while} ( dir ) \{
                                node = elem;
                                \textcolor{keywordflow}{while} ( (node = node[ dir ]) ) \{
                                    \textcolor{keywordflow}{if} ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 
      1 ) \{
                                        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                                    \}
                                \}
                                \textcolor{comment}{// Reverse direction for :only-* (if we haven't yet done so)}
                                start = dir = type === \textcolor{stringliteral}{"only"} && !start && \textcolor{stringliteral}{"nextSibling"};
                            \}
                            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                        \}

                        start = [ forward ? parent.firstChild : parent.lastChild ];

                        \textcolor{comment}{// non-xml :nth-child(...) stores cache data on `parent`}
                        \textcolor{keywordflow}{if} ( forward && useCache ) \{
                            \textcolor{comment}{// Seek `elem` from a previously-cached index}
                            outerCache = parent[ expando ] || (parent[ expando ] = \{\});
                            cache = outerCache[ type ] || [];
                            nodeIndex = cache[0] === dirruns && cache[1];
                            diff = cache[0] === dirruns && cache[2];
                            node = nodeIndex && parent.childNodes[ nodeIndex ];

                            \textcolor{keywordflow}{while} ( (node = ++nodeIndex && node && node[ dir ] ||

                                \textcolor{comment}{// Fallback to seeking `elem` from the start}
                                (diff = nodeIndex = 0) || start.pop()) ) \{

                                \textcolor{comment}{// When found, cache indexes on `parent` and break}
                                \textcolor{keywordflow}{if} ( node.nodeType === 1 && ++diff && node === elem ) \{
                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                    \textcolor{keywordflow}{break};
                                \}
                            \}

                        \textcolor{comment}{// Use previously-cached element index if available}
                        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = \{\}))[ type 
      ]) && cache[0] === dirruns ) \{
                            diff = cache[1];

                        \textcolor{comment}{// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)}
                        \} \textcolor{keywordflow}{else} \{
                            \textcolor{comment}{// Use the same loop as above to seek `elem` from the start}
                            \textcolor{keywordflow}{while} ( (node = ++nodeIndex && node && node[ dir ] ||
                                (diff = nodeIndex = 0) || start.pop()) ) \{

                                \textcolor{keywordflow}{if} ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 
      ) && ++diff ) \{
                                    \textcolor{comment}{// Cache the index of each encountered element}
                                    \textcolor{keywordflow}{if} ( useCache ) \{
                                        (node[ expando ] || (node[ expando ] = \{\}))[ type ] = [ dirruns, 
      diff ];
                                    \}

                                    \textcolor{keywordflow}{if} ( node === elem ) \{
                                        \textcolor{keywordflow}{break};
                                    \}
                                \}
                            \}
                        \}

                        \textcolor{comment}{// Incorporate the offset, then check against cycle size}
                        diff -= last;
                        \textcolor{keywordflow}{return} diff === first || ( diff % first === 0 && diff / first >= 0 );
                    \}
                \};
        \},

        \textcolor{stringliteral}{"PSEUDO"}: \textcolor{keyword}{function}( pseudo, argument ) \{
            \textcolor{comment}{// pseudo-class names are case-insensitive}
            \textcolor{comment}{// http://www.w3.org/TR/selectors/#pseudo-classes}
            \textcolor{comment}{// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters}
            \textcolor{comment}{// Remember that setFilters inherits from pseudos}
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( \textcolor{stringliteral}{"unsupported pseudo: "} + pseudo );

            \textcolor{comment}{// The user may use createPseudo to indicate that}
            \textcolor{comment}{// arguments are needed to create the filter function}
            \textcolor{comment}{// just as Sizzle does}
            \textcolor{keywordflow}{if} ( fn[ expando ] ) \{
                \textcolor{keywordflow}{return} fn( argument );
            \}

            \textcolor{comment}{// But maintain support for old signatures}
            \textcolor{keywordflow}{if} ( fn.length > 1 ) \{
                args = [ pseudo, pseudo, \textcolor{stringliteral}{""}, argument ];
                \textcolor{keywordflow}{return} Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(\textcolor{keyword}{function}( seed, matches ) \{
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        \textcolor{keywordflow}{while} ( i-- ) \{
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        \}
                    \}) :
                    \textcolor{keyword}{function}( elem ) \{
                        \textcolor{keywordflow}{return} fn( elem, 0, args );
                    \};
            \}

            \textcolor{keywordflow}{return} fn;
        \}
    \},

    pseudos: \{
        \textcolor{comment}{// Potentially complex pseudos}
        \textcolor{stringliteral}{"not"}: markFunction(\textcolor{keyword}{function}( selector ) \{
            \textcolor{comment}{// Trim the selector passed to compile}
            \textcolor{comment}{// to avoid treating leading and trailing}
            \textcolor{comment}{// spaces as combinators}
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, \textcolor{stringliteral}{"$1"} ) );

            \textcolor{keywordflow}{return} matcher[ expando ] ?
                markFunction(\textcolor{keyword}{function}( seed, matches, context, xml ) \{
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    \textcolor{comment}{// Match elements unmatched by `matcher`}
                    \textcolor{keywordflow}{while} ( i-- ) \{
                        \textcolor{keywordflow}{if} ( (elem = unmatched[i]) ) \{
                            seed[i] = !(matches[i] = elem);
                        \}
                    \}
                \}) :
                \textcolor{keyword}{function}( elem, context, xml ) \{
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    \textcolor{keywordflow}{return} !results.pop();
                \};
        \}),

        \textcolor{stringliteral}{"has"}: markFunction(\textcolor{keyword}{function}( selector ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                \textcolor{keywordflow}{return} Sizzle( selector, elem ).length > 0;
            \};
        \}),

        \textcolor{stringliteral}{"contains"}: markFunction(\textcolor{keyword}{function}( text ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                \textcolor{keywordflow}{return} ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
            \};
        \}),

        \textcolor{comment}{// "Whether an element is represented by a :lang() selector}
        \textcolor{comment}{// is based solely on the element's language value}
        \textcolor{comment}{// being equal to the identifier C,}
        \textcolor{comment}{// or beginning with the identifier C immediately followed by "-".}
        \textcolor{comment}{// The matching of C against the element's language value is performed case-insensitively.}
        \textcolor{comment}{// The identifier C does not have to be a valid language name."}
        \textcolor{comment}{// http://www.w3.org/TR/selectors/#lang-pseudo}
        \textcolor{stringliteral}{"lang"}: markFunction( \textcolor{keyword}{function}( lang ) \{
            \textcolor{comment}{// lang value must be a valid identifier}
            \textcolor{keywordflow}{if} ( !ridentifier.test(lang || \textcolor{stringliteral}{""}) ) \{
                Sizzle.error( \textcolor{stringliteral}{"unsupported lang: "} + lang );
            \}
            lang = lang.replace( runescape, funescape ).toLowerCase();
            \textcolor{keywordflow}{return} \textcolor{keyword}{function}( elem ) \{
                var elemLang;
                \textcolor{keywordflow}{do} \{
                    \textcolor{keywordflow}{if} ( (elemLang = documentIsHTML ?
                        elem.lang :
                        elem.getAttribute(\textcolor{stringliteral}{"xml:lang"}) || elem.getAttribute(\textcolor{stringliteral}{"lang"})) ) \{

                        elemLang = elemLang.toLowerCase();
                        \textcolor{keywordflow}{return} elemLang === lang || elemLang.indexOf( lang + \textcolor{stringliteral}{"-"} ) === 0;
                    \}
                \} \textcolor{keywordflow}{while} ( (elem = elem.parentNode) && elem.nodeType === 1 );
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
            \};
        \}),

        \textcolor{comment}{// Miscellaneous}
        \textcolor{stringliteral}{"target"}: \textcolor{keyword}{function}( elem ) \{
            var hash = window.location && window.location.hash;
            \textcolor{keywordflow}{return} hash && hash.slice( 1 ) === elem.id;
        \},

        \textcolor{stringliteral}{"root"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} elem === docElem;
        \},

        \textcolor{stringliteral}{"focus"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(
      elem.type || elem.href || ~elem.tabIndex);
        \},

        \textcolor{comment}{// Boolean properties}
        \textcolor{stringliteral}{"enabled"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} elem.disabled === \textcolor{keyword}{false};
        \},

        \textcolor{stringliteral}{"disabled"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} elem.disabled === \textcolor{keyword}{true};
        \},

        \textcolor{stringliteral}{"checked"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{comment}{// In CSS3, :checked should return both checked and selected elements}
            \textcolor{comment}{// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked}
            var nodeName = elem.nodeName.toLowerCase();
            \textcolor{keywordflow}{return} (nodeName === \textcolor{stringliteral}{"input"} && !!elem.checked) || (nodeName === \textcolor{stringliteral}{"option"} && !!elem.selected);
        \},

        \textcolor{stringliteral}{"selected"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{comment}{// Accessing this property makes selected-by-default}
            \textcolor{comment}{// options in Safari work properly}
            \textcolor{keywordflow}{if} ( elem.parentNode ) \{
                elem.parentNode.selectedIndex;
            \}

            \textcolor{keywordflow}{return} elem.selected === \textcolor{keyword}{true};
        \},

        \textcolor{comment}{// Contents}
        \textcolor{stringliteral}{"empty"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{comment}{// http://www.w3.org/TR/selectors/#empty-pseudo}
            \textcolor{comment}{// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),}
            \textcolor{comment}{//   but not by others (comment: 8; processing instruction: 7; etc.)}
            \textcolor{comment}{// nodeType < 6 works because attributes (2) do not appear as children}
            \textcolor{keywordflow}{for} ( elem = elem.firstChild; elem; elem = elem.nextSibling ) \{
                \textcolor{keywordflow}{if} ( elem.nodeType < 6 ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
            \}
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \},

        \textcolor{stringliteral}{"parent"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} !Expr.pseudos[\textcolor{stringliteral}{"empty"}]( elem );
        \},

        \textcolor{comment}{// Element/input types}
        \textcolor{stringliteral}{"header"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} rheader.test( elem.nodeName );
        \},

        \textcolor{stringliteral}{"input"}: \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} rinputs.test( elem.nodeName );
        \},

        \textcolor{stringliteral}{"button"}: \textcolor{keyword}{function}( elem ) \{
            var name = elem.nodeName.toLowerCase();
            \textcolor{keywordflow}{return} name === \textcolor{stringliteral}{"input"} && elem.type === \textcolor{stringliteral}{"button"} || name === \textcolor{stringliteral}{"button"};
        \},

        \textcolor{stringliteral}{"text"}: \textcolor{keyword}{function}( elem ) \{
            var attr;
            \textcolor{keywordflow}{return} elem.nodeName.toLowerCase() === \textcolor{stringliteral}{"input"} &&
                elem.type === \textcolor{stringliteral}{"text"} &&

                \textcolor{comment}{// Support: IE<8}
                \textcolor{comment}{// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"}
                ( (attr = elem.getAttribute(\textcolor{stringliteral}{"type"})) == null || attr.toLowerCase() === \textcolor{stringliteral}{"text"} );
        \},

        \textcolor{comment}{// Position-in-collection}
        \textcolor{stringliteral}{"first"}: createPositionalPseudo(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} [ 0 ];
        \}),

        \textcolor{stringliteral}{"last"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length ) \{
            \textcolor{keywordflow}{return} [ length - 1 ];
        \}),

        \textcolor{stringliteral}{"eq"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length, argument ) \{
            \textcolor{keywordflow}{return} [ argument < 0 ? argument + length : argument ];
        \}),

        \textcolor{stringliteral}{"even"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length ) \{
            var i = 0;
            \textcolor{keywordflow}{for} ( ; i < length; i += 2 ) \{
                matchIndexes.push( i );
            \}
            \textcolor{keywordflow}{return} matchIndexes;
        \}),

        \textcolor{stringliteral}{"odd"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length ) \{
            var i = 1;
            \textcolor{keywordflow}{for} ( ; i < length; i += 2 ) \{
                matchIndexes.push( i );
            \}
            \textcolor{keywordflow}{return} matchIndexes;
        \}),

        \textcolor{stringliteral}{"lt"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length, argument ) \{
            var i = argument < 0 ? argument + length : argument;
            \textcolor{keywordflow}{for} ( ; --i >= 0; ) \{
                matchIndexes.push( i );
            \}
            \textcolor{keywordflow}{return} matchIndexes;
        \}),

        \textcolor{stringliteral}{"gt"}: createPositionalPseudo(\textcolor{keyword}{function}( matchIndexes, length, argument ) \{
            var i = argument < 0 ? argument + length : argument;
            \textcolor{keywordflow}{for} ( ; ++i < length; ) \{
                matchIndexes.push( i );
            \}
            \textcolor{keywordflow}{return} matchIndexes;
        \})
    \}
\};

Expr.pseudos[\textcolor{stringliteral}{"nth"}] = Expr.pseudos[\textcolor{stringliteral}{"eq"}];

\textcolor{comment}{// Add button/input type pseudos}
\textcolor{keywordflow}{for} ( i in \{ radio: \textcolor{keyword}{true}, checkbox: \textcolor{keyword}{true}, file: \textcolor{keyword}{true}, password: \textcolor{keyword}{true}, image: \textcolor{keyword}{true} \} ) \{
    Expr.pseudos[ i ] = createInputPseudo( i );
\}
\textcolor{keywordflow}{for} ( i in \{ submit: \textcolor{keyword}{true}, reset: \textcolor{keyword}{true} \} ) \{
    Expr.pseudos[ i ] = createButtonPseudo( i );
\}

\textcolor{comment}{// Easy API for creating new setFilters}
\textcolor{keyword}{function} setFilters() \{\}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = \textcolor{keyword}{new} setFilters();

tokenize = Sizzle.tokenize = \textcolor{keyword}{function}( selector, parseOnly ) \{
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + \textcolor{stringliteral}{" "} ];

    \textcolor{keywordflow}{if} ( cached ) \{
        \textcolor{keywordflow}{return} parseOnly ? 0 : cached.slice( 0 );
    \}

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    \textcolor{keywordflow}{while} ( soFar ) \{

        \textcolor{comment}{// Comma and first run}
        \textcolor{keywordflow}{if} ( !matched || (match = rcomma.exec( soFar )) ) \{
            \textcolor{keywordflow}{if} ( match ) \{
                \textcolor{comment}{// Don't consume trailing commas as valid}
                soFar = soFar.slice( match[0].length ) || soFar;
            \}
            groups.push( (tokens = []) );
        \}

        matched = \textcolor{keyword}{false};

        \textcolor{comment}{// Combinators}
        \textcolor{keywordflow}{if} ( (match = rcombinators.exec( soFar )) ) \{
            matched = match.shift();
            tokens.push(\{
                value: matched,
                \textcolor{comment}{// Cast descendant combinators to space}
                type: match[0].replace( rtrim, \textcolor{stringliteral}{" "} )
            \});
            soFar = soFar.slice( matched.length );
        \}

        \textcolor{comment}{// Filters}
        \textcolor{keywordflow}{for} ( type in Expr.filter ) \{
            \textcolor{keywordflow}{if} ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) \{
                matched = match.shift();
                tokens.push(\{
                    value: matched,
                    type: type,
                    matches: match
                \});
                soFar = soFar.slice( matched.length );
            \}
        \}

        \textcolor{keywordflow}{if} ( !matched ) \{
            \textcolor{keywordflow}{break};
        \}
    \}

    \textcolor{comment}{// Return the length of the invalid excess}
    \textcolor{comment}{// if we're just parsing}
    \textcolor{comment}{// Otherwise, throw an error or return tokens}
    \textcolor{keywordflow}{return} parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            \textcolor{comment}{// Cache the tokens}
            tokenCache( selector, groups ).slice( 0 );
\};

\textcolor{keyword}{function} toSelector( tokens ) \{
    var i = 0,
        len = tokens.length,
        selector = \textcolor{stringliteral}{""};
    \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
        selector += tokens[i].value;
    \}
    \textcolor{keywordflow}{return} selector;
\}

\textcolor{keyword}{function} addCombinator( matcher, combinator, base ) \{
    var dir = combinator.dir,
        checkNonElements = base && dir === \textcolor{stringliteral}{"parentNode"},
        doneName = done++;

    \textcolor{keywordflow}{return} combinator.first ?
        \textcolor{comment}{// Check against closest ancestor/preceding element}
        \textcolor{keyword}{function}( elem, context, xml ) \{
            \textcolor{keywordflow}{while} ( (elem = elem[ dir ]) ) \{
                \textcolor{keywordflow}{if} ( elem.nodeType === 1 || checkNonElements ) \{
                    \textcolor{keywordflow}{return} matcher( elem, context, xml );
                \}
            \}
        \} :

        \textcolor{comment}{// Check against all ancestor/preceding elements}
        \textcolor{keyword}{function}( elem, context, xml ) \{
            var oldCache, outerCache,
                newCache = [ dirruns, doneName ];

            \textcolor{comment}{// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching}
            \textcolor{keywordflow}{if} ( xml ) \{
                \textcolor{keywordflow}{while} ( (elem = elem[ dir ]) ) \{
                    \textcolor{keywordflow}{if} ( elem.nodeType === 1 || checkNonElements ) \{
                        \textcolor{keywordflow}{if} ( matcher( elem, context, xml ) ) \{
                            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                        \}
                    \}
                \}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{while} ( (elem = elem[ dir ]) ) \{
                    \textcolor{keywordflow}{if} ( elem.nodeType === 1 || checkNonElements ) \{
                        outerCache = elem[ expando ] || (elem[ expando ] = \{\});
                        \textcolor{keywordflow}{if} ( (oldCache = outerCache[ dir ]) &&
                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) \{

                            \textcolor{comment}{// Assign to newCache so results back-propagate to previous elements}
                            \textcolor{keywordflow}{return} (newCache[ 2 ] = oldCache[ 2 ]);
                        \} \textcolor{keywordflow}{else} \{
                            \textcolor{comment}{// Reuse newcache so results back-propagate to previous elements}
                            outerCache[ dir ] = newCache;

                            \textcolor{comment}{// A match means we're done; a fail means we have to keep checking}
                            \textcolor{keywordflow}{if} ( (newCache[ 2 ] = matcher( elem, context, xml )) ) \{
                                \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                            \}
                        \}
                    \}
                \}
            \}
        \};
\}

\textcolor{keyword}{function} elementMatcher( matchers ) \{
    \textcolor{keywordflow}{return} matchers.length > 1 ?
        \textcolor{keyword}{function}( elem, context, xml ) \{
            var i = matchers.length;
            \textcolor{keywordflow}{while} ( i-- ) \{
                \textcolor{keywordflow}{if} ( !matchers[i]( elem, context, xml ) ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
            \}
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \} :
        matchers[0];
\}

\textcolor{keyword}{function} multipleContexts( selector, contexts, results ) \{
    var i = 0,
        len = contexts.length;
    \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
        Sizzle( selector, contexts[i], results );
    \}
    \textcolor{keywordflow}{return} results;
\}

\textcolor{keyword}{function} condense( unmatched, map, filter, context, xml ) \{
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
        \textcolor{keywordflow}{if} ( (elem = unmatched[i]) ) \{
            \textcolor{keywordflow}{if} ( !filter || filter( elem, context, xml ) ) \{
                newUnmatched.push( elem );
                \textcolor{keywordflow}{if} ( mapped ) \{
                    map.push( i );
                \}
            \}
        \}
    \}

    \textcolor{keywordflow}{return} newUnmatched;
\}

\textcolor{keyword}{function} setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) \{
    \textcolor{keywordflow}{if} ( postFilter && !postFilter[ expando ] ) \{
        postFilter = setMatcher( postFilter );
    \}
    \textcolor{keywordflow}{if} ( postFinder && !postFinder[ expando ] ) \{
        postFinder = setMatcher( postFinder, postSelector );
    \}
    \textcolor{keywordflow}{return} markFunction(\textcolor{keyword}{function}( seed, results, context, xml ) \{
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            \textcolor{comment}{// Get initial elements from seed or context}
            elems = seed || multipleContexts( selector || \textcolor{stringliteral}{"*"}, context.nodeType ? [ context ] : context, []
       ),

            \textcolor{comment}{// Prefilter to get matcher input, preserving a map for seed-results synchronization}
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                \textcolor{comment}{// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting
       results,}
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    \textcolor{comment}{// ...intermediate processing is necessary}
                    [] :

                    \textcolor{comment}{// ...otherwise use results directly}
                    results :
                matcherIn;

        \textcolor{comment}{// Find primary matches}
        \textcolor{keywordflow}{if} ( matcher ) \{
            matcher( matcherIn, matcherOut, context, xml );
        \}

        \textcolor{comment}{// Apply postFilter}
        \textcolor{keywordflow}{if} ( postFilter ) \{
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            \textcolor{comment}{// Un-match failing elements by moving them back to matcherIn}
            i = temp.length;
            \textcolor{keywordflow}{while} ( i-- ) \{
                \textcolor{keywordflow}{if} ( (elem = temp[i]) ) \{
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                \}
            \}
        \}

        \textcolor{keywordflow}{if} ( seed ) \{
            \textcolor{keywordflow}{if} ( postFinder || preFilter ) \{
                \textcolor{keywordflow}{if} ( postFinder ) \{
                    \textcolor{comment}{// Get the final matcherOut by condensing this intermediate into postFinder contexts}
                    temp = [];
                    i = matcherOut.length;
                    \textcolor{keywordflow}{while} ( i-- ) \{
                        \textcolor{keywordflow}{if} ( (elem = matcherOut[i]) ) \{
                            \textcolor{comment}{// Restore matcherIn since elem is not yet a final match}
                            temp.push( (matcherIn[i] = elem) );
                        \}
                    \}
                    postFinder( null, (matcherOut = []), temp, xml );
                \}

                \textcolor{comment}{// Move matched elements from seed to results to keep them synchronized}
                i = matcherOut.length;
                \textcolor{keywordflow}{while} ( i-- ) \{
                    \textcolor{keywordflow}{if} ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) \{

                        seed[temp] = !(results[temp] = elem);
                    \}
                \}
            \}

        \textcolor{comment}{// Add elements to results, through postFinder if defined}
        \} \textcolor{keywordflow}{else} \{
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            \textcolor{keywordflow}{if} ( postFinder ) \{
                postFinder( null, results, matcherOut, xml );
            \} \textcolor{keywordflow}{else} \{
                push.apply( results, matcherOut );
            \}
        \}
    \});
\}

\textcolor{keyword}{function} matcherFromTokens( tokens ) \{
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[\textcolor{stringliteral}{" "}],
        i = leadingRelative ? 1 : 0,

        \textcolor{comment}{// The foundational matcher ensures that elements are reachable from top-level context(s)}
        matchContext = addCombinator( \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} elem === checkContext;
        \}, implicitRelative, true ),
        matchAnyContext = addCombinator( \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} indexOf.call( checkContext, elem ) > -1;
        \}, implicitRelative, true ),
        matchers = [ \textcolor{keyword}{function}( elem, context, xml ) \{
            \textcolor{keywordflow}{return} ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        \} ];

    \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
        \textcolor{keywordflow}{if} ( (matcher = Expr.relative[ tokens[i].type ]) ) \{
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        \} \textcolor{keywordflow}{else} \{
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            \textcolor{comment}{// Return special upon seeing a positional matcher}
            \textcolor{keywordflow}{if} ( matcher[ expando ] ) \{
                \textcolor{comment}{// Find the next relative operator (if any) for proper handling}
                j = ++i;
                \textcolor{keywordflow}{for} ( ; j < len; j++ ) \{
                    \textcolor{keywordflow}{if} ( Expr.relative[ tokens[j].type ] ) \{
                        \textcolor{keywordflow}{break};
                    \}
                \}
                \textcolor{keywordflow}{return} setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && toSelector(
                        \textcolor{comment}{// If the preceding token was a descendant combinator, insert an implicit
       any-element `*`}
                        tokens.slice( 0, i - 1 ).concat(\{ value: tokens[ i - 2 ].type === \textcolor{stringliteral}{" "} ? \textcolor{stringliteral}{"*"} : \textcolor{stringliteral}{""} \})
                    ).replace( rtrim, \textcolor{stringliteral}{"$1"} ),
                    matcher,
                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j < len && toSelector( tokens )
                );
            \}
            matchers.push( matcher );
        \}
    \}

    \textcolor{keywordflow}{return} elementMatcher( matchers );
\}

\textcolor{keyword}{function} matcherFromGroupMatchers( elementMatchers, setMatchers ) \{
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = \textcolor{keyword}{function}( seed, context, xml, results, outermost ) \{
            var elem, j, matcher,
                matchedCount = 0,
                i = \textcolor{stringliteral}{"0"},
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                \textcolor{comment}{// We must always have either seed elements or outermost context}
                elems = seed || byElement && Expr.find[\textcolor{stringliteral}{"TAG"}]( \textcolor{stringliteral}{"*"}, outermost ),
                \textcolor{comment}{// Use integer dirruns iff this is the outermost matcher}
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;

            \textcolor{keywordflow}{if} ( outermost ) \{
                outermostContext = context !== document && context;
            \}

            \textcolor{comment}{// Add elements passing elementMatchers directly to results}
            \textcolor{comment}{// Keep `i` a string if there are no elements so `matchedCount` will be "00" below}
            \textcolor{comment}{// Support: IE<9, Safari}
            \textcolor{comment}{// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id}
            \textcolor{keywordflow}{for} ( ; i !== len && (elem = elems[i]) != null; i++ ) \{
                \textcolor{keywordflow}{if} ( byElement && elem ) \{
                    j = 0;
                    \textcolor{keywordflow}{while} ( (matcher = elementMatchers[j++]) ) \{
                        \textcolor{keywordflow}{if} ( matcher( elem, context, xml ) ) \{
                            results.push( elem );
                            \textcolor{keywordflow}{break};
                        \}
                    \}
                    \textcolor{keywordflow}{if} ( outermost ) \{
                        dirruns = dirrunsUnique;
                    \}
                \}

                \textcolor{comment}{// Track unmatched elements for set filters}
                \textcolor{keywordflow}{if} ( bySet ) \{
                    \textcolor{comment}{// They will have gone through all possible matchers}
                    \textcolor{keywordflow}{if} ( (elem = !matcher && elem) ) \{
                        matchedCount--;
                    \}

                    \textcolor{comment}{// Lengthen the array for every element, matched or not}
                    \textcolor{keywordflow}{if} ( seed ) \{
                        unmatched.push( elem );
                    \}
                \}
            \}

            \textcolor{comment}{// Apply set filters to unmatched elements}
            matchedCount += i;
            \textcolor{keywordflow}{if} ( bySet && i !== matchedCount ) \{
                j = 0;
                \textcolor{keywordflow}{while} ( (matcher = setMatchers[j++]) ) \{
                    matcher( unmatched, setMatched, context, xml );
                \}

                \textcolor{keywordflow}{if} ( seed ) \{
                    \textcolor{comment}{// Reintegrate element matches to eliminate the need for sorting}
                    \textcolor{keywordflow}{if} ( matchedCount > 0 ) \{
                        \textcolor{keywordflow}{while} ( i-- ) \{
                            \textcolor{keywordflow}{if} ( !(unmatched[i] || setMatched[i]) ) \{
                                setMatched[i] = pop.call( results );
                            \}
                        \}
                    \}

                    \textcolor{comment}{// Discard index placeholder values to get only actual matches}
                    setMatched = condense( setMatched );
                \}

                \textcolor{comment}{// Add matches to results}
                push.apply( results, setMatched );

                \textcolor{comment}{// Seedless set matches succeeding multiple successful matchers stipulate sorting}
                \textcolor{keywordflow}{if} ( outermost && !seed && setMatched.length > 0 &&
                    ( matchedCount + setMatchers.length ) > 1 ) \{

                    Sizzle.uniqueSort( results );
                \}
            \}

            \textcolor{comment}{// Override manipulation of globals by nested matchers}
            \textcolor{keywordflow}{if} ( outermost ) \{
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            \}

            \textcolor{keywordflow}{return} unmatched;
        \};

    \textcolor{keywordflow}{return} bySet ?
        markFunction( superMatcher ) :
        superMatcher;
\}

compile = Sizzle.compile = \textcolor{keyword}{function}( selector, match \textcolor{comment}{/* Internal Use Only */} ) \{
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + \textcolor{stringliteral}{" "} ];

    \textcolor{keywordflow}{if} ( !cached ) \{
        \textcolor{comment}{// Generate a function of recursive functions that can be used to check each element}
        \textcolor{keywordflow}{if} ( !match ) \{
            match = tokenize( selector );
        \}
        i = match.length;
        \textcolor{keywordflow}{while} ( i-- ) \{
            cached = matcherFromTokens( match[i] );
            \textcolor{keywordflow}{if} ( cached[ expando ] ) \{
                setMatchers.push( cached );
            \} \textcolor{keywordflow}{else} \{
                elementMatchers.push( cached );
            \}
        \}

        \textcolor{comment}{// Cache the compiled function}
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

        \textcolor{comment}{// Save selector and tokenization}
        cached.selector = selector;
    \}
    \textcolor{keywordflow}{return} cached;
\};

select = Sizzle.select = \textcolor{keyword}{function}( selector, context, results, seed ) \{
    var i, tokens, token, type, find,
        compiled = typeof selector === \textcolor{stringliteral}{"function"} && selector,
        match = !seed && tokenize( (selector = compiled.selector || selector) );

    results = results || [];

    \textcolor{comment}{// Try to minimize operations if there is no seed and only one group}
    \textcolor{keywordflow}{if} ( match.length === 1 ) \{

        \textcolor{comment}{// Take a shortcut and set the context if the root selector is an ID}
        tokens = match[0] = match[0].slice( 0 );
        \textcolor{keywordflow}{if} ( tokens.length > 2 && (token = tokens[0]).type === \textcolor{stringliteral}{"ID"} &&
                support.getById && context.nodeType === 9 && documentIsHTML &&
                Expr.relative[ tokens[1].type ] ) \{

            context = ( Expr.find[\textcolor{stringliteral}{"ID"}]( token.matches[0].replace(runescape, funescape), context ) || [] )[
      0];
            \textcolor{keywordflow}{if} ( !context ) \{
                \textcolor{keywordflow}{return} results;

            \textcolor{comment}{// Precompiled matchers will still verify ancestry, so step up a level}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( compiled ) \{
                context = context.parentNode;
            \}

            selector = selector.slice( tokens.shift().value.length );
        \}

        \textcolor{comment}{// Fetch a seed set for right-to-left matching}
        i = matchExpr[\textcolor{stringliteral}{"needsContext"}].test( selector ) ? 0 : tokens.length;
        \textcolor{keywordflow}{while} ( i-- ) \{
            token = tokens[i];

            \textcolor{comment}{// Abort if we hit a combinator}
            \textcolor{keywordflow}{if} ( Expr.relative[ (type = token.type) ] ) \{
                \textcolor{keywordflow}{break};
            \}
            \textcolor{keywordflow}{if} ( (find = Expr.find[ type ]) ) \{
                \textcolor{comment}{// Search, expanding context for leading sibling combinators}
                \textcolor{keywordflow}{if} ( (seed = find(
                    token.matches[0].replace( runescape, funescape ),
                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                )) ) \{

                    \textcolor{comment}{// If seed is empty or no tokens remain, we can return early}
                    tokens.splice( i, 1 );
                    selector = seed.length && toSelector( tokens );
                    \textcolor{keywordflow}{if} ( !selector ) \{
                        push.apply( results, seed );
                        \textcolor{keywordflow}{return} results;
                    \}

                    \textcolor{keywordflow}{break};
                \}
            \}
        \}
    \}

    \textcolor{comment}{// Compile and execute a filtering function if one is not provided}
    \textcolor{comment}{// Provide `match` to avoid retokenization if we modified the selector above}
    ( compiled || compile( selector, match ) )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector ) && testContext( context.parentNode ) || context
    );
    \textcolor{keywordflow}{return} results;
\};

\textcolor{comment}{// One-time assignments}

\textcolor{comment}{// Sort stability}
support.sortStable = expando.split(\textcolor{stringliteral}{""}).sort( sortOrder ).join(\textcolor{stringliteral}{""}) === expando;

\textcolor{comment}{// Support: Chrome<14}
\textcolor{comment}{// Always assume duplicates if they aren't passed to the comparison function}
support.detectDuplicates = !!hasDuplicate;

\textcolor{comment}{// Initialize against the default document}
setDocument();

\textcolor{comment}{// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)}
\textcolor{comment}{// Detached nodes confoundingly follow *each other*}
support.sortDetached = assert(\textcolor{keyword}{function}( div1 ) \{
    \textcolor{comment}{// Should return 1, but returns 4 (following)}
    \textcolor{keywordflow}{return} div1.compareDocumentPosition( document.createElement(\textcolor{stringliteral}{"div"}) ) & 1;
\});

\textcolor{comment}{// Support: IE<8}
\textcolor{comment}{// Prevent attribute/property "interpolation"}
\textcolor{comment}{// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx}
\textcolor{keywordflow}{if} ( !assert(\textcolor{keyword}{function}( div ) \{
    div.innerHTML = \textcolor{stringliteral}{"<a href='#'></a>"};
    \textcolor{keywordflow}{return} div.firstChild.getAttribute(\textcolor{stringliteral}{"href"}) === \textcolor{stringliteral}{"#"} ;
\}) ) \{
    addHandle( \textcolor{stringliteral}{"type|href|height|width"}, \textcolor{keyword}{function}( elem, name, isXML ) \{
        \textcolor{keywordflow}{if} ( !isXML ) \{
            \textcolor{keywordflow}{return} elem.getAttribute( name, name.toLowerCase() === \textcolor{stringliteral}{"type"} ? 1 : 2 );
        \}
    \});
\}

\textcolor{comment}{// Support: IE<9}
\textcolor{comment}{// Use defaultValue in place of getAttribute("value")}
\textcolor{keywordflow}{if} ( !support.attributes || !assert(\textcolor{keyword}{function}( div ) \{
    div.innerHTML = \textcolor{stringliteral}{"<input/>"};
    div.firstChild.setAttribute( \textcolor{stringliteral}{"value"}, \textcolor{stringliteral}{""} );
    \textcolor{keywordflow}{return} div.firstChild.getAttribute( \textcolor{stringliteral}{"value"} ) === \textcolor{stringliteral}{""};
\}) ) \{
    addHandle( \textcolor{stringliteral}{"value"}, \textcolor{keyword}{function}( elem, name, isXML ) \{
        \textcolor{keywordflow}{if} ( !isXML && elem.nodeName.toLowerCase() === \textcolor{stringliteral}{"input"} ) \{
            \textcolor{keywordflow}{return} elem.defaultValue;
        \}
    \});
\}

\textcolor{comment}{// Support: IE<9}
\textcolor{comment}{// Use getAttributeNode to fetch booleans when getAttribute lies}
\textcolor{keywordflow}{if} ( !assert(\textcolor{keyword}{function}( div ) \{
    \textcolor{keywordflow}{return} div.getAttribute(\textcolor{stringliteral}{"disabled"}) == null;
\}) ) \{
    addHandle( booleans, \textcolor{keyword}{function}( elem, name, isXML ) \{
        var val;
        \textcolor{keywordflow}{if} ( !isXML ) \{
            \textcolor{keywordflow}{return} elem[ name ] === \textcolor{keyword}{true} ? name.toLowerCase() :
                    (val = elem.getAttributeNode( name )) && val.specified ?
                    val.value :
                null;
        \}
    \});
\}

\textcolor{keywordflow}{return} Sizzle;

\})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[\textcolor{stringliteral}{":"}] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\(\backslash\)w+)\(\backslash\)s*\(\backslash\)/?>(?:<\(\backslash\)/\(\backslash\)1>|)$/);



var risSimple = /^.[^:#\(\backslash\)[\(\backslash\).,]*$/;

\textcolor{comment}{// Implement the identical functionality for filter and not}
\textcolor{keyword}{function} winnow( elements, qualifier, not ) \{
    \textcolor{keywordflow}{if} ( jQuery.isFunction( qualifier ) ) \{
        \textcolor{keywordflow}{return} jQuery.grep( elements, \textcolor{keyword}{function}( elem, i ) \{
            \textcolor{comment}{/* jshint -W018 */}
            \textcolor{keywordflow}{return} !!qualifier.call( elem, i, elem ) !== not;
        \});

    \}

    \textcolor{keywordflow}{if} ( qualifier.nodeType ) \{
        \textcolor{keywordflow}{return} jQuery.grep( elements, \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{return} ( elem === qualifier ) !== not;
        \});

    \}

    \textcolor{keywordflow}{if} ( typeof qualifier === \textcolor{stringliteral}{"string"} ) \{
        \textcolor{keywordflow}{if} ( risSimple.test( qualifier ) ) \{
            \textcolor{keywordflow}{return} jQuery.filter( qualifier, elements, not );
        \}

        qualifier = jQuery.filter( qualifier, elements );
    \}

    \textcolor{keywordflow}{return} jQuery.grep( elements, \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
    \});
\}

jQuery.filter = \textcolor{keyword}{function}( expr, elems, not ) \{
    var elem = elems[ 0 ];

    \textcolor{keywordflow}{if} ( not ) \{
        expr = \textcolor{stringliteral}{":not("} + expr + \textcolor{stringliteral}{")"};
    \}

    \textcolor{keywordflow}{return} elems.length === 1 && elem.nodeType === 1 ?
        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
        jQuery.find.matches( expr, jQuery.grep( elems, \textcolor{keyword}{function}( elem ) \{
            return elem.nodeType === 1;
        \}));
\};

jQuery.fn.extend(\{
    find: \textcolor{keyword}{function}( selector ) \{
        var i,
            len = this.length,
            ret = [],
            \textcolor{keyword}{self} = \textcolor{keyword}{this};

        \textcolor{keywordflow}{if} ( typeof selector !== \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{return} this.pushStack( jQuery( selector ).filter(\textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{for} ( i = 0; i < len; i++ ) \{
                    \textcolor{keywordflow}{if} ( jQuery.contains( \textcolor{keyword}{self}[ i ], \textcolor{keyword}{this} ) ) \{
                        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                    \}
                \}
            \}) );
        \}

        \textcolor{keywordflow}{for} ( i = 0; i < len; i++ ) \{
            jQuery.find( selector, \textcolor{keyword}{self}[ i ], ret );
        \}

        \textcolor{comment}{// Needed because $( selector, context ) becomes $( context ).find( selector )}
        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + \textcolor{stringliteral}{" "} + selector : selector;
        \textcolor{keywordflow}{return} ret;
    \},
    filter: \textcolor{keyword}{function}( selector ) \{
        \textcolor{keywordflow}{return} this.pushStack( winnow(\textcolor{keyword}{this}, selector || [], \textcolor{keyword}{false}) );
    \},
    not: \textcolor{keyword}{function}( selector ) \{
        \textcolor{keywordflow}{return} this.pushStack( winnow(\textcolor{keyword}{this}, selector || [], \textcolor{keyword}{true}) );
    \},
    is: \textcolor{keyword}{function}( selector ) \{
        \textcolor{keywordflow}{return} !!winnow(
            \textcolor{keyword}{this},

            \textcolor{comment}{// If this is a positional/relative selector, check membership in the returned set}
            \textcolor{comment}{// so $("p:first").is("p:last") won't return true for a doc with two "p".}
            typeof selector === \textcolor{stringliteral}{"string"} && rneedsContext.test( selector ) ?
                jQuery( selector ) :
                selector || [],
            false
        ).length;
    \}
\});


\textcolor{comment}{// Initialize a jQuery object}


\textcolor{comment}{// A central reference to the root jQuery(document)}
var rootjQuery,

    \textcolor{comment}{// A simple way to check for HTML strings}
    \textcolor{comment}{// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)}
    \textcolor{comment}{// Strict HTML recognition (#11290: must start with <)}
    rquickExpr = /^(?:\(\backslash\)s*(<[\(\backslash\)w\(\backslash\)W]+>)[^>]*|#([\(\backslash\)w-]*))$/,

    init = jQuery.fn.init = \textcolor{keyword}{function}( selector, context ) \{
        var match, elem;

        \textcolor{comment}{// HANDLE: $(""), $(null), $(undefined), $(false)}
        \textcolor{keywordflow}{if} ( !selector ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
        \}

        \textcolor{comment}{// Handle HTML strings}
        \textcolor{keywordflow}{if} ( typeof selector === \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{if} ( selector[0] === \textcolor{stringliteral}{"<"} && selector[ selector.length - 1 ] === \textcolor{stringliteral}{">"} && selector.length >= 3 ) \{
                \textcolor{comment}{// Assume that strings that start and end with <> are HTML and skip the regex check}
                match = [ null, selector, null ];

            \} \textcolor{keywordflow}{else} \{
                match = rquickExpr.exec( selector );
            \}

            \textcolor{comment}{// Match html or make sure no context is specified for #id}
            \textcolor{keywordflow}{if} ( match && (match[1] || !context) ) \{

                \textcolor{comment}{// HANDLE: $(html) -> $(array)}
                \textcolor{keywordflow}{if} ( match[1] ) \{
                    context = context instanceof jQuery ? context[0] : context;

                    \textcolor{comment}{// scripts is true for back-compat}
                    \textcolor{comment}{// Intentionally let the error be thrown if parseHTML is not present}
                    jQuery.merge( \textcolor{keyword}{this}, jQuery.parseHTML(
                        match[1],
                        context && context.nodeType ? context.ownerDocument || context : document,
                        \textcolor{keyword}{true}
                    ) );

                    \textcolor{comment}{// HANDLE: $(html, props)}
                    \textcolor{keywordflow}{if} ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) \{
                        \textcolor{keywordflow}{for} ( match in context ) \{
                            \textcolor{comment}{// Properties of context are called as methods if possible}
                            \textcolor{keywordflow}{if} ( jQuery.isFunction( \textcolor{keyword}{this}[ match ] ) ) \{
                                \textcolor{keyword}{this}[ match ]( context[ match ] );

                            \textcolor{comment}{// ...and otherwise set as attributes}
                            \} \textcolor{keywordflow}{else} \{
                                this.attr( match, context[ match ] );
                            \}
                        \}
                    \}

                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};

                \textcolor{comment}{// HANDLE: $(#id)}
                \} \textcolor{keywordflow}{else} \{
                    elem = document.getElementById( match[2] );

                    \textcolor{comment}{// Check parentNode to catch when Blackberry 4.6 returns}
                    \textcolor{comment}{// nodes that are no longer in the document #6963}
                    \textcolor{keywordflow}{if} ( elem && elem.parentNode ) \{
                        \textcolor{comment}{// Inject the element directly into the jQuery object}
                        this.length = 1;
                        \textcolor{keyword}{this}[0] = elem;
                    \}

                    this.context = document;
                    this.selector = selector;
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \}

            \textcolor{comment}{// HANDLE: $(expr, $(...))}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !context || context.jquery ) \{
                \textcolor{keywordflow}{return} ( context || rootjQuery ).find( selector );

            \textcolor{comment}{// HANDLE: $(expr, context)}
            \textcolor{comment}{// (which is just equivalent to: $(context).find(expr)}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{return} this.constructor( context ).find( selector );
            \}

        \textcolor{comment}{// HANDLE: $(DOMElement)}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( selector.nodeType ) \{
            this.context = \textcolor{keyword}{this}[0] = selector;
            this.length = 1;
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};

        \textcolor{comment}{// HANDLE: $(function)}
        \textcolor{comment}{// Shortcut for document ready}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( jQuery.isFunction( selector ) ) \{
            \textcolor{keywordflow}{return} typeof rootjQuery.ready !== \textcolor{stringliteral}{"undefined"} ?
                rootjQuery.ready( selector ) :
                \textcolor{comment}{// Execute immediately if ready is not present}
                selector( jQuery );
        \}

        \textcolor{keywordflow}{if} ( selector.selector !== undefined ) \{
            this.selector = selector.selector;
            this.context = selector.context;
        \}

        \textcolor{keywordflow}{return} jQuery.makeArray( selector, \textcolor{keyword}{this} );
    \};

\textcolor{comment}{// Give the init function the jQuery prototype for later instantiation}
init.prototype = jQuery.fn;

\textcolor{comment}{// Initialize central reference}
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    \textcolor{comment}{// methods guaranteed to produce a unique set when starting from a unique set}
    guaranteedUnique = \{
        children: \textcolor{keyword}{true},
        contents: \textcolor{keyword}{true},
        next: \textcolor{keyword}{true},
        prev: \textcolor{keyword}{true}
    \};

jQuery.extend(\{
    dir: \textcolor{keyword}{function}( elem, dir, until ) \{
        var matched = [],
            truncate = until !== undefined;

        \textcolor{keywordflow}{while} ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) \{
            \textcolor{keywordflow}{if} ( elem.nodeType === 1 ) \{
                \textcolor{keywordflow}{if} ( truncate && jQuery( elem ).is( until ) ) \{
                    \textcolor{keywordflow}{break};
                \}
                matched.push( elem );
            \}
        \}
        \textcolor{keywordflow}{return} matched;
    \},

    sibling: \textcolor{keyword}{function}( n, elem ) \{
        var matched = [];

        \textcolor{keywordflow}{for} ( ; n; n = n.nextSibling ) \{
            \textcolor{keywordflow}{if} ( n.nodeType === 1 && n !== elem ) \{
                matched.push( n );
            \}
        \}

        \textcolor{keywordflow}{return} matched;
    \}
\});

jQuery.fn.extend(\{
    has: \textcolor{keyword}{function}( target ) \{
        var targets = jQuery( target, \textcolor{keyword}{this} ),
            l = targets.length;

        \textcolor{keywordflow}{return} this.filter(\textcolor{keyword}{function}() \{
            var i = 0;
            \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
                \textcolor{keywordflow}{if} ( jQuery.contains( \textcolor{keyword}{this}, targets[i] ) ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
                \}
            \}
        \});
    \},

    closest: \textcolor{keyword}{function}( selectors, context ) \{
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            pos = rneedsContext.test( selectors ) || typeof selectors !== \textcolor{stringliteral}{"string"} ?
                jQuery( selectors, context || this.context ) :
                0;

        \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
            \textcolor{keywordflow}{for} ( cur = \textcolor{keyword}{this}[i]; cur && cur !== context; cur = cur.parentNode ) \{
                \textcolor{comment}{// Always skip document fragments}
                \textcolor{keywordflow}{if} ( cur.nodeType < 11 && (pos ?
                    pos.index(cur) > -1 :

                    \textcolor{comment}{// Don't pass non-elements to Sizzle}
                    cur.nodeType === 1 &&
                        jQuery.find.matchesSelector(cur, selectors)) ) \{

                    matched.push( cur );
                    \textcolor{keywordflow}{break};
                \}
            \}
        \}

        \textcolor{keywordflow}{return} this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
    \},

    \textcolor{comment}{// Determine the position of an element within}
    \textcolor{comment}{// the matched set of elements}
    index: \textcolor{keyword}{function}( elem ) \{

        \textcolor{comment}{// No argument, return index in parent}
        \textcolor{keywordflow}{if} ( !elem ) \{
            \textcolor{keywordflow}{return} ( \textcolor{keyword}{this}[ 0 ] && \textcolor{keyword}{this}[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
        \}

        \textcolor{comment}{// index in selector}
        \textcolor{keywordflow}{if} ( typeof elem === \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{return} indexOf.call( jQuery( elem ), \textcolor{keyword}{this}[ 0 ] );
        \}

        \textcolor{comment}{// Locate the position of the desired element}
        \textcolor{keywordflow}{return} indexOf.call( \textcolor{keyword}{this},

            \textcolor{comment}{// If it receives a jQuery object, the first element is used}
            elem.jquery ? elem[ 0 ] : elem
        );
    \},

    add: \textcolor{keyword}{function}( selector, context ) \{
        \textcolor{keywordflow}{return} this.pushStack(
            jQuery.unique(
                jQuery.merge( \textcolor{keyword}{this}.get(), jQuery( selector, context ) )
            )
        );
    \},

    addBack: \textcolor{keyword}{function}( selector ) \{
        \textcolor{keywordflow}{return} this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    \}
\});

\textcolor{keyword}{function} sibling( cur, dir ) \{
    \textcolor{keywordflow}{while} ( (cur = cur[dir]) && cur.nodeType !== 1 ) \{\}
    \textcolor{keywordflow}{return} cur;
\}

jQuery.each(\{
    parent: \textcolor{keyword}{function}( elem ) \{
        var parent = elem.parentNode;
        \textcolor{keywordflow}{return} parent && parent.nodeType !== 11 ? parent : null;
    \},
    parents: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"parentNode"} );
    \},
    parentsUntil: \textcolor{keyword}{function}( elem, i, until ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"parentNode"}, until );
    \},
    next: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} sibling( elem, \textcolor{stringliteral}{"nextSibling"} );
    \},
    prev: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} sibling( elem, \textcolor{stringliteral}{"previousSibling"} );
    \},
    nextAll: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"nextSibling"} );
    \},
    prevAll: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"previousSibling"} );
    \},
    nextUntil: \textcolor{keyword}{function}( elem, i, until ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"nextSibling"}, until );
    \},
    prevUntil: \textcolor{keyword}{function}( elem, i, until ) \{
        \textcolor{keywordflow}{return} jQuery.dir( elem, \textcolor{stringliteral}{"previousSibling"}, until );
    \},
    siblings: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} jQuery.sibling( ( elem.parentNode || \{\} ).firstChild, elem );
    \},
    children: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} jQuery.sibling( elem.firstChild );
    \},
    contents: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} elem.contentDocument || jQuery.merge( [], elem.childNodes );
    \}
\}, \textcolor{keyword}{function}( name, fn ) \{
    jQuery.fn[ name ] = \textcolor{keyword}{function}( until, selector ) \{
        var matched = jQuery.map( \textcolor{keyword}{this}, fn, until );

        \textcolor{keywordflow}{if} ( name.slice( -5 ) !== \textcolor{stringliteral}{"Until"} ) \{
            selector = until;
        \}

        \textcolor{keywordflow}{if} ( selector && typeof selector === \textcolor{stringliteral}{"string"} ) \{
            matched = jQuery.filter( selector, matched );
        \}

        \textcolor{keywordflow}{if} ( this.length > 1 ) \{
            \textcolor{comment}{// Remove duplicates}
            \textcolor{keywordflow}{if} ( !guaranteedUnique[ name ] ) \{
                jQuery.unique( matched );
            \}

            \textcolor{comment}{// Reverse order for parents* and prev-derivatives}
            \textcolor{keywordflow}{if} ( rparentsprev.test( name ) ) \{
                matched.reverse();
            \}
        \}

        \textcolor{keywordflow}{return} this.pushStack( matched );
    \};
\});
var rnotwhite = (/\(\backslash\)S+/g);



\textcolor{comment}{// String to Object options format cache}
var optionsCache = \{\};

\textcolor{comment}{// Convert String-formatted options into Object-formatted ones and store in cache}
\textcolor{keyword}{function} createOptions( options ) \{
    var \textcolor{keywordtype}{object} = optionsCache[ options ] = \{\};
    jQuery.each( options.match( rnotwhite ) || [], \textcolor{keyword}{function}( \_, flag ) \{
        \textcolor{keywordtype}{object}[ flag ] = \textcolor{keyword}{true};
    \});
    \textcolor{keywordflow}{return} object;
\}

\textcolor{comment}{/*}
\textcolor{comment}{ * Create a callback list using the following parameters:}
\textcolor{comment}{ *}
\textcolor{comment}{ *  options: an optional list of space-separated options that will change how}
\textcolor{comment}{ *          the callback list behaves or a more traditional option object}
\textcolor{comment}{ *}
\textcolor{comment}{ * By default a callback list will act like an event callback list and can be}
\textcolor{comment}{ * "fired" multiple times.}
\textcolor{comment}{ *}
\textcolor{comment}{ * Possible options:}
\textcolor{comment}{ *}
\textcolor{comment}{ *  once:           will ensure the callback list can only be fired once (like a Deferred)}
\textcolor{comment}{ *}
\textcolor{comment}{ *  memory:         will keep track of previous values and will call any callback added}
\textcolor{comment}{ *                  after the list has been fired right away with the latest "memorized"}
\textcolor{comment}{ *                  values (like a Deferred)}
\textcolor{comment}{ *}
\textcolor{comment}{ *  unique:         will ensure a callback can only be added once (no duplicate in the list)}
\textcolor{comment}{ *}
\textcolor{comment}{ *  stopOnFalse:    interrupt callings when a callback returns false}
\textcolor{comment}{ *}
\textcolor{comment}{ */}
jQuery.Callbacks = \textcolor{keyword}{function}( options ) \{

    \textcolor{comment}{// Convert options from String-formatted to Object-formatted if needed}
    \textcolor{comment}{// (we check in cache first)}
    options = typeof options === \textcolor{stringliteral}{"string"} ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( \{\}, options );

    var \textcolor{comment}{// Last fire value (for non-forgettable lists)}
        memory,
        \textcolor{comment}{// Flag to know if list was already fired}
        fired,
        \textcolor{comment}{// Flag to know if list is currently firing}
        firing,
        \textcolor{comment}{// First callback to fire (used internally by add and fireWith)}
        firingStart,
        \textcolor{comment}{// End of the loop when firing}
        firingLength,
        \textcolor{comment}{// Index of currently firing callback (modified by remove if needed)}
        firingIndex,
        \textcolor{comment}{// Actual callback list}
        list = [],
        \textcolor{comment}{// Stack of fire calls for repeatable lists}
        stack = !options.once && [],
        \textcolor{comment}{// Fire callbacks}
        fire = \textcolor{keyword}{function}( data ) \{
            memory = options.memory && data;
            fired = \textcolor{keyword}{true};
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = \textcolor{keyword}{true};
            \textcolor{keywordflow}{for} ( ; list && firingIndex < firingLength; firingIndex++ ) \{
                \textcolor{keywordflow}{if} ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === \textcolor{keyword}{false} && options.stopOnFalse ) \{
                    memory = \textcolor{keyword}{false}; \textcolor{comment}{// To prevent further calls using add}
                    \textcolor{keywordflow}{break};
                \}
            \}
            firing = \textcolor{keyword}{false};
            \textcolor{keywordflow}{if} ( list ) \{
                \textcolor{keywordflow}{if} ( stack ) \{
                    \textcolor{keywordflow}{if} ( stack.length ) \{
                        fire( stack.shift() );
                    \}
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( memory ) \{
                    list = [];
                \} \textcolor{keywordflow}{else} \{
                    \textcolor{keyword}{self}.disable();
                \}
            \}
        \},
        \textcolor{comment}{// Actual Callbacks object}
        \textcolor{keyword}{self} = \{
            \textcolor{comment}{// Add a callback or a collection of callbacks to the list}
            add: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( list ) \{
                    \textcolor{comment}{// First, we save the current length}
                    var start = list.length;
                    (\textcolor{keyword}{function} add( args ) \{
                        jQuery.each( args, \textcolor{keyword}{function}( \_, arg ) \{
                            var type = jQuery.type( arg );
                            \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"function"} ) \{
                                \textcolor{keywordflow}{if} ( !options.unique || !\textcolor{keyword}{self}.has( arg ) ) \{
                                    list.push( arg );
                                \}
                            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( arg && arg.length && type !== \textcolor{stringliteral}{"string"} ) \{
                                \textcolor{comment}{// Inspect recursively}
                                add( arg );
                            \}
                        \});
                    \})( arguments );
                    \textcolor{comment}{// Do we need to add the callbacks to the}
                    \textcolor{comment}{// current firing batch?}
                    \textcolor{keywordflow}{if} ( firing ) \{
                        firingLength = list.length;
                    \textcolor{comment}{// With memory, if we're not firing then}
                    \textcolor{comment}{// we should call right away}
                    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( memory ) \{
                        firingStart = start;
                        fire( memory );
                    \}
                \}
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Remove a callback from the list}
            \textcolor{keyword}{remove}: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( list ) \{
                    jQuery.each( arguments, \textcolor{keyword}{function}( \_, arg ) \{
                        var index;
                        \textcolor{keywordflow}{while} ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) \{
                            list.splice( index, 1 );
                            \textcolor{comment}{// Handle firing indexes}
                            \textcolor{keywordflow}{if} ( firing ) \{
                                \textcolor{keywordflow}{if} ( index <= firingLength ) \{
                                    firingLength--;
                                \}
                                \textcolor{keywordflow}{if} ( index <= firingIndex ) \{
                                    firingIndex--;
                                \}
                            \}
                        \}
                    \});
                \}
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Check if a given callback is in the list.}
            \textcolor{comment}{// If no argument is given, return whether or not list has callbacks attached.}
            has: \textcolor{keyword}{function}( fn ) \{
                \textcolor{keywordflow}{return} fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
            \},
            \textcolor{comment}{// Remove all callbacks from the list}
            empty: \textcolor{keyword}{function}() \{
                list = [];
                firingLength = 0;
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Have the list do nothing anymore}
            disable: \textcolor{keyword}{function}() \{
                list = stack = memory = undefined;
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Is it disabled?}
            disabled: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{return} !list;
            \},
            \textcolor{comment}{// Lock the list in its current state}
            lock: \textcolor{keyword}{function}() \{
                stack = undefined;
                \textcolor{keywordflow}{if} ( !memory ) \{
                    \textcolor{keyword}{self}.disable();
                \}
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Is it locked?}
            locked: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{return} !stack;
            \},
            \textcolor{comment}{// Call all callbacks with the given context and arguments}
            fireWith: \textcolor{keyword}{function}( context, args ) \{
                \textcolor{keywordflow}{if} ( list && ( !fired || stack ) ) \{
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    \textcolor{keywordflow}{if} ( firing ) \{
                        stack.push( args );
                    \} \textcolor{keywordflow}{else} \{
                        fire( args );
                    \}
                \}
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// Call all the callbacks with the given arguments}
            fire: \textcolor{keyword}{function}() \{
                \textcolor{keyword}{self}.fireWith( \textcolor{keyword}{this}, arguments );
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \},
            \textcolor{comment}{// To know if the callbacks have already been called at least once}
            fired: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{return} !!fired;
            \}
        \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{self};
\};


jQuery.extend(\{

    Deferred: \textcolor{keyword}{function}( func ) \{
        var tuples = [
                \textcolor{comment}{// action, add listener, listener list, final state}
                [ \textcolor{stringliteral}{"resolve"}, \textcolor{stringliteral}{"done"}, jQuery.Callbacks(\textcolor{stringliteral}{"once memory"}), \textcolor{stringliteral}{"resolved"} ],
                [ \textcolor{stringliteral}{"reject"}, \textcolor{stringliteral}{"fail"}, jQuery.Callbacks(\textcolor{stringliteral}{"once memory"}), \textcolor{stringliteral}{"rejected"} ],
                [ \textcolor{stringliteral}{"notify"}, \textcolor{stringliteral}{"progress"}, jQuery.Callbacks(\textcolor{stringliteral}{"memory"}) ]
            ],
            state = \textcolor{stringliteral}{"pending"},
            promise = \{
                state: \textcolor{keyword}{function}() \{
                    \textcolor{keywordflow}{return} state;
                \},
                always: \textcolor{keyword}{function}() \{
                    deferred.done( arguments ).fail( arguments );
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \},
                then: \textcolor{keyword}{function}( \textcolor{comment}{/* fnDone, fnFail, fnProgress */} ) \{
                    var fns = arguments;
                    \textcolor{keywordflow}{return} jQuery.Deferred(\textcolor{keyword}{function}( newDefer ) \{
                        jQuery.each( tuples, \textcolor{keyword}{function}( i, tuple ) \{
                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                            \textcolor{comment}{// deferred[ done | fail | progress ] for forwarding actions to newDefer}
                            deferred[ tuple[1] ](\textcolor{keyword}{function}() \{
                                var returned = fn && fn.apply( \textcolor{keyword}{this}, arguments );
                                \textcolor{keywordflow}{if} ( returned && jQuery.isFunction( returned.promise ) ) \{
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject )
                                        .progress( newDefer.notify );
                                \} \textcolor{keywordflow}{else} \{
                                    newDefer[ tuple[ 0 ] + \textcolor{stringliteral}{"With"} ]( \textcolor{keyword}{this} === promise ? newDefer.promise() 
      : \textcolor{keyword}{this}, fn ? [ returned ] : arguments );
                                \}
                            \});
                        \});
                        fns = null;
                    \}).promise();
                \},
                \textcolor{comment}{// Get a promise for this deferred}
                \textcolor{comment}{// If obj is provided, the promise aspect is added to the object}
                promise: \textcolor{keyword}{function}( obj ) \{
                    \textcolor{keywordflow}{return} obj != null ? jQuery.extend( obj, promise ) : promise;
                \}
            \},
            deferred = \{\};

        \textcolor{comment}{// Keep pipe for back-compat}
        promise.pipe = promise.then;

        \textcolor{comment}{// Add list-specific methods}
        jQuery.each( tuples, \textcolor{keyword}{function}( i, tuple ) \{
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            \textcolor{comment}{// promise[ done | fail | progress ] = list.add}
            promise[ tuple[1] ] = list.add;

            \textcolor{comment}{// Handle state}
            \textcolor{keywordflow}{if} ( stateString ) \{
                list.add(\textcolor{keyword}{function}() \{
                    \textcolor{comment}{// state = [ resolved | rejected ]}
                    state = stateString;

                \textcolor{comment}{// [ reject\_list | resolve\_list ].disable; progress\_list.lock}
                \}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            \}

            \textcolor{comment}{// deferred[ resolve | reject | notify ]}
            deferred[ tuple[0] ] = \textcolor{keyword}{function}() \{
                deferred[ tuple[0] + \textcolor{stringliteral}{"With"} ]( \textcolor{keyword}{this} === deferred ? promise : \textcolor{keyword}{this}, arguments );
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \};
            deferred[ tuple[0] + \textcolor{stringliteral}{"With"} ] = list.fireWith;
        \});

        \textcolor{comment}{// Make the deferred a promise}
        promise.promise( deferred );

        \textcolor{comment}{// Call given func if any}
        \textcolor{keywordflow}{if} ( func ) \{
            func.call( deferred, deferred );
        \}

        \textcolor{comment}{// All done!}
        \textcolor{keywordflow}{return} deferred;
    \},

    \textcolor{comment}{// Deferred helper}
    when: \textcolor{keyword}{function}( subordinate \textcolor{comment}{/* , ..., subordinateN */} ) \{
        var i = 0,
            resolveValues = slice.call( arguments ),
            length = resolveValues.length,

            \textcolor{comment}{// the count of uncompleted subordinates}
            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? 
      length : 0,

            \textcolor{comment}{// the master Deferred. If resolveValues consist of only a single Deferred, just use that.}
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            \textcolor{comment}{// Update function for both resolve and progress values}
            updateFunc = \textcolor{keyword}{function}( i, contexts, values ) \{
                \textcolor{keywordflow}{return} \textcolor{keyword}{function}( value ) \{
                    contexts[ i ] = \textcolor{keyword}{this};
                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                    \textcolor{keywordflow}{if} ( values === progressValues ) \{
                        deferred.notifyWith( contexts, values );
                    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !( --remaining ) ) \{
                        deferred.resolveWith( contexts, values );
                    \}
                \};
            \},

            progressValues, progressContexts, resolveContexts;

        \textcolor{comment}{// add listeners to Deferred subordinates; treat others as resolved}
        \textcolor{keywordflow}{if} ( length > 1 ) \{
            progressValues = \textcolor{keyword}{new} Array( length );
            progressContexts = \textcolor{keyword}{new} Array( length );
            resolveContexts = \textcolor{keyword}{new} Array( length );
            \textcolor{keywordflow}{for} ( ; i < length; i++ ) \{
                \textcolor{keywordflow}{if} ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) \{
                    resolveValues[ i ].promise()
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                \} \textcolor{keywordflow}{else} \{
                    --remaining;
                \}
            \}
        \}

        \textcolor{comment}{// if we're not waiting on anything, resolve the master}
        \textcolor{keywordflow}{if} ( !remaining ) \{
            deferred.resolveWith( resolveContexts, resolveValues );
        \}

        \textcolor{keywordflow}{return} deferred.promise();
    \}
\});


\textcolor{comment}{// The deferred used on DOM ready}
var readyList;

jQuery.fn.ready = \textcolor{keyword}{function}( fn ) \{
    \textcolor{comment}{// Add the callback}
    jQuery.ready.promise().done( fn );

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
\};

jQuery.extend(\{
    \textcolor{comment}{// Is the DOM ready to be used? Set to true once it occurs.}
    isReady: \textcolor{keyword}{false},

    \textcolor{comment}{// A counter to track how many items to wait for before}
    \textcolor{comment}{// the ready event fires. See #6781}
    readyWait: 1,

    \textcolor{comment}{// Hold (or release) the ready event}
    holdReady: \textcolor{keyword}{function}( hold ) \{
        \textcolor{keywordflow}{if} ( hold ) \{
            jQuery.readyWait++;
        \} \textcolor{keywordflow}{else} \{
            jQuery.ready( \textcolor{keyword}{true} );
        \}
    \},

    \textcolor{comment}{// Handle when the DOM is ready}
    ready: \textcolor{keyword}{function}( wait ) \{

        \textcolor{comment}{// Abort if there are pending holds or we're already ready}
        \textcolor{keywordflow}{if} ( wait === \textcolor{keyword}{true} ? --jQuery.readyWait : jQuery.isReady ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Remember that the DOM is ready}
        jQuery.isReady = \textcolor{keyword}{true};

        \textcolor{comment}{// If a normal DOM Ready event fired, decrement, and wait if need be}
        \textcolor{keywordflow}{if} ( wait !== \textcolor{keyword}{true} && --jQuery.readyWait > 0 ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// If there are functions bound, to execute}
        readyList.resolveWith( document, [ jQuery ] );

        \textcolor{comment}{// Trigger any bound ready events}
        \textcolor{keywordflow}{if} ( jQuery.fn.triggerHandler ) \{
            jQuery( document ).triggerHandler( \textcolor{stringliteral}{"ready"} );
            jQuery( document ).off( \textcolor{stringliteral}{"ready"} );
        \}
    \}
\});

\textcolor{keyword}{function} completed() \{
    document.removeEventListener( \textcolor{stringliteral}{"DOMContentLoaded"}, completed, \textcolor{keyword}{false} );
    window.removeEventListener( \textcolor{stringliteral}{"load"}, completed, \textcolor{keyword}{false} );
    jQuery.ready();
\}

jQuery.ready.promise = \textcolor{keyword}{function}( obj ) \{
    \textcolor{keywordflow}{if} ( !readyList ) \{

        readyList = jQuery.Deferred();

        \textcolor{comment}{// Catch cases where $(document).ready() is called after the browser event has already occurred.}
        \textcolor{comment}{// we once tried to use readyState "interactive" here, but it caused issues like the one}
        \textcolor{comment}{// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15}
        \textcolor{keywordflow}{if} ( document.readyState === \textcolor{stringliteral}{"complete"} ) \{
            \textcolor{comment}{// Handle it asynchronously to allow scripts the opportunity to delay ready}
            setTimeout( jQuery.ready );

        \} \textcolor{keywordflow}{else} \{

            \textcolor{comment}{// Use the handy event callback}
            document.addEventListener( \textcolor{stringliteral}{"DOMContentLoaded"}, completed, \textcolor{keyword}{false} );

            \textcolor{comment}{// A fallback to window.onload, that will always work}
            window.addEventListener( \textcolor{stringliteral}{"load"}, completed, \textcolor{keyword}{false} );
        \}
    \}
    \textcolor{keywordflow}{return} readyList.promise( obj );
\};

\textcolor{comment}{// Kick off the DOM ready check even if the user does not}
jQuery.ready.promise();




\textcolor{comment}{// Multifunctional method to get and set values of a collection}
\textcolor{comment}{// The value/s can optionally be executed if it's a function}
var access = jQuery.access = \textcolor{keyword}{function}( elems, fn, key, value, chainable, emptyGet, raw ) \{
    var i = 0,
        len = elems.length,
        bulk = key == null;

    \textcolor{comment}{// Sets many values}
    \textcolor{keywordflow}{if} ( jQuery.type( key ) === \textcolor{stringliteral}{"object"} ) \{
        chainable = \textcolor{keyword}{true};
        \textcolor{keywordflow}{for} ( i in key ) \{
            jQuery.access( elems, fn, i, key[i], \textcolor{keyword}{true}, emptyGet, raw );
        \}

    \textcolor{comment}{// Sets one value}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( value !== undefined ) \{
        chainable = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} ( !jQuery.isFunction( value ) ) \{
            raw = \textcolor{keyword}{true};
        \}

        \textcolor{keywordflow}{if} ( bulk ) \{
            \textcolor{comment}{// Bulk operations run against the entire set}
            \textcolor{keywordflow}{if} ( raw ) \{
                fn.call( elems, value );
                fn = null;

            \textcolor{comment}{// ...except when executing function values}
            \} \textcolor{keywordflow}{else} \{
                bulk = fn;
                fn = \textcolor{keyword}{function}( elem, key, value ) \{
                    \textcolor{keywordflow}{return} bulk.call( jQuery( elem ), value );
                \};
            \}
        \}

        \textcolor{keywordflow}{if} ( fn ) \{
            \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
            \}
        \}
    \}

    \textcolor{keywordflow}{return} chainable ?
        elems :

        \textcolor{comment}{// Gets}
        bulk ?
            fn.call( elems ) :
            len ? fn( elems[0], key ) : emptyGet;
\};


jQuery.acceptData = \textcolor{keyword}{function}( owner ) \{
    \textcolor{comment}{// Accepts only:}
    \textcolor{comment}{//  - Node}
    \textcolor{comment}{//    - Node.ELEMENT\_NODE}
    \textcolor{comment}{//    - Node.DOCUMENT\_NODE}
    \textcolor{comment}{//  - Object}
    \textcolor{comment}{//    - Any}
    \textcolor{comment}{/* jshint -W018 */}
    \textcolor{keywordflow}{return} owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
\};


\textcolor{keyword}{function} Data() \{
    \textcolor{comment}{// Support: Android < 4,}
    \textcolor{comment}{// Old WebKit does not have Object.preventExtensions/freeze method,}
    \textcolor{comment}{// return new empty object instead with no [[set]] accessor}
    Object.defineProperty( this.cache = \{\}, 0, \{
        \textcolor{keyword}{get}: \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} \{\};
        \}
    \});

    this.expando = jQuery.expando + Math.random();
\}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = \{
    key: \textcolor{keyword}{function}( owner ) \{
        \textcolor{comment}{// We can accept data for non-element nodes in modern browsers,}
        \textcolor{comment}{// but we should not, see #8335.}
        \textcolor{comment}{// Always return the key for a frozen object.}
        \textcolor{keywordflow}{if} ( !Data.accepts( owner ) ) \{
            \textcolor{keywordflow}{return} 0;
        \}

        var descriptor = \{\},
            \textcolor{comment}{// Check if the owner object already has a cache key}
            unlock = owner[ this.expando ];

        \textcolor{comment}{// If not, create one}
        \textcolor{keywordflow}{if} ( !unlock ) \{
            unlock = Data.uid++;

            \textcolor{comment}{// Secure it in a non-enumerable, non-writable property}
            \textcolor{keywordflow}{try} \{
                descriptor[ this.expando ] = \{ value: unlock \};
                Object.defineProperties( owner, descriptor );

            \textcolor{comment}{// Support: Android < 4}
            \textcolor{comment}{// Fallback to a less secure definition}
            \} \textcolor{keywordflow}{catch} ( e ) \{
                descriptor[ this.expando ] = unlock;
                jQuery.extend( owner, descriptor );
            \}
        \}

        \textcolor{comment}{// Ensure the cache object}
        \textcolor{keywordflow}{if} ( !this.cache[ unlock ] ) \{
            this.cache[ unlock ] = \{\};
        \}

        \textcolor{keywordflow}{return} unlock;
    \},
    set: \textcolor{keyword}{function}( owner, data, value ) \{
        var prop,
            \textcolor{comment}{// There may be an unlock assigned to this node,}
            \textcolor{comment}{// if there is no entry for this "owner", create one inline}
            \textcolor{comment}{// and set the unlock as though an owner entry had always existed}
            unlock = this.key( owner ),
            cache = this.cache[ unlock ];

        \textcolor{comment}{// Handle: [ owner, key, value ] args}
        \textcolor{keywordflow}{if} ( typeof data === \textcolor{stringliteral}{"string"} ) \{
            cache[ data ] = value;

        \textcolor{comment}{// Handle: [ owner, \{ properties \} ] args}
        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// Fresh assignments by object are shallow copied}
            \textcolor{keywordflow}{if} ( jQuery.isEmptyObject( cache ) ) \{
                jQuery.extend( this.cache[ unlock ], data );
            \textcolor{comment}{// Otherwise, copy the properties one-by-one to the cache object}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{for} ( prop in data ) \{
                    cache[ prop ] = data[ prop ];
                \}
            \}
        \}
        \textcolor{keywordflow}{return} cache;
    \},
    \textcolor{keyword}{get}: \textcolor{keyword}{function}( owner, key ) \{
        \textcolor{comment}{// Either a valid cache is found, or will be created.}
        \textcolor{comment}{// New caches will be created and the unlock returned,}
        \textcolor{comment}{// allowing direct access to the newly created}
        \textcolor{comment}{// empty data object. A valid owner object must be provided.}
        var cache = this.cache[ this.key( owner ) ];

        \textcolor{keywordflow}{return} key === undefined ?
            cache : cache[ key ];
    \},
    access: \textcolor{keyword}{function}( owner, key, value ) \{
        var stored;
        \textcolor{comment}{// In cases where either:}
        \textcolor{comment}{//}
        \textcolor{comment}{//   1. No key was specified}
        \textcolor{comment}{//   2. A string key was specified, but no value provided}
        \textcolor{comment}{//}
        \textcolor{comment}{// Take the "read" path and allow the get method to determine}
        \textcolor{comment}{// which value to return, respectively either:}
        \textcolor{comment}{//}
        \textcolor{comment}{//   1. The entire cache object}
        \textcolor{comment}{//   2. The data stored at the key}
        \textcolor{comment}{//}
        \textcolor{keywordflow}{if} ( key === undefined ||
                ((key && typeof key === \textcolor{stringliteral}{"string"}) && value === undefined) ) \{

            stored = this.\textcolor{keyword}{get}( owner, key );

            \textcolor{keywordflow}{return} stored !== undefined ?
                stored : this.\textcolor{keyword}{get}( owner, jQuery.camelCase(key) );
        \}

        \textcolor{comment}{// [*]When the key is not a string, or both a key and value}
        \textcolor{comment}{// are specified, set or extend (existing objects) with either:}
        \textcolor{comment}{//}
        \textcolor{comment}{//   1. An object of properties}
        \textcolor{comment}{//   2. A key and value}
        \textcolor{comment}{//}
        this.set( owner, key, value );

        \textcolor{comment}{// Since the "set" path can have two possible entry points}
        \textcolor{comment}{// return the expected data based on which path was taken[*]}
        \textcolor{keywordflow}{return} value !== undefined ? value : key;
    \},
    \textcolor{keyword}{remove}: \textcolor{keyword}{function}( owner, key ) \{
        var i, name, camel,
            unlock = this.key( owner ),
            cache = this.cache[ unlock ];

        \textcolor{keywordflow}{if} ( key === undefined ) \{
            this.cache[ unlock ] = \{\};

        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// Support array or space separated string of keys}
            \textcolor{keywordflow}{if} ( jQuery.isArray( key ) ) \{
                \textcolor{comment}{// If "name" is an array of keys...}
                \textcolor{comment}{// When data is initially created, via ("key", "val") signature,}
                \textcolor{comment}{// keys will be converted to camelCase.}
                \textcolor{comment}{// Since there is no way to tell \_how\_ a key was added, remove}
                \textcolor{comment}{// both plain key and camelCase key. #12786}
                \textcolor{comment}{// This will only penalize the array argument path.}
                name = key.concat( key.map( jQuery.camelCase ) );
            \} \textcolor{keywordflow}{else} \{
                camel = jQuery.camelCase( key );
                \textcolor{comment}{// Try the string as a key before any manipulation}
                \textcolor{keywordflow}{if} ( key in cache ) \{
                    name = [ key, camel ];
                \} \textcolor{keywordflow}{else} \{
                    \textcolor{comment}{// If a key with the spaces exists, use it.}
                    \textcolor{comment}{// Otherwise, create an array by matching non-whitespace}
                    name = camel;
                    name = name in cache ?
                        [ name ] : ( name.match( rnotwhite ) || [] );
                \}
            \}

            i = name.length;
            \textcolor{keywordflow}{while} ( i-- ) \{
                \textcolor{keyword}{delete} cache[ name[ i ] ];
            \}
        \}
    \},
    hasData: \textcolor{keyword}{function}( owner ) \{
        \textcolor{keywordflow}{return} !jQuery.isEmptyObject(
            this.cache[ owner[ this.expando ] ] || \{\}
        );
    \},
    discard: \textcolor{keyword}{function}( owner ) \{
        \textcolor{keywordflow}{if} ( owner[ this.expando ] ) \{
            \textcolor{keyword}{delete} this.cache[ owner[ this.expando ] ];
        \}
    \}
\};
var data\_priv = \textcolor{keyword}{new} Data();

var data\_user = \textcolor{keyword}{new} Data();



\textcolor{comment}{/*}
\textcolor{comment}{    Implementation Summary}
\textcolor{comment}{}
\textcolor{comment}{    1. Enforce API surface and semantic compatibility with 1.9.x branch}
\textcolor{comment}{    2. Improve the module's maintainability by reducing the storage}
\textcolor{comment}{        paths to a single mechanism.}
\textcolor{comment}{    3. Use the same single mechanism to support "private" and "user" data.}
\textcolor{comment}{    4. \_Never\_ expose "private" data to user code (TODO: Drop \_data, \_removeData)}
\textcolor{comment}{    5. Avoid exposing implementation details on user objects (eg. expando properties)}
\textcolor{comment}{    6. Provide a clear path for implementation upgrade to WeakMap in 2014}
\textcolor{comment}{*/}
var rbrace = /^(?:\(\backslash\)\{[\(\backslash\)w\(\backslash\)W]*\(\backslash\)\}|\(\backslash\)[[\(\backslash\)w\(\backslash\)W]*\(\backslash\)])$/,
    rmultiDash = /([A-Z])/g;

\textcolor{keyword}{function} dataAttr( elem, key, data ) \{
    var name;

    \textcolor{comment}{// If nothing was found internally, try to fetch any}
    \textcolor{comment}{// data from the HTML5 data-* attribute}
    \textcolor{keywordflow}{if} ( data === undefined && elem.nodeType === 1 ) \{
        name = \textcolor{stringliteral}{"data-"} + key.replace( rmultiDash, \textcolor{stringliteral}{"-$1"} ).toLowerCase();
        data = elem.getAttribute( name );

        \textcolor{keywordflow}{if} ( typeof data === \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{try} \{
                data = data === \textcolor{stringliteral}{"true"} ? \textcolor{keyword}{true} :
                    data === \textcolor{stringliteral}{"false"} ? \textcolor{keyword}{false} :
                    data === \textcolor{stringliteral}{"null"} ? null :
                    \textcolor{comment}{// Only convert to a number if it doesn't change the string}
                    +data + \textcolor{stringliteral}{""} === data ? +data :
                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                    data;
            \} \textcolor{keywordflow}{catch}( e ) \{\}

            \textcolor{comment}{// Make sure we set the data so it isn't changed later}
            data\_user.set( elem, key, data );
        \} \textcolor{keywordflow}{else} \{
            data = undefined;
        \}
    \}
    \textcolor{keywordflow}{return} data;
\}

jQuery.extend(\{
    hasData: \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} data\_user.hasData( elem ) || data\_priv.hasData( elem );
    \},

    data: \textcolor{keyword}{function}( elem, name, data ) \{
        \textcolor{keywordflow}{return} data\_user.access( elem, name, data );
    \},

    removeData: \textcolor{keyword}{function}( elem, name ) \{
        data\_user.remove( elem, name );
    \},

    \textcolor{comment}{// TODO: Now that all calls to \_data and \_removeData have been replaced}
    \textcolor{comment}{// with direct calls to data\_priv methods, these can be deprecated.}
    \_data: \textcolor{keyword}{function}( elem, name, data ) \{
        \textcolor{keywordflow}{return} data\_priv.access( elem, name, data );
    \},

    \_removeData: \textcolor{keyword}{function}( elem, name ) \{
        data\_priv.remove( elem, name );
    \}
\});

jQuery.fn.extend(\{
    data: \textcolor{keyword}{function}( key, value ) \{
        var i, name, data,
            elem = \textcolor{keyword}{this}[ 0 ],
            attrs = elem && elem.attributes;

        \textcolor{comment}{// Gets all values}
        \textcolor{keywordflow}{if} ( key === undefined ) \{
            \textcolor{keywordflow}{if} ( this.length ) \{
                data = data\_user.get( elem );

                \textcolor{keywordflow}{if} ( elem.nodeType === 1 && !data\_priv.get( elem, \textcolor{stringliteral}{"hasDataAttrs"} ) ) \{
                    i = attrs.length;
                    \textcolor{keywordflow}{while} ( i-- ) \{

                        \textcolor{comment}{// Support: IE11+}
                        \textcolor{comment}{// The attrs elements can be null (#14894)}
                        \textcolor{keywordflow}{if} ( attrs[ i ] ) \{
                            name = attrs[ i ].name;
                            \textcolor{keywordflow}{if} ( name.indexOf( \textcolor{stringliteral}{"data-"} ) === 0 ) \{
                                name = jQuery.camelCase( name.slice(5) );
                                dataAttr( elem, name, data[ name ] );
                            \}
                        \}
                    \}
                    data\_priv.set( elem, \textcolor{stringliteral}{"hasDataAttrs"}, \textcolor{keyword}{true} );
                \}
            \}

            \textcolor{keywordflow}{return} data;
        \}

        \textcolor{comment}{// Sets multiple values}
        \textcolor{keywordflow}{if} ( typeof key === \textcolor{stringliteral}{"object"} ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
                data\_user.set( \textcolor{keyword}{this}, key );
            \});
        \}

        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( value ) \{
            var data,
                camelKey = jQuery.camelCase( key );

            \textcolor{comment}{// The calling jQuery object (element matches) is not empty}
            \textcolor{comment}{// (and therefore has an element appears at this[ 0 ]) and the}
            \textcolor{comment}{// `value` parameter was not undefined. An empty jQuery object}
            \textcolor{comment}{// will result in `undefined` for elem = this[ 0 ] which will}
            \textcolor{comment}{// throw an exception if an attempt to read a data cache is made.}
            \textcolor{keywordflow}{if} ( elem && value === undefined ) \{
                \textcolor{comment}{// Attempt to get data from the cache}
                \textcolor{comment}{// with the key as-is}
                data = data\_user.get( elem, key );
                \textcolor{keywordflow}{if} ( data !== undefined ) \{
                    \textcolor{keywordflow}{return} data;
                \}

                \textcolor{comment}{// Attempt to get data from the cache}
                \textcolor{comment}{// with the key camelized}
                data = data\_user.get( elem, camelKey );
                \textcolor{keywordflow}{if} ( data !== undefined ) \{
                    \textcolor{keywordflow}{return} data;
                \}

                \textcolor{comment}{// Attempt to "discover" the data in}
                \textcolor{comment}{// HTML5 custom data-* attrs}
                data = dataAttr( elem, camelKey, undefined );
                \textcolor{keywordflow}{if} ( data !== undefined ) \{
                    \textcolor{keywordflow}{return} data;
                \}

                \textcolor{comment}{// We tried really hard, but the data doesn't exist.}
                \textcolor{keywordflow}{return};
            \}

            \textcolor{comment}{// Set the data...}
            this.each(\textcolor{keyword}{function}() \{
                \textcolor{comment}{// First, attempt to store a copy or reference of any}
                \textcolor{comment}{// data that might've been store with a camelCased key.}
                var data = data\_user.get( \textcolor{keyword}{this}, camelKey );

                \textcolor{comment}{// For HTML5 data-* attribute interop, we have to}
                \textcolor{comment}{// store property names with dashes in a camelCase form.}
                \textcolor{comment}{// This might not apply to all properties...*}
                data\_user.set( \textcolor{keyword}{this}, camelKey, value );

                \textcolor{comment}{// *... In the case of properties that might \_actually\_}
                \textcolor{comment}{// have dashes, we need to also store a copy of that}
                \textcolor{comment}{// unchanged property.}
                \textcolor{keywordflow}{if} ( key.indexOf(\textcolor{stringliteral}{"-"}) !== -1 && data !== undefined ) \{
                    data\_user.set( \textcolor{keyword}{this}, key, value );
                \}
            \});
        \}, null, value, arguments.length > 1, null, true );
    \},

    removeData: \textcolor{keyword}{function}( key ) \{
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            data\_user.remove( \textcolor{keyword}{this}, key );
        \});
    \}
\});


jQuery.extend(\{
    queue: \textcolor{keyword}{function}( elem, type, data ) \{
        var queue;

        \textcolor{keywordflow}{if} ( elem ) \{
            type = ( type || \textcolor{stringliteral}{"fx"} ) + \textcolor{stringliteral}{"queue"};
            queue = data\_priv.get( elem, type );

            \textcolor{comment}{// Speed up dequeue by getting out quickly if this is just a lookup}
            \textcolor{keywordflow}{if} ( data ) \{
                \textcolor{keywordflow}{if} ( !queue || jQuery.isArray( data ) ) \{
                    queue = data\_priv.access( elem, type, jQuery.makeArray(data) );
                \} \textcolor{keywordflow}{else} \{
                    queue.push( data );
                \}
            \}
            \textcolor{keywordflow}{return} queue || [];
        \}
    \},

    dequeue: \textcolor{keyword}{function}( elem, type ) \{
        type = type || \textcolor{stringliteral}{"fx"};

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery.\_queueHooks( elem, type ),
            next = \textcolor{keyword}{function}() \{
                jQuery.dequeue( elem, type );
            \};

        \textcolor{comment}{// If the fx queue is dequeued, always remove the progress sentinel}
        \textcolor{keywordflow}{if} ( fn === \textcolor{stringliteral}{"inprogress"} ) \{
            fn = queue.shift();
            startLength--;
        \}

        \textcolor{keywordflow}{if} ( fn ) \{

            \textcolor{comment}{// Add a progress sentinel to prevent the fx queue from being}
            \textcolor{comment}{// automatically dequeued}
            \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"fx"} ) \{
                queue.unshift( \textcolor{stringliteral}{"inprogress"} );
            \}

            \textcolor{comment}{// clear up the last queue stop function}
            \textcolor{keyword}{delete} hooks.stop;
            fn.call( elem, next, hooks );
        \}

        \textcolor{keywordflow}{if} ( !startLength && hooks ) \{
            hooks.empty.fire();
        \}
    \},

    \textcolor{comment}{// not intended for public consumption - generates a queueHooks object, or returns the current one}
    \_queueHooks: \textcolor{keyword}{function}( elem, type ) \{
        var key = type + \textcolor{stringliteral}{"queueHooks"};
        \textcolor{keywordflow}{return} data\_priv.get( elem, key ) || data\_priv.access( elem, key, \{
            empty: jQuery.Callbacks(\textcolor{stringliteral}{"once memory"}).add(\textcolor{keyword}{function}() \{
                data\_priv.remove( elem, [ type + \textcolor{stringliteral}{"queue"}, key ] );
            \})
        \});
    \}
\});

jQuery.fn.extend(\{
    queue: \textcolor{keyword}{function}( type, data ) \{
        var setter = 2;

        \textcolor{keywordflow}{if} ( typeof type !== \textcolor{stringliteral}{"string"} ) \{
            data = type;
            type = \textcolor{stringliteral}{"fx"};
            setter--;
        \}

        \textcolor{keywordflow}{if} ( arguments.length < setter ) \{
            \textcolor{keywordflow}{return} jQuery.queue( \textcolor{keyword}{this}[0], type );
        \}

        \textcolor{keywordflow}{return} data === undefined ?
            \textcolor{keyword}{this} :
            this.each(\textcolor{keyword}{function}() \{
                var queue = jQuery.queue( \textcolor{keyword}{this}, type, data );

                \textcolor{comment}{// ensure a hooks for this queue}
                jQuery.\_queueHooks( \textcolor{keyword}{this}, type );

                \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"fx"} && queue[0] !== \textcolor{stringliteral}{"inprogress"} ) \{
                    jQuery.dequeue( \textcolor{keyword}{this}, type );
                \}
            \});
    \},
    dequeue: \textcolor{keyword}{function}( type ) \{
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            jQuery.dequeue( \textcolor{keyword}{this}, type );
        \});
    \},
    clearQueue: \textcolor{keyword}{function}( type ) \{
        \textcolor{keywordflow}{return} this.queue( type || \textcolor{stringliteral}{"fx"}, [] );
    \},
    \textcolor{comment}{// Get a promise resolved when queues of a certain type}
    \textcolor{comment}{// are emptied (fx is the type by default)}
    promise: \textcolor{keyword}{function}( type, obj ) \{
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = \textcolor{keyword}{this},
            i = this.length,
            resolve = \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( !( --count ) ) \{
                    defer.resolveWith( elements, [ elements ] );
                \}
            \};

        \textcolor{keywordflow}{if} ( typeof type !== \textcolor{stringliteral}{"string"} ) \{
            obj = type;
            type = undefined;
        \}
        type = type || \textcolor{stringliteral}{"fx"};

        \textcolor{keywordflow}{while} ( i-- ) \{
            tmp = data\_priv.get( elements[ i ], type + \textcolor{stringliteral}{"queueHooks"} );
            \textcolor{keywordflow}{if} ( tmp && tmp.empty ) \{
                count++;
                tmp.empty.add( resolve );
            \}
        \}
        resolve();
        \textcolor{keywordflow}{return} defer.promise( obj );
    \}
\});
var pnum = (/[+-]?(?:\(\backslash\)d*\(\backslash\).|)\(\backslash\)d+(?:[eE][+-]?\(\backslash\)d+|)/).source;

var cssExpand = [ \textcolor{stringliteral}{"Top"}, \textcolor{stringliteral}{"Right"}, \textcolor{stringliteral}{"Bottom"}, \textcolor{stringliteral}{"Left"} ];

var isHidden = \textcolor{keyword}{function}( elem, el ) \{
        \textcolor{comment}{// isHidden might be called from jQuery#filter function;}
        \textcolor{comment}{// in that case, element will be second argument}
        elem = el || elem;
        \textcolor{keywordflow}{return} jQuery.css( elem, \textcolor{stringliteral}{"display"} ) === \textcolor{stringliteral}{"none"} || !jQuery.contains( elem.ownerDocument, elem );
    \};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(\textcolor{keyword}{function}() \{
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild( document.createElement( \textcolor{stringliteral}{"div"} ) ),
        input = document.createElement( \textcolor{stringliteral}{"input"} );

    \textcolor{comment}{// #11217 - WebKit loses check when the name is after the checked attribute}
    \textcolor{comment}{// Support: Windows Web Apps (WWA)}
    \textcolor{comment}{// `name` and `type` need .setAttribute for WWA}
    input.setAttribute( \textcolor{stringliteral}{"type"}, \textcolor{stringliteral}{"radio"} );
    input.setAttribute( \textcolor{stringliteral}{"checked"}, \textcolor{stringliteral}{"checked"} );
    input.setAttribute( \textcolor{stringliteral}{"name"}, \textcolor{stringliteral}{"t"} );

    div.appendChild( input );

    \textcolor{comment}{// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3}
    \textcolor{comment}{// old WebKit doesn't clone checked state correctly in fragments}
    support.checkClone = div.cloneNode( \textcolor{keyword}{true} ).cloneNode( \textcolor{keyword}{true} ).lastChild.checked;

    \textcolor{comment}{// Make sure textarea (and checkbox) defaultValue is properly cloned}
    \textcolor{comment}{// Support: IE9-IE11+}
    div.innerHTML = \textcolor{stringliteral}{"<textarea>x</textarea>"};
    support.noCloneChecked = !!div.cloneNode( \textcolor{keyword}{true} ).lastChild.defaultValue;
\})();
var strundefined = typeof undefined;



support.focusinBubbles = \textcolor{stringliteral}{"onfocusin"} in window;


var
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\(\backslash\).(.+)|)$/;

\textcolor{keyword}{function} returnTrue() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}

\textcolor{keyword}{function} returnFalse() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

\textcolor{keyword}{function} safeActiveElement() \{
    \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{return} document.activeElement;
    \} \textcolor{keywordflow}{catch} ( err ) \{ \}
\}

\textcolor{comment}{/*}
\textcolor{comment}{ * Helper functions for managing events -- not part of the public interface.}
\textcolor{comment}{ * Props to Dean Edwards' addEvent library for many of the ideas.}
\textcolor{comment}{ */}
jQuery.event = \{

    global: \{\},

    add: \textcolor{keyword}{function}( elem, types, handler, data, selector ) \{

        var handleObjIn, eventHandle, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = data\_priv.get( elem );

        \textcolor{comment}{// Don't attach events to noData or text/comment nodes (but allow plain objects)}
        \textcolor{keywordflow}{if} ( !elemData ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Caller can pass in an object of custom data in lieu of the handler}
        \textcolor{keywordflow}{if} ( handler.handler ) \{
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        \}

        \textcolor{comment}{// Make sure that the handler has a unique ID, used to find/remove it later}
        \textcolor{keywordflow}{if} ( !handler.guid ) \{
            handler.guid = jQuery.guid++;
        \}

        \textcolor{comment}{// Init the element's event structure and main handler, if this is the first}
        \textcolor{keywordflow}{if} ( !(events = elemData.events) ) \{
            events = elemData.events = \{\};
        \}
        \textcolor{keywordflow}{if} ( !(eventHandle = elemData.handle) ) \{
            eventHandle = elemData.handle = \textcolor{keyword}{function}( e ) \{
                \textcolor{comment}{// Discard the second event of a jQuery.event.trigger() and}
                \textcolor{comment}{// when an event is called after a page has unloaded}
                \textcolor{keywordflow}{return} typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                    jQuery.event.dispatch.apply( elem, arguments ) : undefined;
            \};
        \}

        \textcolor{comment}{// Handle multiple events separated by a space}
        types = ( types || \textcolor{stringliteral}{""} ).match( rnotwhite ) || [ \textcolor{stringliteral}{""} ];
        t = types.length;
        \textcolor{keywordflow}{while} ( t-- ) \{
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || \textcolor{stringliteral}{""} ).split( \textcolor{stringliteral}{"."} ).sort();

            \textcolor{comment}{// There *must* be a type, no attaching namespace-only handlers}
            \textcolor{keywordflow}{if} ( !type ) \{
                \textcolor{keywordflow}{continue};
            \}

            \textcolor{comment}{// If event changes its type, use the special event handlers for the changed type}
            special = jQuery.event.special[ type ] || \{\};

            \textcolor{comment}{// If selector defined, determine special event api type, otherwise given type}
            type = ( selector ? special.delegateType : special.bindType ) || type;

            \textcolor{comment}{// Update special based on newly reset type}
            special = jQuery.event.special[ type ] || \{\};

            \textcolor{comment}{// handleObj is passed to all event handlers}
            handleObj = jQuery.extend(\{
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                \textcolor{keyword}{namespace}: namespaces.join(\textcolor{stringliteral}{"."})
            \}, handleObjIn );

            \textcolor{comment}{// Init the event handler queue if we're the first}
            \textcolor{keywordflow}{if} ( !(handlers = events[ type ]) ) \{
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                \textcolor{comment}{// Only use addEventListener if the special events handler returns false}
                \textcolor{keywordflow}{if} ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false 
      ) \{
                    \textcolor{keywordflow}{if} ( elem.addEventListener ) \{
                        elem.addEventListener( type, eventHandle, \textcolor{keyword}{false} );
                    \}
                \}
            \}

            \textcolor{keywordflow}{if} ( special.add ) \{
                special.add.call( elem, handleObj );

                \textcolor{keywordflow}{if} ( !handleObj.handler.guid ) \{
                    handleObj.handler.guid = handler.guid;
                \}
            \}

            \textcolor{comment}{// Add to the element's handler list, delegates in front}
            \textcolor{keywordflow}{if} ( selector ) \{
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            \} \textcolor{keywordflow}{else} \{
                handlers.push( handleObj );
            \}

            \textcolor{comment}{// Keep track of which events have ever been used, for event optimization}
            jQuery.event.global[ type ] = \textcolor{keyword}{true};
        \}

    \},

    \textcolor{comment}{// Detach an event or set of events from an element}
    \textcolor{keyword}{remove}: \textcolor{keyword}{function}( elem, types, handler, selector, mappedTypes ) \{

        var j, origCount, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = data\_priv.hasData( elem ) && data\_priv.get( elem );

        \textcolor{keywordflow}{if} ( !elemData || !(events = elemData.events) ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Once for each type.namespace in types; type may be omitted}
        types = ( types || \textcolor{stringliteral}{""} ).match( rnotwhite ) || [ \textcolor{stringliteral}{""} ];
        t = types.length;
        \textcolor{keywordflow}{while} ( t-- ) \{
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || \textcolor{stringliteral}{""} ).split( \textcolor{stringliteral}{"."} ).sort();

            \textcolor{comment}{// Unbind all events (on this namespace, if provided) for the element}
            \textcolor{keywordflow}{if} ( !type ) \{
                \textcolor{keywordflow}{for} ( type in events ) \{
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, \textcolor{keyword}{true} );
                \}
                \textcolor{keywordflow}{continue};
            \}

            special = jQuery.event.special[ type ] || \{\};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[2] && \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"(^|\(\backslash\)\(\backslash\).)"} + namespaces.join(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\).(?:.*\(\backslash\)\(\backslash\).|)"}) + \textcolor{stringliteral}{"(\(\backslash\)\(\backslash\).|$)"} );

            \textcolor{comment}{// Remove matching events}
            origCount = j = handlers.length;
            \textcolor{keywordflow}{while} ( j-- ) \{
                handleObj = handlers[ j ];

                \textcolor{keywordflow}{if} ( ( mappedTypes || origType === handleObj.origType ) &&
                    ( !handler || handler.guid === handleObj.guid ) &&
                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                    ( !selector || selector === handleObj.selector || selector === \textcolor{stringliteral}{"**"} && handleObj.
      selector ) ) \{
                    handlers.splice( j, 1 );

                    \textcolor{keywordflow}{if} ( handleObj.selector ) \{
                        handlers.delegateCount--;
                    \}
                    \textcolor{keywordflow}{if} ( special.remove ) \{
                        special.remove.call( elem, handleObj );
                    \}
                \}
            \}

            \textcolor{comment}{// Remove generic event handler if we removed something and no more handlers exist}
            \textcolor{comment}{// (avoids potential for endless recursion during removal of special event handlers)}
            \textcolor{keywordflow}{if} ( origCount && !handlers.length ) \{
                \textcolor{keywordflow}{if} ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === 
      false ) \{
                    jQuery.removeEvent( elem, type, elemData.handle );
                \}

                \textcolor{keyword}{delete} events[ type ];
            \}
        \}

        \textcolor{comment}{// Remove the expando if it's no longer used}
        \textcolor{keywordflow}{if} ( jQuery.isEmptyObject( events ) ) \{
            \textcolor{keyword}{delete} elemData.handle;
            data\_priv.remove( elem, \textcolor{stringliteral}{"events"} );
        \}
    \},

    trigger: \textcolor{keyword}{function}( event, data, elem, onlyHandlers ) \{

        var i, cur, tmp, bubbleType, ontype, handle, special,
            eventPath = [ elem || document ],
            type = hasOwn.call( event, \textcolor{stringliteral}{"type"} ) ? \textcolor{keyword}{event}.type : event,
            namespaces = hasOwn.call( event, \textcolor{stringliteral}{"namespace"} ) ? \textcolor{keyword}{event}.namespace.split(\textcolor{stringliteral}{"."}) : [];

        cur = tmp = elem = elem || document;

        \textcolor{comment}{// Don't do events on text and comment nodes}
        \textcolor{keywordflow}{if} ( elem.nodeType === 3 || elem.nodeType === 8 ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// focus/blur morphs to focusin/out; ensure we're not firing them right now}
        \textcolor{keywordflow}{if} ( rfocusMorph.test( type + jQuery.event.triggered ) ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{keywordflow}{if} ( type.indexOf(\textcolor{stringliteral}{"."}) >= 0 ) \{
            \textcolor{comment}{// Namespaced trigger; create a regexp to match event type in handle()}
            namespaces = type.split(\textcolor{stringliteral}{"."});
            type = namespaces.shift();
            namespaces.sort();
        \}
        ontype = type.indexOf(\textcolor{stringliteral}{":"}) < 0 && \textcolor{stringliteral}{"on"} + type;

        \textcolor{comment}{// Caller can pass in a jQuery.Event object, Object, or just an event type string}
        \textcolor{keyword}{event} = \textcolor{keyword}{event}[ jQuery.expando ] ?
            \textcolor{keyword}{event} :
            \textcolor{keyword}{new} jQuery.Event( type, typeof event === \textcolor{stringliteral}{"object"} && event );

        \textcolor{comment}{// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)}
        \textcolor{keyword}{event}.isTrigger = onlyHandlers ? 2 : 3;
        \textcolor{keyword}{event}.namespace = namespaces.join(\textcolor{stringliteral}{"."});
        \textcolor{keyword}{event}.namespace\_re = \textcolor{keyword}{event}.namespace ?
            \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"(^|\(\backslash\)\(\backslash\).)"} + namespaces.join(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\).(?:.*\(\backslash\)\(\backslash\).|)"}) + \textcolor{stringliteral}{"(\(\backslash\)\(\backslash\).|$)"} ) :
            null;

        \textcolor{comment}{// Clean up the event in case it is being reused}
        \textcolor{keyword}{event}.result = undefined;
        \textcolor{keywordflow}{if} ( !event.target ) \{
            \textcolor{keyword}{event}.target = elem;
        \}

        \textcolor{comment}{// Clone any incoming data and prepend the event, creating the handler arg list}
        data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

        \textcolor{comment}{// Allow special events to draw outside the lines}
        special = jQuery.event.special[ type ] || \{\};
        \textcolor{keywordflow}{if} ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Determine event propagation path in advance, per W3C events spec (#9951)}
        \textcolor{comment}{// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)}
        \textcolor{keywordflow}{if} ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) \{

            bubbleType = special.delegateType || type;
            \textcolor{keywordflow}{if} ( !rfocusMorph.test( bubbleType + type ) ) \{
                cur = cur.parentNode;
            \}
            \textcolor{keywordflow}{for} ( ; cur; cur = cur.parentNode ) \{
                eventPath.push( cur );
                tmp = cur;
            \}

            \textcolor{comment}{// Only add window if we got to document (e.g., not plain obj or detached DOM)}
            \textcolor{keywordflow}{if} ( tmp === (elem.ownerDocument || document) ) \{
                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            \}
        \}

        \textcolor{comment}{// Fire handlers on the event path}
        i = 0;
        \textcolor{keywordflow}{while} ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) \{

            \textcolor{keyword}{event}.type = i > 1 ?
                bubbleType :
                special.bindType || type;

            \textcolor{comment}{// jQuery handler}
            handle = ( data\_priv.get( cur, \textcolor{stringliteral}{"events"} ) || \{\} )[ event.type ] && data\_priv.get( cur, \textcolor{stringliteral}{"handle"}
       );
            \textcolor{keywordflow}{if} ( handle ) \{
                handle.apply( cur, data );
            \}

            \textcolor{comment}{// Native handler}
            handle = ontype && cur[ ontype ];
            \textcolor{keywordflow}{if} ( handle && handle.apply && jQuery.acceptData( cur ) ) \{
                \textcolor{keyword}{event}.result = handle.apply( cur, data );
                \textcolor{keywordflow}{if} ( event.result === \textcolor{keyword}{false} ) \{
                    \textcolor{keyword}{event}.preventDefault();
                \}
            \}
        \}
        \textcolor{keyword}{event}.type = type;

        \textcolor{comment}{// If nobody prevented the default action, do it now}
        \textcolor{keywordflow}{if} ( !onlyHandlers && !event.isDefaultPrevented() ) \{

            \textcolor{keywordflow}{if} ( (!special.\_default || special.\_default.apply( eventPath.pop(), data ) === \textcolor{keyword}{false}) &&
                jQuery.acceptData( elem ) ) \{

                \textcolor{comment}{// Call a native DOM method on the target with the same name name as the event.}
                \textcolor{comment}{// Don't do default actions on window, that's where global variables be (#6170)}
                \textcolor{keywordflow}{if} ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) \{

                    \textcolor{comment}{// Don't re-trigger an onFOO event when we call its FOO() method}
                    tmp = elem[ ontype ];

                    \textcolor{keywordflow}{if} ( tmp ) \{
                        elem[ ontype ] = null;
                    \}

                    \textcolor{comment}{// Prevent re-triggering of the same event, since we already bubbled it above}
                    jQuery.event.triggered = type;
                    elem[ type ]();
                    jQuery.event.triggered = undefined;

                    \textcolor{keywordflow}{if} ( tmp ) \{
                        elem[ ontype ] = tmp;
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{event}.result;
    \},

    dispatch: \textcolor{keyword}{function}( event ) \{

        \textcolor{comment}{// Make a writable jQuery.Event from the native event object}
        \textcolor{keyword}{event} = jQuery.event.fix( event );

        var i, j, ret, matched, handleObj,
            handlerQueue = [],
            args = slice.call( arguments ),
            handlers = ( data\_priv.get( \textcolor{keyword}{this}, \textcolor{stringliteral}{"events"} ) || \{\} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || \{\};

        \textcolor{comment}{// Use the fix-ed jQuery.Event rather than the (read-only) native event}
        args[0] = event;
        \textcolor{keyword}{event}.delegateTarget = \textcolor{keyword}{this};

        \textcolor{comment}{// Call the preDispatch hook for the mapped type, and let it bail if desired}
        \textcolor{keywordflow}{if} ( special.preDispatch && special.preDispatch.call( \textcolor{keyword}{this}, event ) === false ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Determine handlers}
        handlerQueue = jQuery.event.handlers.call( \textcolor{keyword}{this}, event, handlers );

        \textcolor{comment}{// Run delegates first; they may want to stop propagation beneath us}
        i = 0;
        \textcolor{keywordflow}{while} ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) \{
            \textcolor{keyword}{event}.currentTarget = matched.elem;

            j = 0;
            \textcolor{keywordflow}{while} ( (handleObj = matched.handlers[ j++ ]) && !\textcolor{keyword}{event}.isImmediatePropagationStopped() ) \{

                \textcolor{comment}{// Triggered event must either 1) have no namespace, or}
                \textcolor{comment}{// 2) have namespace(s) a subset or equal to those in the bound event (both can have no
       namespace).}
                \textcolor{keywordflow}{if} ( !event.namespace\_re || event.namespace\_re.test( handleObj.namespace ) ) \{

                    \textcolor{keyword}{event}.handleObj = handleObj;
                    \textcolor{keyword}{event}.data = handleObj.data;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || \{\}).handle || handleObj.handler 
      )
                            .apply( matched.elem, args );

                    \textcolor{keywordflow}{if} ( ret !== undefined ) \{
                        \textcolor{keywordflow}{if} ( (event.result = ret) === \textcolor{keyword}{false} ) \{
                            \textcolor{keyword}{event}.preventDefault();
                            \textcolor{keyword}{event}.stopPropagation();
                        \}
                    \}
                \}
            \}
        \}

        \textcolor{comment}{// Call the postDispatch hook for the mapped type}
        \textcolor{keywordflow}{if} ( special.postDispatch ) \{
            special.postDispatch.call( \textcolor{keyword}{this}, event );
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{event}.result;
    \},

    handlers: \textcolor{keyword}{function}( event, handlers ) \{
        var i, matches, sel, handleObj,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = \textcolor{keyword}{event}.target;

        \textcolor{comment}{// Find delegate handlers}
        \textcolor{comment}{// Black-hole SVG <use> instance trees (#13180)}
        \textcolor{comment}{// Avoid non-left-click bubbling in Firefox (#3861)}
        \textcolor{keywordflow}{if} ( delegateCount && cur.nodeType && (!event.button || event.type !== \textcolor{stringliteral}{"click"}) ) \{

            \textcolor{keywordflow}{for} ( ; cur !== \textcolor{keyword}{this}; cur = cur.parentNode || this ) \{

                \textcolor{comment}{// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)}
                \textcolor{keywordflow}{if} ( cur.disabled !== \textcolor{keyword}{true} || event.type !== \textcolor{stringliteral}{"click"} ) \{
                    matches = [];
                    \textcolor{keywordflow}{for} ( i = 0; i < delegateCount; i++ ) \{
                        handleObj = handlers[ i ];

                        \textcolor{comment}{// Don't conflict with Object.prototype properties (#13203)}
                        sel = handleObj.selector + \textcolor{stringliteral}{" "};

                        \textcolor{keywordflow}{if} ( matches[ sel ] === undefined ) \{
                            matches[ sel ] = handleObj.needsContext ?
                                jQuery( sel, \textcolor{keyword}{this} ).index( cur ) >= 0 :
                                jQuery.find( sel, \textcolor{keyword}{this}, null, [ cur ] ).length;
                        \}
                        \textcolor{keywordflow}{if} ( matches[ sel ] ) \{
                            matches.push( handleObj );
                        \}
                    \}
                    \textcolor{keywordflow}{if} ( matches.length ) \{
                        handlerQueue.push(\{ elem: cur, handlers: matches \});
                    \}
                \}
            \}
        \}

        \textcolor{comment}{// Add the remaining (directly-bound) handlers}
        \textcolor{keywordflow}{if} ( delegateCount < handlers.length ) \{
            handlerQueue.push(\{ elem: \textcolor{keyword}{this}, handlers: handlers.slice( delegateCount ) \});
        \}

        \textcolor{keywordflow}{return} handlerQueue;
    \},

    \textcolor{comment}{// Includes some event props shared by KeyEvent and MouseEvent}
    props: \textcolor{stringliteral}{"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey
       target timeStamp view which"}.split(\textcolor{stringliteral}{" "}),

    fixHooks: \{\},

    keyHooks: \{
        props: \textcolor{stringliteral}{"char charCode key keyCode"}.split(\textcolor{stringliteral}{" "}),
        filter: \textcolor{keyword}{function}( event, original ) \{

            \textcolor{comment}{// Add which for key events}
            \textcolor{keywordflow}{if} ( event.which == null ) \{
                \textcolor{keyword}{event}.which = original.charCode != null ? original.charCode : original.keyCode;
            \}

            \textcolor{keywordflow}{return} event;
        \}
    \},

    mouseHooks: \{
        props: \textcolor{stringliteral}{"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement"}.split
      (\textcolor{stringliteral}{" "}),
        filter: \textcolor{keyword}{function}( event, original ) \{
            var eventDoc, doc, body,
                button = original.button;

            \textcolor{comment}{// Calculate pageX/Y if missing and clientX/Y available}
            \textcolor{keywordflow}{if} ( event.pageX == null && original.clientX != null ) \{
                eventDoc = \textcolor{keyword}{event}.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                \textcolor{keyword}{event}.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) 
      - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                \textcolor{keyword}{event}.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) 
      - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
            \}

            \textcolor{comment}{// Add which for click: 1 === left; 2 === middle; 3 === right}
            \textcolor{comment}{// Note: button is not normalized, so don't use it}
            \textcolor{keywordflow}{if} ( !event.which && button !== undefined ) \{
                \textcolor{keyword}{event}.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            \}

            \textcolor{keywordflow}{return} event;
        \}
    \},

    fix: \textcolor{keyword}{function}( event ) \{
        \textcolor{keywordflow}{if} ( event[ jQuery.expando ] ) \{
            \textcolor{keywordflow}{return} event;
        \}

        \textcolor{comment}{// Create a writable copy of the event object and normalize some properties}
        var i, prop, copy,
            type = \textcolor{keyword}{event}.type,
            originalEvent = event,
            fixHook = this.fixHooks[ type ];

        \textcolor{keywordflow}{if} ( !fixHook ) \{
            this.fixHooks[ type ] = fixHook =
                rmouseEvent.test( type ) ? this.mouseHooks :
                rkeyEvent.test( type ) ? this.keyHooks :
                \{\};
        \}
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        \textcolor{keyword}{event} = \textcolor{keyword}{new} jQuery.Event( originalEvent );

        i = copy.length;
        \textcolor{keywordflow}{while} ( i-- ) \{
            prop = copy[ i ];
            \textcolor{keyword}{event}[ prop ] = originalEvent[ prop ];
        \}

        \textcolor{comment}{// Support: Cordova 2.5 (WebKit) (#13255)}
        \textcolor{comment}{// All events should have a target; Cordova deviceready doesn't}
        \textcolor{keywordflow}{if} ( !event.target ) \{
            \textcolor{keyword}{event}.target = document;
        \}

        \textcolor{comment}{// Support: Safari 6.0+, Chrome < 28}
        \textcolor{comment}{// Target should not be a text node (#504, #13143)}
        \textcolor{keywordflow}{if} ( event.target.nodeType === 3 ) \{
            \textcolor{keyword}{event}.target = \textcolor{keyword}{event}.target.parentNode;
        \}

        \textcolor{keywordflow}{return} fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
    \},

    special: \{
        load: \{
            \textcolor{comment}{// Prevent triggered image.load events from bubbling to window.load}
            noBubble: \textcolor{keyword}{true}
        \},
        focus: \{
            \textcolor{comment}{// Fire native event if possible so blur/focus sequence is correct}
            trigger: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( \textcolor{keyword}{this} !== safeActiveElement() && this.focus ) \{
                    this.focus();
                    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
            \},
            delegateType: \textcolor{stringliteral}{"focusin"}
        \},
        blur: \{
            trigger: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( \textcolor{keyword}{this} === safeActiveElement() && this.blur ) \{
                    this.blur();
                    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
            \},
            delegateType: \textcolor{stringliteral}{"focusout"}
        \},
        click: \{
            \textcolor{comment}{// For checkbox, fire native event so checked state will be right}
            trigger: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( this.type === \textcolor{stringliteral}{"checkbox"} && this.click && jQuery.nodeName( \textcolor{keyword}{this}, \textcolor{stringliteral}{"input"} ) ) \{
                    this.click();
                    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
                \}
            \},

            \textcolor{comment}{// For cross-browser consistency, don't fire native .click() on links}
            \_default: \textcolor{keyword}{function}( event ) \{
                \textcolor{keywordflow}{return} jQuery.nodeName( event.target, \textcolor{stringliteral}{"a"} );
            \}
        \},

        beforeunload: \{
            postDispatch: \textcolor{keyword}{function}( event ) \{

                \textcolor{comment}{// Support: Firefox 20+}
                \textcolor{comment}{// Firefox doesn't alert if the returnValue field is not set.}
                \textcolor{keywordflow}{if} ( event.result !== undefined && event.originalEvent ) \{
                    \textcolor{keyword}{event}.originalEvent.returnValue = \textcolor{keyword}{event}.result;
                \}
            \}
        \}
    \},

    simulate: \textcolor{keyword}{function}( type, elem, event, bubble ) \{
        \textcolor{comment}{// Piggyback on a donor event to simulate a different one.}
        \textcolor{comment}{// Fake originalEvent to avoid donor's stopPropagation, but if the}
        \textcolor{comment}{// simulated event prevents default then we do the same on the donor.}
        var e = jQuery.extend(
            \textcolor{keyword}{new} jQuery.Event(),
            event,
            \{
                type: type,
                isSimulated: \textcolor{keyword}{true},
                originalEvent: \{\}
            \}
        );
        \textcolor{keywordflow}{if} ( bubble ) \{
            jQuery.event.trigger( e, null, elem );
        \} \textcolor{keywordflow}{else} \{
            jQuery.event.dispatch.call( elem, e );
        \}
        \textcolor{keywordflow}{if} ( e.isDefaultPrevented() ) \{
            \textcolor{keyword}{event}.preventDefault();
        \}
    \}
\};

jQuery.removeEvent = \textcolor{keyword}{function}( elem, type, handle ) \{
    \textcolor{keywordflow}{if} ( elem.removeEventListener ) \{
        elem.removeEventListener( type, handle, \textcolor{keyword}{false} );
    \}
\};

jQuery.Event = \textcolor{keyword}{function}( src, props ) \{
    \textcolor{comment}{// Allow instantiation without the 'new' keyword}
    \textcolor{keywordflow}{if} ( !(\textcolor{keyword}{this} instanceof jQuery.Event) ) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} jQuery.Event( src, props );
    \}

    \textcolor{comment}{// Event object}
    \textcolor{keywordflow}{if} ( src && src.type ) \{
        this.originalEvent = src;
        this.type = src.type;

        \textcolor{comment}{// Events bubbling up the document may have been marked as prevented}
        \textcolor{comment}{// by a handler lower down the tree; reflect the correct value.}
        this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined &&
                \textcolor{comment}{// Support: Android < 4.0}
                src.returnValue === \textcolor{keyword}{false} ?
            returnTrue :
            returnFalse;

    \textcolor{comment}{// Event type}
    \} \textcolor{keywordflow}{else} \{
        this.type = src;
    \}

    \textcolor{comment}{// Put explicitly provided properties onto the event object}
    \textcolor{keywordflow}{if} ( props ) \{
        jQuery.extend( \textcolor{keyword}{this}, props );
    \}

    \textcolor{comment}{// Create a timestamp if incoming event doesn't have one}
    this.timeStamp = src && src.timeStamp || jQuery.now();

    \textcolor{comment}{// Mark it as fixed}
    \textcolor{keyword}{this}[ jQuery.expando ] = \textcolor{keyword}{true};
\};

\textcolor{comment}{// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding}
\textcolor{comment}{// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html}
jQuery.Event.prototype = \{
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: \textcolor{keyword}{function}() \{
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;

        \textcolor{keywordflow}{if} ( e && e.preventDefault ) \{
            e.preventDefault();
        \}
    \},
    stopPropagation: \textcolor{keyword}{function}() \{
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;

        \textcolor{keywordflow}{if} ( e && e.stopPropagation ) \{
            e.stopPropagation();
        \}
    \},
    stopImmediatePropagation: \textcolor{keyword}{function}() \{
        var e = this.originalEvent;

        this.isImmediatePropagationStopped = returnTrue;

        \textcolor{keywordflow}{if} ( e && e.stopImmediatePropagation ) \{
            e.stopImmediatePropagation();
        \}

        this.stopPropagation();
    \}
\};

\textcolor{comment}{// Create mouseenter/leave events using mouseover/out and event-time checks}
\textcolor{comment}{// Support: Chrome 15+}
jQuery.each(\{
    mouseenter: \textcolor{stringliteral}{"mouseover"},
    mouseleave: \textcolor{stringliteral}{"mouseout"},
    pointerenter: \textcolor{stringliteral}{"pointerover"},
    pointerleave: \textcolor{stringliteral}{"pointerout"}
\}, \textcolor{keyword}{function}( orig, fix ) \{
    jQuery.event.special[ orig ] = \{
        delegateType: fix,
        bindType: fix,

        handle: \textcolor{keyword}{function}( event ) \{
            var ret,
                target = \textcolor{keyword}{this},
                related = \textcolor{keyword}{event}.relatedTarget,
                handleObj = \textcolor{keyword}{event}.handleObj;

            \textcolor{comment}{// For mousenter/leave call the handler if related is outside the target.}
            \textcolor{comment}{// NB: No relatedTarget if the mouse left/entered the browser window}
            \textcolor{keywordflow}{if} ( !related || (related !== target && !jQuery.contains( target, related )) ) \{
                \textcolor{keyword}{event}.type = handleObj.origType;
                ret = handleObj.handler.apply( \textcolor{keyword}{this}, arguments );
                \textcolor{keyword}{event}.type = fix;
            \}
            \textcolor{keywordflow}{return} ret;
        \}
    \};
\});

\textcolor{comment}{// Create "bubbling" focus and blur events}
\textcolor{comment}{// Support: Firefox, Chrome, Safari}
\textcolor{keywordflow}{if} ( !support.focusinBubbles ) \{
    jQuery.each(\{ focus: \textcolor{stringliteral}{"focusin"}, blur: \textcolor{stringliteral}{"focusout"} \}, \textcolor{keyword}{function}( orig, fix ) \{

        \textcolor{comment}{// Attach a single capturing handler on the document while someone wants focusin/focusout}
        var handler = \textcolor{keyword}{function}( event ) \{
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            \};

        jQuery.event.special[ fix ] = \{
            setup: \textcolor{keyword}{function}() \{
                var doc = this.ownerDocument || \textcolor{keyword}{this},
                    attaches = data\_priv.access( doc, fix );

                \textcolor{keywordflow}{if} ( !attaches ) \{
                    doc.addEventListener( orig, handler, \textcolor{keyword}{true} );
                \}
                data\_priv.access( doc, fix, ( attaches || 0 ) + 1 );
            \},
            teardown: \textcolor{keyword}{function}() \{
                var doc = this.ownerDocument || \textcolor{keyword}{this},
                    attaches = data\_priv.access( doc, fix ) - 1;

                \textcolor{keywordflow}{if} ( !attaches ) \{
                    doc.removeEventListener( orig, handler, \textcolor{keyword}{true} );
                    data\_priv.remove( doc, fix );

                \} \textcolor{keywordflow}{else} \{
                    data\_priv.access( doc, fix, attaches );
                \}
            \}
        \};
    \});
\}

jQuery.fn.extend(\{

    on: \textcolor{keyword}{function}( types, selector, data, fn, \textcolor{comment}{/*INTERNAL*/} one ) \{
        var origFn, type;

        \textcolor{comment}{// Types can be a map of types/handlers}
        \textcolor{keywordflow}{if} ( typeof types === \textcolor{stringliteral}{"object"} ) \{
            \textcolor{comment}{// ( types-Object, selector, data )}
            \textcolor{keywordflow}{if} ( typeof selector !== \textcolor{stringliteral}{"string"} ) \{
                \textcolor{comment}{// ( types-Object, data )}
                data = data || selector;
                selector = undefined;
            \}
            \textcolor{keywordflow}{for} ( type in types ) \{
                this.on( type, selector, data, types[ type ], one );
            \}
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
        \}

        \textcolor{keywordflow}{if} ( data == null && fn == null ) \{
            \textcolor{comment}{// ( types, fn )}
            fn = selector;
            data = selector = undefined;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( fn == null ) \{
            \textcolor{keywordflow}{if} ( typeof selector === \textcolor{stringliteral}{"string"} ) \{
                \textcolor{comment}{// ( types, selector, fn )}
                fn = data;
                data = undefined;
            \} \textcolor{keywordflow}{else} \{
                \textcolor{comment}{// ( types, data, fn )}
                fn = data;
                data = selector;
                selector = undefined;
            \}
        \}
        \textcolor{keywordflow}{if} ( fn === \textcolor{keyword}{false} ) \{
            fn = returnFalse;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !fn ) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
        \}

        \textcolor{keywordflow}{if} ( one === 1 ) \{
            origFn = fn;
            fn = \textcolor{keyword}{function}( event ) \{
                \textcolor{comment}{// Can use an empty set, since event contains the info}
                jQuery().off( event );
                \textcolor{keywordflow}{return} origFn.apply( \textcolor{keyword}{this}, arguments );
            \};
            \textcolor{comment}{// Use same guid so caller can remove using origFn}
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        \}
        \textcolor{keywordflow}{return} this.each( \textcolor{keyword}{function}() \{
            jQuery.event.add( \textcolor{keyword}{this}, types, fn, data, selector );
        \});
    \},
    one: \textcolor{keyword}{function}( types, selector, data, fn ) \{
        \textcolor{keywordflow}{return} this.on( types, selector, data, fn, 1 );
    \},
    off: \textcolor{keyword}{function}( types, selector, fn ) \{
        var handleObj, type;
        \textcolor{keywordflow}{if} ( types && types.preventDefault && types.handleObj ) \{
            \textcolor{comment}{// ( event )  dispatched jQuery.Event}
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + \textcolor{stringliteral}{"."} + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
        \}
        \textcolor{keywordflow}{if} ( typeof types === \textcolor{stringliteral}{"object"} ) \{
            \textcolor{comment}{// ( types-object [, selector] )}
            \textcolor{keywordflow}{for} ( type in types ) \{
                this.off( type, selector, types[ type ] );
            \}
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
        \}
        \textcolor{keywordflow}{if} ( selector === \textcolor{keyword}{false} || typeof selector === \textcolor{stringliteral}{"function"} ) \{
            \textcolor{comment}{// ( types [, fn] )}
            fn = selector;
            selector = undefined;
        \}
        \textcolor{keywordflow}{if} ( fn === \textcolor{keyword}{false} ) \{
            fn = returnFalse;
        \}
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            jQuery.event.remove( \textcolor{keyword}{this}, types, fn, selector );
        \});
    \},

    trigger: \textcolor{keyword}{function}( type, data ) \{
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            jQuery.event.trigger( type, data, \textcolor{keyword}{this} );
        \});
    \},
    triggerHandler: \textcolor{keyword}{function}( type, data ) \{
        var elem = \textcolor{keyword}{this}[0];
        \textcolor{keywordflow}{if} ( elem ) \{
            \textcolor{keywordflow}{return} jQuery.event.trigger( type, data, elem, \textcolor{keyword}{true} );
        \}
    \}
\});


var
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\(\backslash\)w:]+)[^>]*)\(\backslash\)/>/gi,
    rtagName = /<([\(\backslash\)w:]+)/,
    rhtml = /<|&#?\(\backslash\)w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    \textcolor{comment}{// checked="checked" or checked}
    rchecked = /checked\(\backslash\)s*(?:[^=]|=\(\backslash\)s*.checked.)/i,
    rscriptType = /^$|\(\backslash\)/(?:java|ecma)script/i,
    rscriptTypeMasked = /^\textcolor{keyword}{true}\(\backslash\)/(.*)/,
    rcleanScript = /^\(\backslash\)s*<!(?:\(\backslash\)[CDATA\(\backslash\)[|--)|(?:\(\backslash\)]\(\backslash\)]|--)>\(\backslash\)s*$/g,

    \textcolor{comment}{// We have to close these tags to support XHTML (#13200)}
    wrapMap = \{

        \textcolor{comment}{// Support: IE 9}
        option: [ 1, \textcolor{stringliteral}{"<select multiple='multiple'>"}, \textcolor{stringliteral}{"</select>"} ],

        thead: [ 1, \textcolor{stringliteral}{"<table>"}, \textcolor{stringliteral}{"</table>"} ],
        col: [ 2, \textcolor{stringliteral}{"<table><colgroup>"}, \textcolor{stringliteral}{"</colgroup></table>"} ],
        tr: [ 2, \textcolor{stringliteral}{"<table><tbody>"}, \textcolor{stringliteral}{"</tbody></table>"} ],
        td: [ 3, \textcolor{stringliteral}{"<table><tbody><tr>"}, \textcolor{stringliteral}{"</tr></tbody></table>"} ],

        \_default: [ 0, \textcolor{stringliteral}{""}, \textcolor{stringliteral}{""} ]
    \};

\textcolor{comment}{// Support: IE 9}
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

\textcolor{comment}{// Support: 1.x compatibility}
\textcolor{comment}{// Manipulating tables requires a tbody}
\textcolor{keyword}{function} manipulationTarget( elem, content ) \{
    \textcolor{keywordflow}{return} jQuery.nodeName( elem, \textcolor{stringliteral}{"table"} ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \textcolor{stringliteral}{"tr"} ) ?

        elem.getElementsByTagName(\textcolor{stringliteral}{"tbody"})[0] ||
            elem.appendChild( elem.ownerDocument.createElement(\textcolor{stringliteral}{"tbody"}) ) :
        elem;
\}

\textcolor{comment}{// Replace/restore the type attribute of script elements for safe DOM manipulation}
\textcolor{keyword}{function} disableScript( elem ) \{
    elem.type = (elem.getAttribute(\textcolor{stringliteral}{"type"}) !== null) + \textcolor{stringliteral}{"/"} + elem.type;
    \textcolor{keywordflow}{return} elem;
\}
\textcolor{keyword}{function} restoreScript( elem ) \{
    var match = rscriptTypeMasked.exec( elem.type );

    \textcolor{keywordflow}{if} ( match ) \{
        elem.type = match[ 1 ];
    \} \textcolor{keywordflow}{else} \{
        elem.removeAttribute(\textcolor{stringliteral}{"type"});
    \}

    \textcolor{keywordflow}{return} elem;
\}

\textcolor{comment}{// Mark scripts as having already been evaluated}
\textcolor{keyword}{function} setGlobalEval( elems, refElements ) \{
    var i = 0,
        l = elems.length;

    \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
        data\_priv.set(
            elems[ i ], \textcolor{stringliteral}{"globalEval"}, !refElements || data\_priv.get( refElements[ i ], \textcolor{stringliteral}{"globalEval"} )
        );
    \}
\}

\textcolor{keyword}{function} cloneCopyEvent( src, dest ) \{
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    \textcolor{keywordflow}{if} ( dest.nodeType !== 1 ) \{
        \textcolor{keywordflow}{return};
    \}

    \textcolor{comment}{// 1. Copy private data: events, handlers, etc.}
    \textcolor{keywordflow}{if} ( data\_priv.hasData( src ) ) \{
        pdataOld = data\_priv.access( src );
        pdataCur = data\_priv.set( dest, pdataOld );
        events = pdataOld.events;

        \textcolor{keywordflow}{if} ( events ) \{
            \textcolor{keyword}{delete} pdataCur.handle;
            pdataCur.events = \{\};

            \textcolor{keywordflow}{for} ( type in events ) \{
                \textcolor{keywordflow}{for} ( i = 0, l = events[ type ].length; i < l; i++ ) \{
                    jQuery.event.add( dest, type, events[ type ][ i ] );
                \}
            \}
        \}
    \}

    \textcolor{comment}{// 2. Copy user data}
    \textcolor{keywordflow}{if} ( data\_user.hasData( src ) ) \{
        udataOld = data\_user.access( src );
        udataCur = jQuery.extend( \{\}, udataOld );

        data\_user.set( dest, udataCur );
    \}
\}

\textcolor{keyword}{function} getAll( context, tag ) \{
    var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \textcolor{stringliteral}{"*"} ) :
            context.querySelectorAll ? context.querySelectorAll( tag || \textcolor{stringliteral}{"*"} ) :
            [];

    \textcolor{keywordflow}{return} tag === undefined || tag && jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], ret ) :
        ret;
\}

\textcolor{comment}{// Support: IE >= 9}
\textcolor{keyword}{function} fixInput( src, dest ) \{
    var nodeName = dest.nodeName.toLowerCase();

    \textcolor{comment}{// Fails to persist the checked state of a cloned checkbox or radio button.}
    \textcolor{keywordflow}{if} ( nodeName === \textcolor{stringliteral}{"input"} && rcheckableType.test( src.type ) ) \{
        dest.checked = src.checked;

    \textcolor{comment}{// Fails to return the selected option to the default selected state when cloning options}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( nodeName === \textcolor{stringliteral}{"input"} || nodeName === \textcolor{stringliteral}{"textarea"} ) \{
        dest.defaultValue = src.defaultValue;
    \}
\}

jQuery.extend(\{
    clone: \textcolor{keyword}{function}( elem, dataAndEvents, deepDataAndEvents ) \{
        var i, l, srcElements, destElements,
            clone = elem.cloneNode( \textcolor{keyword}{true} ),
            inPage = jQuery.contains( elem.ownerDocument, elem );

        \textcolor{comment}{// Support: IE >= 9}
        \textcolor{comment}{// Fix Cloning issues}
        \textcolor{keywordflow}{if} ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                !jQuery.isXMLDoc( elem ) ) \{

            \textcolor{comment}{// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2}
            destElements = getAll( clone );
            srcElements = getAll( elem );

            \textcolor{keywordflow}{for} ( i = 0, l = srcElements.length; i < l; i++ ) \{
                fixInput( srcElements[ i ], destElements[ i ] );
            \}
        \}

        \textcolor{comment}{// Copy the events from the original to the clone}
        \textcolor{keywordflow}{if} ( dataAndEvents ) \{
            \textcolor{keywordflow}{if} ( deepDataAndEvents ) \{
                srcElements = srcElements || getAll( elem );
                destElements = destElements || getAll( clone );

                \textcolor{keywordflow}{for} ( i = 0, l = srcElements.length; i < l; i++ ) \{
                    cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                \}
            \} \textcolor{keywordflow}{else} \{
                cloneCopyEvent( elem, clone );
            \}
        \}

        \textcolor{comment}{// Preserve script evaluation history}
        destElements = getAll( clone, \textcolor{stringliteral}{"script"} );
        \textcolor{keywordflow}{if} ( destElements.length > 0 ) \{
            setGlobalEval( destElements, !inPage && getAll( elem, \textcolor{stringliteral}{"script"} ) );
        \}

        \textcolor{comment}{// Return the cloned set}
        \textcolor{keywordflow}{return} clone;
    \},

    buildFragment: \textcolor{keyword}{function}( elems, context, scripts, selection ) \{
        var elem, tmp, tag, wrap, contains, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
            elem = elems[ i ];

            \textcolor{keywordflow}{if} ( elem || elem === 0 ) \{

                \textcolor{comment}{// Add nodes directly}
                \textcolor{keywordflow}{if} ( jQuery.type( elem ) === \textcolor{stringliteral}{"object"} ) \{
                    \textcolor{comment}{// Support: QtWebKit}
                    \textcolor{comment}{// jQuery.merge because push.apply(\_, arraylike) throws}
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                \textcolor{comment}{// Convert non-html into a text node}
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !rhtml.test( elem ) ) \{
                    nodes.push( context.createTextNode( elem ) );

                \textcolor{comment}{// Convert html into DOM nodes}
                \} \textcolor{keywordflow}{else} \{
                    tmp = tmp || fragment.appendChild( context.createElement(\textcolor{stringliteral}{"div"}) );

                    \textcolor{comment}{// Deserialize a standard representation}
                    tag = ( rtagName.exec( elem ) || [ \textcolor{stringliteral}{""}, \textcolor{stringliteral}{""} ] )[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap.\_default;
                    tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \textcolor{stringliteral}{"<$1></$2>"} ) + wrap[ 2 ];

                    \textcolor{comment}{// Descend through wrappers to the right content}
                    j = wrap[ 0 ];
                    \textcolor{keywordflow}{while} ( j-- ) \{
                        tmp = tmp.lastChild;
                    \}

                    \textcolor{comment}{// Support: QtWebKit}
                    \textcolor{comment}{// jQuery.merge because push.apply(\_, arraylike) throws}
                    jQuery.merge( nodes, tmp.childNodes );

                    \textcolor{comment}{// Remember the top-level container}
                    tmp = fragment.firstChild;

                    \textcolor{comment}{// Fixes #12346}
                    \textcolor{comment}{// Support: Webkit, IE}
                    tmp.textContent = \textcolor{stringliteral}{""};
                \}
            \}
        \}

        \textcolor{comment}{// Remove wrapper from fragment}
        fragment.textContent = \textcolor{stringliteral}{""};

        i = 0;
        \textcolor{keywordflow}{while} ( (elem = nodes[ i++ ]) ) \{

            \textcolor{comment}{// #4087 - If origin and destination elements are the same, and this is}
            \textcolor{comment}{// that element, do not do anything}
            \textcolor{keywordflow}{if} ( selection && jQuery.inArray( elem, selection ) !== -1 ) \{
                \textcolor{keywordflow}{continue};
            \}

            contains = jQuery.contains( elem.ownerDocument, elem );

            \textcolor{comment}{// Append to fragment}
            tmp = getAll( fragment.appendChild( elem ), \textcolor{stringliteral}{"script"} );

            \textcolor{comment}{// Preserve script evaluation history}
            \textcolor{keywordflow}{if} ( contains ) \{
                setGlobalEval( tmp );
            \}

            \textcolor{comment}{// Capture executables}
            \textcolor{keywordflow}{if} ( scripts ) \{
                j = 0;
                \textcolor{keywordflow}{while} ( (elem = tmp[ j++ ]) ) \{
                    \textcolor{keywordflow}{if} ( rscriptType.test( elem.type || \textcolor{stringliteral}{""} ) ) \{
                        scripts.push( elem );
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} fragment;
    \},

    cleanData: \textcolor{keyword}{function}( elems ) \{
        var data, elem, type, key,
            special = jQuery.event.special,
            i = 0;

        \textcolor{keywordflow}{for} ( ; (elem = elems[ i ]) !== undefined; i++ ) \{
            \textcolor{keywordflow}{if} ( jQuery.acceptData( elem ) ) \{
                key = elem[ data\_priv.expando ];

                \textcolor{keywordflow}{if} ( key && (data = data\_priv.cache[ key ]) ) \{
                    \textcolor{keywordflow}{if} ( data.events ) \{
                        \textcolor{keywordflow}{for} ( type in data.events ) \{
                            \textcolor{keywordflow}{if} ( special[ type ] ) \{
                                jQuery.event.remove( elem, type );

                            \textcolor{comment}{// This is a shortcut to avoid jQuery.event.remove's overhead}
                            \} \textcolor{keywordflow}{else} \{
                                jQuery.removeEvent( elem, type, data.handle );
                            \}
                        \}
                    \}
                    \textcolor{keywordflow}{if} ( data\_priv.cache[ key ] ) \{
                        \textcolor{comment}{// Discard any remaining `private` data}
                        \textcolor{keyword}{delete} data\_priv.cache[ key ];
                    \}
                \}
            \}
            \textcolor{comment}{// Discard any remaining `user` data}
            \textcolor{keyword}{delete} data\_user.cache[ elem[ data\_user.expando ] ];
        \}
    \}
\});

jQuery.fn.extend(\{
    text: \textcolor{keyword}{function}( value ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( value ) \{
            \textcolor{keywordflow}{return} value === undefined ?
                jQuery.text( \textcolor{keyword}{this} ) :
                this.empty().each(\textcolor{keyword}{function}() \{
                    \textcolor{keywordflow}{if} ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) \{
                        this.textContent = value;
                    \}
                \});
        \}, null, value, arguments.length );
    \},

    append: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.domManip( arguments, \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{if} ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) \{
                var target = manipulationTarget( \textcolor{keyword}{this}, elem );
                target.appendChild( elem );
            \}
        \});
    \},

    prepend: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.domManip( arguments, \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{if} ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) \{
                var target = manipulationTarget( \textcolor{keyword}{this}, elem );
                target.insertBefore( elem, target.firstChild );
            \}
        \});
    \},

    before: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.domManip( arguments, \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{if} ( this.parentNode ) \{
                this.parentNode.insertBefore( elem, \textcolor{keyword}{this} );
            \}
        \});
    \},

    after: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.domManip( arguments, \textcolor{keyword}{function}( elem ) \{
            \textcolor{keywordflow}{if} ( this.parentNode ) \{
                this.parentNode.insertBefore( elem, this.nextSibling );
            \}
        \});
    \},

    \textcolor{keyword}{remove}: \textcolor{keyword}{function}( selector, keepData \textcolor{comment}{/* Internal Use Only */} ) \{
        var elem,
            elems = selector ? jQuery.filter( selector, \textcolor{keyword}{this} ) : \textcolor{keyword}{this},
            i = 0;

        \textcolor{keywordflow}{for} ( ; (elem = elems[i]) != null; i++ ) \{
            \textcolor{keywordflow}{if} ( !keepData && elem.nodeType === 1 ) \{
                jQuery.cleanData( getAll( elem ) );
            \}

            \textcolor{keywordflow}{if} ( elem.parentNode ) \{
                \textcolor{keywordflow}{if} ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) \{
                    setGlobalEval( getAll( elem, \textcolor{stringliteral}{"script"} ) );
                \}
                elem.parentNode.removeChild( elem );
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \},

    empty: \textcolor{keyword}{function}() \{
        var elem,
            i = 0;

        \textcolor{keywordflow}{for} ( ; (elem = \textcolor{keyword}{this}[i]) != null; i++ ) \{
            \textcolor{keywordflow}{if} ( elem.nodeType === 1 ) \{

                \textcolor{comment}{// Prevent memory leaks}
                jQuery.cleanData( getAll( elem, \textcolor{keyword}{false} ) );

                \textcolor{comment}{// Remove any remaining nodes}
                elem.textContent = \textcolor{stringliteral}{""};
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \},

    clone: \textcolor{keyword}{function}( dataAndEvents, deepDataAndEvents ) \{
        dataAndEvents = dataAndEvents == null ? \textcolor{keyword}{false} : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        \textcolor{keywordflow}{return} this.map(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} jQuery.clone( \textcolor{keyword}{this}, dataAndEvents, deepDataAndEvents );
        \});
    \},

    html: \textcolor{keyword}{function}( value ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( value ) \{
            var elem = \textcolor{keyword}{this}[ 0 ] || \{\},
                i = 0,
                l = this.length;

            \textcolor{keywordflow}{if} ( value === undefined && elem.nodeType === 1 ) \{
                return elem.innerHTML;
            \}

            \textcolor{comment}{// See if we can take a shortcut and just use innerHTML}
            if ( typeof value === \textcolor{stringliteral}{"string"} && !rnoInnerhtml.test( value ) &&
                !wrapMap[ ( rtagName.exec( value ) || [ \textcolor{stringliteral}{""}, \textcolor{stringliteral}{""} ] )[ 1 ].toLowerCase() ] ) \{

                value = value.replace( rxhtmlTag, \textcolor{stringliteral}{"<$1></$2>"} );

                \textcolor{keywordflow}{try} \{
                    \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
                        elem = \textcolor{keyword}{this}[ i ] || \{\};

                        \textcolor{comment}{// Remove element nodes and prevent memory leaks}
                        \textcolor{keywordflow}{if} ( elem.nodeType === 1 ) \{
                            jQuery.cleanData( getAll( elem, \textcolor{keyword}{false} ) );
                            elem.innerHTML = value;
                        \}
                    \}

                    elem = 0;

                \textcolor{comment}{// If using innerHTML throws an exception, use the fallback method}
                \} \textcolor{keywordflow}{catch}( e ) \{\}
            \}

            \textcolor{keywordflow}{if} ( elem ) \{
                this.empty().append( value );
            \}
        \}, null, value, arguments.length );
    \},

    replaceWith: \textcolor{keyword}{function}() \{
        var arg = arguments[ 0 ];

        \textcolor{comment}{// Make the changes, replacing each context element with the new content}
        this.domManip( arguments, \textcolor{keyword}{function}( elem ) \{
            arg = this.parentNode;

            jQuery.cleanData( getAll( \textcolor{keyword}{this} ) );

            \textcolor{keywordflow}{if} ( arg ) \{
                arg.replaceChild( elem, \textcolor{keyword}{this} );
            \}
        \});

        \textcolor{comment}{// Force removal if there was no new content (e.g., from empty arguments)}
        \textcolor{keywordflow}{return} arg && (arg.length || arg.nodeType) ? \textcolor{keyword}{this} : this.\textcolor{keyword}{remove}();
    \},

    detach: \textcolor{keyword}{function}( selector ) \{
        \textcolor{keywordflow}{return} this.\textcolor{keyword}{remove}( selector, true );
    \},

    domManip: \textcolor{keyword}{function}( args, callback ) \{

        \textcolor{comment}{// Flatten any nested arrays}
        args = concat.apply( [], args );

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = this.length,
            set = \textcolor{keyword}{this},
            iNoClone = l - 1,
            value = args[ 0 ],
            isFunction = jQuery.isFunction( value );

        \textcolor{comment}{// We can't cloneNode fragments that contain checked, in WebKit}
        \textcolor{keywordflow}{if} ( isFunction ||
                ( l > 1 && typeof value === \textcolor{stringliteral}{"string"} &&
                    !support.checkClone && rchecked.test( value ) ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( index ) \{
                var \textcolor{keyword}{self} = set.eq( index );
                \textcolor{keywordflow}{if} ( isFunction ) \{
                    args[ 0 ] = value.call( \textcolor{keyword}{this}, index, \textcolor{keyword}{self}.html() );
                \}
                \textcolor{keyword}{self}.domManip( args, callback );
            \});
        \}

        \textcolor{keywordflow}{if} ( l ) \{
            fragment = jQuery.buildFragment( args, \textcolor{keyword}{this}[ 0 ].ownerDocument, \textcolor{keyword}{false}, \textcolor{keyword}{this} );
            first = fragment.firstChild;

            \textcolor{keywordflow}{if} ( fragment.childNodes.length === 1 ) \{
                fragment = first;
            \}

            \textcolor{keywordflow}{if} ( first ) \{
                scripts = jQuery.map( getAll( fragment, \textcolor{stringliteral}{"script"} ), disableScript );
                hasScripts = scripts.length;

                \textcolor{comment}{// Use the original fragment for the last item instead of the first because it can end up}
                \textcolor{comment}{// being emptied incorrectly in certain situations (#8070).}
                \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
                    node = fragment;

                    \textcolor{keywordflow}{if} ( i !== iNoClone ) \{
                        node = jQuery.clone( node, \textcolor{keyword}{true}, \textcolor{keyword}{true} );

                        \textcolor{comment}{// Keep references to cloned scripts for later restoration}
                        \textcolor{keywordflow}{if} ( hasScripts ) \{
                            \textcolor{comment}{// Support: QtWebKit}
                            \textcolor{comment}{// jQuery.merge because push.apply(\_, arraylike) throws}
                            jQuery.merge( scripts, getAll( node, \textcolor{stringliteral}{"script"} ) );
                        \}
                    \}

                    callback.call( \textcolor{keyword}{this}[ i ], node, i );
                \}

                \textcolor{keywordflow}{if} ( hasScripts ) \{
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    \textcolor{comment}{// Reenable scripts}
                    jQuery.map( scripts, restoreScript );

                    \textcolor{comment}{// Evaluate executable scripts on first document insertion}
                    \textcolor{keywordflow}{for} ( i = 0; i < hasScripts; i++ ) \{
                        node = scripts[ i ];
                        \textcolor{keywordflow}{if} ( rscriptType.test( node.type || \textcolor{stringliteral}{""} ) &&
                            !data\_priv.access( node, \textcolor{stringliteral}{"globalEval"} ) && jQuery.contains( doc, node ) ) \{

                            \textcolor{keywordflow}{if} ( node.src ) \{
                                \textcolor{comment}{// Optional AJAX dependency, but won't run scripts if not present}
                                \textcolor{keywordflow}{if} ( jQuery.\_evalUrl ) \{
                                    jQuery.\_evalUrl( node.src );
                                \}
                            \} \textcolor{keywordflow}{else} \{
                                jQuery.globalEval( node.textContent.replace( rcleanScript, \textcolor{stringliteral}{""} ) );
                            \}
                        \}
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
\});

jQuery.each(\{
    appendTo: \textcolor{stringliteral}{"append"},
    prependTo: \textcolor{stringliteral}{"prepend"},
    insertBefore: \textcolor{stringliteral}{"before"},
    insertAfter: \textcolor{stringliteral}{"after"},
    replaceAll: \textcolor{stringliteral}{"replaceWith"}
\}, \textcolor{keyword}{function}( name, original ) \{
    jQuery.fn[ name ] = \textcolor{keyword}{function}( selector ) \{
        var elems,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1,
            i = 0;

        \textcolor{keywordflow}{for} ( ; i <= last; i++ ) \{
            elems = i === last ? \textcolor{keyword}{this} : this.clone( \textcolor{keyword}{true} );
            jQuery( insert[ i ] )[ original ]( elems );

            \textcolor{comment}{// Support: QtWebKit}
            \textcolor{comment}{// .get() because push.apply(\_, arraylike) throws}
            push.apply( ret, elems.get() );
        \}

        \textcolor{keywordflow}{return} this.pushStack( ret );
    \};
\});


var iframe,
    elemdisplay = \{\};

\textcolor{comment}{// Called only from within defaultDisplay}
\textcolor{keyword}{function} actualDisplay( name, doc ) \{
    var style,
        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

        \textcolor{comment}{// getDefaultComputedStyle might be reliably used only on attached element}
        display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) )
       ?

            \textcolor{comment}{// Use of this method is a temporary fix (more like optmization) until something better comes
       along,}
            \textcolor{comment}{// since it was removed from specification and supported only in FF}
            style.display : jQuery.css( elem[ 0 ], \textcolor{stringliteral}{"display"} );

    \textcolor{comment}{// We don't have any data stored on the element,}
    \textcolor{comment}{// so use "detach" method as fast way to get rid of the element}
    elem.detach();

    \textcolor{keywordflow}{return} display;
\}

\textcolor{keyword}{function} defaultDisplay( nodeName ) \{
    var doc = document,
        display = elemdisplay[ nodeName ];

    \textcolor{keywordflow}{if} ( !display ) \{
        display = actualDisplay( nodeName, doc );

        \textcolor{comment}{// If the simple way fails, read from inside an iframe}
        \textcolor{keywordflow}{if} ( display === \textcolor{stringliteral}{"none"} || !display ) \{

            \textcolor{comment}{// Use the already-created iframe if possible}
            iframe = (iframe || jQuery( \textcolor{stringliteral}{"<iframe frameborder='0' width='0' height='0'/>"} )).appendTo( doc.
      documentElement );

            \textcolor{comment}{// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse}
            doc = iframe[ 0 ].contentDocument;

            \textcolor{comment}{// Support: IE}
            doc.write();
            doc.close();

            display = actualDisplay( nodeName, doc );
            iframe.detach();
        \}

        \textcolor{comment}{// Store the correct default display}
        elemdisplay[ nodeName ] = display;
    \}

    \textcolor{keywordflow}{return} display;
\}
var rmargin = (/^margin/);

var rnumnonpx = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^("} + pnum + \textcolor{stringliteral}{")(?!px)[a-z%]+$"}, \textcolor{stringliteral}{"i"} );

var getStyles = \textcolor{keyword}{function}( elem ) \{
        \textcolor{keywordflow}{return} elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    \};



\textcolor{keyword}{function} curCSS( elem, name, computed ) \{
    var width, minWidth, maxWidth, ret,
        style = elem.style;

    computed = computed || getStyles( elem );

    \textcolor{comment}{// Support: IE9}
    \textcolor{comment}{// getPropertyValue is only needed for .css('filter') in IE9, see #12537}
    \textcolor{keywordflow}{if} ( computed ) \{
        ret = computed.getPropertyValue( name ) || computed[ name ];
    \}

    \textcolor{keywordflow}{if} ( computed ) \{

        \textcolor{keywordflow}{if} ( ret === \textcolor{stringliteral}{""} && !jQuery.contains( elem.ownerDocument, elem ) ) \{
            ret = jQuery.style( elem, name );
        \}

        \textcolor{comment}{// Support: iOS < 6}
        \textcolor{comment}{// A tribute to the "awesome hack by Dean Edwards"}
        \textcolor{comment}{// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably
       pixels}
        \textcolor{comment}{// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values}
        \textcolor{keywordflow}{if} ( rnumnonpx.test( ret ) && rmargin.test( name ) ) \{

            \textcolor{comment}{// Remember the original values}
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;

            \textcolor{comment}{// Put in the new values to get a computed value out}
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;

            \textcolor{comment}{// Revert the changed values}
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
        \}
    \}

    \textcolor{keywordflow}{return} ret !== undefined ?
        \textcolor{comment}{// Support: IE}
        \textcolor{comment}{// IE returns zIndex value as an integer.}
        ret + \textcolor{stringliteral}{""} :
        ret;
\}


\textcolor{keyword}{function} addGetHookIf( conditionFn, hookFn ) \{
    \textcolor{comment}{// Define the hook, we'll check on the first run if it's really needed.}
    \textcolor{keywordflow}{return} \{
        \textcolor{keyword}{get}: \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( conditionFn() ) \{
                \textcolor{comment}{// Hook not needed (or it's not possible to use it due to missing dependency),}
                \textcolor{comment}{// remove it.}
                \textcolor{comment}{// Since there are no other hooks for marginRight, remove the whole object.}
                \textcolor{keyword}{delete} this.\textcolor{keyword}{get};
                \textcolor{keywordflow}{return};
            \}

            \textcolor{comment}{// Hook needed; redefine it so that the support test is not executed again.}

            \textcolor{keywordflow}{return} (this.\textcolor{keyword}{get} = hookFn).apply( \textcolor{keyword}{this}, arguments );
        \}
    \};
\}


(\textcolor{keyword}{function}() \{
    var pixelPositionVal, boxSizingReliableVal,
        docElem = document.documentElement,
        container = document.createElement( \textcolor{stringliteral}{"div"} ),
        div = document.createElement( \textcolor{stringliteral}{"div"} );

    \textcolor{keywordflow}{if} ( !div.style ) \{
        \textcolor{keywordflow}{return};
    \}

    div.style.backgroundClip = \textcolor{stringliteral}{"content-box"};
    div.cloneNode( \textcolor{keyword}{true} ).style.backgroundClip = \textcolor{stringliteral}{""};
    support.clearCloneStyle = div.style.backgroundClip === \textcolor{stringliteral}{"content-box"};

    container.style.cssText = \textcolor{stringliteral}{"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;"} +
        \textcolor{stringliteral}{"position:absolute"};
    container.appendChild( div );

    \textcolor{comment}{// Executing both pixelPosition & boxSizingReliable tests require only one layout}
    \textcolor{comment}{// so they're executed at the same time to save the second computation.}
    \textcolor{keyword}{function} computePixelPositionAndBoxSizingReliable() \{
        div.style.cssText =
            \textcolor{comment}{// Support: Firefox<29, Android 2.3}
            \textcolor{comment}{// Vendor-prefix box-sizing}
            \textcolor{stringliteral}{"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;"} +
            \textcolor{stringliteral}{"box-sizing:border-box;display:block;margin-top:1%;top:1%;"} +
            \textcolor{stringliteral}{"border:1px;padding:1px;width:4px;position:absolute"};
        div.innerHTML = \textcolor{stringliteral}{""};
        docElem.appendChild( container );

        var divStyle = window.getComputedStyle( div, null );
        pixelPositionVal = divStyle.top !== \textcolor{stringliteral}{"1%"};
        boxSizingReliableVal = divStyle.width === \textcolor{stringliteral}{"4px"};

        docElem.removeChild( container );
    \}

    \textcolor{comment}{// Support: node.js jsdom}
    \textcolor{comment}{// Don't assume that getComputedStyle is a property of the global object}
    \textcolor{keywordflow}{if} ( window.getComputedStyle ) \{
        jQuery.extend( support, \{
            pixelPosition: \textcolor{keyword}{function}() \{
                \textcolor{comment}{// This test is executed only once but we still do memoizing}
                \textcolor{comment}{// since we can use the boxSizingReliable pre-computing.}
                \textcolor{comment}{// No need to check if the test was already performed, though.}
                computePixelPositionAndBoxSizingReliable();
                \textcolor{keywordflow}{return} pixelPositionVal;
            \},
            boxSizingReliable: \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( boxSizingReliableVal == null ) \{
                    computePixelPositionAndBoxSizingReliable();
                \}
                \textcolor{keywordflow}{return} boxSizingReliableVal;
            \},
            reliableMarginRight: \textcolor{keyword}{function}() \{
                \textcolor{comment}{// Support: Android 2.3}
                \textcolor{comment}{// Check if div with explicit width and no margin-right incorrectly}
                \textcolor{comment}{// gets computed margin-right based on width of container. (#3333)}
                \textcolor{comment}{// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right}
                \textcolor{comment}{// This support function is only executed once so no memoizing is needed.}
                var ret,
                    marginDiv = div.appendChild( document.createElement( \textcolor{stringliteral}{"div"} ) );

                \textcolor{comment}{// Reset CSS: box-sizing; display; margin; border; padding}
                marginDiv.style.cssText = div.style.cssText =
                    \textcolor{comment}{// Support: Firefox<29, Android 2.3}
                    \textcolor{comment}{// Vendor-prefix box-sizing}
                    \textcolor{stringliteral}{"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;"} +
                    \textcolor{stringliteral}{"box-sizing:content-box;display:block;margin:0;border:0;padding:0"};
                marginDiv.style.marginRight = marginDiv.style.width = \textcolor{stringliteral}{"0"};
                div.style.width = \textcolor{stringliteral}{"1px"};
                docElem.appendChild( container );

                ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

                docElem.removeChild( container );

                \textcolor{keywordflow}{return} ret;
            \}
        \});
    \}
\})();


\textcolor{comment}{// A method for quickly swapping in/out CSS properties to get correct calculations.}
jQuery.swap = \textcolor{keyword}{function}( elem, options, callback, args ) \{
    var ret, name,
        old = \{\};

    \textcolor{comment}{// Remember the old values, and insert the new ones}
    \textcolor{keywordflow}{for} ( name in options ) \{
        old[ name ] = elem.style[ name ];
        elem.style[ name ] = options[ name ];
    \}

    ret = callback.apply( elem, args || [] );

    \textcolor{comment}{// Revert the old values}
    \textcolor{keywordflow}{for} ( name in options ) \{
        elem.style[ name ] = old[ name ];
    \}

    \textcolor{keywordflow}{return} ret;
\};


var
    \textcolor{comment}{// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"}
    \textcolor{comment}{// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display}
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^("} + pnum + \textcolor{stringliteral}{")(.*)$"}, \textcolor{stringliteral}{"i"} ),
    rrelNum = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^([+-])=("} + pnum + \textcolor{stringliteral}{")"}, \textcolor{stringliteral}{"i"} ),

    cssShow = \{ position: \textcolor{stringliteral}{"absolute"}, visibility: \textcolor{stringliteral}{"hidden"}, display: \textcolor{stringliteral}{"block"} \},
    cssNormalTransform = \{
        letterSpacing: \textcolor{stringliteral}{"0"},
        fontWeight: \textcolor{stringliteral}{"400"}
    \},

    cssPrefixes = [ \textcolor{stringliteral}{"Webkit"}, \textcolor{stringliteral}{"O"}, \textcolor{stringliteral}{"Moz"}, \textcolor{stringliteral}{"ms"} ];

\textcolor{comment}{// return a css property mapped to a potentially vendor prefixed property}
\textcolor{keyword}{function} vendorPropName( style, name ) \{

    \textcolor{comment}{// shortcut for names that are not vendor prefixed}
    \textcolor{keywordflow}{if} ( name in style ) \{
        \textcolor{keywordflow}{return} name;
    \}

    \textcolor{comment}{// check for vendor prefixed names}
    var capName = name[0].toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    \textcolor{keywordflow}{while} ( i-- ) \{
        name = cssPrefixes[ i ] + capName;
        \textcolor{keywordflow}{if} ( name in style ) \{
            \textcolor{keywordflow}{return} name;
        \}
    \}

    \textcolor{keywordflow}{return} origName;
\}

\textcolor{keyword}{function} setPositiveNumber( elem, value, subtract ) \{
    var matches = rnumsplit.exec( value );
    \textcolor{keywordflow}{return} matches ?
        \textcolor{comment}{// Guard against undefined "subtract", e.g., when used as in cssHooks}
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \textcolor{stringliteral}{"px"} ) :
        value;
\}

\textcolor{keyword}{function} augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) \{
    var i = extra === ( isBorderBox ? \textcolor{stringliteral}{"border"} : \textcolor{stringliteral}{"content"} ) ?
        \textcolor{comment}{// If we already have the right measurement, avoid augmentation}
        4 :
        \textcolor{comment}{// Otherwise initialize for horizontal or vertical properties}
        name === \textcolor{stringliteral}{"width"} ? 1 : 0,

        val = 0;

    \textcolor{keywordflow}{for} ( ; i < 4; i += 2 ) \{
        \textcolor{comment}{// both box models exclude margin, so add it if we want it}
        \textcolor{keywordflow}{if} ( extra === \textcolor{stringliteral}{"margin"} ) \{
            val += jQuery.css( elem, extra + cssExpand[ i ], \textcolor{keyword}{true}, styles );
        \}

        \textcolor{keywordflow}{if} ( isBorderBox ) \{
            \textcolor{comment}{// border-box includes padding, so remove it if we want content}
            \textcolor{keywordflow}{if} ( extra === \textcolor{stringliteral}{"content"} ) \{
                val -= jQuery.css( elem, \textcolor{stringliteral}{"padding"} + cssExpand[ i ], \textcolor{keyword}{true}, styles );
            \}

            \textcolor{comment}{// at this point, extra isn't border nor margin, so remove border}
            \textcolor{keywordflow}{if} ( extra !== \textcolor{stringliteral}{"margin"} ) \{
                val -= jQuery.css( elem, \textcolor{stringliteral}{"border"} + cssExpand[ i ] + \textcolor{stringliteral}{"Width"}, \textcolor{keyword}{true}, styles );
            \}
        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// at this point, extra isn't content, so add padding}
            val += jQuery.css( elem, \textcolor{stringliteral}{"padding"} + cssExpand[ i ], \textcolor{keyword}{true}, styles );

            \textcolor{comment}{// at this point, extra isn't content nor padding, so add border}
            \textcolor{keywordflow}{if} ( extra !== \textcolor{stringliteral}{"padding"} ) \{
                val += jQuery.css( elem, \textcolor{stringliteral}{"border"} + cssExpand[ i ] + \textcolor{stringliteral}{"Width"}, \textcolor{keyword}{true}, styles );
            \}
        \}
    \}

    \textcolor{keywordflow}{return} val;
\}

\textcolor{keyword}{function} getWidthOrHeight( elem, name, extra ) \{

    \textcolor{comment}{// Start with offset property, which is equivalent to the border-box value}
    var valueIsBorderBox = \textcolor{keyword}{true},
        val = name === \textcolor{stringliteral}{"width"} ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = jQuery.css( elem, \textcolor{stringliteral}{"boxSizing"}, \textcolor{keyword}{false}, styles ) === \textcolor{stringliteral}{"border-box"};

    \textcolor{comment}{// some non-html elements return undefined for offsetWidth, so check for null/undefined}
    \textcolor{comment}{// svg - https://bugzilla.mozilla.org/show\_bug.cgi?id=649285}
    \textcolor{comment}{// MathML - https://bugzilla.mozilla.org/show\_bug.cgi?id=491668}
    \textcolor{keywordflow}{if} ( val <= 0 || val == null ) \{
        \textcolor{comment}{// Fall back to computed then uncomputed css if necessary}
        val = curCSS( elem, name, styles );
        \textcolor{keywordflow}{if} ( val < 0 || val == null ) \{
            val = elem.style[ name ];
        \}

        \textcolor{comment}{// Computed unit is not pixels. Stop here and return.}
        \textcolor{keywordflow}{if} ( rnumnonpx.test(val) ) \{
            \textcolor{keywordflow}{return} val;
        \}

        \textcolor{comment}{// we need the check for style in case a browser which returns unreliable values}
        \textcolor{comment}{// for getComputedStyle silently falls back to the reliable elem.style}
        valueIsBorderBox = isBorderBox &&
            ( support.boxSizingReliable() || val === elem.style[ name ] );

        \textcolor{comment}{// Normalize "", auto, and prepare for extra}
        val = parseFloat( val ) || 0;
    \}

    \textcolor{comment}{// use the active box-sizing model to add/subtract irrelevant styles}
    \textcolor{keywordflow}{return} ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? \textcolor{stringliteral}{"border"} : \textcolor{stringliteral}{"content"} ),
            valueIsBorderBox,
            styles
        )
    ) + \textcolor{stringliteral}{"px"};
\}

\textcolor{keyword}{function} showHide( elements, show ) \{
    var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

    \textcolor{keywordflow}{for} ( ; index < length; index++ ) \{
        elem = elements[ index ];
        \textcolor{keywordflow}{if} ( !elem.style ) \{
            \textcolor{keywordflow}{continue};
        \}

        values[ index ] = data\_priv.get( elem, \textcolor{stringliteral}{"olddisplay"} );
        display = elem.style.display;
        \textcolor{keywordflow}{if} ( show ) \{
            \textcolor{comment}{// Reset the inline display of this element to learn if it is}
            \textcolor{comment}{// being hidden by cascaded rules or not}
            \textcolor{keywordflow}{if} ( !values[ index ] && display === \textcolor{stringliteral}{"none"} ) \{
                elem.style.display = \textcolor{stringliteral}{""};
            \}

            \textcolor{comment}{// Set elements which have been overridden with display: none}
            \textcolor{comment}{// in a stylesheet to whatever the default browser style is}
            \textcolor{comment}{// for such an element}
            \textcolor{keywordflow}{if} ( elem.style.display === \textcolor{stringliteral}{""} && isHidden( elem ) ) \{
                values[ index ] = data\_priv.access( elem, \textcolor{stringliteral}{"olddisplay"}, defaultDisplay(elem.nodeName) );
            \}
        \} \textcolor{keywordflow}{else} \{
            hidden = isHidden( elem );

            \textcolor{keywordflow}{if} ( display !== \textcolor{stringliteral}{"none"} || !hidden ) \{
                data\_priv.set( elem, \textcolor{stringliteral}{"olddisplay"}, hidden ? display : jQuery.css( elem, \textcolor{stringliteral}{"display"} ) );
            \}
        \}
    \}

    \textcolor{comment}{// Set the display of most of the elements in a second loop}
    \textcolor{comment}{// to avoid the constant reflow}
    \textcolor{keywordflow}{for} ( index = 0; index < length; index++ ) \{
        elem = elements[ index ];
        \textcolor{keywordflow}{if} ( !elem.style ) \{
            \textcolor{keywordflow}{continue};
        \}
        \textcolor{keywordflow}{if} ( !show || elem.style.display === \textcolor{stringliteral}{"none"} || elem.style.display === \textcolor{stringliteral}{""} ) \{
            elem.style.display = show ? values[ index ] || \textcolor{stringliteral}{""} : \textcolor{stringliteral}{"none"};
        \}
    \}

    \textcolor{keywordflow}{return} elements;
\}

jQuery.extend(\{
    \textcolor{comment}{// Add in style property hooks for overriding the default}
    \textcolor{comment}{// behavior of getting and setting a style property}
    cssHooks: \{
        opacity: \{
            \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem, computed ) \{
                \textcolor{keywordflow}{if} ( computed ) \{
                    \textcolor{comment}{// We should always get a number back from opacity}
                    var ret = curCSS( elem, \textcolor{stringliteral}{"opacity"} );
                    \textcolor{keywordflow}{return} ret === \textcolor{stringliteral}{""} ? \textcolor{stringliteral}{"1"} : ret;
                \}
            \}
        \}
    \},

    \textcolor{comment}{// Don't automatically add "px" to these possibly-unitless properties}
    cssNumber: \{
        \textcolor{stringliteral}{"columnCount"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"fillOpacity"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"flexGrow"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"flexShrink"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"fontWeight"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"lineHeight"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"opacity"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"order"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"orphans"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"widows"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"zIndex"}: \textcolor{keyword}{true},
        \textcolor{stringliteral}{"zoom"}: \textcolor{keyword}{true}
    \},

    \textcolor{comment}{// Add in properties whose names you wish to fix before}
    \textcolor{comment}{// setting or getting the value}
    cssProps: \{
        \textcolor{comment}{// normalize float css property}
        \textcolor{stringliteral}{"float"}: \textcolor{stringliteral}{"cssFloat"}
    \},

    \textcolor{comment}{// Get and set the style property on a DOM Node}
    style: \textcolor{keyword}{function}( elem, name, value, extra ) \{
        \textcolor{comment}{// Don't set styles on text and comment nodes}
        \textcolor{keywordflow}{if} ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Make sure that we're working with the right name}
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, 
      origName ) );

        \textcolor{comment}{// gets hook for the prefixed version}
        \textcolor{comment}{// followed by the unprefixed version}
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        \textcolor{comment}{// Check if we're setting a value}
        \textcolor{keywordflow}{if} ( value !== undefined ) \{
            type = typeof value;

            \textcolor{comment}{// convert relative number strings (+= or -=) to relative numbers. #7345}
            \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"string"} && (ret = rrelNum.exec( value )) ) \{
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                \textcolor{comment}{// Fixes bug #9237}
                type = \textcolor{stringliteral}{"number"};
            \}

            \textcolor{comment}{// Make sure that null and NaN values aren't set. See: #7116}
            \textcolor{keywordflow}{if} ( value == null || value !== value ) \{
                \textcolor{keywordflow}{return};
            \}

            \textcolor{comment}{// If a number was passed in, add 'px' to the (except for certain CSS properties)}
            \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"number"} && !jQuery.cssNumber[ origName ] ) \{
                value += \textcolor{stringliteral}{"px"};
            \}

            \textcolor{comment}{// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,}
            \textcolor{comment}{// but it would mean to define eight (for every problematic property) identical functions}
            \textcolor{keywordflow}{if} ( !support.clearCloneStyle && value === \textcolor{stringliteral}{""} && name.indexOf( \textcolor{stringliteral}{"background"} ) === 0 ) \{
                style[ name ] = \textcolor{stringliteral}{"inherit"};
            \}

            \textcolor{comment}{// If a hook was provided, use that value, otherwise just set the specified value}
            \textcolor{keywordflow}{if} ( !hooks || !(\textcolor{stringliteral}{"set"} in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) \{
                style[ name ] = value;
            \}

        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// If a hook was provided get the non-computed value from there}
            \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"get"} in hooks && (ret = hooks.get( elem, \textcolor{keyword}{false}, extra )) !== undefined ) \{
                \textcolor{keywordflow}{return} ret;
            \}

            \textcolor{comment}{// Otherwise just get the value from the style object}
            \textcolor{keywordflow}{return} style[ name ];
        \}
    \},

    css: \textcolor{keyword}{function}( elem, name, extra, styles ) \{
        var val, num, hooks,
            origName = jQuery.camelCase( name );

        \textcolor{comment}{// Make sure that we're working with the right name}
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, 
      origName ) );

        \textcolor{comment}{// gets hook for the prefixed version}
        \textcolor{comment}{// followed by the unprefixed version}
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        \textcolor{comment}{// If a hook was provided get the computed value from there}
        \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"get"} in hooks ) \{
            val = hooks.get( elem, \textcolor{keyword}{true}, extra );
        \}

        \textcolor{comment}{// Otherwise, if a way to get the computed value exists, use that}
        \textcolor{keywordflow}{if} ( val === undefined ) \{
            val = curCSS( elem, name, styles );
        \}

        \textcolor{comment}{//convert "normal" to computed value}
        \textcolor{keywordflow}{if} ( val === \textcolor{stringliteral}{"normal"} && name in cssNormalTransform ) \{
            val = cssNormalTransform[ name ];
        \}

        \textcolor{comment}{// Return, converting to number if forced or a qualifier was provided and val looks numeric}
        \textcolor{keywordflow}{if} ( extra === \textcolor{stringliteral}{""} || extra ) \{
            num = parseFloat( val );
            \textcolor{keywordflow}{return} extra === \textcolor{keyword}{true} || jQuery.isNumeric( num ) ? num || 0 : val;
        \}
        \textcolor{keywordflow}{return} val;
    \}
\});

jQuery.each([ \textcolor{stringliteral}{"height"}, \textcolor{stringliteral}{"width"} ], \textcolor{keyword}{function}( i, name ) \{
    jQuery.cssHooks[ name ] = \{
        \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem, computed, extra ) \{
            \textcolor{keywordflow}{if} ( computed ) \{
                \textcolor{comment}{// certain elements can have dimension info if we invisibly show them}
                \textcolor{comment}{// however, it must have a current display style that would benefit from this}
                \textcolor{keywordflow}{return} rdisplayswap.test( jQuery.css( elem, \textcolor{stringliteral}{"display"} ) ) && elem.offsetWidth === 0 ?
                    jQuery.swap( elem, cssShow, \textcolor{keyword}{function}() \{
                        return getWidthOrHeight( elem, name, extra );
                    \}) :
                    getWidthOrHeight( elem, name, extra );
            \}
        \},

        set: \textcolor{keyword}{function}( elem, value, extra ) \{
            var styles = extra && getStyles( elem );
            \textcolor{keywordflow}{return} setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    jQuery.css( elem, \textcolor{stringliteral}{"boxSizing"}, \textcolor{keyword}{false}, styles ) === \textcolor{stringliteral}{"border-box"},
                    styles
                ) : 0
            );
        \}
    \};
\});

\textcolor{comment}{// Support: Android 2.3}
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
    \textcolor{keyword}{function}( elem, computed ) \{
        if ( computed ) \{
            \textcolor{comment}{// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right}
            \textcolor{comment}{// Work around by temporarily setting element display to inline-block}
            return jQuery.swap( elem, \{ \textcolor{stringliteral}{"display"}: \textcolor{stringliteral}{"inline-block"} \},
                curCSS, [ elem, \textcolor{stringliteral}{"marginRight"} ] );
        \}
    \}
);

\textcolor{comment}{// These hooks are used by animate to expand properties}
jQuery.each(\{
    margin: \textcolor{stringliteral}{""},
    padding: \textcolor{stringliteral}{""},
    border: \textcolor{stringliteral}{"Width"}
\}, \textcolor{keyword}{function}( prefix, suffix ) \{
    jQuery.cssHooks[ prefix + suffix ] = \{
        expand: \textcolor{keyword}{function}( value ) \{
            var i = 0,
                expanded = \{\},

                \textcolor{comment}{// assumes a single number if not a string}
                parts = typeof value === \textcolor{stringliteral}{"string"} ? value.split(\textcolor{stringliteral}{" "}) : [ value ];

            \textcolor{keywordflow}{for} ( ; i < 4; i++ ) \{
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            \}

            \textcolor{keywordflow}{return} expanded;
        \}
    \};

    \textcolor{keywordflow}{if} ( !rmargin.test( prefix ) ) \{
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    \}
\});

jQuery.fn.extend(\{
    css: \textcolor{keyword}{function}( name, value ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( elem, name, value ) \{
            var styles, len,
                map = \{\},
                i = 0;

            \textcolor{keywordflow}{if} ( jQuery.isArray( name ) ) \{
                styles = getStyles( elem );
                len = name.length;

                \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], \textcolor{keyword}{false}, styles );
                \}

                \textcolor{keywordflow}{return} map;
            \}

            \textcolor{keywordflow}{return} value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        \}, name, value, arguments.length > 1 );
    \},
    show: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} showHide( \textcolor{keyword}{this}, \textcolor{keyword}{true} );
    \},
    hide: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} showHide( \textcolor{keyword}{this} );
    \},
    toggle: \textcolor{keyword}{function}( state ) \{
        \textcolor{keywordflow}{if} ( typeof state === \textcolor{stringliteral}{"boolean"} ) \{
            \textcolor{keywordflow}{return} state ? this.show() : this.hide();
        \}

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( isHidden( \textcolor{keyword}{this} ) ) \{
                jQuery( \textcolor{keyword}{this} ).show();
            \} \textcolor{keywordflow}{else} \{
                jQuery( \textcolor{keyword}{this} ).hide();
            \}
        \});
    \}
\});


\textcolor{keyword}{function} Tween( elem, options, prop, end, easing ) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Tween.prototype.init( elem, options, prop, end, easing );
\}
jQuery.Tween = Tween;

Tween.prototype = \{
    constructor: Tween,
    init: \textcolor{keyword}{function}( elem, options, prop, end, easing, unit ) \{
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || \textcolor{stringliteral}{"swing"};
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{"px"} );
    \},
    cur: \textcolor{keyword}{function}() \{
        var hooks = Tween.propHooks[ this.prop ];

        \textcolor{keywordflow}{return} hooks && hooks.get ?
            hooks.get( \textcolor{keyword}{this} ) :
            Tween.propHooks.\_default.get( \textcolor{keyword}{this} );
    \},
    run: \textcolor{keyword}{function}( percent ) \{
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        \textcolor{keywordflow}{if} ( this.options.duration ) \{
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        \} \textcolor{keywordflow}{else} \{
            this.pos = eased = percent;
        \}
        this.now = ( this.end - this.start ) * eased + this.start;

        \textcolor{keywordflow}{if} ( this.options.step ) \{
            this.options.step.call( this.elem, this.now, \textcolor{keyword}{this} );
        \}

        \textcolor{keywordflow}{if} ( hooks && hooks.set ) \{
            hooks.set( \textcolor{keyword}{this} );
        \} \textcolor{keywordflow}{else} \{
            Tween.propHooks.\_default.set( \textcolor{keyword}{this} );
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
\};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = \{
    \_default: \{
        \textcolor{keyword}{get}: \textcolor{keyword}{function}( tween ) \{
            var result;

            \textcolor{keywordflow}{if} ( tween.elem[ tween.prop ] != null &&
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) \{
                \textcolor{keywordflow}{return} tween.elem[ tween.prop ];
            \}

            \textcolor{comment}{// passing an empty string as a 3rd parameter to .css will automatically}
            \textcolor{comment}{// attempt a parseFloat and fallback to a string if the parse fails}
            \textcolor{comment}{// so, simple values such as "10px" are parsed to Float.}
            \textcolor{comment}{// complex values such as "rotate(1rad)" are returned as is.}
            result = jQuery.css( tween.elem, tween.prop, \textcolor{stringliteral}{""} );
            \textcolor{comment}{// Empty strings, null, undefined and "auto" are converted to 0.}
            \textcolor{keywordflow}{return} !result || result === \textcolor{stringliteral}{"auto"} ? 0 : result;
        \},
        set: \textcolor{keyword}{function}( tween ) \{
            \textcolor{comment}{// use step hook for back compat - use cssHook if its there - use .style if its}
            \textcolor{comment}{// available and use plain properties where available}
            \textcolor{keywordflow}{if} ( jQuery.fx.step[ tween.prop ] ) \{
                jQuery.fx.step[ tween.prop ]( tween );
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || 
      jQuery.cssHooks[ tween.prop ] ) ) \{
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            \} \textcolor{keywordflow}{else} \{
                tween.elem[ tween.prop ] = tween.now;
            \}
        \}
    \}
\};

\textcolor{comment}{// Support: IE9}
\textcolor{comment}{// Panic based approach to setting things on disconnected nodes}

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = \{
    set: \textcolor{keyword}{function}( tween ) \{
        \textcolor{keywordflow}{if} ( tween.elem.nodeType && tween.elem.parentNode ) \{
            tween.elem[ tween.prop ] = tween.now;
        \}
    \}
\};

jQuery.easing = \{
    linear: \textcolor{keyword}{function}( p ) \{
        \textcolor{keywordflow}{return} p;
    \},
    swing: \textcolor{keyword}{function}( p ) \{
        \textcolor{keywordflow}{return} 0.5 - Math.cos( p * Math.PI ) / 2;
    \}
\};

jQuery.fx = Tween.prototype.init;

\textcolor{comment}{// Back Compat <1.8 extension point}
jQuery.fx.step = \{\};




var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = \textcolor{keyword}{new} RegExp( \textcolor{stringliteral}{"^(?:([+-])=|)("} + pnum + \textcolor{stringliteral}{")([a-z%]*)$"}, \textcolor{stringliteral}{"i"} ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = \{
        \textcolor{stringliteral}{"*"}: [ \textcolor{keyword}{function}( prop, value ) \{
            var tween = this.createTween( prop, value ),
                target = tween.cur(),
                parts = rfxnum.exec( value ),
                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{"px"} ),

                \textcolor{comment}{// Starting value computation is required for potential unit mismatches}
                start = ( jQuery.cssNumber[ prop ] || unit !== \textcolor{stringliteral}{"px"} && +target ) &&
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                scale = 1,
                maxIterations = 20;

            \textcolor{keywordflow}{if} ( start && start[ 3 ] !== unit ) \{
                \textcolor{comment}{// Trust units reported by jQuery.css}
                unit = unit || start[ 3 ];

                \textcolor{comment}{// Make sure we update the tween properties later on}
                parts = parts || [];

                \textcolor{comment}{// Iteratively approximate from a nonzero starting point}
                start = +target || 1;

                \textcolor{keywordflow}{do} \{
                    \textcolor{comment}{// If previous iteration zeroed out, double until we get *something*}
                    \textcolor{comment}{// Use a string for doubling factor so we don't accidentally see scale as unchanged
       below}
                    scale = scale || \textcolor{stringliteral}{".5"};

                    \textcolor{comment}{// Adjust and apply}
                    start = start / scale;
                    jQuery.style( tween.elem, prop, start + unit );

                \textcolor{comment}{// Update scale, tolerating zero or NaN from tween.cur()}
                \textcolor{comment}{// And breaking the loop if scale is unchanged or perfect, or if we've just had enough}
                \} \textcolor{keywordflow}{while} ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
            \}

            \textcolor{comment}{// Update tween properties}
            \textcolor{keywordflow}{if} ( parts ) \{
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                \textcolor{comment}{// If a +=/-= token was provided, we're doing a relative animation}
                tween.end = parts[ 1 ] ?
                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                    +parts[ 2 ];
            \}

            \textcolor{keywordflow}{return} tween;
        \} ]
    \};

\textcolor{comment}{// Animations created synchronously will run synchronously}
\textcolor{keyword}{function} createFxNow() \{
    setTimeout(\textcolor{keyword}{function}() \{
        fxNow = undefined;
    \});
    \textcolor{keywordflow}{return} ( fxNow = jQuery.now() );
\}

\textcolor{comment}{// Generate parameters to create a standard animation}
\textcolor{keyword}{function} genFx( type, includeWidth ) \{
    var which,
        i = 0,
        attrs = \{ height: type \};

    \textcolor{comment}{// if we include width, step value is 1 to do all cssExpand values,}
    \textcolor{comment}{// if we don't include width, step value is 2 to skip over Left and Right}
    includeWidth = includeWidth ? 1 : 0;
    \textcolor{keywordflow}{for} ( ; i < 4 ; i += 2 - includeWidth ) \{
        which = cssExpand[ i ];
        attrs[ \textcolor{stringliteral}{"margin"} + which ] = attrs[ \textcolor{stringliteral}{"padding"} + which ] = type;
    \}

    \textcolor{keywordflow}{if} ( includeWidth ) \{
        attrs.opacity = attrs.width = type;
    \}

    \textcolor{keywordflow}{return} attrs;
\}

\textcolor{keyword}{function} createTween( value, prop, animation ) \{
    var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \textcolor{stringliteral}{"*"} ] ),
        index = 0,
        length = collection.length;
    \textcolor{keywordflow}{for} ( ; index < length; index++ ) \{
        \textcolor{keywordflow}{if} ( (tween = collection[ index ].call( animation, prop, value )) ) \{

            \textcolor{comment}{// we're done with this property}
            \textcolor{keywordflow}{return} tween;
        \}
    \}
\}

\textcolor{keyword}{function} defaultPrefilter( elem, props, opts ) \{
    \textcolor{comment}{/* jshint validthis: true */}
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
        anim = \textcolor{keyword}{this},
        orig = \{\},
        style = elem.style,
        hidden = elem.nodeType && isHidden( elem ),
        dataShow = data\_priv.get( elem, \textcolor{stringliteral}{"fxshow"} );

    \textcolor{comment}{// handle queue: false promises}
    \textcolor{keywordflow}{if} ( !opts.queue ) \{
        hooks = jQuery.\_queueHooks( elem, \textcolor{stringliteral}{"fx"} );
        \textcolor{keywordflow}{if} ( hooks.unqueued == null ) \{
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = \textcolor{keyword}{function}() \{
                \textcolor{keywordflow}{if} ( !hooks.unqueued ) \{
                    oldfire();
                \}
            \};
        \}
        hooks.unqueued++;

        anim.always(\textcolor{keyword}{function}() \{
            \textcolor{comment}{// doing this makes sure that the complete handler will be called}
            \textcolor{comment}{// before this completes}
            anim.always(\textcolor{keyword}{function}() \{
                hooks.unqueued--;
                \textcolor{keywordflow}{if} ( !jQuery.queue( elem, \textcolor{stringliteral}{"fx"} ).length ) \{
                    hooks.empty.fire();
                \}
            \});
        \});
    \}

    \textcolor{comment}{// height/width overflow pass}
    \textcolor{keywordflow}{if} ( elem.nodeType === 1 && ( \textcolor{stringliteral}{"height"} in props || \textcolor{stringliteral}{"width"} in props ) ) \{
        \textcolor{comment}{// Make sure that nothing sneaks out}
        \textcolor{comment}{// Record all 3 overflow attributes because IE9-10 do not}
        \textcolor{comment}{// change the overflow attribute when overflowX and}
        \textcolor{comment}{// overflowY are set to the same value}
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        \textcolor{comment}{// Set display property to inline-block for height/width}
        \textcolor{comment}{// animations on inline elements that are having width/height animated}
        display = jQuery.css( elem, \textcolor{stringliteral}{"display"} );

        \textcolor{comment}{// Test default display if display is currently "none"}
        checkDisplay = display === \textcolor{stringliteral}{"none"} ?
            data\_priv.get( elem, \textcolor{stringliteral}{"olddisplay"} ) || defaultDisplay( elem.nodeName ) : display;

        \textcolor{keywordflow}{if} ( checkDisplay === \textcolor{stringliteral}{"inline"} && jQuery.css( elem, \textcolor{stringliteral}{"float"} ) === \textcolor{stringliteral}{"none"} ) \{
            style.display = \textcolor{stringliteral}{"inline-block"};
        \}
    \}

    \textcolor{keywordflow}{if} ( opts.overflow ) \{
        style.overflow = \textcolor{stringliteral}{"hidden"};
        anim.always(\textcolor{keyword}{function}() \{
            style.overflow = opts.overflow[ 0 ];
            style.overflowX = opts.overflow[ 1 ];
            style.overflowY = opts.overflow[ 2 ];
        \});
    \}

    \textcolor{comment}{// show/hide pass}
    \textcolor{keywordflow}{for} ( prop in props ) \{
        value = props[ prop ];
        \textcolor{keywordflow}{if} ( rfxtypes.exec( value ) ) \{
            \textcolor{keyword}{delete} props[ prop ];
            toggle = toggle || value === \textcolor{stringliteral}{"toggle"};
            \textcolor{keywordflow}{if} ( value === ( hidden ? \textcolor{stringliteral}{"hide"} : \textcolor{stringliteral}{"show"} ) ) \{

                \textcolor{comment}{// If there is dataShow left over from a stopped hide or show and we are going to proceed
       with show, we should pretend to be hidden}
                \textcolor{keywordflow}{if} ( value === \textcolor{stringliteral}{"show"} && dataShow && dataShow[ prop ] !== undefined ) \{
                    hidden = \textcolor{keyword}{true};
                \} \textcolor{keywordflow}{else} \{
                    \textcolor{keywordflow}{continue};
                \}
            \}
            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

        \textcolor{comment}{// Any non-fx value stops us from restoring the original display value}
        \} \textcolor{keywordflow}{else} \{
            display = undefined;
        \}
    \}

    \textcolor{keywordflow}{if} ( !jQuery.isEmptyObject( orig ) ) \{
        \textcolor{keywordflow}{if} ( dataShow ) \{
            \textcolor{keywordflow}{if} ( \textcolor{stringliteral}{"hidden"} in dataShow ) \{
                hidden = dataShow.hidden;
            \}
        \} \textcolor{keywordflow}{else} \{
            dataShow = data\_priv.access( elem, \textcolor{stringliteral}{"fxshow"}, \{\} );
        \}

        \textcolor{comment}{// store state if its toggle - enables .stop().toggle() to "reverse"}
        \textcolor{keywordflow}{if} ( toggle ) \{
            dataShow.hidden = !hidden;
        \}
        \textcolor{keywordflow}{if} ( hidden ) \{
            jQuery( elem ).show();
        \} \textcolor{keywordflow}{else} \{
            anim.done(\textcolor{keyword}{function}() \{
                jQuery( elem ).hide();
            \});
        \}
        anim.done(\textcolor{keyword}{function}() \{
            var prop;

            data\_priv.remove( elem, \textcolor{stringliteral}{"fxshow"} );
            \textcolor{keywordflow}{for} ( prop in orig ) \{
                jQuery.style( elem, prop, orig[ prop ] );
            \}
        \});
        \textcolor{keywordflow}{for} ( prop in orig ) \{
            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

            \textcolor{keywordflow}{if} ( !( prop in dataShow ) ) \{
                dataShow[ prop ] = tween.start;
                \textcolor{keywordflow}{if} ( hidden ) \{
                    tween.end = tween.start;
                    tween.start = prop === \textcolor{stringliteral}{"width"} || prop === \textcolor{stringliteral}{"height"} ? 1 : 0;
                \}
            \}
        \}

    \textcolor{comment}{// If this is a noop like .hide().hide(), restore an overwritten display value}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (display === \textcolor{stringliteral}{"none"} ? defaultDisplay( elem.nodeName ) : display) === \textcolor{stringliteral}{"inline"} ) \{
        style.display = display;
    \}
\}

\textcolor{keyword}{function} propFilter( props, specialEasing ) \{
    var index, name, easing, value, hooks;

    \textcolor{comment}{// camelCase, specialEasing and expand cssHook pass}
    \textcolor{keywordflow}{for} ( index in props ) \{
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        \textcolor{keywordflow}{if} ( jQuery.isArray( value ) ) \{
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        \}

        \textcolor{keywordflow}{if} ( index !== name ) \{
            props[ name ] = value;
            \textcolor{keyword}{delete} props[ index ];
        \}

        hooks = jQuery.cssHooks[ name ];
        \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"expand"} in hooks ) \{
            value = hooks.expand( value );
            \textcolor{keyword}{delete} props[ name ];

            \textcolor{comment}{// not quite $.extend, this wont overwrite keys already present.}
            \textcolor{comment}{// also - reusing 'index' from above because we have the correct "name"}
            \textcolor{keywordflow}{for} ( index in value ) \{
                \textcolor{keywordflow}{if} ( !( index in props ) ) \{
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                \}
            \}
        \} \textcolor{keywordflow}{else} \{
            specialEasing[ name ] = easing;
        \}
    \}
\}

\textcolor{keyword}{function} Animation( elem, properties, options ) \{
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( \textcolor{keyword}{function}() \{
            \textcolor{comment}{// don't match elem in the :animated selector}
            \textcolor{keyword}{delete} tick.elem;
        \}),
        tick = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( stopped ) \{
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
            \}
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                \textcolor{comment}{// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)}
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            \textcolor{keywordflow}{for} ( ; index < length ; index++ ) \{
                animation.tweens[ index ].run( percent );
            \}

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            \textcolor{keywordflow}{if} ( percent < 1 && length ) \{
                \textcolor{keywordflow}{return} remaining;
            \} \textcolor{keywordflow}{else} \{
                deferred.resolveWith( elem, [ animation ] );
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
            \}
        \},
        animation = deferred.promise(\{
            elem: elem,
            props: jQuery.extend( \{\}, properties ),
            opts: jQuery.extend( \textcolor{keyword}{true}, \{ specialEasing: \{\} \}, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: \textcolor{keyword}{function}( prop, end ) \{
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                \textcolor{keywordflow}{return} tween;
            \},
            stop: \textcolor{keyword}{function}( gotoEnd ) \{
                var index = 0,
                    \textcolor{comment}{// if we are going to the end, we want to run all the tweens}
                    \textcolor{comment}{// otherwise we skip this part}
                    length = gotoEnd ? animation.tweens.length : 0;
                \textcolor{keywordflow}{if} ( stopped ) \{
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \}
                stopped = \textcolor{keyword}{true};
                \textcolor{keywordflow}{for} ( ; index < length ; index++ ) \{
                    animation.tweens[ index ].run( 1 );
                \}

                \textcolor{comment}{// resolve when we played the last frame}
                \textcolor{comment}{// otherwise, reject}
                \textcolor{keywordflow}{if} ( gotoEnd ) \{
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                \} \textcolor{keywordflow}{else} \{
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                \}
                \textcolor{keywordflow}{return} \textcolor{keyword}{this};
            \}
        \}),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    \textcolor{keywordflow}{for} ( ; index < length ; index++ ) \{
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        \textcolor{keywordflow}{if} ( result ) \{
            \textcolor{keywordflow}{return} result;
        \}
    \}

    jQuery.map( props, createTween, animation );

    \textcolor{keywordflow}{if} ( jQuery.isFunction( animation.opts.start ) ) \{
        animation.opts.start.call( elem, animation );
    \}

    jQuery.fx.timer(
        jQuery.extend( tick, \{
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        \})
    );

    \textcolor{comment}{// attach callbacks from options}
    \textcolor{keywordflow}{return} animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
\}

jQuery.Animation = jQuery.extend( Animation, \{

    tweener: \textcolor{keyword}{function}( props, callback ) \{
        \textcolor{keywordflow}{if} ( jQuery.isFunction( props ) ) \{
            callback = props;
            props = [ \textcolor{stringliteral}{"*"} ];
        \} \textcolor{keywordflow}{else} \{
            props = props.split(\textcolor{stringliteral}{" "});
        \}

        var prop,
            index = 0,
            length = props.length;

        \textcolor{keywordflow}{for} ( ; index < length ; index++ ) \{
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        \}
    \},

    prefilter: \textcolor{keyword}{function}( callback, prepend ) \{
        \textcolor{keywordflow}{if} ( prepend ) \{
            animationPrefilters.unshift( callback );
        \} \textcolor{keywordflow}{else} \{
            animationPrefilters.push( callback );
        \}
    \}
\});

jQuery.speed = \textcolor{keyword}{function}( speed, easing, fn ) \{
    var opt = speed && typeof speed === \textcolor{stringliteral}{"object"} ? jQuery.extend( \{\}, speed ) : \{
        complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    \};

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \textcolor{stringliteral}{"number"} ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds.\_default;

    \textcolor{comment}{// normalize opt.queue - true/undefined/null -> "fx"}
    \textcolor{keywordflow}{if} ( opt.queue == null || opt.queue === \textcolor{keyword}{true} ) \{
        opt.queue = \textcolor{stringliteral}{"fx"};
    \}

    \textcolor{comment}{// Queueing}
    opt.old = opt.complete;

    opt.complete = \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} ( jQuery.isFunction( opt.old ) ) \{
            opt.old.call( \textcolor{keyword}{this} );
        \}

        \textcolor{keywordflow}{if} ( opt.queue ) \{
            jQuery.dequeue( \textcolor{keyword}{this}, opt.queue );
        \}
    \};

    \textcolor{keywordflow}{return} opt;
\};

jQuery.fn.extend(\{
    fadeTo: \textcolor{keyword}{function}( speed, to, easing, callback ) \{

        \textcolor{comment}{// show any hidden elements after setting opacity to 0}
        \textcolor{keywordflow}{return} this.filter( isHidden ).css( \textcolor{stringliteral}{"opacity"}, 0 ).show()

            \textcolor{comment}{// animate to the value specified}
            .end().animate(\{ opacity: to \}, speed, easing, callback );
    \},
    animate: \textcolor{keyword}{function}( prop, speed, easing, callback ) \{
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = \textcolor{keyword}{function}() \{
                \textcolor{comment}{// Operate on a copy of prop so per-property easing won't be lost}
                var anim = Animation( \textcolor{keyword}{this}, jQuery.extend( \{\}, prop ), optall );

                \textcolor{comment}{// Empty animations, or finishing resolves immediately}
                \textcolor{keywordflow}{if} ( empty || data\_priv.get( \textcolor{keyword}{this}, \textcolor{stringliteral}{"finish"} ) ) \{
                    anim.stop( \textcolor{keyword}{true} );
                \}
            \};
            doAnimation.finish = doAnimation;

        \textcolor{keywordflow}{return} empty || optall.queue === \textcolor{keyword}{false} ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    \},
    stop: \textcolor{keyword}{function}( type, clearQueue, gotoEnd ) \{
        var stopQueue = \textcolor{keyword}{function}( hooks ) \{
            var stop = hooks.stop;
            \textcolor{keyword}{delete} hooks.stop;
            stop( gotoEnd );
        \};

        \textcolor{keywordflow}{if} ( typeof type !== \textcolor{stringliteral}{"string"} ) \{
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        \}
        \textcolor{keywordflow}{if} ( clearQueue && type !== \textcolor{keyword}{false} ) \{
            this.queue( type || \textcolor{stringliteral}{"fx"}, [] );
        \}

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            var dequeue = \textcolor{keyword}{true},
                index = type != null && type + \textcolor{stringliteral}{"queueHooks"},
                timers = jQuery.timers,
                data = data\_priv.get( \textcolor{keyword}{this} );

            \textcolor{keywordflow}{if} ( index ) \{
                \textcolor{keywordflow}{if} ( data[ index ] && data[ index ].stop ) \{
                    stopQueue( data[ index ] );
                \}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{keywordflow}{for} ( index in data ) \{
                    \textcolor{keywordflow}{if} ( data[ index ] && data[ index ].stop && rrun.test( index ) ) \{
                        stopQueue( data[ index ] );
                    \}
                \}
            \}

            \textcolor{keywordflow}{for} ( index = timers.length; index--; ) \{
                \textcolor{keywordflow}{if} ( timers[ index ].elem === \textcolor{keyword}{this} && (type == null || timers[ index ].queue === type) ) \{
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = \textcolor{keyword}{false};
                    timers.splice( index, 1 );
                \}
            \}

            \textcolor{comment}{// start the next in the queue if the last step wasn't forced}
            \textcolor{comment}{// timers currently will call their complete callbacks, which will dequeue}
            \textcolor{comment}{// but only if they were gotoEnd}
            \textcolor{keywordflow}{if} ( dequeue || !gotoEnd ) \{
                jQuery.dequeue( \textcolor{keyword}{this}, type );
            \}
        \});
    \},
    finish: \textcolor{keyword}{function}( type ) \{
        \textcolor{keywordflow}{if} ( type !== \textcolor{keyword}{false} ) \{
            type = type || \textcolor{stringliteral}{"fx"};
        \}
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            var index,
                data = data\_priv.get( \textcolor{keyword}{this} ),
                queue = data[ type + \textcolor{stringliteral}{"queue"} ],
                hooks = data[ type + \textcolor{stringliteral}{"queueHooks"} ],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;

            \textcolor{comment}{// enable finishing flag on private data}
            data.finish = \textcolor{keyword}{true};

            \textcolor{comment}{// empty the queue first}
            jQuery.queue( \textcolor{keyword}{this}, type, [] );

            \textcolor{keywordflow}{if} ( hooks && hooks.stop ) \{
                hooks.stop.call( \textcolor{keyword}{this}, \textcolor{keyword}{true} );
            \}

            \textcolor{comment}{// look for any active animations, and finish them}
            \textcolor{keywordflow}{for} ( index = timers.length; index--; ) \{
                \textcolor{keywordflow}{if} ( timers[ index ].elem === \textcolor{keyword}{this} && timers[ index ].queue === type ) \{
                    timers[ index ].anim.stop( \textcolor{keyword}{true} );
                    timers.splice( index, 1 );
                \}
            \}

            \textcolor{comment}{// look for any animations in the old queue and finish them}
            \textcolor{keywordflow}{for} ( index = 0; index < length; index++ ) \{
                \textcolor{keywordflow}{if} ( queue[ index ] && queue[ index ].finish ) \{
                    queue[ index ].finish.call( \textcolor{keyword}{this} );
                \}
            \}

            \textcolor{comment}{// turn off finishing flag}
            \textcolor{keyword}{delete} data.finish;
        \});
    \}
\});

jQuery.each([ \textcolor{stringliteral}{"toggle"}, \textcolor{stringliteral}{"show"}, \textcolor{stringliteral}{"hide"} ], \textcolor{keyword}{function}( i, name ) \{
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = \textcolor{keyword}{function}( speed, easing, callback ) \{
        \textcolor{keywordflow}{return} speed == null || typeof speed === \textcolor{stringliteral}{"boolean"} ?
            cssFn.apply( \textcolor{keyword}{this}, arguments ) :
            this.animate( genFx( name, \textcolor{keyword}{true} ), speed, easing, callback );
    \};
\});

\textcolor{comment}{// Generate shortcuts for custom animations}
jQuery.each(\{
    slideDown: genFx(\textcolor{stringliteral}{"show"}),
    slideUp: genFx(\textcolor{stringliteral}{"hide"}),
    slideToggle: genFx(\textcolor{stringliteral}{"toggle"}),
    fadeIn: \{ opacity: \textcolor{stringliteral}{"show"} \},
    fadeOut: \{ opacity: \textcolor{stringliteral}{"hide"} \},
    fadeToggle: \{ opacity: \textcolor{stringliteral}{"toggle"} \}
\}, \textcolor{keyword}{function}( name, props ) \{
    jQuery.fn[ name ] = \textcolor{keyword}{function}( speed, easing, callback ) \{
        \textcolor{keywordflow}{return} this.animate( props, speed, easing, callback );
    \};
\});

jQuery.timers = [];
jQuery.fx.tick = \textcolor{keyword}{function}() \{
    var timer,
        i = 0,
        timers = jQuery.timers;

    fxNow = jQuery.now();

    \textcolor{keywordflow}{for} ( ; i < timers.length; i++ ) \{
        timer = timers[ i ];
        \textcolor{comment}{// Checks the timer has not already been removed}
        \textcolor{keywordflow}{if} ( !timer() && timers[ i ] === timer ) \{
            timers.splice( i--, 1 );
        \}
    \}

    \textcolor{keywordflow}{if} ( !timers.length ) \{
        jQuery.fx.stop();
    \}
    fxNow = undefined;
\};

jQuery.fx.timer = \textcolor{keyword}{function}( timer ) \{
    jQuery.timers.push( timer );
    \textcolor{keywordflow}{if} ( timer() ) \{
        jQuery.fx.start();
    \} \textcolor{keywordflow}{else} \{
        jQuery.timers.pop();
    \}
\};

jQuery.fx.interval = 13;

jQuery.fx.start = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} ( !timerId ) \{
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    \}
\};

jQuery.fx.stop = \textcolor{keyword}{function}() \{
    clearInterval( timerId );
    timerId = null;
\};

jQuery.fx.speeds = \{
    slow: 600,
    fast: 200,
    \textcolor{comment}{// Default speed}
    \_default: 400
\};


\textcolor{comment}{// Based off of the plugin by Clint Helfers, with permission.}
\textcolor{comment}{// http://blindsignals.com/index.php/2009/07/jquery-delay/}
jQuery.fn.delay = \textcolor{keyword}{function}( time, type ) \{
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || \textcolor{stringliteral}{"fx"};

    \textcolor{keywordflow}{return} this.queue( type, \textcolor{keyword}{function}( next, hooks ) \{
        var timeout = setTimeout( next, time );
        hooks.stop = \textcolor{keyword}{function}() \{
            clearTimeout( timeout );
        \};
    \});
\};


(\textcolor{keyword}{function}() \{
    var input = document.createElement( \textcolor{stringliteral}{"input"} ),
        select = document.createElement( \textcolor{stringliteral}{"select"} ),
        opt = select.appendChild( document.createElement( \textcolor{stringliteral}{"option"} ) );

    input.type = \textcolor{stringliteral}{"checkbox"};

    \textcolor{comment}{// Support: iOS 5.1, Android 4.x, Android 2.3}
    \textcolor{comment}{// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)}
    support.checkOn = input.value !== \textcolor{stringliteral}{""};

    \textcolor{comment}{// Must access the parent to make an option select properly}
    \textcolor{comment}{// Support: IE9, IE10}
    support.optSelected = opt.selected;

    \textcolor{comment}{// Make sure that the options inside disabled selects aren't marked as disabled}
    \textcolor{comment}{// (WebKit marks them as disabled)}
    select.disabled = \textcolor{keyword}{true};
    support.optDisabled = !opt.disabled;

    \textcolor{comment}{// Check if an input maintains its value after becoming a radio}
    \textcolor{comment}{// Support: IE9, IE10}
    input = document.createElement( \textcolor{stringliteral}{"input"} );
    input.value = \textcolor{stringliteral}{"t"};
    input.type = \textcolor{stringliteral}{"radio"};
    support.radioValue = input.value === \textcolor{stringliteral}{"t"};
\})();


var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend(\{
    attr: \textcolor{keyword}{function}( name, value ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, jQuery.attr, name, value, arguments.length > 1 );
    \},

    removeAttr: \textcolor{keyword}{function}( name ) \{
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            jQuery.removeAttr( \textcolor{keyword}{this}, name );
        \});
    \}
\});

jQuery.extend(\{
    attr: \textcolor{keyword}{function}( elem, name, value ) \{
        var hooks, ret,
            nType = elem.nodeType;

        \textcolor{comment}{// don't get/set attributes on text, comment and attribute nodes}
        \textcolor{keywordflow}{if} ( !elem || nType === 3 || nType === 8 || nType === 2 ) \{
            \textcolor{keywordflow}{return};
        \}

        \textcolor{comment}{// Fallback to prop when attributes are not supported}
        \textcolor{keywordflow}{if} ( typeof elem.getAttribute === strundefined ) \{
            \textcolor{keywordflow}{return} jQuery.prop( elem, name, value );
        \}

        \textcolor{comment}{// All attributes are lowercase}
        \textcolor{comment}{// Grab necessary hook if one is defined}
        \textcolor{keywordflow}{if} ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) \{
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] ||
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        \}

        \textcolor{keywordflow}{if} ( value !== undefined ) \{

            \textcolor{keywordflow}{if} ( value === null ) \{
                jQuery.removeAttr( elem, name );

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"set"} in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) \{
                \textcolor{keywordflow}{return} ret;

            \} \textcolor{keywordflow}{else} \{
                elem.setAttribute( name, value + \textcolor{stringliteral}{""} );
                \textcolor{keywordflow}{return} value;
            \}

        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"get"} in hooks && (ret = hooks.get( elem, name )) !== null ) \{
            \textcolor{keywordflow}{return} ret;

        \} \textcolor{keywordflow}{else} \{
            ret = jQuery.find.attr( elem, name );

            \textcolor{comment}{// Non-existent attributes return null, we normalize to undefined}
            \textcolor{keywordflow}{return} ret == null ?
                undefined :
                ret;
        \}
    \},

    removeAttr: \textcolor{keyword}{function}( elem, value ) \{
        var name, propName,
            i = 0,
            attrNames = value && value.match( rnotwhite );

        \textcolor{keywordflow}{if} ( attrNames && elem.nodeType === 1 ) \{
            \textcolor{keywordflow}{while} ( (name = attrNames[i++]) ) \{
                propName = jQuery.propFix[ name ] || name;

                \textcolor{comment}{// Boolean attributes get special treatment (#10870)}
                \textcolor{keywordflow}{if} ( jQuery.expr.match.bool.test( name ) ) \{
                    \textcolor{comment}{// Set corresponding property to false}
                    elem[ propName ] = \textcolor{keyword}{false};
                \}

                elem.removeAttribute( name );
            \}
        \}
    \},

    attrHooks: \{
        type: \{
            set: \textcolor{keyword}{function}( elem, value ) \{
                \textcolor{keywordflow}{if} ( !support.radioValue && value === \textcolor{stringliteral}{"radio"} &&
                    jQuery.nodeName( elem, \textcolor{stringliteral}{"input"} ) ) \{
                    \textcolor{comment}{// Setting the type on a radio button after the value resets the value in IE6-9}
                    \textcolor{comment}{// Reset value to default in case type is set after value during creation}
                    var val = elem.value;
                    elem.setAttribute( \textcolor{stringliteral}{"type"}, value );
                    \textcolor{keywordflow}{if} ( val ) \{
                        elem.value = val;
                    \}
                    \textcolor{keywordflow}{return} value;
                \}
            \}
        \}
    \}
\});

\textcolor{comment}{// Hooks for boolean attributes}
boolHook = \{
    set: \textcolor{keyword}{function}( elem, value, name ) \{
        \textcolor{keywordflow}{if} ( value === \textcolor{keyword}{false} ) \{
            \textcolor{comment}{// Remove boolean attributes when set to false}
            jQuery.removeAttr( elem, name );
        \} \textcolor{keywordflow}{else} \{
            elem.setAttribute( name, name );
        \}
        \textcolor{keywordflow}{return} name;
    \}
\};
jQuery.each( jQuery.expr.match.bool.source.match( /\(\backslash\)w+/g ), \textcolor{keyword}{function}( i, name ) \{
    var getter = attrHandle[ name ] || jQuery.find.attr;

    attrHandle[ name ] = \textcolor{keyword}{function}( elem, name, isXML ) \{
        var ret, handle;
        \textcolor{keywordflow}{if} ( !isXML ) \{
            \textcolor{comment}{// Avoid an infinite loop by temporarily removing this function from the getter}
            handle = attrHandle[ name ];
            attrHandle[ name ] = ret;
            ret = getter( elem, name, isXML ) != null ?
                name.toLowerCase() :
                null;
            attrHandle[ name ] = handle;
        \}
        \textcolor{keywordflow}{return} ret;
    \};
\});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend(\{
    prop: \textcolor{keyword}{function}( name, value ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, jQuery.prop, name, value, arguments.length > 1 );
    \},

    removeProp: \textcolor{keyword}{function}( name ) \{
        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            \textcolor{keyword}{delete} \textcolor{keyword}{this}[ jQuery.propFix[ name ] || name ];
        \});
    \}
\});

jQuery.extend(\{
    propFix: \{
        \textcolor{stringliteral}{"for"}: \textcolor{stringliteral}{"htmlFor"},
        \textcolor{stringliteral}{"class"}: \textcolor{stringliteral}{"className"}
    \},

    prop: \textcolor{keyword}{function}( elem, name, value ) \{
        var ret, hooks, notxml,
            nType = elem.nodeType;

        \textcolor{comment}{// don't get/set properties on text, comment and attribute nodes}
        \textcolor{keywordflow}{if} ( !elem || nType === 3 || nType === 8 || nType === 2 ) \{
            \textcolor{keywordflow}{return};
        \}

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        \textcolor{keywordflow}{if} ( notxml ) \{
            \textcolor{comment}{// Fix name and attach hooks}
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
        \}

        \textcolor{keywordflow}{if} ( value !== undefined ) \{
            \textcolor{keywordflow}{return} hooks && \textcolor{stringliteral}{"set"} in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                ret :
                ( elem[ name ] = value );

        \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{return} hooks && \textcolor{stringliteral}{"get"} in hooks && (ret = hooks.get( elem, name )) !== null ?
                ret :
                elem[ name ];
        \}
    \},

    propHooks: \{
        tabIndex: \{
            \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem ) \{
                \textcolor{keywordflow}{return} elem.hasAttribute( \textcolor{stringliteral}{"tabindex"} ) || rfocusable.test( elem.nodeName ) || elem.href ?
                    elem.tabIndex :
                    -1;
            \}
        \}
    \}
\});

\textcolor{comment}{// Support: IE9+}
\textcolor{comment}{// Selectedness for an option in an optgroup can be inaccurate}
\textcolor{keywordflow}{if} ( !support.optSelected ) \{
    jQuery.propHooks.selected = \{
        \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem ) \{
            var parent = elem.parentNode;
            \textcolor{keywordflow}{if} ( parent && parent.parentNode ) \{
                parent.parentNode.selectedIndex;
            \}
            \textcolor{keywordflow}{return} null;
        \}
    \};
\}

jQuery.each([
    \textcolor{stringliteral}{"tabIndex"},
    \textcolor{stringliteral}{"readOnly"},
    \textcolor{stringliteral}{"maxLength"},
    \textcolor{stringliteral}{"cellSpacing"},
    \textcolor{stringliteral}{"cellPadding"},
    \textcolor{stringliteral}{"rowSpan"},
    \textcolor{stringliteral}{"colSpan"},
    \textcolor{stringliteral}{"useMap"},
    \textcolor{stringliteral}{"frameBorder"},
    \textcolor{stringliteral}{"contentEditable"}
], \textcolor{keyword}{function}() \{
    jQuery.propFix[ this.toLowerCase() ] = \textcolor{keyword}{this};
\});




var rclass = /[\(\backslash\)t\(\backslash\)r\(\backslash\)n\(\backslash\)f]/g;

jQuery.fn.extend(\{
    addClass: \textcolor{keyword}{function}( value ) \{
        var classes, elem, cur, clazz, j, finalValue,
            proceed = typeof value === \textcolor{stringliteral}{"string"} && value,
            i = 0,
            len = this.length;

        \textcolor{keywordflow}{if} ( jQuery.isFunction( value ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( j ) \{
                jQuery( \textcolor{keyword}{this} ).addClass( value.call( \textcolor{keyword}{this}, j, \textcolor{keyword}{this}.className ) );
            \});
        \}

        \textcolor{keywordflow}{if} ( proceed ) \{
            \textcolor{comment}{// The disjunction here is for better compressibility (see removeClass)}
            classes = ( value || \textcolor{stringliteral}{""} ).match( rnotwhite ) || [];

            \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
                elem = \textcolor{keyword}{this}[ i ];
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( \textcolor{stringliteral}{" "} + elem.className + \textcolor{stringliteral}{" "} ).replace( rclass, \textcolor{stringliteral}{" "} ) :
                    \textcolor{stringliteral}{" "}
                );

                \textcolor{keywordflow}{if} ( cur ) \{
                    j = 0;
                    \textcolor{keywordflow}{while} ( (clazz = classes[j++]) ) \{
                        \textcolor{keywordflow}{if} ( cur.indexOf( \textcolor{stringliteral}{" "} + clazz + \textcolor{stringliteral}{" "} ) < 0 ) \{
                            cur += clazz + \textcolor{stringliteral}{" "};
                        \}
                    \}

                    \textcolor{comment}{// only assign if different to avoid unneeded rendering.}
                    finalValue = jQuery.trim( cur );
                    \textcolor{keywordflow}{if} ( elem.className !== finalValue ) \{
                        elem.className = finalValue;
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \},

    removeClass: \textcolor{keyword}{function}( value ) \{
        var classes, elem, cur, clazz, j, finalValue,
            proceed = arguments.length === 0 || typeof value === \textcolor{stringliteral}{"string"} && value,
            i = 0,
            len = this.length;

        \textcolor{keywordflow}{if} ( jQuery.isFunction( value ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( j ) \{
                jQuery( \textcolor{keyword}{this} ).removeClass( value.call( \textcolor{keyword}{this}, j, \textcolor{keyword}{this}.className ) );
            \});
        \}
        \textcolor{keywordflow}{if} ( proceed ) \{
            classes = ( value || \textcolor{stringliteral}{""} ).match( rnotwhite ) || [];

            \textcolor{keywordflow}{for} ( ; i < len; i++ ) \{
                elem = \textcolor{keyword}{this}[ i ];
                \textcolor{comment}{// This expression is here for better compressibility (see addClass)}
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( \textcolor{stringliteral}{" "} + elem.className + \textcolor{stringliteral}{" "} ).replace( rclass, \textcolor{stringliteral}{" "} ) :
                    \textcolor{stringliteral}{""}
                );

                \textcolor{keywordflow}{if} ( cur ) \{
                    j = 0;
                    \textcolor{keywordflow}{while} ( (clazz = classes[j++]) ) \{
                        \textcolor{comment}{// Remove *all* instances}
                        \textcolor{keywordflow}{while} ( cur.indexOf( \textcolor{stringliteral}{" "} + clazz + \textcolor{stringliteral}{" "} ) >= 0 ) \{
                            cur = cur.replace( \textcolor{stringliteral}{" "} + clazz + \textcolor{stringliteral}{" "}, \textcolor{stringliteral}{" "} );
                        \}
                    \}

                    \textcolor{comment}{// only assign if different to avoid unneeded rendering.}
                    finalValue = value ? jQuery.trim( cur ) : \textcolor{stringliteral}{""};
                    \textcolor{keywordflow}{if} ( elem.className !== finalValue ) \{
                        elem.className = finalValue;
                    \}
                \}
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \},

    toggleClass: \textcolor{keyword}{function}( value, stateVal ) \{
        var type = typeof value;

        \textcolor{keywordflow}{if} ( typeof stateVal === \textcolor{stringliteral}{"boolean"} && type === \textcolor{stringliteral}{"string"} ) \{
            \textcolor{keywordflow}{return} stateVal ? this.addClass( value ) : this.removeClass( value );
        \}

        \textcolor{keywordflow}{if} ( jQuery.isFunction( value ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( i ) \{
                jQuery( \textcolor{keyword}{this} ).toggleClass( value.call(\textcolor{keyword}{this}, i, \textcolor{keyword}{this}.className, stateVal), stateVal );
            \});
        \}

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( type === \textcolor{stringliteral}{"string"} ) \{
                \textcolor{comment}{// toggle individual class names}
                var className,
                    i = 0,
                    \textcolor{keyword}{self} = jQuery( \textcolor{keyword}{this} ),
                    classNames = value.match( rnotwhite ) || [];

                \textcolor{keywordflow}{while} ( (className = classNames[ i++ ]) ) \{
                    \textcolor{comment}{// check each className given, space separated list}
                    \textcolor{keywordflow}{if} ( \textcolor{keyword}{self}.hasClass( className ) ) \{
                        \textcolor{keyword}{self}.removeClass( className );
                    \} \textcolor{keywordflow}{else} \{
                        \textcolor{keyword}{self}.addClass( className );
                    \}
                \}

            \textcolor{comment}{// Toggle whole class name}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( type === strundefined || type === \textcolor{stringliteral}{"boolean"} ) \{
                \textcolor{keywordflow}{if} ( this.className ) \{
                    \textcolor{comment}{// store className if set}
                    data\_priv.set( \textcolor{keyword}{this}, \textcolor{stringliteral}{"\_\_className\_\_"}, this.className );
                \}

                \textcolor{comment}{// If the element has a class name or if we're passed "false",}
                \textcolor{comment}{// then remove the whole classname (if there was one, the above saved it).}
                \textcolor{comment}{// Otherwise bring back whatever was previously saved (if anything),}
                \textcolor{comment}{// falling back to the empty string if nothing was stored.}
                this.className = this.className || value === \textcolor{keyword}{false} ? \textcolor{stringliteral}{""} : data\_priv.get( \textcolor{keyword}{this}, \textcolor{stringliteral}{"
      \_\_className\_\_"} ) || \textcolor{stringliteral}{""};
            \}
        \});
    \},

    hasClass: \textcolor{keyword}{function}( selector ) \{
        var className = \textcolor{stringliteral}{" "} + selector + \textcolor{stringliteral}{" "},
            i = 0,
            l = this.length;
        \textcolor{keywordflow}{for} ( ; i < l; i++ ) \{
            \textcolor{keywordflow}{if} ( \textcolor{keyword}{this}[i].nodeType === 1 && (\textcolor{stringliteral}{" "} + \textcolor{keyword}{this}[i].className + \textcolor{stringliteral}{" "}).replace(rclass, \textcolor{stringliteral}{" "}).indexOf( 
      className ) >= 0 ) \{
                \textcolor{keywordflow}{return} \textcolor{keyword}{true};
            \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
\});




var rreturn = /\(\backslash\)r/g;

jQuery.fn.extend(\{
    val: \textcolor{keyword}{function}( value ) \{
        var hooks, ret, isFunction,
            elem = \textcolor{keyword}{this}[0];

        \textcolor{keywordflow}{if} ( !arguments.length ) \{
            \textcolor{keywordflow}{if} ( elem ) \{
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                \textcolor{keywordflow}{if} ( hooks && \textcolor{stringliteral}{"get"} in hooks && (ret = hooks.get( elem, \textcolor{stringliteral}{"value"} )) !== undefined ) \{
                    \textcolor{keywordflow}{return} ret;
                \}

                ret = elem.value;

                \textcolor{keywordflow}{return} typeof ret === \textcolor{stringliteral}{"string"} ?
                    \textcolor{comment}{// handle most common string cases}
                    ret.replace(rreturn, \textcolor{stringliteral}{""}) :
                    \textcolor{comment}{// handle cases where value is null/undef or number}
                    ret == null ? \textcolor{stringliteral}{""} : ret;
            \}

            \textcolor{keywordflow}{return};
        \}

        isFunction = jQuery.isFunction( value );

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( i ) \{
            var val;

            \textcolor{keywordflow}{if} ( this.nodeType !== 1 ) \{
                \textcolor{keywordflow}{return};
            \}

            \textcolor{keywordflow}{if} ( isFunction ) \{
                val = value.call( \textcolor{keyword}{this}, i, jQuery( \textcolor{keyword}{this} ).val() );
            \} \textcolor{keywordflow}{else} \{
                val = value;
            \}

            \textcolor{comment}{// Treat null/undefined as ""; convert numbers to string}
            \textcolor{keywordflow}{if} ( val == null ) \{
                val = \textcolor{stringliteral}{""};

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( typeof val === \textcolor{stringliteral}{"number"} ) \{
                val += \textcolor{stringliteral}{""};

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( jQuery.isArray( val ) ) \{
                val = jQuery.map( val, \textcolor{keyword}{function}( value ) \{
                    \textcolor{keywordflow}{return} value == null ? \textcolor{stringliteral}{""} : value + \textcolor{stringliteral}{""};
                \});
            \}

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            \textcolor{comment}{// If set returns undefined, fall back to normal setting}
            \textcolor{keywordflow}{if} ( !hooks || !(\textcolor{stringliteral}{"set"} in hooks) || hooks.set( \textcolor{keyword}{this}, val, \textcolor{stringliteral}{"value"} ) === undefined ) \{
                this.value = val;
            \}
        \});
    \}
\});

jQuery.extend(\{
    valHooks: \{
        option: \{
            \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem ) \{
                var val = jQuery.find.attr( elem, \textcolor{stringliteral}{"value"} );
                \textcolor{keywordflow}{return} val != null ?
                    val :
                    \textcolor{comment}{// Support: IE10-11+}
                    \textcolor{comment}{// option.text throws exceptions (#14686, #14858)}
                    jQuery.trim( jQuery.text( elem ) );
            \}
        \},
        select: \{
            \textcolor{keyword}{get}: \textcolor{keyword}{function}( elem ) \{
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === \textcolor{stringliteral}{"select-one"} || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                \textcolor{comment}{// Loop through all the selected options}
                \textcolor{keywordflow}{for} ( ; i < max; i++ ) \{
                    option = options[ i ];

                    \textcolor{comment}{// IE6-9 doesn't update selected after form reset (#2551)}
                    \textcolor{keywordflow}{if} ( ( option.selected || i === index ) &&
                            \textcolor{comment}{// Don't return options that are disabled or in a disabled optgroup}
                            ( support.optDisabled ? !option.disabled : option.getAttribute( \textcolor{stringliteral}{"disabled"} ) ==
      = null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \textcolor{stringliteral}{"optgroup
      "} ) ) ) \{

                        \textcolor{comment}{// Get the specific value for the option}
                        value = jQuery( option ).val();

                        \textcolor{comment}{// We don't need an array for one selects}
                        \textcolor{keywordflow}{if} ( one ) \{
                            \textcolor{keywordflow}{return} value;
                        \}

                        \textcolor{comment}{// Multi-Selects return an array}
                        values.push( value );
                    \}
                \}

                \textcolor{keywordflow}{return} values;
            \},

            set: \textcolor{keyword}{function}( elem, value ) \{
                var optionSet, option,
                    options = elem.options,
                    values = jQuery.makeArray( value ),
                    i = options.length;

                \textcolor{keywordflow}{while} ( i-- ) \{
                    option = options[ i ];
                    \textcolor{keywordflow}{if} ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) \{
                        optionSet = \textcolor{keyword}{true};
                    \}
                \}

                \textcolor{comment}{// force browsers to behave consistently when non-matching value is set}
                \textcolor{keywordflow}{if} ( !optionSet ) \{
                    elem.selectedIndex = -1;
                \}
                \textcolor{keywordflow}{return} values;
            \}
        \}
    \}
\});

\textcolor{comment}{// Radios and checkboxes getter/setter}
jQuery.each([ \textcolor{stringliteral}{"radio"}, \textcolor{stringliteral}{"checkbox"} ], \textcolor{keyword}{function}() \{
    jQuery.valHooks[ this ] = \{
        set: \textcolor{keyword}{function}( elem, value ) \{
            \textcolor{keywordflow}{if} ( jQuery.isArray( value ) ) \{
                \textcolor{keywordflow}{return} ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
            \}
        \}
    \};
    \textcolor{keywordflow}{if} ( !support.checkOn ) \{
        jQuery.valHooks[ this ].get = \textcolor{keyword}{function}( elem ) \{
            \textcolor{comment}{// Support: Webkit}
            \textcolor{comment}{// "" is returned instead of "on" if a value isn't specified}
            \textcolor{keywordflow}{return} elem.getAttribute(\textcolor{stringliteral}{"value"}) === null ? \textcolor{stringliteral}{"on"} : elem.value;
        \};
    \}
\});




\textcolor{comment}{// Return jQuery for attributes-only inclusion}


jQuery.each( (\textcolor{stringliteral}{"blur focus focusin focusout load resize scroll unload click dblclick "} +
    \textcolor{stringliteral}{"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "} +
    \textcolor{stringliteral}{"change select submit keydown keypress keyup error contextmenu"}).split(\textcolor{stringliteral}{" "}), \textcolor{keyword}{function}( i, name ) \{

    \textcolor{comment}{// Handle event binding}
    jQuery.fn[ name ] = \textcolor{keyword}{function}( data, fn ) \{
        \textcolor{keywordflow}{return} arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    \};
\});

jQuery.fn.extend(\{
    hover: \textcolor{keyword}{function}( fnOver, fnOut ) \{
        \textcolor{keywordflow}{return} this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    \},

    bind: \textcolor{keyword}{function}( types, data, fn ) \{
        \textcolor{keywordflow}{return} this.on( types, null, data, fn );
    \},
    unbind: \textcolor{keyword}{function}( types, fn ) \{
        \textcolor{keywordflow}{return} this.off( types, null, fn );
    \},

    delegate: \textcolor{keyword}{function}( selector, types, data, fn ) \{
        \textcolor{keywordflow}{return} this.on( types, selector, data, fn );
    \},
    undelegate: \textcolor{keyword}{function}( selector, types, fn ) \{
        \textcolor{comment}{// ( namespace ) or ( selector, types [, fn] )}
        \textcolor{keywordflow}{return} arguments.length === 1 ? this.off( selector, \textcolor{stringliteral}{"**"} ) : this.off( types, selector || \textcolor{stringliteral}{"**"}, fn 
      );
    \}
\});


var nonce = jQuery.now();

var rquery = (/\(\backslash\)?/);



\textcolor{comment}{// Support: Android 2.3}
\textcolor{comment}{// Workaround failure to string-cast null input}
jQuery.parseJSON = \textcolor{keyword}{function}( data ) \{
    \textcolor{keywordflow}{return} JSON.parse( data + \textcolor{stringliteral}{""} );
\};


\textcolor{comment}{// Cross-browser xml parsing}
jQuery.parseXML = \textcolor{keyword}{function}( data ) \{
    var xml, tmp;
    \textcolor{keywordflow}{if} ( !data || typeof data !== \textcolor{stringliteral}{"string"} ) \{
        \textcolor{keywordflow}{return} null;
    \}

    \textcolor{comment}{// Support: IE9}
    \textcolor{keywordflow}{try} \{
        tmp = \textcolor{keyword}{new} DOMParser();
        xml = tmp.parseFromString( data, \textcolor{stringliteral}{"text/xml"} );
    \} \textcolor{keywordflow}{catch} ( e ) \{
        xml = undefined;
    \}

    \textcolor{keywordflow}{if} ( !xml || xml.getElementsByTagName( \textcolor{stringliteral}{"parsererror"} ).length ) \{
        jQuery.error( \textcolor{stringliteral}{"Invalid XML: "} + data );
    \}
    \textcolor{keywordflow}{return} xml;
\};


var
    \textcolor{comment}{// Document location}
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rts = /([?&])\_=[^&]*/,
    rheaders = /^(.*?):[ \(\backslash\)t]*([^\(\backslash\)r\(\backslash\)n]*)$/mg,
    \textcolor{comment}{// #7653, #8125, #8152: local protocol detection}
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\(\backslash\)/\(\backslash\)\textcolor{comment}{//,}
    rurl = /^([\(\backslash\)w.+-]+:)(?:\(\backslash\)/\(\backslash\)/(?:[^\(\backslash\)/?#]*@|)([^\(\backslash\)/?#:]*)(?::(\(\backslash\)d+)|)|)/,

    \textcolor{comment}{/* Prefilters}
\textcolor{comment}{     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)}
\textcolor{comment}{     * 2) These are called:}
\textcolor{comment}{     *    - BEFORE asking for a transport}
\textcolor{comment}{     *    - AFTER param serialization (s.data is a string if s.processData is true)}
\textcolor{comment}{     * 3) key is the dataType}
\textcolor{comment}{     * 4) the catchall symbol "*" can be used}
\textcolor{comment}{     * 5) execution will start with transport dataType and THEN continue down to "*" if needed}
\textcolor{comment}{     */}
    prefilters = \{\},

    \textcolor{comment}{/* Transports bindings}
\textcolor{comment}{     * 1) key is the dataType}
\textcolor{comment}{     * 2) the catchall symbol "*" can be used}
\textcolor{comment}{     * 3) selection will start with transport dataType and THEN go to "*" if needed}
\textcolor{comment}{     */}
    transports = \{\},

    \textcolor{comment}{// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression}
    allTypes = \textcolor{stringliteral}{"*/"}.concat(\textcolor{stringliteral}{"*"});

\textcolor{comment}{// #8138, IE may throw an exception when accessing}
\textcolor{comment}{// a field from window.location if document.domain has been set}
\textcolor{keywordflow}{try} \{
    ajaxLocation = location.href;
\} \textcolor{keywordflow}{catch}( e ) \{
    \textcolor{comment}{// Use the href attribute of an A element}
    \textcolor{comment}{// since IE will modify it given document.location}
    ajaxLocation = document.createElement( \textcolor{stringliteral}{"a"} );
    ajaxLocation.href = \textcolor{stringliteral}{""};
    ajaxLocation = ajaxLocation.href;
\}

\textcolor{comment}{// Segment location into parts}
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

\textcolor{comment}{// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport}
\textcolor{keyword}{function} addToPrefiltersOrTransports( structure ) \{

    \textcolor{comment}{// dataTypeExpression is optional and defaults to "*"}
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}( dataTypeExpression, func ) \{

        \textcolor{keywordflow}{if} ( typeof dataTypeExpression !== \textcolor{stringliteral}{"string"} ) \{
            func = dataTypeExpression;
            dataTypeExpression = \textcolor{stringliteral}{"*"};
        \}

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

        \textcolor{keywordflow}{if} ( jQuery.isFunction( func ) ) \{
            \textcolor{comment}{// For each dataType in the dataTypeExpression}
            \textcolor{keywordflow}{while} ( (dataType = dataTypes[i++]) ) \{
                \textcolor{comment}{// Prepend if requested}
                \textcolor{keywordflow}{if} ( dataType[0] === \textcolor{stringliteral}{"+"} ) \{
                    dataType = dataType.slice( 1 ) || \textcolor{stringliteral}{"*"};
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                \textcolor{comment}{// Otherwise append}
                \} \textcolor{keywordflow}{else} \{
                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                \}
            \}
        \}
    \};
\}

\textcolor{comment}{// Base inspection function for prefilters and transports}
\textcolor{keyword}{function} inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) \{

    var inspected = \{\},
        seekingTransport = ( structure === transports );

    \textcolor{keyword}{function} inspect( dataType ) \{
        var selected;
        inspected[ dataType ] = \textcolor{keyword}{true};
        jQuery.each( structure[ dataType ] || [], \textcolor{keyword}{function}( \_, prefilterOrFactory ) \{
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            \textcolor{keywordflow}{if} ( typeof dataTypeOrTransport === \textcolor{stringliteral}{"string"} && !seekingTransport && !inspected[ 
      dataTypeOrTransport ] ) \{
                options.dataTypes.unshift( dataTypeOrTransport );
                inspect( dataTypeOrTransport );
                \textcolor{keywordflow}{return} \textcolor{keyword}{false};
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( seekingTransport ) \{
                \textcolor{keywordflow}{return} !( selected = dataTypeOrTransport );
            \}
        \});
        \textcolor{keywordflow}{return} selected;
    \}

    \textcolor{keywordflow}{return} inspect( options.dataTypes[ 0 ] ) || !inspected[ \textcolor{stringliteral}{"*"} ] && inspect( \textcolor{stringliteral}{"*"} );
\}

\textcolor{comment}{// A special extend for ajax options}
\textcolor{comment}{// that takes "flat" options (not to be deep extended)}
\textcolor{comment}{// Fixes #9887}
\textcolor{keyword}{function} ajaxExtend( target, src ) \{
    var key, deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || \{\};

    \textcolor{keywordflow}{for} ( key in src ) \{
        \textcolor{keywordflow}{if} ( src[ key ] !== undefined ) \{
            ( flatOptions[ key ] ? target : ( deep || (deep = \{\}) ) )[ key ] = src[ key ];
        \}
    \}
    \textcolor{keywordflow}{if} ( deep ) \{
        jQuery.extend( \textcolor{keyword}{true}, target, deep );
    \}

    \textcolor{keywordflow}{return} target;
\}

\textcolor{comment}{/* Handles responses to an ajax request:}
\textcolor{comment}{ * - finds the right dataType (mediates between content-type and expected dataType)}
\textcolor{comment}{ * - returns the corresponding response}
\textcolor{comment}{ */}
\textcolor{keyword}{function} ajaxHandleResponses( s, jqXHR, responses ) \{

    var ct, type, finalDataType, firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;

    \textcolor{comment}{// Remove auto dataType and get content-type in the process}
    \textcolor{keywordflow}{while} ( dataTypes[ 0 ] === \textcolor{stringliteral}{"*"} ) \{
        dataTypes.shift();
        \textcolor{keywordflow}{if} ( ct === undefined ) \{
            ct = s.mimeType || jqXHR.getResponseHeader(\textcolor{stringliteral}{"Content-Type"});
        \}
    \}

    \textcolor{comment}{// Check if we're dealing with a known content-type}
    \textcolor{keywordflow}{if} ( ct ) \{
        \textcolor{keywordflow}{for} ( type in contents ) \{
            \textcolor{keywordflow}{if} ( contents[ type ] && contents[ type ].test( ct ) ) \{
                dataTypes.unshift( type );
                \textcolor{keywordflow}{break};
            \}
        \}
    \}

    \textcolor{comment}{// Check to see if we have a response for the expected dataType}
    \textcolor{keywordflow}{if} ( dataTypes[ 0 ] in responses ) \{
        finalDataType = dataTypes[ 0 ];
    \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Try convertible dataTypes}
        \textcolor{keywordflow}{for} ( type in responses ) \{
            \textcolor{keywordflow}{if} ( !dataTypes[ 0 ] || s.converters[ type + \textcolor{stringliteral}{" "} + dataTypes[0] ] ) \{
                finalDataType = type;
                \textcolor{keywordflow}{break};
            \}
            \textcolor{keywordflow}{if} ( !firstDataType ) \{
                firstDataType = type;
            \}
        \}
        \textcolor{comment}{// Or just use first one}
        finalDataType = finalDataType || firstDataType;
    \}

    \textcolor{comment}{// If we found a dataType}
    \textcolor{comment}{// We add the dataType to the list if needed}
    \textcolor{comment}{// and return the corresponding response}
    \textcolor{keywordflow}{if} ( finalDataType ) \{
        \textcolor{keywordflow}{if} ( finalDataType !== dataTypes[ 0 ] ) \{
            dataTypes.unshift( finalDataType );
        \}
        \textcolor{keywordflow}{return} responses[ finalDataType ];
    \}
\}

\textcolor{comment}{/* Chain conversions given the request and the original response}
\textcolor{comment}{ * Also sets the responseXXX fields on the jqXHR instance}
\textcolor{comment}{ */}
\textcolor{keyword}{function} ajaxConvert( s, response, jqXHR, isSuccess ) \{
    var conv2, current, conv, tmp, prev,
        converters = \{\},
        \textcolor{comment}{// Work with a copy of dataTypes in case we need to modify it for conversion}
        dataTypes = s.dataTypes.slice();

    \textcolor{comment}{// Create converters map with lowercased keys}
    \textcolor{keywordflow}{if} ( dataTypes[ 1 ] ) \{
        \textcolor{keywordflow}{for} ( conv in s.converters ) \{
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        \}
    \}

    current = dataTypes.shift();

    \textcolor{comment}{// Convert to each sequential dataType}
    \textcolor{keywordflow}{while} ( current ) \{

        \textcolor{keywordflow}{if} ( s.responseFields[ current ] ) \{
            jqXHR[ s.responseFields[ current ] ] = response;
        \}

        \textcolor{comment}{// Apply the dataFilter if provided}
        \textcolor{keywordflow}{if} ( !prev && isSuccess && s.dataFilter ) \{
            response = s.dataFilter( response, s.dataType );
        \}

        prev = current;
        current = dataTypes.shift();

        \textcolor{keywordflow}{if} ( current ) \{

        \textcolor{comment}{// There's only work to do if current dataType is non-auto}
            \textcolor{keywordflow}{if} ( current === \textcolor{stringliteral}{"*"} ) \{

                current = prev;

            \textcolor{comment}{// Convert response if prev dataType is non-auto and differs from current}
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( prev !== \textcolor{stringliteral}{"*"} && prev !== current ) \{

                \textcolor{comment}{// Seek a direct converter}
                conv = converters[ prev + \textcolor{stringliteral}{" "} + current ] || converters[ \textcolor{stringliteral}{"* "} + current ];

                \textcolor{comment}{// If none found, seek a pair}
                \textcolor{keywordflow}{if} ( !conv ) \{
                    \textcolor{keywordflow}{for} ( conv2 in converters ) \{

                        \textcolor{comment}{// If conv2 outputs current}
                        tmp = conv2.split( \textcolor{stringliteral}{" "} );
                        \textcolor{keywordflow}{if} ( tmp[ 1 ] === current ) \{

                            \textcolor{comment}{// If prev can be converted to accepted input}
                            conv = converters[ prev + \textcolor{stringliteral}{" "} + tmp[ 0 ] ] ||
                                converters[ \textcolor{stringliteral}{"* "} + tmp[ 0 ] ];
                            \textcolor{keywordflow}{if} ( conv ) \{
                                \textcolor{comment}{// Condense equivalence converters}
                                \textcolor{keywordflow}{if} ( conv === \textcolor{keyword}{true} ) \{
                                    conv = converters[ conv2 ];

                                \textcolor{comment}{// Otherwise, insert the intermediate dataType}
                                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( converters[ conv2 ] !== \textcolor{keyword}{true} ) \{
                                    current = tmp[ 0 ];
                                    dataTypes.unshift( tmp[ 1 ] );
                                \}
                                \textcolor{keywordflow}{break};
                            \}
                        \}
                    \}
                \}

                \textcolor{comment}{// Apply converter (if not an equivalence)}
                \textcolor{keywordflow}{if} ( conv !== \textcolor{keyword}{true} ) \{

                    \textcolor{comment}{// Unless errors are allowed to bubble, catch and return them}
                    \textcolor{keywordflow}{if} ( conv && s[ \textcolor{stringliteral}{"throws"} ] ) \{
                        response = conv( response );
                    \} \textcolor{keywordflow}{else} \{
                        \textcolor{keywordflow}{try} \{
                            response = conv( response );
                        \} \textcolor{keywordflow}{catch} ( e ) \{
                            \textcolor{keywordflow}{return} \{ state: \textcolor{stringliteral}{"parsererror"}, error: conv ? e : \textcolor{stringliteral}{"No conversion from "} + prev +
       \textcolor{stringliteral}{" to "} + current \};
                        \}
                    \}
                \}
            \}
        \}
    \}

    \textcolor{keywordflow}{return} \{ state: \textcolor{stringliteral}{"success"}, data: response \};
\}

jQuery.extend(\{

    \textcolor{comment}{// Counter for holding the number of active queries}
    active: 0,

    \textcolor{comment}{// Last-Modified header cache for next request}
    lastModified: \{\},
    etag: \{\},

    ajaxSettings: \{
        url: ajaxLocation,
        type: \textcolor{stringliteral}{"GET"},
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: \textcolor{keyword}{true},
        processData: \textcolor{keyword}{true},
        async: \textcolor{keyword}{true},
        contentType: \textcolor{stringliteral}{"application/x-www-form-urlencoded; charset=UTF-8"},
        \textcolor{comment}{/*}
\textcolor{comment}{        timeout: 0,}
\textcolor{comment}{        data: null,}
\textcolor{comment}{        dataType: null,}
\textcolor{comment}{        username: null,}
\textcolor{comment}{        password: null,}
\textcolor{comment}{        cache: null,}
\textcolor{comment}{        throws: false,}
\textcolor{comment}{        traditional: false,}
\textcolor{comment}{        headers: \{\},}
\textcolor{comment}{        */}

        accepts: \{
            \textcolor{stringliteral}{"*"}: allTypes,
            text: \textcolor{stringliteral}{"text/plain"},
            html: \textcolor{stringliteral}{"text/html"},
            xml: \textcolor{stringliteral}{"application/xml, text/xml"},
            json: \textcolor{stringliteral}{"application/json, text/javascript"}
        \},

        contents: \{
            xml: /xml/,
            html: /html/,
            json: /json/
        \},

        responseFields: \{
            xml: \textcolor{stringliteral}{"responseXML"},
            text: \textcolor{stringliteral}{"responseText"},
            json: \textcolor{stringliteral}{"responseJSON"}
        \},

        \textcolor{comment}{// Data converters}
        \textcolor{comment}{// Keys separate source (or catchall "*") and destination types with a single space}
        converters: \{

            \textcolor{comment}{// Convert anything to text}
            \textcolor{stringliteral}{"* text"}: String,

            \textcolor{comment}{// Text to html (true = no transformation)}
            \textcolor{stringliteral}{"text html"}: \textcolor{keyword}{true},

            \textcolor{comment}{// Evaluate text as a json expression}
            \textcolor{stringliteral}{"text json"}: jQuery.parseJSON,

            \textcolor{comment}{// Parse text as xml}
            \textcolor{stringliteral}{"text xml"}: jQuery.parseXML
        \},

        \textcolor{comment}{// For options that shouldn't be deep extended:}
        \textcolor{comment}{// you can add your own custom options here if}
        \textcolor{comment}{// and when you create one that shouldn't be}
        \textcolor{comment}{// deep extended (see ajaxExtend)}
        flatOptions: \{
            url: \textcolor{keyword}{true},
            context: \textcolor{keyword}{true}
        \}
    \},

    \textcolor{comment}{// Creates a full fledged settings object into target}
    \textcolor{comment}{// with both ajaxSettings and settings fields.}
    \textcolor{comment}{// If target is omitted, writes into ajaxSettings.}
    ajaxSetup: \textcolor{keyword}{function}( target, settings ) \{
        \textcolor{keywordflow}{return} settings ?

            \textcolor{comment}{// Building a settings object}
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            \textcolor{comment}{// Extending ajaxSettings}
            ajaxExtend( jQuery.ajaxSettings, target );
    \},

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    \textcolor{comment}{// Main method}
    ajax: \textcolor{keyword}{function}( url, options ) \{

        \textcolor{comment}{// If url is an object, simulate pre-1.5 signature}
        \textcolor{keywordflow}{if} ( typeof url === \textcolor{stringliteral}{"object"} ) \{
            options = url;
            url = undefined;
        \}

        \textcolor{comment}{// Force options to be an object}
        options = options || \{\};

        var transport,
            \textcolor{comment}{// URL without anti-cache param}
            cacheURL,
            \textcolor{comment}{// Response headers}
            responseHeadersString,
            responseHeaders,
            \textcolor{comment}{// timeout handle}
            timeoutTimer,
            \textcolor{comment}{// Cross-domain detection vars}
            parts,
            \textcolor{comment}{// To know if global events are to be dispatched}
            fireGlobals,
            \textcolor{comment}{// Loop variable}
            i,
            \textcolor{comment}{// Create the final options object}
            s = jQuery.ajaxSetup( \{\}, options ),
            \textcolor{comment}{// Callbacks context}
            callbackContext = s.context || s,
            \textcolor{comment}{// Context for global events is callbackContext if it is a DOM node or jQuery collection}
            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,
            \textcolor{comment}{// Deferreds}
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks(\textcolor{stringliteral}{"once memory"}),
            \textcolor{comment}{// Status-dependent callbacks}
            statusCode = s.statusCode || \{\},
            \textcolor{comment}{// Headers (they are sent all at once)}
            requestHeaders = \{\},
            requestHeadersNames = \{\},
            \textcolor{comment}{// The jqXHR state}
            state = 0,
            \textcolor{comment}{// Default abort message}
            strAbort = \textcolor{stringliteral}{"canceled"},
            \textcolor{comment}{// Fake xhr}
            jqXHR = \{
                readyState: 0,

                \textcolor{comment}{// Builds headers hashtable if needed}
                getResponseHeader: \textcolor{keyword}{function}( key ) \{
                    var match;
                    \textcolor{keywordflow}{if} ( state === 2 ) \{
                        \textcolor{keywordflow}{if} ( !responseHeaders ) \{
                            responseHeaders = \{\};
                            \textcolor{keywordflow}{while} ( (match = rheaders.exec( responseHeadersString )) ) \{
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            \}
                        \}
                        match = responseHeaders[ key.toLowerCase() ];
                    \}
                    \textcolor{keywordflow}{return} match == null ? null : match;
                \},

                \textcolor{comment}{// Raw string}
                getAllResponseHeaders: \textcolor{keyword}{function}() \{
                    \textcolor{keywordflow}{return} state === 2 ? responseHeadersString : null;
                \},

                \textcolor{comment}{// Caches the header}
                setRequestHeader: \textcolor{keyword}{function}( name, value ) \{
                    var lname = name.toLowerCase();
                    \textcolor{keywordflow}{if} ( !state ) \{
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    \}
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \},

                \textcolor{comment}{// Overrides response content-type header}
                overrideMimeType: \textcolor{keyword}{function}( type ) \{
                    \textcolor{keywordflow}{if} ( !state ) \{
                        s.mimeType = type;
                    \}
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \},

                \textcolor{comment}{// Status-dependent callbacks}
                statusCode: \textcolor{keyword}{function}( map ) \{
                    var code;
                    \textcolor{keywordflow}{if} ( map ) \{
                        \textcolor{keywordflow}{if} ( state < 2 ) \{
                            \textcolor{keywordflow}{for} ( code in map ) \{
                                \textcolor{comment}{// Lazy-add the new callback in a way that preserves old ones}
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            \}
                        \} \textcolor{keywordflow}{else} \{
                            \textcolor{comment}{// Execute the appropriate callbacks}
                            jqXHR.always( map[ jqXHR.status ] );
                        \}
                    \}
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \},

                \textcolor{comment}{// Cancel the request}
                abort: \textcolor{keyword}{function}( statusText ) \{
                    var finalText = statusText || strAbort;
                    \textcolor{keywordflow}{if} ( transport ) \{
                        transport.abort( finalText );
                    \}
                    done( 0, finalText );
                    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
                \}
            \};

        \textcolor{comment}{// Attach deferreds}
        deferred.promise( jqXHR ).complete = completeDeferred.add;
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;

        \textcolor{comment}{// Remove hash character (#7531: and string promotion)}
        \textcolor{comment}{// Add protocol if not provided (prefilters might expect it)}
        \textcolor{comment}{// Handle falsy url in the settings object (#10093: consistency with old signature)}
        \textcolor{comment}{// We also use the url parameter if available}
        s.url = ( ( url || s.url || ajaxLocation ) + \textcolor{stringliteral}{""} ).replace( rhash, \textcolor{stringliteral}{""} )
            .replace( rprotocol, ajaxLocParts[ 1 ] + \textcolor{stringliteral}{"//"} );

        \textcolor{comment}{// Alias method option to type as per ticket #12004}
        s.type = options.method || options.type || s.method || s.type;

        \textcolor{comment}{// Extract dataTypes list}
        s.dataTypes = jQuery.trim( s.dataType || \textcolor{stringliteral}{"*"} ).toLowerCase().match( rnotwhite ) || [ \textcolor{stringliteral}{""} ];

        \textcolor{comment}{// A cross-domain request is in order when we have a protocol:host:port mismatch}
        \textcolor{keywordflow}{if} ( s.crossDomain == null ) \{
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === \textcolor{stringliteral}{"http:"} ? \textcolor{stringliteral}{"80"} : \textcolor{stringliteral}{"443"} ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \textcolor{stringliteral}{"http:"} ? \textcolor{stringliteral}{"80"} : \textcolor{stringliteral}{"443"} ) ) )
            );
        \}

        \textcolor{comment}{// Convert data if not already a string}
        \textcolor{keywordflow}{if} ( s.data && s.processData && typeof s.data !== \textcolor{stringliteral}{"string"} ) \{
            s.data = jQuery.param( s.data, s.traditional );
        \}

        \textcolor{comment}{// Apply prefilters}
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        \textcolor{comment}{// If request was aborted inside a prefilter, stop there}
        \textcolor{keywordflow}{if} ( state === 2 ) \{
            \textcolor{keywordflow}{return} jqXHR;
        \}

        \textcolor{comment}{// We can fire global events as of now if asked to}
        fireGlobals = s.global;

        \textcolor{comment}{// Watch for a new set of requests}
        \textcolor{keywordflow}{if} ( fireGlobals && jQuery.active++ === 0 ) \{
            jQuery.event.trigger(\textcolor{stringliteral}{"ajaxStart"});
        \}

        \textcolor{comment}{// Uppercase the type}
        s.type = s.type.toUpperCase();

        \textcolor{comment}{// Determine if request has content}
        s.hasContent = !rnoContent.test( s.type );

        \textcolor{comment}{// Save the URL in case we're toying with the If-Modified-Since}
        \textcolor{comment}{// and/or If-None-Match header later on}
        cacheURL = s.url;

        \textcolor{comment}{// More options handling for requests with no content}
        \textcolor{keywordflow}{if} ( !s.hasContent ) \{

            \textcolor{comment}{// If data is available, append data to url}
            \textcolor{keywordflow}{if} ( s.data ) \{
                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? \textcolor{stringliteral}{"&"} : \textcolor{stringliteral}{"?"} ) + s.data );
                \textcolor{comment}{// #9682: remove data so that it's not used in an eventual retry}
                \textcolor{keyword}{delete} s.data;
            \}

            \textcolor{comment}{// Add anti-cache in url if needed}
            \textcolor{keywordflow}{if} ( s.cache === \textcolor{keyword}{false} ) \{
                s.url = rts.test( cacheURL ) ?

                    \textcolor{comment}{// If there is already a '\_' parameter, set its value}
                    cacheURL.replace( rts, \textcolor{stringliteral}{"$1\_="} + nonce++ ) :

                    \textcolor{comment}{// Otherwise add one to the end}
                    cacheURL + ( rquery.test( cacheURL ) ? \textcolor{stringliteral}{"&"} : \textcolor{stringliteral}{"?"} ) + \textcolor{stringliteral}{"\_="} + nonce++;
            \}
        \}

        \textcolor{comment}{// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.}
        \textcolor{keywordflow}{if} ( s.ifModified ) \{
            \textcolor{keywordflow}{if} ( jQuery.lastModified[ cacheURL ] ) \{
                jqXHR.setRequestHeader( \textcolor{stringliteral}{"If-Modified-Since"}, jQuery.lastModified[ cacheURL ] );
            \}
            \textcolor{keywordflow}{if} ( jQuery.etag[ cacheURL ] ) \{
                jqXHR.setRequestHeader( \textcolor{stringliteral}{"If-None-Match"}, jQuery.etag[ cacheURL ] );
            \}
        \}

        \textcolor{comment}{// Set the correct header, if data is being sent}
        \textcolor{keywordflow}{if} ( s.data && s.hasContent && s.contentType !== \textcolor{keyword}{false} || options.contentType ) \{
            jqXHR.setRequestHeader( \textcolor{stringliteral}{"Content-Type"}, s.contentType );
        \}

        \textcolor{comment}{// Set the Accepts header for the server, depending on the dataType}
        jqXHR.setRequestHeader(
            \textcolor{stringliteral}{"Accept"},
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \textcolor{stringliteral}{"*"} ? \textcolor{stringliteral}{", "} + allTypes + \textcolor{stringliteral}{"; q=0.01"} : \textcolor{stringliteral}{"
      "} ) :
                s.accepts[ \textcolor{stringliteral}{"*"} ]
        );

        \textcolor{comment}{// Check for headers option}
        \textcolor{keywordflow}{for} ( i in s.headers ) \{
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        \}

        \textcolor{comment}{// Allow custom headers/mimetypes and early abort}
        \textcolor{keywordflow}{if} ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === \textcolor{keyword}{false} || state === 2 ) ) 
      \{
            \textcolor{comment}{// Abort if not done already and return}
            \textcolor{keywordflow}{return} jqXHR.abort();
        \}

        \textcolor{comment}{// aborting is no longer a cancellation}
        strAbort = \textcolor{stringliteral}{"abort"};

        \textcolor{comment}{// Install callbacks on deferreds}
        \textcolor{keywordflow}{for} ( i in \{ success: 1, error: 1, complete: 1 \} ) \{
            jqXHR[ i ]( s[ i ] );
        \}

        \textcolor{comment}{// Get transport}
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        \textcolor{comment}{// If no transport, we auto-abort}
        \textcolor{keywordflow}{if} ( !transport ) \{
            done( -1, \textcolor{stringliteral}{"No Transport"} );
        \} \textcolor{keywordflow}{else} \{
            jqXHR.readyState = 1;

            \textcolor{comment}{// Send global event}
            \textcolor{keywordflow}{if} ( fireGlobals ) \{
                globalEventContext.trigger( \textcolor{stringliteral}{"ajaxSend"}, [ jqXHR, s ] );
            \}
            \textcolor{comment}{// Timeout}
            \textcolor{keywordflow}{if} ( s.async && s.timeout > 0 ) \{
                timeoutTimer = setTimeout(\textcolor{keyword}{function}() \{
                    jqXHR.abort(\textcolor{stringliteral}{"timeout"});
                \}, s.timeout );
            \}

            \textcolor{keywordflow}{try} \{
                state = 1;
                transport.send( requestHeaders, done );
            \} \textcolor{keywordflow}{catch} ( e ) \{
                \textcolor{comment}{// Propagate exception as error if not done}
                \textcolor{keywordflow}{if} ( state < 2 ) \{
                    done( -1, e );
                \textcolor{comment}{// Simply rethrow otherwise}
                \} \textcolor{keywordflow}{else} \{
                    \textcolor{keywordflow}{throw} e;
                \}
            \}
        \}

        \textcolor{comment}{// Callback for when everything is done}
        \textcolor{keyword}{function} done( status, nativeStatusText, responses, headers ) \{
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            \textcolor{comment}{// Called once}
            \textcolor{keywordflow}{if} ( state === 2 ) \{
                \textcolor{keywordflow}{return};
            \}

            \textcolor{comment}{// State is "done" now}
            state = 2;

            \textcolor{comment}{// Clear timeout if it exists}
            \textcolor{keywordflow}{if} ( timeoutTimer ) \{
                clearTimeout( timeoutTimer );
            \}

            \textcolor{comment}{// Dereference transport for early garbage collection}
            \textcolor{comment}{// (no matter how long the jqXHR object will be used)}
            transport = undefined;

            \textcolor{comment}{// Cache response headers}
            responseHeadersString = headers || \textcolor{stringliteral}{""};

            \textcolor{comment}{// Set readyState}
            jqXHR.readyState = status > 0 ? 4 : 0;

            \textcolor{comment}{// Determine if successful}
            isSuccess = status >= 200 && status < 300 || status === 304;

            \textcolor{comment}{// Get response data}
            \textcolor{keywordflow}{if} ( responses ) \{
                response = ajaxHandleResponses( s, jqXHR, responses );
            \}

            \textcolor{comment}{// Convert no matter what (that way responseXXX fields are always set)}
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            \textcolor{comment}{// If successful, handle type chaining}
            \textcolor{keywordflow}{if} ( isSuccess ) \{

                \textcolor{comment}{// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.}
                \textcolor{keywordflow}{if} ( s.ifModified ) \{
                    modified = jqXHR.getResponseHeader(\textcolor{stringliteral}{"Last-Modified"});
                    \textcolor{keywordflow}{if} ( modified ) \{
                        jQuery.lastModified[ cacheURL ] = modified;
                    \}
                    modified = jqXHR.getResponseHeader(\textcolor{stringliteral}{"etag"});
                    \textcolor{keywordflow}{if} ( modified ) \{
                        jQuery.etag[ cacheURL ] = modified;
                    \}
                \}

                \textcolor{comment}{// if no content}
                \textcolor{keywordflow}{if} ( status === 204 || s.type === \textcolor{stringliteral}{"HEAD"} ) \{
                    statusText = \textcolor{stringliteral}{"nocontent"};

                \textcolor{comment}{// if not modified}
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( status === 304 ) \{
                    statusText = \textcolor{stringliteral}{"notmodified"};

                \textcolor{comment}{// If we have data, let's convert it}
                \} \textcolor{keywordflow}{else} \{
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                \}
            \} \textcolor{keywordflow}{else} \{
                \textcolor{comment}{// We extract error from statusText}
                \textcolor{comment}{// then normalize statusText and status for non-aborts}
                error = statusText;
                \textcolor{keywordflow}{if} ( status || !statusText ) \{
                    statusText = \textcolor{stringliteral}{"error"};
                    \textcolor{keywordflow}{if} ( status < 0 ) \{
                        status = 0;
                    \}
                \}
            \}

            \textcolor{comment}{// Set data for the fake xhr object}
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + \textcolor{stringliteral}{""};

            \textcolor{comment}{// Success/Error}
            \textcolor{keywordflow}{if} ( isSuccess ) \{
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            \} \textcolor{keywordflow}{else} \{
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            \}

            \textcolor{comment}{// Status-dependent callbacks}
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            \textcolor{keywordflow}{if} ( fireGlobals ) \{
                globalEventContext.trigger( isSuccess ? \textcolor{stringliteral}{"ajaxSuccess"} : \textcolor{stringliteral}{"ajaxError"},
                    [ jqXHR, s, isSuccess ? success : error ] );
            \}

            \textcolor{comment}{// Complete}
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            \textcolor{keywordflow}{if} ( fireGlobals ) \{
                globalEventContext.trigger( \textcolor{stringliteral}{"ajaxComplete"}, [ jqXHR, s ] );
                \textcolor{comment}{// Handle the global AJAX counter}
                \textcolor{keywordflow}{if} ( !( --jQuery.active ) ) \{
                    jQuery.event.trigger(\textcolor{stringliteral}{"ajaxStop"});
                \}
            \}
        \}

        \textcolor{keywordflow}{return} jqXHR;
    \},

    getJSON: \textcolor{keyword}{function}( url, data, callback ) \{
        \textcolor{keywordflow}{return} jQuery.get( url, data, callback, \textcolor{stringliteral}{"json"} );
    \},

    getScript: \textcolor{keyword}{function}( url, callback ) \{
        \textcolor{keywordflow}{return} jQuery.get( url, undefined, callback, \textcolor{stringliteral}{"script"} );
    \}
\});

jQuery.each( [ \textcolor{stringliteral}{"get"}, \textcolor{stringliteral}{"post"} ], \textcolor{keyword}{function}( i, method ) \{
    jQuery[ method ] = \textcolor{keyword}{function}( url, data, callback, type ) \{
        \textcolor{comment}{// shift arguments if data argument was omitted}
        \textcolor{keywordflow}{if} ( jQuery.isFunction( data ) ) \{
            type = type || callback;
            callback = data;
            data = undefined;
        \}

        \textcolor{keywordflow}{return} jQuery.ajax(\{
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        \});
    \};
\});

\textcolor{comment}{// Attach a bunch of functions for handling common AJAX events}
jQuery.each( [ \textcolor{stringliteral}{"ajaxStart"}, \textcolor{stringliteral}{"ajaxStop"}, \textcolor{stringliteral}{"ajaxComplete"}, \textcolor{stringliteral}{"ajaxError"}, \textcolor{stringliteral}{"ajaxSuccess"}, \textcolor{stringliteral}{"ajaxSend"} ], \textcolor{keyword}{function}(
       i, type ) \{
    jQuery.fn[ type ] = \textcolor{keyword}{function}( fn ) \{
        \textcolor{keywordflow}{return} this.on( type, fn );
    \};
\});


jQuery.\_evalUrl = \textcolor{keyword}{function}( url ) \{
    \textcolor{keywordflow}{return} jQuery.ajax(\{
        url: url,
        type: \textcolor{stringliteral}{"GET"},
        dataType: \textcolor{stringliteral}{"script"},
        async: \textcolor{keyword}{false},
        global: \textcolor{keyword}{false},
        \textcolor{stringliteral}{"throws"}: \textcolor{keyword}{true}
    \});
\};


jQuery.fn.extend(\{
    wrapAll: \textcolor{keyword}{function}( html ) \{
        var wrap;

        \textcolor{keywordflow}{if} ( jQuery.isFunction( html ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( i ) \{
                jQuery( \textcolor{keyword}{this} ).wrapAll( html.call(\textcolor{keyword}{this}, i) );
            \});
        \}

        \textcolor{keywordflow}{if} ( \textcolor{keyword}{this}[ 0 ] ) \{

            \textcolor{comment}{// The elements to wrap the target around}
            wrap = jQuery( html, \textcolor{keyword}{this}[ 0 ].ownerDocument ).eq( 0 ).clone( \textcolor{keyword}{true} );

            \textcolor{keywordflow}{if} ( \textcolor{keyword}{this}[ 0 ].parentNode ) \{
                wrap.insertBefore( \textcolor{keyword}{this}[ 0 ] );
            \}

            wrap.map(\textcolor{keyword}{function}() \{
                var elem = \textcolor{keyword}{this};

                \textcolor{keywordflow}{while} ( elem.firstElementChild ) \{
                    elem = elem.firstElementChild;
                \}

                \textcolor{keywordflow}{return} elem;
            \}).append( \textcolor{keyword}{this} );
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \},

    wrapInner: \textcolor{keyword}{function}( html ) \{
        \textcolor{keywordflow}{if} ( jQuery.isFunction( html ) ) \{
            \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( i ) \{
                jQuery( \textcolor{keyword}{this} ).wrapInner( html.call(\textcolor{keyword}{this}, i) );
            \});
        \}

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}() \{
            var \textcolor{keyword}{self} = jQuery( \textcolor{keyword}{this} ),
                contents = \textcolor{keyword}{self}.contents();

            \textcolor{keywordflow}{if} ( contents.length ) \{
                contents.wrapAll( html );

            \} \textcolor{keywordflow}{else} \{
                \textcolor{keyword}{self}.append( html );
            \}
        \});
    \},

    wrap: \textcolor{keyword}{function}( html ) \{
        var isFunction = jQuery.isFunction( html );

        \textcolor{keywordflow}{return} this.each(\textcolor{keyword}{function}( i ) \{
            jQuery( \textcolor{keyword}{this} ).wrapAll( isFunction ? html.call(\textcolor{keyword}{this}, i) : html );
        \});
    \},

    unwrap: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.parent().each(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( !jQuery.nodeName( \textcolor{keyword}{this}, \textcolor{stringliteral}{"body"} ) ) \{
                jQuery( \textcolor{keyword}{this} ).replaceWith( this.childNodes );
            \}
        \}).end();
    \}
\});


jQuery.expr.filters.hidden = \textcolor{keyword}{function}( elem ) \{
    \textcolor{comment}{// Support: Opera <= 12.12}
    \textcolor{comment}{// Opera reports offsetWidths and offsetHeights less than zero on some elements}
    \textcolor{keywordflow}{return} elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
\};
jQuery.expr.filters.visible = \textcolor{keyword}{function}( elem ) \{
    \textcolor{keywordflow}{return} !jQuery.expr.filters.hidden( elem );
\};




var r20 = /%20/g,
    rbracket = /\(\backslash\)[\(\backslash\)]$/,
    rCRLF = /\(\backslash\)r?\(\backslash\)n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

\textcolor{keyword}{function} buildParams( prefix, obj, traditional, add ) \{
    var name;

    \textcolor{keywordflow}{if} ( jQuery.isArray( obj ) ) \{
        \textcolor{comment}{// Serialize array item.}
        jQuery.each( obj, \textcolor{keyword}{function}( i, v ) \{
            \textcolor{keywordflow}{if} ( traditional || rbracket.test( prefix ) ) \{
                \textcolor{comment}{// Treat each array item as a scalar.}
                add( prefix, v );

            \} \textcolor{keywordflow}{else} \{
                \textcolor{comment}{// Item is non-scalar (array or object), encode its numeric index.}
                buildParams( prefix + \textcolor{stringliteral}{"["} + ( typeof v === \textcolor{stringliteral}{"object"} ? i : \textcolor{stringliteral}{""} ) + \textcolor{stringliteral}{"]"}, v, traditional, add )
      ;
            \}
        \});

    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !traditional && jQuery.type( obj ) === \textcolor{stringliteral}{"object"} ) \{
        \textcolor{comment}{// Serialize object item.}
        \textcolor{keywordflow}{for} ( name in obj ) \{
            buildParams( prefix + \textcolor{stringliteral}{"["} + name + \textcolor{stringliteral}{"]"}, obj[ name ], traditional, add );
        \}

    \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Serialize scalar item.}
        add( prefix, obj );
    \}
\}

\textcolor{comment}{// Serialize an array of form elements or a set of}
\textcolor{comment}{// key/values into a query string}
jQuery.param = \textcolor{keyword}{function}( a, traditional ) \{
    var prefix,
        s = [],
        add = \textcolor{keyword}{function}( key, value ) \{
            \textcolor{comment}{// If value is a function, invoke it and return its value}
            value = jQuery.isFunction( value ) ? value() : ( value == null ? \textcolor{stringliteral}{""} : value );
            s[ s.length ] = encodeURIComponent( key ) + \textcolor{stringliteral}{"="} + encodeURIComponent( value );
        \};

    \textcolor{comment}{// Set traditional to true for jQuery <= 1.3.2 behavior.}
    \textcolor{keywordflow}{if} ( traditional === undefined ) \{
        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    \}

    \textcolor{comment}{// If an array was passed in, assume that it is an array of form elements.}
    \textcolor{keywordflow}{if} ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) \{
        \textcolor{comment}{// Serialize the form elements}
        jQuery.each( a, \textcolor{keyword}{function}() \{
            add( this.name, this.value );
        \});

    \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// If traditional, encode the "old" way (the way 1.3.2 or older}
        \textcolor{comment}{// did it), otherwise encode params recursively.}
        \textcolor{keywordflow}{for} ( prefix in a ) \{
            buildParams( prefix, a[ prefix ], traditional, add );
        \}
    \}

    \textcolor{comment}{// Return the resulting serialization}
    \textcolor{keywordflow}{return} s.join( \textcolor{stringliteral}{"&"} ).replace( r20, \textcolor{stringliteral}{"+"} );
\};

jQuery.fn.extend(\{
    serialize: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} jQuery.param( this.serializeArray() );
    \},
    serializeArray: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.map(\textcolor{keyword}{function}() \{
            \textcolor{comment}{// Can add propHook for "elements" to filter or add form elements}
            var elements = jQuery.prop( \textcolor{keyword}{this}, \textcolor{stringliteral}{"elements"} );
            \textcolor{keywordflow}{return} elements ? jQuery.makeArray( elements ) : \textcolor{keyword}{this};
        \})
        .filter(\textcolor{keyword}{function}() \{
            var type = this.type;

            \textcolor{comment}{// Use .is( ":disabled" ) so that fieldset[disabled] works}
            \textcolor{keywordflow}{return} this.name && !jQuery( \textcolor{keyword}{this} ).is( \textcolor{stringliteral}{":disabled"} ) &&
                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                ( this.checked || !rcheckableType.test( type ) );
        \})
        .map(\textcolor{keyword}{function}( i, elem ) \{
            var val = jQuery( \textcolor{keyword}{this} ).val();

            \textcolor{keywordflow}{return} val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, \textcolor{keyword}{function}( val ) \{
                        \textcolor{keywordflow}{return} \{ name: elem.name, value: val.replace( rCRLF, \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"} ) \};
                    \}) :
                    \{ name: elem.name, value: val.replace( rCRLF, \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"} ) \};
        \}).\textcolor{keyword}{get}();
    \}
\});


jQuery.ajaxSettings.xhr = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} XMLHttpRequest();
    \} \textcolor{keywordflow}{catch}( e ) \{\}
\};

var xhrId = 0,
    xhrCallbacks = \{\},
    xhrSuccessStatus = \{
        \textcolor{comment}{// file protocol always yields status code 0, assume 200}
        0: 200,
        \textcolor{comment}{// Support: IE9}
        \textcolor{comment}{// #1450: sometimes IE returns 1223 when it should be 204}
        1223: 204
    \},
    xhrSupported = jQuery.ajaxSettings.xhr();

\textcolor{comment}{// Support: IE9}
\textcolor{comment}{// Open requests must be manually aborted on unload (#5280)}
\textcolor{keywordflow}{if} ( window.ActiveXObject ) \{
    jQuery( window ).on( \textcolor{stringliteral}{"unload"}, \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{for} ( var key in xhrCallbacks ) \{
            xhrCallbacks[ key ]();
        \}
    \});
\}

support.cors = !!xhrSupported && ( \textcolor{stringliteral}{"withCredentials"} in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(\textcolor{keyword}{function}( options ) \{
    var callback;

    \textcolor{comment}{// Cross domain only allowed if supported through XMLHttpRequest}
    \textcolor{keywordflow}{if} ( support.cors || xhrSupported && !options.crossDomain ) \{
        return \{
            send: function( headers, complete ) \{
                var i,
                    xhr = options.xhr(),
                    id = ++xhrId;

                xhr.open( options.type, options.url, options.async, options.username, options.password );

                \textcolor{comment}{// Apply custom fields if provided}
                if ( options.xhrFields ) \{
                    for ( i in options.xhrFields ) \{
                        xhr[ i ] = options.xhrFields[ i ];
                    \}
                \}

                \textcolor{comment}{// Override mime type if needed}
                if ( options.mimeType && xhr.overrideMimeType ) \{
                    xhr.overrideMimeType( options.mimeType );
                \}

                \textcolor{comment}{// X-Requested-With header}
                \textcolor{comment}{// For cross-domain requests, seeing as conditions for a preflight are}
                \textcolor{comment}{// akin to a jigsaw puzzle, we simply never set it to be sure.}
                \textcolor{comment}{// (it can always be set on a per-request basis or even using ajaxSetup)}
                \textcolor{comment}{// For same-domain requests, won't change header if already provided.}
                if ( !options.crossDomain && !headers[\textcolor{stringliteral}{"X-Requested-With"}] ) \{
                    headers[\textcolor{stringliteral}{"X-Requested-With"}] = \textcolor{stringliteral}{"XMLHttpRequest"};
                \}

                \textcolor{comment}{// Set headers}
                for ( i in headers ) \{
                    xhr.setRequestHeader( i, headers[ i ] );
                \}

                \textcolor{comment}{// Callback}
                callback = function( type ) \{
                    return function() \{
                        if ( callback ) \{
                            delete xhrCallbacks[ id ];
                            callback = xhr.onload = xhr.onerror = null;

                            if ( type === \textcolor{stringliteral}{"abort"} ) \{
                                xhr.abort();
                            \} else if ( type === \textcolor{stringliteral}{"error"} ) \{
                                complete(
                                    \textcolor{comment}{// file: protocol always yields status 0; see #8605, #14207}
                                    xhr.status,
                                    xhr.statusText
                                );
                            \} else \{
                                complete(
                                    xhrSuccessStatus[ xhr.status ] || xhr.status,
                                    xhr.statusText,
                                    \textcolor{comment}{// Support: IE9}
                                    \textcolor{comment}{// Accessing binary-data responseText throws an exception}
                                    \textcolor{comment}{// (#11426)}
                                    typeof xhr.responseText === \textcolor{stringliteral}{"string"} ? \{
                                        text: xhr.responseText
                                    \} : undefined,
                                    xhr.getAllResponseHeaders()
                                );
                            \}
                        \}
                    \};
                \};

                \textcolor{comment}{// Listen to events}
                xhr.onload = callback();
                xhr.onerror = callback(\textcolor{stringliteral}{"error"});

                \textcolor{comment}{// Create the abort callback}
                callback = xhrCallbacks[ id ] = callback(\textcolor{stringliteral}{"abort"});

                try \{
                    \textcolor{comment}{// Do send the request (this may raise an exception)}
                    xhr.send( options.hasContent && options.data || null );
                \} catch ( e ) \{
                    \textcolor{comment}{// #14683: Only rethrow if this hasn't been notified as an error yet}
                    if ( callback ) \{
                        throw e;
                    \}
                \}
            \},

            abort: function() \{
                if ( callback ) \{
                    callback();
                \}
            \}
        \};
    \}
\});




\textcolor{comment}{// Install script dataType}
jQuery.ajaxSetup(\{
    accepts: \{
        script: \textcolor{stringliteral}{"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"}
    \},
    contents: \{
        script: /(?:java|ecma)script/
    \},
    converters: \{
        \textcolor{stringliteral}{"text script"}: \textcolor{keyword}{function}( text ) \{
            jQuery.globalEval( text );
            \textcolor{keywordflow}{return} text;
        \}
    \}
\});

\textcolor{comment}{// Handle cache's special case and crossDomain}
jQuery.ajaxPrefilter( \textcolor{stringliteral}{"script"}, \textcolor{keyword}{function}( s ) \{
    \textcolor{keywordflow}{if} ( s.cache === undefined ) \{
        s.cache = false;
    \}
    if ( s.crossDomain ) \{
        s.type = \textcolor{stringliteral}{"GET"};
    \}
\});

\textcolor{comment}{// Bind script tag hack transport}
jQuery.ajaxTransport( \textcolor{stringliteral}{"script"}, \textcolor{keyword}{function}( s ) \{
    \textcolor{comment}{// This transport only deals with cross domain requests}
    \textcolor{keywordflow}{if} ( s.crossDomain ) \{
        var script, callback;
        return \{
            send: function( \_, complete ) \{
                script = jQuery(\textcolor{stringliteral}{"<script>"}).prop(\{
                    async: true,
                    charset: s.scriptCharset,
                    src: s.url
                \}).on(
                    \textcolor{stringliteral}{"load error"},
                    callback = function( evt ) \{
                        script.remove();
                        callback = null;
                        if ( evt ) \{
                            complete( evt.type === \textcolor{stringliteral}{"error"} ? 404 : 200, evt.type );
                        \}
                    \}
                );
                document.head.appendChild( script[ 0 ] );
            \},
            abort: function() \{
                if ( callback ) \{
                    callback();
                \}
            \}
        \};
    \}
\});




var oldCallbacks = [],
    rjsonp = /(=)\(\backslash\)?(?=&|$)|\(\backslash\)?\(\backslash\)?/;

\textcolor{comment}{// Default jsonp settings}
jQuery.ajaxSetup(\{
    jsonp: \textcolor{stringliteral}{"callback"},
    jsonpCallback: \textcolor{keyword}{function}() \{
        var callback = oldCallbacks.pop() || ( jQuery.expando + \textcolor{stringliteral}{"\_"} + ( nonce++ ) );
        \textcolor{keyword}{this}[ callback ] = \textcolor{keyword}{true};
        \textcolor{keywordflow}{return} callback;
    \}
\});

\textcolor{comment}{// Detect, normalize options and install callbacks for jsonp requests}
jQuery.ajaxPrefilter( \textcolor{stringliteral}{"json jsonp"}, \textcolor{keyword}{function}( s, originalSettings, jqXHR ) \{

    var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== \textcolor{keyword}{false} && ( rjsonp.test( s.url ) ?
            \textcolor{stringliteral}{"url"} :
            typeof s.data === \textcolor{stringliteral}{"string"} && !( s.contentType || \textcolor{stringliteral}{""} ).indexOf(\textcolor{stringliteral}{"
      application/x-www-form-urlencoded"}) && rjsonp.test( s.data ) && \textcolor{stringliteral}{"data"}
        );

    \textcolor{comment}{// Handle iff the expected data type is "jsonp" or we have a parameter to set}
    \textcolor{keywordflow}{if} ( jsonProp || s.dataTypes[ 0 ] === \textcolor{stringliteral}{"jsonp"} ) \{

        \textcolor{comment}{// Get callback name, remembering preexisting value associated with it}
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

        \textcolor{comment}{// Insert callback into url or form data}
        \textcolor{keywordflow}{if} ( jsonProp ) \{
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \textcolor{stringliteral}{"$1"} + callbackName );
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( s.jsonp !== \textcolor{keyword}{false} ) \{
            s.url += ( rquery.test( s.url ) ? \textcolor{stringliteral}{"&"} : \textcolor{stringliteral}{"?"} ) + s.jsonp + \textcolor{stringliteral}{"="} + callbackName;
        \}

        \textcolor{comment}{// Use data converter to retrieve json after script execution}
        s.converters[\textcolor{stringliteral}{"script json"}] = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} ( !responseContainer ) \{
                jQuery.error( callbackName + \textcolor{stringliteral}{" was not called"} );
            \}
            \textcolor{keywordflow}{return} responseContainer[ 0 ];
        \};

        \textcolor{comment}{// force json dataType}
        s.dataTypes[ 0 ] = \textcolor{stringliteral}{"json"};

        \textcolor{comment}{// Install callback}
        overwritten = window[ callbackName ];
        window[ callbackName ] = \textcolor{keyword}{function}() \{
            responseContainer = arguments;
        \};

        \textcolor{comment}{// Clean-up function (fires after converters)}
        jqXHR.always(\textcolor{keyword}{function}() \{
            \textcolor{comment}{// Restore preexisting value}
            window[ callbackName ] = overwritten;

            \textcolor{comment}{// Save back as free}
            \textcolor{keywordflow}{if} ( s[ callbackName ] ) \{
                \textcolor{comment}{// make sure that re-using the options doesn't screw things around}
                s.jsonpCallback = originalSettings.jsonpCallback;

                \textcolor{comment}{// save the callback name for future use}
                oldCallbacks.push( callbackName );
            \}

            \textcolor{comment}{// Call if it was a function and we have a response}
            \textcolor{keywordflow}{if} ( responseContainer && jQuery.isFunction( overwritten ) ) \{
                overwritten( responseContainer[ 0 ] );
            \}

            responseContainer = overwritten = undefined;
        \});

        \textcolor{comment}{// Delegate to script}
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"script"};
    \}
\});




\textcolor{comment}{// data: string of html}
\textcolor{comment}{// context (optional): If specified, the fragment will be created in this context, defaults to document}
\textcolor{comment}{// keepScripts (optional): If true, will include scripts passed in the html string}
jQuery.parseHTML = \textcolor{keyword}{function}( data, context, keepScripts ) \{
    \textcolor{keywordflow}{if} ( !data || typeof data !== \textcolor{stringliteral}{"string"} ) \{
        \textcolor{keywordflow}{return} null;
    \}
    \textcolor{keywordflow}{if} ( typeof context === \textcolor{stringliteral}{"boolean"} ) \{
        keepScripts = context;
        context = \textcolor{keyword}{false};
    \}
    context = context || document;

    var parsed = rsingleTag.exec( data ),
        scripts = !keepScripts && [];

    \textcolor{comment}{// Single tag}
    \textcolor{keywordflow}{if} ( parsed ) \{
        \textcolor{keywordflow}{return} [ context.createElement( parsed[1] ) ];
    \}

    parsed = jQuery.buildFragment( [ data ], context, scripts );

    \textcolor{keywordflow}{if} ( scripts && scripts.length ) \{
        jQuery( scripts ).remove();
    \}

    \textcolor{keywordflow}{return} jQuery.merge( [], parsed.childNodes );
\};


\textcolor{comment}{// Keep a copy of the old load method}
var \_load = jQuery.fn.load;

jQuery.fn.load = \textcolor{keyword}{function}( url, params, callback ) \{
    \textcolor{keywordflow}{if} ( typeof url !== \textcolor{stringliteral}{"string"} && \_load ) \{
        \textcolor{keywordflow}{return} \_load.apply( \textcolor{keyword}{this}, arguments );
    \}

    var selector, type, response,
        \textcolor{keyword}{self} = \textcolor{keyword}{this},
        off = url.indexOf(\textcolor{stringliteral}{" "});

    \textcolor{keywordflow}{if} ( off >= 0 ) \{
        selector = jQuery.trim( url.slice( off ) );
        url = url.slice( 0, off );
    \}

    \textcolor{comment}{// If it's a function}
    \textcolor{keywordflow}{if} ( jQuery.isFunction( params ) ) \{

        \textcolor{comment}{// We assume that it's the callback}
        callback = params;
        params = undefined;

    \textcolor{comment}{// Otherwise, build a param string}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( params && typeof params === \textcolor{stringliteral}{"object"} ) \{
        type = \textcolor{stringliteral}{"POST"};
    \}

    \textcolor{comment}{// If we have elements to modify, make the request}
    \textcolor{keywordflow}{if} ( \textcolor{keyword}{self}.length > 0 ) \{
        jQuery.ajax(\{
            url: url,

            \textcolor{comment}{// if "type" variable is undefined, then "GET" method will be used}
            type: type,
            dataType: \textcolor{stringliteral}{"html"},
            data: params
        \}).done(\textcolor{keyword}{function}( responseText ) \{

            \textcolor{comment}{// Save response for use in complete callback}
            response = arguments;

            \textcolor{keyword}{self}.html( selector ?

                \textcolor{comment}{// If a selector was specified, locate the right elements in a dummy div}
                \textcolor{comment}{// Exclude scripts to avoid IE 'Permission Denied' errors}
                jQuery(\textcolor{stringliteral}{"<div>"}).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                \textcolor{comment}{// Otherwise use the full result}
                responseText );

        \}).complete( callback && \textcolor{keyword}{function}( jqXHR, status ) \{
            \textcolor{keyword}{self}.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        \});
    \}

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
\};




jQuery.expr.filters.animated = \textcolor{keyword}{function}( elem ) \{
    \textcolor{keywordflow}{return} jQuery.grep(jQuery.timers, \textcolor{keyword}{function}( fn ) \{
        return elem === fn.elem;
    \}).length;
\};




var docElem = window.document.documentElement;

\textcolor{keyword}{function} getWindow( elem ) \{
    \textcolor{keywordflow}{return} jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
\}

jQuery.offset = \{
    setOffset: \textcolor{keyword}{function}( elem, options, i ) \{
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, \textcolor{stringliteral}{"position"} ),
            curElem = jQuery( elem ),
            props = \{\};

        \textcolor{comment}{// Set position first, in-case top/left are set even on static elem}
        \textcolor{keywordflow}{if} ( position === \textcolor{stringliteral}{"static"} ) \{
            elem.style.position = \textcolor{stringliteral}{"relative"};
        \}

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, \textcolor{stringliteral}{"top"} );
        curCSSLeft = jQuery.css( elem, \textcolor{stringliteral}{"left"} );
        calculatePosition = ( position === \textcolor{stringliteral}{"absolute"} || position === \textcolor{stringliteral}{"fixed"} ) &&
            ( curCSSTop + curCSSLeft ).indexOf(\textcolor{stringliteral}{"auto"}) > -1;

        \textcolor{comment}{// Need to be able to calculate position if either top or left is auto and position is either
       absolute or fixed}
        \textcolor{keywordflow}{if} ( calculatePosition ) \{
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;

        \} \textcolor{keywordflow}{else} \{
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        \}

        \textcolor{keywordflow}{if} ( jQuery.isFunction( options ) ) \{
            options = options.call( elem, i, curOffset );
        \}

        \textcolor{keywordflow}{if} ( options.top != null ) \{
            props.top = ( options.top - curOffset.top ) + curTop;
        \}
        \textcolor{keywordflow}{if} ( options.left != null ) \{
            props.left = ( options.left - curOffset.left ) + curLeft;
        \}

        \textcolor{keywordflow}{if} ( \textcolor{stringliteral}{"using"} in options ) \{
            options.using.call( elem, props );

        \} \textcolor{keywordflow}{else} \{
            curElem.css( props );
        \}
    \}
\};

jQuery.fn.extend(\{
    offset: \textcolor{keyword}{function}( options ) \{
        \textcolor{keywordflow}{if} ( arguments.length ) \{
            \textcolor{keywordflow}{return} options === undefined ?
                \textcolor{keyword}{this} :
                this.each(\textcolor{keyword}{function}( i ) \{
                    jQuery.offset.setOffset( \textcolor{keyword}{this}, options, i );
                \});
        \}

        var docElem, win,
            elem = \textcolor{keyword}{this}[ 0 ],
            box = \{ top: 0, left: 0 \},
            doc = elem && elem.ownerDocument;

        \textcolor{keywordflow}{if} ( !doc ) \{
            \textcolor{keywordflow}{return};
        \}

        docElem = doc.documentElement;

        \textcolor{comment}{// Make sure it's not a disconnected DOM node}
        \textcolor{keywordflow}{if} ( !jQuery.contains( docElem, elem ) ) \{
            \textcolor{keywordflow}{return} box;
        \}

        \textcolor{comment}{// If we don't have gBCR, just use 0,0 rather than error}
        \textcolor{comment}{// BlackBerry 5, iOS 3 (original iPhone)}
        \textcolor{keywordflow}{if} ( typeof elem.getBoundingClientRect !== strundefined ) \{
            box = elem.getBoundingClientRect();
        \}
        win = getWindow( doc );
        \textcolor{keywordflow}{return} \{
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        \};
    \},

    position: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} ( !\textcolor{keyword}{this}[ 0 ] ) \{
            \textcolor{keywordflow}{return};
        \}

        var offsetParent, offset,
            elem = \textcolor{keyword}{this}[ 0 ],
            parentOffset = \{ top: 0, left: 0 \};

        \textcolor{comment}{// Fixed elements are offset from window (parentOffset = \{top:0, left: 0\}, because it is its only
       offset parent}
        \textcolor{keywordflow}{if} ( jQuery.css( elem, \textcolor{stringliteral}{"position"} ) === \textcolor{stringliteral}{"fixed"} ) \{
            \textcolor{comment}{// We assume that getBoundingClientRect is available when computed position is fixed}
            offset = elem.getBoundingClientRect();

        \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// Get *real* offsetParent}
            offsetParent = this.offsetParent();

            \textcolor{comment}{// Get correct offsets}
            offset = this.offset();
            \textcolor{keywordflow}{if} ( !jQuery.nodeName( offsetParent[ 0 ], \textcolor{stringliteral}{"html"} ) ) \{
                parentOffset = offsetParent.offset();
            \}

            \textcolor{comment}{// Add offsetParent borders}
            parentOffset.top += jQuery.css( offsetParent[ 0 ], \textcolor{stringliteral}{"borderTopWidth"}, \textcolor{keyword}{true} );
            parentOffset.left += jQuery.css( offsetParent[ 0 ], \textcolor{stringliteral}{"borderLeftWidth"}, \textcolor{keyword}{true} );
        \}

        \textcolor{comment}{// Subtract parent offsets and element margins}
        \textcolor{keywordflow}{return} \{
            top: offset.top - parentOffset.top - jQuery.css( elem, \textcolor{stringliteral}{"marginTop"}, \textcolor{keyword}{true} ),
            left: offset.left - parentOffset.left - jQuery.css( elem, \textcolor{stringliteral}{"marginLeft"}, \textcolor{keyword}{true} )
        \};
    \},

    offsetParent: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} this.map(\textcolor{keyword}{function}() \{
            var offsetParent = this.offsetParent || docElem;

            \textcolor{keywordflow}{while} ( offsetParent && ( !jQuery.nodeName( offsetParent, \textcolor{stringliteral}{"html"} ) && jQuery.css( offsetParent,
       \textcolor{stringliteral}{"position"} ) === \textcolor{stringliteral}{"static"} ) ) \{
                offsetParent = offsetParent.offsetParent;
            \}

            \textcolor{keywordflow}{return} offsetParent || docElem;
        \});
    \}
\});

\textcolor{comment}{// Create scrollLeft and scrollTop methods}
jQuery.each( \{ scrollLeft: \textcolor{stringliteral}{"pageXOffset"}, scrollTop: \textcolor{stringliteral}{"pageYOffset"} \}, \textcolor{keyword}{function}( method, prop ) \{
    var top = \textcolor{stringliteral}{"pageYOffset"} === prop;

    jQuery.fn[ method ] = \textcolor{keyword}{function}( val ) \{
        \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( elem, method, val ) \{
            var win = getWindow( elem );

            \textcolor{keywordflow}{if} ( val === undefined ) \{
                \textcolor{keywordflow}{return} win ? win[ prop ] : elem[ method ];
            \}

            \textcolor{keywordflow}{if} ( win ) \{
                win.scrollTo(
                    !top ? val : window.pageXOffset,
                    top ? val : window.pageYOffset
                );

            \} \textcolor{keywordflow}{else} \{
                elem[ method ] = val;
            \}
        \}, method, val, arguments.length, null );
    \};
\});

\textcolor{comment}{// Add the top/left cssHooks using jQuery.fn.position}
\textcolor{comment}{// Webkit bug: https://bugs.webkit.org/show\_bug.cgi?id=29084}
\textcolor{comment}{// getComputedStyle returns percent when specified for top/left/bottom/right}
\textcolor{comment}{// rather than make the css module depend on the offset module, we just check for it here}
jQuery.each( [ \textcolor{stringliteral}{"top"}, \textcolor{stringliteral}{"left"} ], \textcolor{keyword}{function}( i, prop ) \{
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
        \textcolor{keyword}{function}( elem, computed ) \{
            if ( computed ) \{
                computed = curCSS( elem, prop );
                \textcolor{comment}{// if curCSS returns percentage, fallback to offset}
                return rnumnonpx.test( computed ) ?
                    jQuery( elem ).position()[ prop ] + \textcolor{stringliteral}{"px"} :
                    computed;
            \}
        \}
    );
\});


\textcolor{comment}{// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods}
jQuery.each( \{ Height: \textcolor{stringliteral}{"height"}, Width: \textcolor{stringliteral}{"width"} \}, \textcolor{keyword}{function}( name, type ) \{
    jQuery.each( \{ padding: \textcolor{stringliteral}{"inner"} + name, content: type, \textcolor{stringliteral}{""}: \textcolor{stringliteral}{"outer"} + name \}, \textcolor{keyword}{function}( defaultExtra, 
      funcName ) \{
        \textcolor{comment}{// margin is only for outerHeight, outerWidth}
        jQuery.fn[ funcName ] = \textcolor{keyword}{function}( margin, value ) \{
            var chainable = arguments.length && ( defaultExtra || typeof margin !== \textcolor{stringliteral}{"boolean"} ),
                extra = defaultExtra || ( margin === \textcolor{keyword}{true} || value === \textcolor{keyword}{true} ? \textcolor{stringliteral}{"margin"} : \textcolor{stringliteral}{"border"} );

            \textcolor{keywordflow}{return} access( \textcolor{keyword}{this}, \textcolor{keyword}{function}( elem, type, value ) \{
                var doc;

                \textcolor{keywordflow}{if} ( jQuery.isWindow( elem ) ) \{
                    \textcolor{comment}{// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there}
                    \textcolor{comment}{// isn't a whole lot we can do. See pull request at this URL for discussion:}
                    \textcolor{comment}{// https://github.com/jquery/jquery/pull/764}
                    \textcolor{keywordflow}{return} elem.document.documentElement[ \textcolor{stringliteral}{"client"} + name ];
                \}

                \textcolor{comment}{// Get document width or height}
                \textcolor{keywordflow}{if} ( elem.nodeType === 9 ) \{
                    doc = elem.documentElement;

                    \textcolor{comment}{// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],}
                    \textcolor{comment}{// whichever is greatest}
                    \textcolor{keywordflow}{return} Math.max(
                        elem.body[ \textcolor{stringliteral}{"scroll"} + name ], doc[ \textcolor{stringliteral}{"scroll"} + name ],
                        elem.body[ \textcolor{stringliteral}{"offset"} + name ], doc[ \textcolor{stringliteral}{"offset"} + name ],
                        doc[ \textcolor{stringliteral}{"client"} + name ]
                    );
                \}

                \textcolor{keywordflow}{return} value === undefined ?
                    \textcolor{comment}{// Get width or height on the element, requesting but not forcing parseFloat}
                    jQuery.css( elem, type, extra ) :

                    \textcolor{comment}{// Set width or height on the element}
                    jQuery.style( elem, type, value, extra );
            \}, type, chainable ? margin : undefined, chainable, null );
        \};
    \});
\});


\textcolor{comment}{// The number of elements contained in the matched element set}
jQuery.fn.size = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.length;
\};

jQuery.fn.andSelf = jQuery.fn.addBack;




\textcolor{comment}{// Register as a named AMD module, since jQuery can be concatenated with other}
\textcolor{comment}{// files that may use define, but not via a proper concatenation script that}
\textcolor{comment}{// understands anonymous AMD modules. A named AMD is safest and most robust}
\textcolor{comment}{// way to register. Lowercase jquery is used because AMD module names are}
\textcolor{comment}{// derived from file names, and jQuery is normally delivered in a lowercase}
\textcolor{comment}{// file name. Do this after creating the global so that if an AMD module wants}
\textcolor{comment}{// to call noConflict to hide this version of jQuery, it will work.}

\textcolor{comment}{// Note that for maximum portability, libraries that are not jQuery should}
\textcolor{comment}{// declare themselves as anonymous modules, and avoid setting a global if an}
\textcolor{comment}{// AMD loader is present. jQuery is a special case. For more information, see}
\textcolor{comment}{// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon}

\textcolor{keywordflow}{if} ( typeof define === \textcolor{stringliteral}{"function"} && define.amd ) \{
    define( \textcolor{stringliteral}{"jquery"}, [], \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} jQuery;
    \});
\}




var
    \textcolor{comment}{// Map over jQuery in case of overwrite}
    \_jQuery = window.jQuery,

    \textcolor{comment}{// Map over the $ in case of overwrite}
    \_$ = window.$;

jQuery.noConflict = \textcolor{keyword}{function}( deep ) \{
    \textcolor{keywordflow}{if} ( window.$ === jQuery ) \{
        window.$ = \_$;
    \}

    \textcolor{keywordflow}{if} ( deep && window.jQuery === jQuery ) \{
        window.jQuery = \_jQuery;
    \}

    \textcolor{keywordflow}{return} jQuery;
\};

\textcolor{comment}{// Expose jQuery and $ identifiers, even in}
\textcolor{comment}{// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)}
\textcolor{comment}{// and CommonJS for browser emulators (#13566)}
\textcolor{keywordflow}{if} ( typeof noGlobal === strundefined ) \{
    window.jQuery = window.$ = jQuery;
\}




\textcolor{keywordflow}{return} jQuery;

\}));

(\textcolor{keyword}{function}(window, document)\{
  var \_jQuery = window.jQuery.noConflict(\textcolor{keyword}{true});

\textcolor{keyword}{function} minErr(module, ErrorConstructor) \{
  ErrorConstructor = ErrorConstructor || Error;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    var SKIP\_INDEXES = 2;

    var templateArgs = arguments,
      code = templateArgs[0],
      message = \textcolor{charliteral}{'['} + (module ? module + \textcolor{charliteral}{':'} : \textcolor{stringliteral}{''}) + code + \textcolor{stringliteral}{'] '},
      \textcolor{keyword}{template} = templateArgs[1],
      paramPrefix, i;

    message += \textcolor{keyword}{template}.replace(/\(\backslash\)\{\(\backslash\)d+\(\backslash\)\}/g, \textcolor{keyword}{function}(match) \{
      var index = +match.slice(1, -1),
        shiftedIndex = index + SKIP\_INDEXES;

      \textcolor{keywordflow}{if} (shiftedIndex < templateArgs.length) \{
        \textcolor{keywordflow}{return} toDebugString(templateArgs[shiftedIndex]);
      \}

      \textcolor{keywordflow}{return} match;
    \});

    message += \textcolor{stringliteral}{'\(\backslash\)nhttp://errors.angularjs.org/1.4.4/'} +
      (module ? module + \textcolor{charliteral}{'/'} : \textcolor{stringliteral}{''}) + code;

    \textcolor{keywordflow}{for} (i = SKIP\_INDEXES, paramPrefix = \textcolor{charliteral}{'?'}; i < templateArgs.length; i++, paramPrefix = \textcolor{charliteral}{'&'}) \{
      message += paramPrefix + \textcolor{charliteral}{'p'} + (i - SKIP\_INDEXES) + \textcolor{charliteral}{'='} +
        encodeURIComponent(toDebugString(templateArgs[i]));
    \}

    \textcolor{keywordflow}{return} \textcolor{keyword}{new} ErrorConstructor(message);
  \};
\}

\textcolor{comment}{/* We need to tell jshint what variables are being exported */}
\textcolor{comment}{/* global angular: true,}
\textcolor{comment}{  msie: true,}
\textcolor{comment}{  jqLite: true,}
\textcolor{comment}{  jQuery: true,}
\textcolor{comment}{  slice: true,}
\textcolor{comment}{  splice: true,}
\textcolor{comment}{  push: true,}
\textcolor{comment}{  toString: true,}
\textcolor{comment}{  ngMinErr: true,}
\textcolor{comment}{  angularModule: true,}
\textcolor{comment}{  uid: true,}
\textcolor{comment}{  REGEX\_STRING\_REGEXP: true,}
\textcolor{comment}{  VALIDITY\_STATE\_PROPERTY: true,}
\textcolor{comment}{}
\textcolor{comment}{  lowercase: true,}
\textcolor{comment}{  uppercase: true,}
\textcolor{comment}{  manualLowercase: true,}
\textcolor{comment}{  manualUppercase: true,}
\textcolor{comment}{  nodeName\_: true,}
\textcolor{comment}{  isArrayLike: true,}
\textcolor{comment}{  forEach: true,}
\textcolor{comment}{  forEachSorted: true,}
\textcolor{comment}{  reverseParams: true,}
\textcolor{comment}{  nextUid: true,}
\textcolor{comment}{  setHashKey: true,}
\textcolor{comment}{  extend: true,}
\textcolor{comment}{  toInt: true,}
\textcolor{comment}{  inherit: true,}
\textcolor{comment}{  merge: true,}
\textcolor{comment}{  noop: true,}
\textcolor{comment}{  identity: true,}
\textcolor{comment}{  valueFn: true,}
\textcolor{comment}{  isUndefined: true,}
\textcolor{comment}{  isDefined: true,}
\textcolor{comment}{  isObject: true,}
\textcolor{comment}{  isBlankObject: true,}
\textcolor{comment}{  isString: true,}
\textcolor{comment}{  isNumber: true,}
\textcolor{comment}{  isDate: true,}
\textcolor{comment}{  isArray: true,}
\textcolor{comment}{  isFunction: true,}
\textcolor{comment}{  isRegExp: true,}
\textcolor{comment}{  isWindow: true,}
\textcolor{comment}{  isScope: true,}
\textcolor{comment}{  isFile: true,}
\textcolor{comment}{  isFormData: true,}
\textcolor{comment}{  isBlob: true,}
\textcolor{comment}{  isBoolean: true,}
\textcolor{comment}{  isPromiseLike: true,}
\textcolor{comment}{  trim: true,}
\textcolor{comment}{  escapeForRegexp: true,}
\textcolor{comment}{  isElement: true,}
\textcolor{comment}{  makeMap: true,}
\textcolor{comment}{  includes: true,}
\textcolor{comment}{  arrayRemove: true,}
\textcolor{comment}{  copy: true,}
\textcolor{comment}{  shallowCopy: true,}
\textcolor{comment}{  equals: true,}
\textcolor{comment}{  csp: true,}
\textcolor{comment}{  jq: true,}
\textcolor{comment}{  concat: true,}
\textcolor{comment}{  sliceArgs: true,}
\textcolor{comment}{  bind: true,}
\textcolor{comment}{  toJsonReplacer: true,}
\textcolor{comment}{  toJson: true,}
\textcolor{comment}{  fromJson: true,}
\textcolor{comment}{  convertTimezoneToLocal: true,}
\textcolor{comment}{  timezoneToOffset: true,}
\textcolor{comment}{  startingTag: true,}
\textcolor{comment}{  tryDecodeURIComponent: true,}
\textcolor{comment}{  parseKeyValue: true,}
\textcolor{comment}{  toKeyValue: true,}
\textcolor{comment}{  encodeUriSegment: true,}
\textcolor{comment}{  encodeUriQuery: true,}
\textcolor{comment}{  angularInit: true,}
\textcolor{comment}{  bootstrap: true,}
\textcolor{comment}{  getTestability: true,}
\textcolor{comment}{  snake\_case: true,}
\textcolor{comment}{  bindJQuery: true,}
\textcolor{comment}{  assertArg: true,}
\textcolor{comment}{  assertArgFn: true,}
\textcolor{comment}{  assertNotHasOwnProperty: true,}
\textcolor{comment}{  getter: true,}
\textcolor{comment}{  getBlockNodes: true,}
\textcolor{comment}{  hasOwnProperty: true,}
\textcolor{comment}{  createMap: true,}
\textcolor{comment}{}
\textcolor{comment}{  NODE\_TYPE\_ELEMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_ATTRIBUTE: true,}
\textcolor{comment}{  NODE\_TYPE\_TEXT: true,}
\textcolor{comment}{  NODE\_TYPE\_COMMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_DOCUMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_DOCUMENT\_FRAGMENT: true,}
\textcolor{comment}{*/}


var REGEX\_STRING\_REGEXP = /^\(\backslash\)/(.+)\(\backslash\)/([a-z]*)$/;

\textcolor{comment}{// The name of a form control's ValidityState property.}
\textcolor{comment}{// This is used so that it's possible for internal tests to create mock ValidityStates.}
var VALIDITY\_STATE\_PROPERTY = \textcolor{stringliteral}{'validity'};

var lowercase = \textcolor{keyword}{function}(string) \{\textcolor{keywordflow}{return} isString(\textcolor{keywordtype}{string}) ? \textcolor{keywordtype}{string}.toLowerCase() : string;\};
var hasOwnProperty = Object.prototype.hasOwnProperty;

var uppercase = \textcolor{keyword}{function}(string) \{\textcolor{keywordflow}{return} isString(\textcolor{keywordtype}{string}) ? \textcolor{keywordtype}{string}.toUpperCase() : string;\};


var manualLowercase = \textcolor{keyword}{function}(s) \{
  \textcolor{comment}{/* jshint bitwise: false */}
  \textcolor{keywordflow}{return} isString(s)
      ? s.replace(/[A-Z]/g, \textcolor{keyword}{function}(ch) \{\textcolor{keywordflow}{return} String.fromCharCode(ch.charCodeAt(0) | 32);\})
      : s;
\};
var manualUppercase = \textcolor{keyword}{function}(s) \{
  \textcolor{comment}{/* jshint bitwise: false */}
  \textcolor{keywordflow}{return} isString(s)
      ? s.replace(/[a-z]/g, \textcolor{keyword}{function}(ch) \{\textcolor{keywordflow}{return} String.fromCharCode(ch.charCodeAt(0) & ~32);\})
      : s;
\};


\textcolor{comment}{// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish}
\textcolor{comment}{// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods}
\textcolor{comment}{// with correct but slower alternatives.}
\textcolor{keywordflow}{if} (\textcolor{charliteral}{'i'} !== \textcolor{charliteral}{'I'}.toLowerCase()) \{
  lowercase = manualLowercase;
  uppercase = manualUppercase;
\}


var
    msie,             \textcolor{comment}{// holds major version number for IE, or NaN if UA is not IE.}
    jqLite,           \textcolor{comment}{// delay binding since jQuery could be loaded after us.}
    jQuery,           \textcolor{comment}{// delay binding}
    slice             = [].slice,
    splice            = [].splice,
    push              = [].push,
    toString          = Object.prototype.toString,
    getPrototypeOf    = Object.getPrototypeOf,
    ngMinErr          = minErr(\textcolor{stringliteral}{'ng'}),

    angular           = window.angular || (window.angular = \{\}),
    angularModule,
    uid               = 0;

msie = document.documentMode;


\textcolor{keyword}{function} isArrayLike(obj) \{
  \textcolor{keywordflow}{if} (obj == null || isWindow(obj)) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \}

  \textcolor{comment}{// Support: iOS 8.2 (not reproducible in simulator)}
  \textcolor{comment}{// "length" in obj used to prevent JIT error (gh-11508)}
  var length = \textcolor{stringliteral}{"length"} in Object(obj) && obj.length;

  \textcolor{keywordflow}{if} (obj.nodeType === NODE\_TYPE\_ELEMENT && length) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}

  \textcolor{keywordflow}{return} isString(obj) || isArray(obj) || length === 0 ||
         typeof length === \textcolor{stringliteral}{'number'} && length > 0 && (length - 1) in obj;
\}

\textcolor{keyword}{function} forEach(obj, iterator, context) \{
  var key, length;
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (isFunction(obj)) \{
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{comment}{// Need to check if hasOwnProperty exists,}
        \textcolor{comment}{// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function}
        \textcolor{keywordflow}{if} (key != \textcolor{stringliteral}{'prototype'} && key != \textcolor{stringliteral}{'length'} && key != \textcolor{stringliteral}{'name'} && (!obj.hasOwnProperty || obj.
      hasOwnProperty(key))) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(obj) || isArrayLike(obj)) \{
      var isPrimitive = typeof obj !== \textcolor{stringliteral}{'object'};
      \textcolor{keywordflow}{for} (key = 0, length = obj.length; key < length; key++) \{
        \textcolor{keywordflow}{if} (isPrimitive || key in obj) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj.forEach && obj.forEach !== forEach) \{
        obj.forEach(iterator, context, obj);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isBlankObject(obj)) \{
      \textcolor{comment}{// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty}
      \textcolor{keywordflow}{for} (key in obj) \{
        iterator.call(context, obj[key], key, obj);
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj.hasOwnProperty === \textcolor{stringliteral}{'function'}) \{
      \textcolor{comment}{// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed}
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{keywordflow}{if} (obj.hasOwnProperty(key)) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// Slow path for objects which do not have a method `hasOwnProperty`}
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{keywordflow}{if} (hasOwnProperty.call(obj, key)) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \}
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} forEachSorted(obj, iterator, context) \{
  var keys = Object.keys(obj).sort();
  \textcolor{keywordflow}{for} (var i = 0; i < keys.length; i++) \{
    iterator.call(context, obj[keys[i]], keys[i]);
  \}
  \textcolor{keywordflow}{return} keys;
\}


\textcolor{keyword}{function} reverseParams(iteratorFn) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value, key) \{ iteratorFn(key, value); \};
\}

\textcolor{keyword}{function} nextUid() \{
  \textcolor{keywordflow}{return} ++uid;
\}


\textcolor{keyword}{function} setHashKey(obj, h) \{
  \textcolor{keywordflow}{if} (h) \{
    obj.$$hashKey = h;
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keyword}{delete} obj.$$hashKey;
  \}
\}


\textcolor{keyword}{function} baseExtend(dst, objs, deep) \{
  var h = dst.$$hashKey;

  \textcolor{keywordflow}{for} (var i = 0, ii = objs.length; i < ii; ++i) \{
    var obj = objs[i];
    \textcolor{keywordflow}{if} (!isObject(obj) && !isFunction(obj)) \textcolor{keywordflow}{continue};
    var keys = Object.keys(obj);
    \textcolor{keywordflow}{for} (var j = 0, jj = keys.length; j < jj; j++) \{
      var key = keys[j];
      var src = obj[key];

      \textcolor{keywordflow}{if} (deep && isObject(src)) \{
        \textcolor{keywordflow}{if} (isDate(src)) \{
          dst[key] = \textcolor{keyword}{new} Date(src.valueOf());
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(src)) \{
          dst[key] = \textcolor{keyword}{new} RegExp(src);
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (!isObject(dst[key])) dst[key] = isArray(src) ? [] : \{\};
          baseExtend(dst[key], [src], \textcolor{keyword}{true});
        \}
      \} \textcolor{keywordflow}{else} \{
        dst[key] = src;
      \}
    \}
  \}

  setHashKey(dst, h);
  \textcolor{keywordflow}{return} dst;
\}

\textcolor{keyword}{function} extend(dst) \{
  \textcolor{keywordflow}{return} baseExtend(dst, slice.call(arguments, 1), \textcolor{keyword}{false});
\}


\textcolor{keyword}{function} merge(dst) \{
  \textcolor{keywordflow}{return} baseExtend(dst, slice.call(arguments, 1), \textcolor{keyword}{true});
\}



\textcolor{keyword}{function} toInt(str) \{
  \textcolor{keywordflow}{return} parseInt(str, 10);
\}


\textcolor{keyword}{function} inherit(parent, extra) \{
  \textcolor{keywordflow}{return} extend(Object.create(parent), extra);
\}

\textcolor{keyword}{function} noop() \{\}
noop.$inject = [];


\textcolor{keyword}{function} identity($) \{\textcolor{keywordflow}{return} $;\}
identity.$inject = [];


\textcolor{keyword}{function} valueFn(value) \{\textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{\textcolor{keywordflow}{return} value;\};\}

\textcolor{keyword}{function} hasCustomToString(obj) \{
  \textcolor{keywordflow}{return} isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
\}


\textcolor{keyword}{function} isUndefined(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'undefined'};\}


\textcolor{keyword}{function} isDefined(value) \{\textcolor{keywordflow}{return} typeof value !== \textcolor{stringliteral}{'undefined'};\}


\textcolor{keyword}{function} isObject(value) \{
  \textcolor{comment}{// http://jsperf.com/isobject4}
  \textcolor{keywordflow}{return} value !== null && typeof value === \textcolor{stringliteral}{'object'};
\}


\textcolor{keyword}{function} isBlankObject(value) \{
  \textcolor{keywordflow}{return} value !== null && typeof value === \textcolor{stringliteral}{'object'} && !getPrototypeOf(value);
\}


\textcolor{keyword}{function} isString(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'string'};\}


\textcolor{keyword}{function} isNumber(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'number'};\}


\textcolor{keyword}{function} isDate(value) \{
  \textcolor{keywordflow}{return} toString.call(value) === \textcolor{stringliteral}{'[object Date]'};
\}


var isArray = Array.isArray;

\textcolor{keyword}{function} isFunction(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'function'};\}


\textcolor{keyword}{function} isRegExp(value) \{
  \textcolor{keywordflow}{return} toString.call(value) === \textcolor{stringliteral}{'[object RegExp]'};
\}


\textcolor{keyword}{function} isWindow(obj) \{
  \textcolor{keywordflow}{return} obj && obj.window === obj;
\}


\textcolor{keyword}{function} isScope(obj) \{
  \textcolor{keywordflow}{return} obj && obj.$evalAsync && obj.$watch;
\}


\textcolor{keyword}{function} isFile(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object File]'};
\}


\textcolor{keyword}{function} isFormData(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object FormData]'};
\}


\textcolor{keyword}{function} isBlob(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object Blob]'};
\}


\textcolor{keyword}{function} isBoolean(value) \{
  \textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'boolean'};
\}


\textcolor{keyword}{function} isPromiseLike(obj) \{
  \textcolor{keywordflow}{return} obj && isFunction(obj.then);
\}


var TYPED\_ARRAY\_REGEXP = /^\(\backslash\)[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(
      64))Array\(\backslash\)]$/;
\textcolor{keyword}{function} isTypedArray(value) \{
  \textcolor{keywordflow}{return} TYPED\_ARRAY\_REGEXP.test(toString.call(value));
\}


var trim = \textcolor{keyword}{function}(value) \{
  \textcolor{keywordflow}{return} isString(value) ? value.trim() : value;
\};

\textcolor{comment}{// Copied from:}
\textcolor{comment}{// http://docs.closure-library.googlecode.com/git/local\_closure\_goog\_string\_string.js.source.html#line1021}
\textcolor{comment}{// Prereq: s is a string.}
var escapeForRegexp = \textcolor{keyword}{function}(s) \{
  \textcolor{keywordflow}{return} s.replace(/([-()\(\backslash\)[\(\backslash\)]\{\}+?*.$\(\backslash\)^|,:#<!\(\backslash\)\(\backslash\)])/g, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)$1'}).
           replace(/\(\backslash\)x08/g, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)x08'});
\};


\textcolor{keyword}{function} isElement(node) \{
  \textcolor{keywordflow}{return} !!(node &&
    (node.nodeName  \textcolor{comment}{// we are a direct element}
    || (node.prop && node.attr && node.find)));  \textcolor{comment}{// we have an on and find method part of jQuery API}
\}

\textcolor{keyword}{function} makeMap(str) \{
  var obj = \{\}, items = str.split(\textcolor{stringliteral}{","}), i;
  \textcolor{keywordflow}{for} (i = 0; i < items.length; i++) \{
    obj[items[i]] = \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{return} obj;
\}


\textcolor{keyword}{function} nodeName\_(element) \{
  \textcolor{keywordflow}{return} lowercase(element.nodeName || (element[0] && element[0].nodeName));
\}

\textcolor{keyword}{function} includes(array, obj) \{
  \textcolor{keywordflow}{return} Array.prototype.indexOf.call(array, obj) != -1;
\}

\textcolor{keyword}{function} arrayRemove(array, value) \{
  var index = array.indexOf(value);
  \textcolor{keywordflow}{if} (index >= 0) \{
    array.splice(index, 1);
  \}
  \textcolor{keywordflow}{return} index;
\}

\textcolor{keyword}{function} copy(source, destination, stackSource, stackDest) \{
  \textcolor{keywordflow}{if} (isWindow(source) || isScope(source)) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpws'},
      \textcolor{stringliteral}{"Can't copy! Making copies of Window or Scope instances is not supported."});
  \}
  \textcolor{keywordflow}{if} (isTypedArray(destination)) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpta'},
      \textcolor{stringliteral}{"Can't copy! TypedArray destination cannot be mutated."});
  \}

  \textcolor{keywordflow}{if} (!destination) \{
    destination = source;
    \textcolor{keywordflow}{if} (isObject(source)) \{
      var index;
      \textcolor{keywordflow}{if} (stackSource && (index = stackSource.indexOf(source)) !== -1) \{
        \textcolor{keywordflow}{return} stackDest[index];
      \}

      \textcolor{comment}{// TypedArray, Date and RegExp have specific copy functionality and must be}
      \textcolor{comment}{// pushed onto the stack before returning.}
      \textcolor{comment}{// Array and other objects create the base object and recurse to copy child}
      \textcolor{comment}{// objects. The array/object will be pushed onto the stack when recursed.}
      \textcolor{keywordflow}{if} (isArray(source)) \{
        \textcolor{keywordflow}{return} copy(source, [], stackSource, stackDest);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isTypedArray(source)) \{
        destination = \textcolor{keyword}{new} source.constructor(source);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDate(source)) \{
        destination = \textcolor{keyword}{new} Date(source.getTime());
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(source)) \{
        destination = \textcolor{keyword}{new} RegExp(source.source, source.toString().match(/[^\(\backslash\)/]*$/)[0]);
        destination.lastIndex = source.lastIndex;
      \} \textcolor{keywordflow}{else} \{
        var emptyObject = Object.create(getPrototypeOf(source));
        \textcolor{keywordflow}{return} copy(source, emptyObject, stackSource, stackDest);
      \}

      \textcolor{keywordflow}{if} (stackDest) \{
        stackSource.push(source);
        stackDest.push(destination);
      \}
    \}
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{if} (source === destination) \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpi'},
      \textcolor{stringliteral}{"Can't copy! Source and destination are identical."});

    stackSource = stackSource || [];
    stackDest = stackDest || [];

    \textcolor{keywordflow}{if} (isObject(source)) \{
      stackSource.push(source);
      stackDest.push(destination);
    \}

    var result, key;
    \textcolor{keywordflow}{if} (isArray(source)) \{
      destination.length = 0;
      \textcolor{keywordflow}{for} (var i = 0; i < source.length; i++) \{
        destination.push(copy(source[i], null, stackSource, stackDest));
      \}
    \} \textcolor{keywordflow}{else} \{
      var h = destination.$$hashKey;
      \textcolor{keywordflow}{if} (isArray(destination)) \{
        destination.length = 0;
      \} \textcolor{keywordflow}{else} \{
        forEach(destination, \textcolor{keyword}{function}(value, key) \{
          \textcolor{keyword}{delete} destination[key];
        \});
      \}
      \textcolor{keywordflow}{if} (isBlankObject(source)) \{
        \textcolor{comment}{// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty}
        \textcolor{keywordflow}{for} (key in source) \{
          destination[key] = copy(source[key], null, stackSource, stackDest);
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (source && typeof source.hasOwnProperty === \textcolor{stringliteral}{'function'}) \{
        \textcolor{comment}{// Slow path, which must rely on hasOwnProperty}
        \textcolor{keywordflow}{for} (key in source) \{
          \textcolor{keywordflow}{if} (source.hasOwnProperty(key)) \{
            destination[key] = copy(source[key], null, stackSource, stackDest);
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Slowest path --- hasOwnProperty can't be called as a method}
        \textcolor{keywordflow}{for} (key in source) \{
          \textcolor{keywordflow}{if} (hasOwnProperty.call(source, key)) \{
            destination[key] = copy(source[key], null, stackSource, stackDest);
          \}
        \}
      \}
      setHashKey(destination,h);
    \}
  \}
  \textcolor{keywordflow}{return} destination;
\}

\textcolor{keyword}{function} shallowCopy(src, dst) \{
  \textcolor{keywordflow}{if} (isArray(src)) \{
    dst = dst || [];

    \textcolor{keywordflow}{for} (var i = 0, ii = src.length; i < ii; i++) \{
      dst[i] = src[i];
    \}
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(src)) \{
    dst = dst || \{\};

    \textcolor{keywordflow}{for} (var key in src) \{
      \textcolor{keywordflow}{if} (!(key.charAt(0) === \textcolor{charliteral}{'$'} && key.charAt(1) === \textcolor{charliteral}{'$'})) \{
        dst[key] = src[key];
      \}
    \}
  \}

  \textcolor{keywordflow}{return} dst || src;
\}


\textcolor{keyword}{function} equals(o1, o2) \{
  \textcolor{keywordflow}{if} (o1 === o2) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \textcolor{keywordflow}{if} (o1 === null || o2 === null) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \textcolor{keywordflow}{if} (o1 !== o1 && o2 !== o2) \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{// NaN === NaN}
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  \textcolor{keywordflow}{if} (t1 == t2) \{
    \textcolor{keywordflow}{if} (t1 == \textcolor{stringliteral}{'object'}) \{
      \textcolor{keywordflow}{if} (isArray(o1)) \{
        \textcolor{keywordflow}{if} (!isArray(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \textcolor{keywordflow}{if} ((length = o1.length) == o2.length) \{
          \textcolor{keywordflow}{for} (key = 0; key < length; key++) \{
            \textcolor{keywordflow}{if} (!equals(o1[key], o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          \}
          \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDate(o1)) \{
        \textcolor{keywordflow}{if} (!isDate(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \textcolor{keywordflow}{return} equals(o1.getTime(), o2.getTime());
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(o1)) \{
        \textcolor{keywordflow}{return} isRegExp(o2) ? o1.toString() == o2.toString() : \textcolor{keyword}{false};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
          isArray(o2) || isDate(o2) || isRegExp(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        keySet = createMap();
        \textcolor{keywordflow}{for} (key in o1) \{
          \textcolor{keywordflow}{if} (key.charAt(0) === \textcolor{charliteral}{'$'} || isFunction(o1[key])) \textcolor{keywordflow}{continue};
          \textcolor{keywordflow}{if} (!equals(o1[key], o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          keySet[key] = \textcolor{keyword}{true};
        \}
        \textcolor{keywordflow}{for} (key in o2) \{
          \textcolor{keywordflow}{if} (!(key in keySet) &&
              key.charAt(0) !== \textcolor{charliteral}{'$'} &&
              o2[key] !== undefined &&
              !isFunction(o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \}
    \}
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

var csp = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{if} (!isDefined(csp.rules)) \{


    var ngCspElement = (document.querySelector(\textcolor{stringliteral}{'[ng-csp]'}) ||
                    document.querySelector(\textcolor{stringliteral}{'[data-ng-csp]'}));

    \textcolor{keywordflow}{if} (ngCspElement) \{
      var ngCspAttribute = ngCspElement.getAttribute(\textcolor{stringliteral}{'ng-csp'}) ||
                    ngCspElement.getAttribute(\textcolor{stringliteral}{'data-ng-csp'});
      csp.rules = \{
        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf(\textcolor{stringliteral}{'no-unsafe-eval'}) !== -1),
        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf(\textcolor{stringliteral}{'no-inline-style'}) !== -1)
      \};
    \} \textcolor{keywordflow}{else} \{
      csp.rules = \{
        noUnsafeEval: noUnsafeEval(),
        noInlineStyle: \textcolor{keyword}{false}
      \};
    \}
  \}

  \textcolor{keywordflow}{return} csp.rules;

  \textcolor{keyword}{function} noUnsafeEval() \{
    \textcolor{keywordflow}{try} \{
      \textcolor{comment}{/* jshint -W031, -W054 */}
      \textcolor{keyword}{new} Function(\textcolor{stringliteral}{''});
      \textcolor{comment}{/* jshint +W031, +W054 */}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
  \}
\};

var jq = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{if} (isDefined(jq.name\_)) \textcolor{keywordflow}{return} jq.name\_;
  var el;
  var i, ii = ngAttrPrefixes.length, prefix, name;
  for (i = 0; i < ii; ++i) \{
    prefix = ngAttrPrefixes[i];
    \textcolor{keywordflow}{if} (el = document.querySelector(\textcolor{charliteral}{'['} + prefix.replace(\textcolor{charliteral}{':'}, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\):'}) + \textcolor{stringliteral}{'jq]'})) \{
      name = el.getAttribute(prefix + \textcolor{stringliteral}{'jq'});
      \textcolor{keywordflow}{break};
    \}
  \}

  \textcolor{keywordflow}{return} (jq.name\_ = name);
\};

\textcolor{keyword}{function} concat(array1, array2, index) \{
  \textcolor{keywordflow}{return} array1.concat(slice.call(array2, index));
\}

\textcolor{keyword}{function} sliceArgs(args, startIndex) \{
  \textcolor{keywordflow}{return} slice.call(args, startIndex || 0);
\}


\textcolor{comment}{/* jshint -W101 */}
\textcolor{comment}{/* jshint +W101 */}
\textcolor{keyword}{function} bind(\textcolor{keyword}{self}, fn) \{
  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  \textcolor{keywordflow}{if} (isFunction(fn) && !(fn instanceof RegExp)) \{
    \textcolor{keywordflow}{return} curryArgs.length
      ? \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} arguments.length
            ? fn.apply(\textcolor{keyword}{self}, concat(curryArgs, arguments, 0))
            : fn.apply(\textcolor{keyword}{self}, curryArgs);
        \}
      : \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} arguments.length
            ? fn.apply(\textcolor{keyword}{self}, arguments)
            : fn.call(\textcolor{keyword}{self});
        \};
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// in IE, native methods are not functions so they cannot be bound (note: they don't need to be)}
    \textcolor{keywordflow}{return} fn;
  \}
\}


\textcolor{keyword}{function} toJsonReplacer(key, value) \{
  var val = value;

  \textcolor{keywordflow}{if} (typeof key === \textcolor{stringliteral}{'string'} && key.charAt(0) === \textcolor{charliteral}{'$'} && key.charAt(1) === \textcolor{charliteral}{'$'}) \{
    val = undefined;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isWindow(value)) \{
    val = \textcolor{stringliteral}{'$WINDOW'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value &&  document === value) \{
    val = \textcolor{stringliteral}{'$DOCUMENT'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isScope(value)) \{
    val = \textcolor{stringliteral}{'$SCOPE'};
  \}

  \textcolor{keywordflow}{return} val;
\}


\textcolor{keyword}{function} toJson(obj, pretty) \{
  \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} undefined;
  \textcolor{keywordflow}{if} (!isNumber(pretty)) \{
    pretty = pretty ? 2 : null;
  \}
  \textcolor{keywordflow}{return} JSON.stringify(obj, toJsonReplacer, pretty);
\}


\textcolor{keyword}{function} fromJson(json) \{
  \textcolor{keywordflow}{return} isString(json)
      ? JSON.parse(json)
      : json;
\}


\textcolor{keyword}{function} timezoneToOffset(timezone, fallback) \{
  var requestedTimezoneOffset = Date.parse(\textcolor{stringliteral}{'Jan 01, 1970 00:00:00 '} + timezone) / 60000;
  \textcolor{keywordflow}{return} isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
\}


\textcolor{keyword}{function} addDateMinutes(date, minutes) \{
  date = \textcolor{keyword}{new} Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  \textcolor{keywordflow}{return} date;
\}


\textcolor{keyword}{function} convertTimezoneToLocal(date, timezone, reverse) \{
  reverse = reverse ? -1 : 1;
  var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
  \textcolor{keywordflow}{return} addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
\}


\textcolor{keyword}{function} startingTag(element) \{
  element = jqLite(element).clone();
  \textcolor{keywordflow}{try} \{
    \textcolor{comment}{// turns out IE does not let you set .html() on elements which}
    \textcolor{comment}{// are not allowed to have children. So we just ignore it.}
    element.empty();
  \} \textcolor{keywordflow}{catch} (e) \{\}
  var elemHtml = jqLite(\textcolor{stringliteral}{'<div>'}).append(element).html();
  \textcolor{keywordflow}{try} \{
    \textcolor{keywordflow}{return} element[0].nodeType === NODE\_TYPE\_TEXT ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\(\backslash\)w\(\backslash\)-]+)/, function(match, nodeName) \{ \textcolor{keywordflow}{return} \textcolor{charliteral}{'<'} + lowercase(nodeName); \});
  \} \textcolor{keywordflow}{catch} (e) \{
    \textcolor{keywordflow}{return} lowercase(elemHtml);
  \}

\}



\textcolor{keyword}{function} tryDecodeURIComponent(value) \{
  \textcolor{keywordflow}{try} \{
    \textcolor{keywordflow}{return} decodeURIComponent(value);
  \} \textcolor{keywordflow}{catch} (e) \{
    \textcolor{comment}{// Ignore any invalid uri component}
  \}
\}


\textcolor{keyword}{function} parseKeyValue(keyValue) \{
  var obj = \{\};
  forEach((keyValue || \textcolor{stringliteral}{""}).split(\textcolor{charliteral}{'&'}), \textcolor{keyword}{function}(keyValue) \{
    var splitPoint, key, val;
    \textcolor{keywordflow}{if} (keyValue) \{
      key = keyValue = keyValue.replace(/\(\backslash\)+/g,\textcolor{stringliteral}{'%20'});
      splitPoint = keyValue.indexOf(\textcolor{charliteral}{'='});
      \textcolor{keywordflow}{if} (splitPoint !== -1) \{
        key = keyValue.substring(0, splitPoint);
        val = keyValue.substring(splitPoint + 1);
      \}
      key = tryDecodeURIComponent(key);
      \textcolor{keywordflow}{if} (isDefined(key)) \{
        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
        \textcolor{keywordflow}{if} (!hasOwnProperty.call(obj, key)) \{
          obj[key] = val;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(obj[key])) \{
          obj[key].push(val);
        \} \textcolor{keywordflow}{else} \{
          obj[key] = [obj[key],val];
        \}
      \}
    \}
  \});
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} toKeyValue(obj) \{
  var parts = [];
  forEach(obj, \textcolor{keyword}{function}(value, key) \{
    \textcolor{keywordflow}{if} (isArray(value)) \{
      forEach(value, \textcolor{keyword}{function}(arrayValue) \{
        parts.push(encodeUriQuery(key, \textcolor{keyword}{true}) +
                   (arrayValue === \textcolor{keyword}{true} ? \textcolor{stringliteral}{''} : \textcolor{charliteral}{'='} + encodeUriQuery(arrayValue, \textcolor{keyword}{true})));
      \});
    \} \textcolor{keywordflow}{else} \{
    parts.push(encodeUriQuery(key, \textcolor{keyword}{true}) +
               (value === \textcolor{keyword}{true} ? \textcolor{stringliteral}{''} : \textcolor{charliteral}{'='} + encodeUriQuery(value, \textcolor{keyword}{true})));
    \}
  \});
  \textcolor{keywordflow}{return} parts.length ? parts.join(\textcolor{charliteral}{'&'}) : \textcolor{stringliteral}{''};
\}


\textcolor{keyword}{function} encodeUriSegment(val) \{
  \textcolor{keywordflow}{return} encodeUriQuery(val, \textcolor{keyword}{true}).
             replace(/%26/gi, \textcolor{charliteral}{'&'}).
             replace(/%3D/gi, \textcolor{charliteral}{'='}).
             replace(/%2B/gi, \textcolor{charliteral}{'+'});
\}


\textcolor{keyword}{function} encodeUriQuery(val, pctEncodeSpaces) \{
  \textcolor{keywordflow}{return} encodeURIComponent(val).
             replace(/%40/gi, \textcolor{charliteral}{'@'}).
             replace(/%3A/gi, \textcolor{charliteral}{':'}).
             replace(/%24/g, \textcolor{charliteral}{'$'}).
             replace(/%2C/gi, \textcolor{charliteral}{','}).
             replace(/%3B/gi, \textcolor{charliteral}{';'}).
             replace(/%20/g, (pctEncodeSpaces ? \textcolor{stringliteral}{'%20'} : \textcolor{charliteral}{'+'}));
\}

var ngAttrPrefixes = [\textcolor{stringliteral}{'ng-'}, \textcolor{stringliteral}{'data-ng-'}, \textcolor{stringliteral}{'ng:'}, \textcolor{stringliteral}{'x-ng-'}];

\textcolor{keyword}{function} getNgAttribute(element, ngAttr) \{
  var attr, i, ii = ngAttrPrefixes.length;
  \textcolor{keywordflow}{for} (i = 0; i < ii; ++i) \{
    attr = ngAttrPrefixes[i] + ngAttr;
    \textcolor{keywordflow}{if} (isString(attr = element.getAttribute(attr))) \{
      \textcolor{keywordflow}{return} attr;
    \}
  \}
  \textcolor{keywordflow}{return} null;
\}

\textcolor{keyword}{function} angularInit(element, bootstrap) \{
  var appElement,
      module,
      config = \{\};

  \textcolor{comment}{// The element `element` has priority over any other element}
  forEach(ngAttrPrefixes, \textcolor{keyword}{function}(prefix) \{
    var name = prefix + \textcolor{stringliteral}{'app'};

    \textcolor{keywordflow}{if} (!appElement && element.hasAttribute && element.hasAttribute(name)) \{
      appElement = element;
      module = element.getAttribute(name);
    \}
  \});
  forEach(ngAttrPrefixes, \textcolor{keyword}{function}(prefix) \{
    var name = prefix + \textcolor{stringliteral}{'app'};
    var candidate;

    \textcolor{keywordflow}{if} (!appElement && (candidate = element.querySelector(\textcolor{charliteral}{'['} + name.replace(\textcolor{charliteral}{':'}, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\):'}) + \textcolor{charliteral}{']'}))) \{
      appElement = candidate;
      module = candidate.getAttribute(name);
    \}
  \});
  \textcolor{keywordflow}{if} (appElement) \{
    config.strictDi = getNgAttribute(appElement, \textcolor{stringliteral}{"strict-di"}) !== null;
    bootstrap(appElement, module ? [module] : [], config);
  \}
\}

\textcolor{keyword}{function} bootstrap(element, modules, config) \{
  \textcolor{keywordflow}{if} (!isObject(config)) config = \{\};
  var defaultConfig = \{
    strictDi: \textcolor{keyword}{false}
  \};
  config = extend(defaultConfig, config);
  var doBootstrap = \textcolor{keyword}{function}() \{
    element = jqLite(element);

    \textcolor{keywordflow}{if} (element.injector()) \{
      var tag = (element[0] === document) ? \textcolor{stringliteral}{'document'} : startingTag(element);
      \textcolor{comment}{//Encode angle brackets to prevent input from being sanitized to empty string #8683}
      \textcolor{keywordflow}{throw} ngMinErr(
          \textcolor{stringliteral}{'btstrpd'},
          \textcolor{stringliteral}{"App Already Bootstrapped with this Element '\{0\}'"},
          tag.replace(/</,\textcolor{stringliteral}{'&lt;'}).replace(/>/,\textcolor{stringliteral}{'&gt;'}));
    \}

    modules = modules || [];
    modules.unshift([\textcolor{stringliteral}{'$provide'}, \textcolor{keyword}{function}($provide) \{
      $provide.value(\textcolor{stringliteral}{'$rootElement'}, element);
    \}]);

    \textcolor{keywordflow}{if} (config.debugInfoEnabled) \{
      \textcolor{comment}{// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.}
      modules.push([\textcolor{stringliteral}{'$compileProvider'}, \textcolor{keyword}{function}($compileProvider) \{
        $compileProvider.debugInfoEnabled(\textcolor{keyword}{true});
      \}]);
    \}

    modules.unshift(\textcolor{stringliteral}{'ng'});
    var injector = createInjector(modules, config.strictDi);
    injector.invoke([\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$rootElement'}, \textcolor{stringliteral}{'$compile'}, \textcolor{stringliteral}{'$injector'},
       \textcolor{keyword}{function} bootstrapApply(scope, element, compile, injector) \{
        scope.$apply(\textcolor{keyword}{function}() \{
          element.data(\textcolor{stringliteral}{'$injector'}, injector);
          compile(element)(scope);
        \});
      \}]
    );
    \textcolor{keywordflow}{return} injector;
  \};

  var NG\_ENABLE\_DEBUG\_INFO = /^NG\_ENABLE\_DEBUG\_INFO!/;
  var NG\_DEFER\_BOOTSTRAP = /^NG\_DEFER\_BOOTSTRAP!/;

  \textcolor{keywordflow}{if} (window && NG\_ENABLE\_DEBUG\_INFO.test(window.name)) \{
    config.debugInfoEnabled = \textcolor{keyword}{true};
    window.name = window.name.replace(NG\_ENABLE\_DEBUG\_INFO, \textcolor{stringliteral}{''});
  \}

  \textcolor{keywordflow}{if} (window && !NG\_DEFER\_BOOTSTRAP.test(window.name)) \{
    \textcolor{keywordflow}{return} doBootstrap();
  \}

  window.name = window.name.replace(NG\_DEFER\_BOOTSTRAP, \textcolor{stringliteral}{''});
  angular.resumeBootstrap = \textcolor{keyword}{function}(extraModules) \{
    forEach(extraModules, \textcolor{keyword}{function}(module) \{
      modules.push(module);
    \});
    \textcolor{keywordflow}{return} doBootstrap();
  \};

  \textcolor{keywordflow}{if} (isFunction(angular.resumeDeferredBootstrap)) \{
    angular.resumeDeferredBootstrap();
  \}
\}

\textcolor{keyword}{function} reloadWithDebugInfo() \{
  window.name = \textcolor{stringliteral}{'NG\_ENABLE\_DEBUG\_INFO!'} + window.name;
  window.location.reload();
\}

\textcolor{keyword}{function} getTestability(rootElement) \{
  var injector = angular.element(rootElement).injector();
  \textcolor{keywordflow}{if} (!injector) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'test'},
      \textcolor{stringliteral}{'no injector found for element argument to getTestability'});
  \}
  \textcolor{keywordflow}{return} injector.get(\textcolor{stringliteral}{'$$testability'});
\}

var SNAKE\_CASE\_REGEXP = /[A-Z]/g;
\textcolor{keyword}{function} snake\_case(name, separator) \{
  separator = separator || \textcolor{charliteral}{'\_'};
  \textcolor{keywordflow}{return} name.replace(SNAKE\_CASE\_REGEXP, \textcolor{keyword}{function}(letter, pos) \{
    \textcolor{keywordflow}{return} (pos ? separator : \textcolor{stringliteral}{''}) + letter.toLowerCase();
  \});
\}

var bindJQueryFired = \textcolor{keyword}{false};
var skipDestroyOnNextJQueryCleanData;
\textcolor{keyword}{function} bindJQuery() \{
  var originalCleanData;

  \textcolor{keywordflow}{if} (bindJQueryFired) \{
    \textcolor{keywordflow}{return};
  \}

  \textcolor{comment}{// bind to jQuery if present;}
  var jqName = jq();
  jQuery = window.jQuery; \textcolor{comment}{// use default jQuery.}
  \textcolor{keywordflow}{if} (isDefined(jqName)) \{ \textcolor{comment}{// `ngJq` present}
    jQuery = jqName === null ? undefined : window[jqName]; \textcolor{comment}{// if empty; use jqLite. if not empty, use
       jQuery specified by `ngJq`.}
  \}

  \textcolor{comment}{// Use jQuery if it exists with proper functionality, otherwise default to us.}
  \textcolor{comment}{// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.}
  \textcolor{comment}{// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older}
  \textcolor{comment}{// versions. It will not work for sure with jQuery <1.7, though.}
  \textcolor{keywordflow}{if} (jQuery && jQuery.fn.on) \{
    jqLite = jQuery;
    extend(jQuery.fn, \{
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    \});

    \textcolor{comment}{// All nodes removed from the DOM via various jQuery APIs like .remove()}
    \textcolor{comment}{// are passed through jQuery.cleanData. Monkey-patch this method to fire}
    \textcolor{comment}{// the $destroy event on all removed nodes.}
    originalCleanData = jQuery.cleanData;
    jQuery.cleanData = \textcolor{keyword}{function}(elems) \{
      var events;
      \textcolor{keywordflow}{if} (!skipDestroyOnNextJQueryCleanData) \{
        \textcolor{keywordflow}{for} (var i = 0, elem; (elem = elems[i]) != null; i++) \{
          events = jQuery.\_data(elem, \textcolor{stringliteral}{"events"});
          \textcolor{keywordflow}{if} (events && events.$destroy) \{
            jQuery(elem).triggerHandler(\textcolor{stringliteral}{'$destroy'});
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        skipDestroyOnNextJQueryCleanData = \textcolor{keyword}{false};
      \}
      originalCleanData(elems);
    \};
  \} \textcolor{keywordflow}{else} \{
    jqLite = JQLite;
  \}

  angular.element = jqLite;

  \textcolor{comment}{// Prevent double-proxying.}
  bindJQueryFired = \textcolor{keyword}{true};
\}

\textcolor{keyword}{function} assertArg(arg, name, reason) \{
  \textcolor{keywordflow}{if} (!arg) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'areq'}, \textcolor{stringliteral}{"Argument '\{0\}' is \{1\}"}, (name || \textcolor{charliteral}{'?'}), (reason || \textcolor{stringliteral}{"required"}));
  \}
  \textcolor{keywordflow}{return} arg;
\}

\textcolor{keyword}{function} assertArgFn(arg, name, acceptArrayAnnotation) \{
  \textcolor{keywordflow}{if} (acceptArrayAnnotation && isArray(arg)) \{
      arg = arg[arg.length - 1];
  \}

  assertArg(isFunction(arg), name, \textcolor{stringliteral}{'not a function, got '} +
      (arg && typeof arg === \textcolor{stringliteral}{'object'} ? arg.constructor.name || \textcolor{stringliteral}{'Object'} : typeof arg));
  \textcolor{keywordflow}{return} arg;
\}

\textcolor{keyword}{function} assertNotHasOwnProperty(name, context) \{
  \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'hasOwnProperty'}) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'badname'}, \textcolor{stringliteral}{"hasOwnProperty is not a valid \{0\} name"}, context);
  \}
\}

\textcolor{comment}{//TODO(misko): this function needs to be removed}
\textcolor{keyword}{function} getter(obj, path, bindFnToScope) \{
  \textcolor{keywordflow}{if} (!path) \textcolor{keywordflow}{return} obj;
  var keys = path.split(\textcolor{charliteral}{'.'});
  var key;
  var lastInstance = obj;
  var len = keys.length;

  \textcolor{keywordflow}{for} (var i = 0; i < len; i++) \{
    key = keys[i];
    \textcolor{keywordflow}{if} (obj) \{
      obj = (lastInstance = obj)[key];
    \}
  \}
  \textcolor{keywordflow}{if} (!bindFnToScope && isFunction(obj)) \{
    \textcolor{keywordflow}{return} bind(lastInstance, obj);
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} getBlockNodes(nodes) \{
  \textcolor{comment}{// TODO(perf): just check if all items in `nodes` are siblings and if they are return the original}
  \textcolor{comment}{//             collection, otherwise update the original collection.}
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  \textcolor{keywordflow}{do} \{
    node = node.nextSibling;
    \textcolor{keywordflow}{if} (!node) \textcolor{keywordflow}{break};
    blockNodes.push(node);
  \} \textcolor{keywordflow}{while} (node !== endNode);

  \textcolor{keywordflow}{return} jqLite(blockNodes);
\}


\textcolor{keyword}{function} createMap() \{
  \textcolor{keywordflow}{return} Object.create(null);
\}

var NODE\_TYPE\_ELEMENT = 1;
var NODE\_TYPE\_ATTRIBUTE = 2;
var NODE\_TYPE\_TEXT = 3;
var NODE\_TYPE\_COMMENT = 8;
var NODE\_TYPE\_DOCUMENT = 9;
var NODE\_TYPE\_DOCUMENT\_FRAGMENT = 11;

\textcolor{keyword}{function} setupModuleLoader(window) \{

  var $injectorMinErr = minErr(\textcolor{stringliteral}{'$injector'});
  var ngMinErr = minErr(\textcolor{stringliteral}{'ng'});

  \textcolor{keyword}{function} ensure(obj, name, factory) \{
    \textcolor{keywordflow}{return} obj[name] || (obj[name] = factory());
  \}

  var angular = ensure(window, \textcolor{stringliteral}{'angular'}, Object);

  \textcolor{comment}{// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during
       bootstrap}
  angular.$$minErr = angular.$$minErr || minErr;

  \textcolor{keywordflow}{return} ensure(angular, \textcolor{stringliteral}{'module'}, \textcolor{keyword}{function}() \{
    var modules = \{\};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function} module(name, requires, configFn) \{
      var assertNotHasOwnProperty = \textcolor{keyword}{function}(name, context) \{
        \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'hasOwnProperty'}) \{
          \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'badname'}, \textcolor{stringliteral}{'hasOwnProperty is not a valid \{0\} name'}, context);
        \}
      \};

      assertNotHasOwnProperty(name, \textcolor{stringliteral}{'module'});
      \textcolor{keywordflow}{if} (requires && modules.hasOwnProperty(name)) \{
        modules[name] = null;
      \}
      \textcolor{keywordflow}{return} ensure(modules, name, \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!requires) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'nomod'}, \textcolor{stringliteral}{"Module '\{0\}' is not available! You either misspelled "} +
             \textcolor{stringliteral}{"the module name or forgot to load it. If registering a module ensure that you "} +
             \textcolor{stringliteral}{"specify the dependencies as the second argument."}, name);
        \}

        var invokeQueue = [];

        var configBlocks = [];

        var runBlocks = [];

        var config = invokeLater(\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'invoke'}, \textcolor{stringliteral}{'push'}, configBlocks);

        var moduleInstance = \{
          \textcolor{comment}{// Private state}
          \_invokeQueue: invokeQueue,
          \_configBlocks: configBlocks,
          \_runBlocks: runBlocks,

          requires: requires,

          name: name,


          provider: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'provider'}),

          factory: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'factory'}),

          service: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'service'}),

          value: invokeLater(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'value'}),

          constant: invokeLater(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'constant'}, \textcolor{stringliteral}{'unshift'}),

          decorator: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'decorator'}),

          animation: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$animateProvider'}, \textcolor{stringliteral}{'register'}),

          filter: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$filterProvider'}, \textcolor{stringliteral}{'register'}),

          controller: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$controllerProvider'}, \textcolor{stringliteral}{'register'}),

          directive: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$compileProvider'}, \textcolor{stringliteral}{'directive'}),

          config: config,

          run: \textcolor{keyword}{function}(block) \{
            runBlocks.push(block);
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
          \}
        \};

        \textcolor{keywordflow}{if} (configFn) \{
          config(configFn);
        \}

        \textcolor{keywordflow}{return} moduleInstance;

        \textcolor{keyword}{function} invokeLater(provider, method, insertMethod, queue) \{
          \textcolor{keywordflow}{if} (!queue) queue = invokeQueue;
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            queue[insertMethod || \textcolor{stringliteral}{'push'}]([provider, method, arguments]);
            \textcolor{keywordflow}{return} moduleInstance;
          \};
        \}

        \textcolor{keyword}{function} invokeLaterAndSetModuleName(provider, method) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}(recipeName, factoryFunction) \{
            \textcolor{keywordflow}{if} (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
            invokeQueue.push([provider, method, arguments]);
            \textcolor{keywordflow}{return} moduleInstance;
          \};
        \}
      \});
    \};
  \});

\}

\textcolor{comment}{/* global: toDebugString: true */}

\textcolor{keyword}{function} serializeObject(obj) \{
  var seen = [];

  \textcolor{keywordflow}{return} JSON.stringify(obj, \textcolor{keyword}{function}(key, val) \{
    val = toJsonReplacer(key, val);
    \textcolor{keywordflow}{if} (isObject(val)) \{

      \textcolor{keywordflow}{if} (seen.indexOf(val) >= 0) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'<<already seen>>'};

      seen.push(val);
    \}
    \textcolor{keywordflow}{return} val;
  \});
\}

\textcolor{keyword}{function} toDebugString(obj) \{
  \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'function'}) \{
    \textcolor{keywordflow}{return} obj.toString().replace(/ \(\backslash\)\{[\(\backslash\)s\(\backslash\)S]*$/, \textcolor{stringliteral}{''});
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'undefined'}) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'undefined'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj !== \textcolor{stringliteral}{'string'}) \{
    \textcolor{keywordflow}{return} serializeObject(obj);
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{comment}{/* global angularModule: true,}
\textcolor{comment}{  version: true,}
\textcolor{comment}{}
\textcolor{comment}{  $CompileProvider,}
\textcolor{comment}{}
\textcolor{comment}{  htmlAnchorDirective,}
\textcolor{comment}{  inputDirective,}
\textcolor{comment}{  inputDirective,}
\textcolor{comment}{  formDirective,}
\textcolor{comment}{  scriptDirective,}
\textcolor{comment}{  selectDirective,}
\textcolor{comment}{  styleDirective,}
\textcolor{comment}{  optionDirective,}
\textcolor{comment}{  ngBindDirective,}
\textcolor{comment}{  ngBindHtmlDirective,}
\textcolor{comment}{  ngBindTemplateDirective,}
\textcolor{comment}{  ngClassDirective,}
\textcolor{comment}{  ngClassEvenDirective,}
\textcolor{comment}{  ngClassOddDirective,}
\textcolor{comment}{  ngCloakDirective,}
\textcolor{comment}{  ngControllerDirective,}
\textcolor{comment}{  ngFormDirective,}
\textcolor{comment}{  ngHideDirective,}
\textcolor{comment}{  ngIfDirective,}
\textcolor{comment}{  ngIncludeDirective,}
\textcolor{comment}{  ngIncludeFillContentDirective,}
\textcolor{comment}{  ngInitDirective,}
\textcolor{comment}{  ngNonBindableDirective,}
\textcolor{comment}{  ngPluralizeDirective,}
\textcolor{comment}{  ngRepeatDirective,}
\textcolor{comment}{  ngShowDirective,}
\textcolor{comment}{  ngStyleDirective,}
\textcolor{comment}{  ngSwitchDirective,}
\textcolor{comment}{  ngSwitchWhenDirective,}
\textcolor{comment}{  ngSwitchDefaultDirective,}
\textcolor{comment}{  ngOptionsDirective,}
\textcolor{comment}{  ngTranscludeDirective,}
\textcolor{comment}{  ngModelDirective,}
\textcolor{comment}{  ngListDirective,}
\textcolor{comment}{  ngChangeDirective,}
\textcolor{comment}{  patternDirective,}
\textcolor{comment}{  patternDirective,}
\textcolor{comment}{  requiredDirective,}
\textcolor{comment}{  requiredDirective,}
\textcolor{comment}{  minlengthDirective,}
\textcolor{comment}{  minlengthDirective,}
\textcolor{comment}{  maxlengthDirective,}
\textcolor{comment}{  maxlengthDirective,}
\textcolor{comment}{  ngValueDirective,}
\textcolor{comment}{  ngModelOptionsDirective,}
\textcolor{comment}{  ngAttributeAliasDirectives,}
\textcolor{comment}{  ngEventDirectives,}
\textcolor{comment}{}
\textcolor{comment}{  $AnchorScrollProvider,}
\textcolor{comment}{  $AnimateProvider,}
\textcolor{comment}{  $CoreAnimateCssProvider,}
\textcolor{comment}{  $$CoreAnimateQueueProvider,}
\textcolor{comment}{  $$CoreAnimateRunnerProvider,}
\textcolor{comment}{  $BrowserProvider,}
\textcolor{comment}{  $CacheFactoryProvider,}
\textcolor{comment}{  $ControllerProvider,}
\textcolor{comment}{  $DocumentProvider,}
\textcolor{comment}{  $ExceptionHandlerProvider,}
\textcolor{comment}{  $FilterProvider,}
\textcolor{comment}{  $$ForceReflowProvider,}
\textcolor{comment}{  $InterpolateProvider,}
\textcolor{comment}{  $IntervalProvider,}
\textcolor{comment}{  $$HashMapProvider,}
\textcolor{comment}{  $HttpProvider,}
\textcolor{comment}{  $HttpParamSerializerProvider,}
\textcolor{comment}{  $HttpParamSerializerJQLikeProvider,}
\textcolor{comment}{  $HttpBackendProvider,}
\textcolor{comment}{  $LocationProvider,}
\textcolor{comment}{  $LogProvider,}
\textcolor{comment}{  $ParseProvider,}
\textcolor{comment}{  $RootScopeProvider,}
\textcolor{comment}{  $QProvider,}
\textcolor{comment}{  $$QProvider,}
\textcolor{comment}{  $$SanitizeUriProvider,}
\textcolor{comment}{  $SceProvider,}
\textcolor{comment}{  $SceDelegateProvider,}
\textcolor{comment}{  $SnifferProvider,}
\textcolor{comment}{  $TemplateCacheProvider,}
\textcolor{comment}{  $TemplateRequestProvider,}
\textcolor{comment}{  $$TestabilityProvider,}
\textcolor{comment}{  $TimeoutProvider,}
\textcolor{comment}{  $$RAFProvider,}
\textcolor{comment}{  $WindowProvider,}
\textcolor{comment}{  $$jqLiteProvider,}
\textcolor{comment}{  $$CookieReaderProvider}
\textcolor{comment}{*/}


var version = \{
  full: \textcolor{stringliteral}{'1.4.4'},    \textcolor{comment}{// all of these placeholder strings will be replaced by grunt's}
  major: 1,    \textcolor{comment}{// package task}
  minor: 4,
  dot: 4,
  codeName: \textcolor{stringliteral}{'pylon-requirement'}
\};


\textcolor{keyword}{function} publishExternalAPI(angular) \{
  extend(angular, \{
    \textcolor{stringliteral}{'bootstrap'}: bootstrap,
    \textcolor{stringliteral}{'copy'}: copy,
    \textcolor{stringliteral}{'extend'}: extend,
    \textcolor{stringliteral}{'merge'}: merge,
    \textcolor{stringliteral}{'equals'}: equals,
    \textcolor{stringliteral}{'element'}: jqLite,
    \textcolor{stringliteral}{'forEach'}: forEach,
    \textcolor{stringliteral}{'injector'}: createInjector,
    \textcolor{stringliteral}{'noop'}: noop,
    \textcolor{stringliteral}{'bind'}: bind,
    \textcolor{stringliteral}{'toJson'}: toJson,
    \textcolor{stringliteral}{'fromJson'}: fromJson,
    \textcolor{stringliteral}{'identity'}: identity,
    \textcolor{stringliteral}{'isUndefined'}: isUndefined,
    \textcolor{stringliteral}{'isDefined'}: isDefined,
    \textcolor{stringliteral}{'isString'}: isString,
    \textcolor{stringliteral}{'isFunction'}: isFunction,
    \textcolor{stringliteral}{'isObject'}: isObject,
    \textcolor{stringliteral}{'isNumber'}: isNumber,
    \textcolor{stringliteral}{'isElement'}: isElement,
    \textcolor{stringliteral}{'isArray'}: isArray,
    \textcolor{stringliteral}{'version'}: version,
    \textcolor{stringliteral}{'isDate'}: isDate,
    \textcolor{stringliteral}{'lowercase'}: lowercase,
    \textcolor{stringliteral}{'uppercase'}: uppercase,
    \textcolor{stringliteral}{'callbacks'}: \{counter: 0\},
    \textcolor{stringliteral}{'getTestability'}: getTestability,
    \textcolor{stringliteral}{'$$minErr'}: minErr,
    \textcolor{stringliteral}{'$$csp'}: csp,
    \textcolor{stringliteral}{'reloadWithDebugInfo'}: reloadWithDebugInfo
  \});

  angularModule = setupModuleLoader(window);

  angularModule(\textcolor{stringliteral}{'ng'}, [\textcolor{stringliteral}{'ngLocale'}], [\textcolor{stringliteral}{'$provide'},
    \textcolor{keyword}{function} ngModule($provide) \{
      \textcolor{comment}{// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.}
      $provide.provider(\{
        $$sanitizeUri: $$SanitizeUriProvider
      \});
      $provide.provider(\textcolor{stringliteral}{'$compile'}, $CompileProvider).
        directive(\{
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
        \}).
        directive(\{
          ngInclude: ngIncludeFillContentDirective
        \}).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider(\{
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $animateCss: $CoreAnimateCssProvider,
        $$animateQueue: $$CoreAnimateQueueProvider,
        $$AnimateRunner: $$CoreAnimateRunnerProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $$forceReflow: $$ForceReflowProvider,
        $interpolate: $InterpolateProvider,
        $interval: $IntervalProvider,
        $http: $HttpProvider,
        $httpParamSerializer: $HttpParamSerializerProvider,
        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $$q: $$QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $templateRequest: $TemplateRequestProvider,
        $$testability: $$TestabilityProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider,
        $$rAF: $$RAFProvider,
        $$jqLite: $$jqLiteProvider,
        $$HashMap: $$HashMapProvider,
        $$cookieReader: $$CookieReaderProvider
      \});
    \}
  ]);
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

\textcolor{comment}{/* global JQLitePrototype: true,}
\textcolor{comment}{  addEventListenerFn: true,}
\textcolor{comment}{  removeEventListenerFn: true,}
\textcolor{comment}{  BOOLEAN\_ATTR: true,}
\textcolor{comment}{  ALIASED\_ATTR: true,}
\textcolor{comment}{*/}

\textcolor{comment}{//JQLite}
\textcolor{comment}{}
JQLite.expando = \textcolor{stringliteral}{'ng339'};

var jqCache = JQLite.cache = \{\},
    jqId = 1,
    addEventListenerFn = \textcolor{keyword}{function}(element, type, fn) \{
      element.addEventListener(type, fn, \textcolor{keyword}{false});
    \},
    removeEventListenerFn = \textcolor{keyword}{function}(element, type, fn) \{
      element.removeEventListener(type, fn, \textcolor{keyword}{false});
    \};

\textcolor{comment}{/*}
\textcolor{comment}{ * !!! This is an undocumented "private" function !!!}
\textcolor{comment}{ */}
JQLite.\_data = \textcolor{keyword}{function}(node) \{
  \textcolor{comment}{//jQuery always returns an object on cache miss}
  \textcolor{keywordflow}{return} this.cache[node[this.expando]] || \{\};
\};

\textcolor{keyword}{function} jqNextId() \{ \textcolor{keywordflow}{return} ++jqId; \}


var SPECIAL\_CHARS\_REGEXP = /([\(\backslash\):\(\backslash\)-\(\backslash\)\_]+(.))/g;
var MOZ\_HACK\_REGEXP = /^moz([A-Z])/;
var MOUSE\_EVENT\_MAP= \{ mouseleave: \textcolor{stringliteral}{"mouseout"}, mouseenter: \textcolor{stringliteral}{"mouseover"}\};
var jqLiteMinErr = minErr(\textcolor{stringliteral}{'jqLite'});

\textcolor{keyword}{function} camelCase(name) \{
  \textcolor{keywordflow}{return} name.
    replace(SPECIAL\_CHARS\_REGEXP, \textcolor{keyword}{function}(\_, separator, letter, offset) \{
      \textcolor{keywordflow}{return} offset ? letter.toUpperCase() : letter;
    \}).
    replace(MOZ\_HACK\_REGEXP, \textcolor{stringliteral}{'Moz$1'});
\}

var SINGLE\_TAG\_REGEXP = /^<(\(\backslash\)w+)\(\backslash\)s*\(\backslash\)/?>(?:<\(\backslash\)/\(\backslash\)1>|)$/;
var HTML\_REGEXP = /<|&#?\(\backslash\)w+;/;
var TAG\_NAME\_REGEXP = /<([\(\backslash\)w:]+)/;
var XHTML\_TAG\_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\(\backslash\)w:]+)[^>]*)\(\backslash\)/>/gi;

var wrapMap = \{
  \textcolor{stringliteral}{'option'}: [1, \textcolor{stringliteral}{'<select multiple="multiple">'}, \textcolor{stringliteral}{'</select>'}],

  \textcolor{stringliteral}{'thead'}: [1, \textcolor{stringliteral}{'<table>'}, \textcolor{stringliteral}{'</table>'}],
  \textcolor{stringliteral}{'col'}: [2, \textcolor{stringliteral}{'<table><colgroup>'}, \textcolor{stringliteral}{'</colgroup></table>'}],
  \textcolor{stringliteral}{'tr'}: [2, \textcolor{stringliteral}{'<table><tbody>'}, \textcolor{stringliteral}{'</tbody></table>'}],
  \textcolor{stringliteral}{'td'}: [3, \textcolor{stringliteral}{'<table><tbody><tr>'}, \textcolor{stringliteral}{'</tr></tbody></table>'}],
  \textcolor{stringliteral}{'\_default'}: [0, \textcolor{stringliteral}{""}, \textcolor{stringliteral}{""}]
\};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


\textcolor{keyword}{function} jqLiteIsTextNode(html) \{
  \textcolor{keywordflow}{return} !HTML\_REGEXP.test(html);
\}

\textcolor{keyword}{function} jqLiteAcceptsData(node) \{
  \textcolor{comment}{// The window object can accept data but has no nodeType}
  \textcolor{comment}{// Otherwise we are only interested in elements (1) and documents (9)}
  var nodeType = node.nodeType;
  \textcolor{keywordflow}{return} nodeType === NODE\_TYPE\_ELEMENT || !nodeType || nodeType === NODE\_TYPE\_DOCUMENT;
\}

\textcolor{keyword}{function} jqLiteHasData(node) \{
  \textcolor{keywordflow}{for} (var key in jqCache[node.ng339]) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

\textcolor{keyword}{function} jqLiteBuildFragment(html, context) \{
  var tmp, tag, wrap,
      fragment = context.createDocumentFragment(),
      nodes = [], i;

  \textcolor{keywordflow}{if} (jqLiteIsTextNode(html)) \{
    \textcolor{comment}{// Convert non-html into a text node}
    nodes.push(context.createTextNode(html));
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// Convert html into DOM nodes}
    tmp = tmp || fragment.appendChild(context.createElement(\textcolor{stringliteral}{"div"}));
    tag = (TAG\_NAME\_REGEXP.exec(html) || [\textcolor{stringliteral}{""}, \textcolor{stringliteral}{""}])[1].toLowerCase();
    wrap = wrapMap[tag] || wrapMap.\_default;
    tmp.innerHTML = wrap[1] + html.replace(XHTML\_TAG\_REGEXP, \textcolor{stringliteral}{"<$1></$2>"}) + wrap[2];

    \textcolor{comment}{// Descend through wrappers to the right content}
    i = wrap[0];
    \textcolor{keywordflow}{while} (i--) \{
      tmp = tmp.lastChild;
    \}

    nodes = concat(nodes, tmp.childNodes);

    tmp = fragment.firstChild;
    tmp.textContent = \textcolor{stringliteral}{""};
  \}

  \textcolor{comment}{// Remove wrapper from fragment}
  fragment.textContent = \textcolor{stringliteral}{""};
  fragment.innerHTML = \textcolor{stringliteral}{""}; \textcolor{comment}{// Clear inner HTML}
  forEach(nodes, \textcolor{keyword}{function}(node) \{
    fragment.appendChild(node);
  \});

  \textcolor{keywordflow}{return} fragment;
\}

\textcolor{keyword}{function} jqLiteParseHTML(html, context) \{
  context = context || document;
  var parsed;

  \textcolor{keywordflow}{if} ((parsed = SINGLE\_TAG\_REGEXP.exec(html))) \{
    \textcolor{keywordflow}{return} [context.createElement(parsed[1])];
  \}

  \textcolor{keywordflow}{if} ((parsed = jqLiteBuildFragment(html, context))) \{
    \textcolor{keywordflow}{return} parsed.childNodes;
  \}

  \textcolor{keywordflow}{return} [];
\}

\textcolor{keyword}{function} JQLite(element) \{
  \textcolor{keywordflow}{if} (element instanceof JQLite) \{
    \textcolor{keywordflow}{return} element;
  \}

  var argIsString;

  \textcolor{keywordflow}{if} (isString(element)) \{
    element = trim(element);
    argIsString = \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{if} (!(\textcolor{keyword}{this} instanceof JQLite)) \{
    \textcolor{keywordflow}{if} (argIsString && element.charAt(0) != \textcolor{charliteral}{'<'}) \{
      \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'nosel'}, \textcolor{stringliteral}{'Looking up elements via selectors is not supported by jqLite! See:
       http://docs.angularjs.org/api/angular.element'});
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} JQLite(element);
  \}

  \textcolor{keywordflow}{if} (argIsString) \{
    jqLiteAddNodes(\textcolor{keyword}{this}, jqLiteParseHTML(element));
  \} \textcolor{keywordflow}{else} \{
    jqLiteAddNodes(\textcolor{keyword}{this}, element);
  \}
\}

\textcolor{keyword}{function} jqLiteClone(element) \{
  \textcolor{keywordflow}{return} element.cloneNode(\textcolor{keyword}{true});
\}

\textcolor{keyword}{function} jqLiteDealoc(element, onlyDescendants) \{
  \textcolor{keywordflow}{if} (!onlyDescendants) jqLiteRemoveData(element);

  \textcolor{keywordflow}{if} (element.querySelectorAll) \{
    var descendants = element.querySelectorAll(\textcolor{charliteral}{'*'});
    \textcolor{keywordflow}{for} (var i = 0, l = descendants.length; i < l; i++) \{
      jqLiteRemoveData(descendants[i]);
    \}
  \}
\}

\textcolor{keyword}{function} jqLiteOff(element, type, fn, unsupported) \{
  \textcolor{keywordflow}{if} (isDefined(unsupported)) \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'offargs'}, \textcolor{stringliteral}{'jqLite#off() does not support the `selector`
       argument'});

  var expandoStore = jqLiteExpandoStore(element);
  var events = expandoStore && expandoStore.events;
  var handle = expandoStore && expandoStore.handle;

  \textcolor{keywordflow}{if} (!handle) \textcolor{keywordflow}{return}; \textcolor{comment}{//no listeners registered}

  \textcolor{keywordflow}{if} (!type) \{
    \textcolor{keywordflow}{for} (type in events) \{
      \textcolor{keywordflow}{if} (type !== \textcolor{stringliteral}{'$destroy'}) \{
        removeEventListenerFn(element, type, handle);
      \}
      \textcolor{keyword}{delete} events[type];
    \}
  \} \textcolor{keywordflow}{else} \{
    forEach(type.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(type) \{
      \textcolor{keywordflow}{if} (isDefined(fn)) \{
        var listenerFns = events[type];
        arrayRemove(listenerFns || [], fn);
        \textcolor{keywordflow}{if} (listenerFns && listenerFns.length > 0) \{
          \textcolor{keywordflow}{return};
        \}
      \}

      removeEventListenerFn(element, type, handle);
      \textcolor{keyword}{delete} events[type];
    \});
  \}
\}

\textcolor{keyword}{function} jqLiteRemoveData(element, name) \{
  var expandoId = element.ng339;
  var expandoStore = expandoId && jqCache[expandoId];

  \textcolor{keywordflow}{if} (expandoStore) \{
    \textcolor{keywordflow}{if} (name) \{
      \textcolor{keyword}{delete} expandoStore.data[name];
      \textcolor{keywordflow}{return};
    \}

    \textcolor{keywordflow}{if} (expandoStore.handle) \{
      \textcolor{keywordflow}{if} (expandoStore.events.$destroy) \{
        expandoStore.handle(\{\}, \textcolor{stringliteral}{'$destroy'});
      \}
      jqLiteOff(element);
    \}
    \textcolor{keyword}{delete} jqCache[expandoId];
    element.ng339 = undefined; \textcolor{comment}{// don't delete DOM expandos. IE and Chrome don't like it}
  \}
\}


\textcolor{keyword}{function} jqLiteExpandoStore(element, createIfNecessary) \{
  var expandoId = element.ng339,
      expandoStore = expandoId && jqCache[expandoId];

  \textcolor{keywordflow}{if} (createIfNecessary && !expandoStore) \{
    element.ng339 = expandoId = jqNextId();
    expandoStore = jqCache[expandoId] = \{events: \{\}, data: \{\}, handle: undefined\};
  \}

  \textcolor{keywordflow}{return} expandoStore;
\}


\textcolor{keyword}{function} jqLiteData(element, key, value) \{
  \textcolor{keywordflow}{if} (jqLiteAcceptsData(element)) \{

    var isSimpleSetter = isDefined(value);
    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
    var massGetter = !key;
    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
    var data = expandoStore && expandoStore.data;

    \textcolor{keywordflow}{if} (isSimpleSetter) \{ \textcolor{comment}{// data('key', value)}
      data[key] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (massGetter) \{  \textcolor{comment}{// data()}
        \textcolor{keywordflow}{return} data;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (isSimpleGetter) \{ \textcolor{comment}{// data('key')}
          \textcolor{comment}{// don't force creation of expandoStore if it doesn't exist yet}
          \textcolor{keywordflow}{return} data && data[key];
        \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// mass-setter: data(\{key1: val1, key2: val2\})}
          extend(data, key);
        \}
      \}
    \}
  \}
\}

\textcolor{keyword}{function} jqLiteHasClass(element, selector) \{
  \textcolor{keywordflow}{if} (!element.getAttribute) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \textcolor{keywordflow}{return} ((\textcolor{stringliteral}{" "} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{stringliteral}{" "}).replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "}).
      indexOf(\textcolor{stringliteral}{" "} + selector + \textcolor{stringliteral}{" "}) > -1);
\}

\textcolor{keyword}{function} jqLiteRemoveClass(element, cssClasses) \{
  \textcolor{keywordflow}{if} (cssClasses && element.setAttribute) \{
    forEach(cssClasses.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(cssClass) \{
      element.setAttribute(\textcolor{stringliteral}{'class'}, trim(
          (\textcolor{stringliteral}{" "} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{stringliteral}{" "})
          .replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "})
          .replace(\textcolor{stringliteral}{" "} + trim(cssClass) + \textcolor{stringliteral}{" "}, \textcolor{stringliteral}{" "}))
      );
    \});
  \}
\}

\textcolor{keyword}{function} jqLiteAddClass(element, cssClasses) \{
  \textcolor{keywordflow}{if} (cssClasses && element.setAttribute) \{
    var existingClasses = (\textcolor{charliteral}{' '} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{charliteral}{' '})
                            .replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "});

    forEach(cssClasses.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(cssClass) \{
      cssClass = trim(cssClass);
      \textcolor{keywordflow}{if} (existingClasses.indexOf(\textcolor{charliteral}{' '} + cssClass + \textcolor{charliteral}{' '}) === -1) \{
        existingClasses += cssClass + \textcolor{charliteral}{' '};
      \}
    \});

    element.setAttribute(\textcolor{stringliteral}{'class'}, trim(existingClasses));
  \}
\}


\textcolor{keyword}{function} jqLiteAddNodes(root, elements) \{
  \textcolor{comment}{// THIS CODE IS VERY HOT. Don't make changes without benchmarking.}

  \textcolor{keywordflow}{if} (elements) \{

    \textcolor{comment}{// if a Node (the most common case)}
    \textcolor{keywordflow}{if} (elements.nodeType) \{
      root[root.length++] = elements;
    \} \textcolor{keywordflow}{else} \{
      var length = elements.length;

      \textcolor{comment}{// if an Array or NodeList and not a Window}
      \textcolor{keywordflow}{if} (typeof length === \textcolor{stringliteral}{'number'} && elements.window !== elements) \{
        \textcolor{keywordflow}{if} (length) \{
          \textcolor{keywordflow}{for} (var i = 0; i < length; i++) \{
            root[root.length++] = elements[i];
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        root[root.length++] = elements;
      \}
    \}
  \}
\}


\textcolor{keyword}{function} jqLiteController(element, name) \{
  \textcolor{keywordflow}{return} jqLiteInheritedData(element, \textcolor{charliteral}{'$'} + (name || \textcolor{stringliteral}{'ngController'}) + \textcolor{stringliteral}{'Controller'});
\}

\textcolor{keyword}{function} jqLiteInheritedData(element, name, value) \{
  \textcolor{comment}{// if element is the document object work with the html element instead}
  \textcolor{comment}{// this makes $(document).scope() possible}
  \textcolor{keywordflow}{if} (element.nodeType == NODE\_TYPE\_DOCUMENT) \{
    element = element.documentElement;
  \}
  var names = isArray(name) ? name : [name];

  \textcolor{keywordflow}{while} (element) \{
    \textcolor{keywordflow}{for} (var i = 0, ii = names.length; i < ii; i++) \{
      \textcolor{keywordflow}{if} ((value = jqLite.data(element, names[i])) !== undefined) \textcolor{keywordflow}{return} value;
    \}

    \textcolor{comment}{// If dealing with a document fragment node with a host element, and no parent, use the host}
    \textcolor{comment}{// element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM}
    \textcolor{comment}{// to lookup parent controllers.}
    element = element.parentNode || (element.nodeType === NODE\_TYPE\_DOCUMENT\_FRAGMENT && element.host);
  \}
\}

\textcolor{keyword}{function} jqLiteEmpty(element) \{
  jqLiteDealoc(element, \textcolor{keyword}{true});
  \textcolor{keywordflow}{while} (element.firstChild) \{
    element.removeChild(element.firstChild);
  \}
\}

\textcolor{keyword}{function} jqLiteRemove(element, keepData) \{
  \textcolor{keywordflow}{if} (!keepData) jqLiteDealoc(element);
  var parent = element.parentNode;
  \textcolor{keywordflow}{if} (parent) parent.removeChild(element);
\}


\textcolor{keyword}{function} jqLiteDocumentLoaded(action, win) \{
  win = win || window;
  \textcolor{keywordflow}{if} (win.document.readyState === \textcolor{stringliteral}{'complete'}) \{
    \textcolor{comment}{// Force the action to be run async for consistent behaviour}
    \textcolor{comment}{// from the action's point of view}
    \textcolor{comment}{// i.e. it will definitely not be in a $apply}
    win.setTimeout(action);
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// No need to unbind this handler as load is only ever called once}
    jqLite(win).on(\textcolor{stringliteral}{'load'}, action);
  \}
\}

\textcolor{comment}{// Functions which are declared directly.}
\textcolor{comment}{}var JQLitePrototype = JQLite.prototype = \{
  ready: \textcolor{keyword}{function}(fn) \{
    var fired = \textcolor{keyword}{false};

    \textcolor{keyword}{function} trigger() \{
      \textcolor{keywordflow}{if} (fired) \textcolor{keywordflow}{return};
      fired = \textcolor{keyword}{true};
      fn();
    \}

    \textcolor{comment}{// check if document is already loaded}
    \textcolor{keywordflow}{if} (document.readyState === \textcolor{stringliteral}{'complete'}) \{
      setTimeout(trigger);
    \} \textcolor{keywordflow}{else} \{
      this.on(\textcolor{stringliteral}{'DOMContentLoaded'}, trigger); \textcolor{comment}{// works for modern browsers and IE9}
      \textcolor{comment}{// we can not use jqLite since we are not done loading and jQuery could be loaded later.}
      \textcolor{comment}{// jshint -W064}
      JQLite(window).on(\textcolor{stringliteral}{'load'}, trigger); \textcolor{comment}{// fallback to window.onload for others}
      \textcolor{comment}{// jshint +W064}
    \}
  \},
  toString: \textcolor{keyword}{function}() \{
    var value = [];
    forEach(\textcolor{keyword}{this}, \textcolor{keyword}{function}(e) \{ value.push(\textcolor{stringliteral}{''} + e);\});
    \textcolor{keywordflow}{return} \textcolor{charliteral}{'['} + value.join(\textcolor{stringliteral}{', '}) + \textcolor{charliteral}{']'};
  \},

  eq: \textcolor{keyword}{function}(index) \{
      \textcolor{keywordflow}{return} (index >= 0) ? jqLite(\textcolor{keyword}{this}[index]) : jqLite(this[this.length + index]);
  \},

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
\};

\textcolor{comment}{// Functions iterating getter/setters.}
\textcolor{comment}{// these functions return self on setter and}
\textcolor{comment}{// value on get.}
\textcolor{comment}{}var BOOLEAN\_ATTR = \{\};
forEach(\textcolor{stringliteral}{'multiple,selected,checked,disabled,readOnly,required,open'}.split(\textcolor{charliteral}{','}), \textcolor{keyword}{function}(value) \{
  BOOLEAN\_ATTR[lowercase(value)] = value;
\});
var BOOLEAN\_ELEMENTS = \{\};
forEach(\textcolor{stringliteral}{'input,select,option,textarea,button,form,details'}.split(\textcolor{charliteral}{','}), \textcolor{keyword}{function}(value) \{
  BOOLEAN\_ELEMENTS[value] = \textcolor{keyword}{true};
\});
var ALIASED\_ATTR = \{
  \textcolor{stringliteral}{'ngMinlength'}: \textcolor{stringliteral}{'minlength'},
  \textcolor{stringliteral}{'ngMaxlength'}: \textcolor{stringliteral}{'maxlength'},
  \textcolor{stringliteral}{'ngMin'}: \textcolor{stringliteral}{'min'},
  \textcolor{stringliteral}{'ngMax'}: \textcolor{stringliteral}{'max'},
  \textcolor{stringliteral}{'ngPattern'}: \textcolor{stringliteral}{'pattern'}
\};

\textcolor{keyword}{function} getBooleanAttrName(element, name) \{
  \textcolor{comment}{// check dom last since we will most likely fail on name}
  var booleanAttr = BOOLEAN\_ATTR[name.toLowerCase()];

  \textcolor{comment}{// booleanAttr is here twice to minimize DOM access}
  \textcolor{keywordflow}{return} booleanAttr && BOOLEAN\_ELEMENTS[nodeName\_(element)] && booleanAttr;
\}

\textcolor{keyword}{function} getAliasedAttrName(element, name) \{
  var nodeName = element.nodeName;
  \textcolor{keywordflow}{return} (nodeName === \textcolor{stringliteral}{'INPUT'} || nodeName === \textcolor{stringliteral}{'TEXTAREA'}) && ALIASED\_ATTR[name];
\}

forEach(\{
  data: jqLiteData,
  removeData: jqLiteRemoveData,
  hasData: jqLiteHasData
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite[name] = fn;
\});

forEach(\{
  data: jqLiteData,
  inheritedData: jqLiteInheritedData,

  scope: \textcolor{keyword}{function}(element) \{
    \textcolor{comment}{// Can't use jqLiteData here directly so we stay compatible with jQuery!}
    \textcolor{keywordflow}{return} jqLite.data(element, \textcolor{stringliteral}{'$scope'}) || jqLiteInheritedData(element.parentNode || element, [\textcolor{stringliteral}{'
      $isolateScope'}, \textcolor{stringliteral}{'$scope'}]);
  \},

  isolateScope: \textcolor{keyword}{function}(element) \{
    \textcolor{comment}{// Can't use jqLiteData here directly so we stay compatible with jQuery!}
    \textcolor{keywordflow}{return} jqLite.data(element, \textcolor{stringliteral}{'$isolateScope'}) || jqLite.data(element, \textcolor{stringliteral}{'$isolateScopeNoTemplate'});
  \},

  controller: jqLiteController,

  injector: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} jqLiteInheritedData(element, \textcolor{stringliteral}{'$injector'});
  \},

  removeAttr: \textcolor{keyword}{function}(element, name) \{
    element.removeAttribute(name);
  \},

  hasClass: jqLiteHasClass,

  css: \textcolor{keyword}{function}(element, name, value) \{
    name = camelCase(name);

    \textcolor{keywordflow}{if} (isDefined(value)) \{
      element.style[name] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} element.style[name];
    \}
  \},

  attr: \textcolor{keyword}{function}(element, name, value) \{
    var nodeType = element.nodeType;
    \textcolor{keywordflow}{if} (nodeType === NODE\_TYPE\_TEXT || nodeType === NODE\_TYPE\_ATTRIBUTE || nodeType === NODE\_TYPE\_COMMENT) 
      \{
      \textcolor{keywordflow}{return};
    \}
    var lowercasedName = lowercase(name);
    \textcolor{keywordflow}{if} (BOOLEAN\_ATTR[lowercasedName]) \{
      \textcolor{keywordflow}{if} (isDefined(value)) \{
        \textcolor{keywordflow}{if} (!!value) \{
          element[name] = \textcolor{keyword}{true};
          element.setAttribute(name, lowercasedName);
        \} \textcolor{keywordflow}{else} \{
          element[name] = \textcolor{keyword}{false};
          element.removeAttribute(lowercasedName);
        \}
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} (element[name] ||
                 (element.attributes.getNamedItem(name) || noop).specified)
               ? lowercasedName
               : undefined;
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDefined(value)) \{
      element.setAttribute(name, value);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (element.getAttribute) \{
      \textcolor{comment}{// the extra argument "2" is to get the right thing for a.href in IE, see jQuery code}
      \textcolor{comment}{// some elements (e.g. Document) don't have get attribute, so return undefined}
      var ret = element.getAttribute(name, 2);
      \textcolor{comment}{// normalize non-existing attributes to undefined (as jQuery)}
      \textcolor{keywordflow}{return} ret === null ? undefined : ret;
    \}
  \},

  prop: \textcolor{keyword}{function}(element, name, value) \{
    \textcolor{keywordflow}{if} (isDefined(value)) \{
      element[name] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} element[name];
    \}
  \},

  text: (\textcolor{keyword}{function}() \{
    getText.$dv = \textcolor{stringliteral}{''};
    \textcolor{keywordflow}{return} getText;

    \textcolor{keyword}{function} getText(element, value) \{
      \textcolor{keywordflow}{if} (isUndefined(value)) \{
        var nodeType = element.nodeType;
        \textcolor{keywordflow}{return} (nodeType === NODE\_TYPE\_ELEMENT || nodeType === NODE\_TYPE\_TEXT) ? element.textContent : \textcolor{stringliteral}{''};
      \}
      element.textContent = value;
    \}
  \})(),

  val: \textcolor{keyword}{function}(element, value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{if} (element.multiple && nodeName\_(element) === \textcolor{stringliteral}{'select'}) \{
        var result = [];
        forEach(element.options, \textcolor{keyword}{function}(option) \{
          if (option.selected) \{
            result.push(option.value || option.text);
          \}
        \});
        \textcolor{keywordflow}{return} result.length === 0 ? null : result;
      \}
      \textcolor{keywordflow}{return} element.value;
    \}
    element.value = value;
  \},

  html: \textcolor{keyword}{function}(element, value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{return} element.innerHTML;
    \}
    jqLiteDealoc(element, \textcolor{keyword}{true});
    element.innerHTML = value;
  \},

  empty: jqLiteEmpty
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite.prototype[name] = \textcolor{keyword}{function}(arg1, arg2) \{
    var i, key;
    var nodeCount = this.length;

    \textcolor{comment}{// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it}
    \textcolor{comment}{// in a way that survives minification.}
    \textcolor{comment}{// jqLiteEmpty takes no arguments but is a setter.}
    \textcolor{keywordflow}{if} (fn !== jqLiteEmpty &&
        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === 
      undefined)) \{
      \textcolor{keywordflow}{if} (isObject(arg1)) \{

        \textcolor{comment}{// we are a write, but the object properties are the key/values}
        \textcolor{keywordflow}{for} (i = 0; i < nodeCount; i++) \{
          \textcolor{keywordflow}{if} (fn === jqLiteData) \{
            \textcolor{comment}{// data() takes the whole object in jQuery}
            fn(\textcolor{keyword}{this}[i], arg1);
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{for} (key in arg1) \{
              fn(\textcolor{keyword}{this}[i], key, arg1[key]);
            \}
          \}
        \}
        \textcolor{comment}{// return self for chaining}
        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// we are a read, so read the first child.}
        \textcolor{comment}{// TODO: do we still need this?}
        var value = fn.$dv;
        \textcolor{comment}{// Only if we have $dv do we iterate over all, otherwise it is just the first element.}
        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
        \textcolor{keywordflow}{for} (var j = 0; j < jj; j++) \{
          var nodeValue = fn(\textcolor{keyword}{this}[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        \}
        \textcolor{keywordflow}{return} value;
      \}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// we are a write, so apply to all children}
      \textcolor{keywordflow}{for} (i = 0; i < nodeCount; i++) \{
        fn(\textcolor{keyword}{this}[i], arg1, arg2);
      \}
      \textcolor{comment}{// return self for chaining}
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
  \};
\});

\textcolor{keyword}{function} createEventHandler(element, events) \{
  var eventHandler = \textcolor{keyword}{function}(event, type) \{
    \textcolor{comment}{// jQuery specific api}
    \textcolor{keyword}{event}.isDefaultPrevented = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{event}.defaultPrevented;
    \};

    var eventFns = events[type || \textcolor{keyword}{event}.type];
    var eventFnsLength = eventFns ? eventFns.length : 0;

    \textcolor{keywordflow}{if} (!eventFnsLength) \textcolor{keywordflow}{return};

    \textcolor{keywordflow}{if} (isUndefined(event.immediatePropagationStopped)) \{
      var originalStopImmediatePropagation = \textcolor{keyword}{event}.stopImmediatePropagation;
      \textcolor{keyword}{event}.stopImmediatePropagation = \textcolor{keyword}{function}() \{
        \textcolor{keyword}{event}.immediatePropagationStopped = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (event.stopPropagation) \{
          \textcolor{keyword}{event}.stopPropagation();
        \}

        \textcolor{keywordflow}{if} (originalStopImmediatePropagation) \{
          originalStopImmediatePropagation.call(event);
        \}
      \};
    \}

    \textcolor{keyword}{event}.isImmediatePropagationStopped = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{event}.immediatePropagationStopped === \textcolor{keyword}{true};
    \};

    \textcolor{comment}{// Copy event handlers in case event handlers array is modified during execution.}
    \textcolor{keywordflow}{if} ((eventFnsLength > 1)) \{
      eventFns = shallowCopy(eventFns);
    \}

    \textcolor{keywordflow}{for} (var i = 0; i < eventFnsLength; i++) \{
      \textcolor{keywordflow}{if} (!event.isImmediatePropagationStopped()) \{
        eventFns[i].call(element, event);
      \}
    \}
  \};

  \textcolor{comment}{// TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all}
  \textcolor{comment}{//       events on `element`}
  eventHandler.elem = element;
  \textcolor{keywordflow}{return} eventHandler;
\}

\textcolor{comment}{// Functions iterating traversal.}
\textcolor{comment}{// These functions chain results into a single}
\textcolor{comment}{// selector.}
\textcolor{comment}{}forEach(\{
  removeData: jqLiteRemoveData,

  on: \textcolor{keyword}{function} jqLiteOn(element, type, fn, unsupported) \{
    \textcolor{keywordflow}{if} (isDefined(unsupported)) \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'onargs'}, \textcolor{stringliteral}{'jqLite#on() does not support the `selector`
       or `eventData` parameters'});

    \textcolor{comment}{// Do not add event handlers to non-elements because they will not be cleaned up.}
    \textcolor{keywordflow}{if} (!jqLiteAcceptsData(element)) \{
      \textcolor{keywordflow}{return};
    \}

    var expandoStore = jqLiteExpandoStore(element, \textcolor{keyword}{true});
    var events = expandoStore.events;
    var handle = expandoStore.handle;

    \textcolor{keywordflow}{if} (!handle) \{
      handle = expandoStore.handle = createEventHandler(element, events);
    \}

    \textcolor{comment}{// http://jsperf.com/string-indexof-vs-split}
    var types = type.indexOf(\textcolor{charliteral}{' '}) >= 0 ? type.split(\textcolor{charliteral}{' '}) : [type];
    var i = types.length;

    \textcolor{keywordflow}{while} (i--) \{
      type = types[i];
      var eventFns = events[type];

      \textcolor{keywordflow}{if} (!eventFns) \{
        events[type] = [];

        \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'mouseenter'} || type === \textcolor{stringliteral}{'mouseleave'}) \{
          \textcolor{comment}{// Refer to jQuery's implementation of mouseenter & mouseleave}
          \textcolor{comment}{// Read about mouseenter and mouseleave:}
          \textcolor{comment}{// http://www.quirksmode.org/js/events\_mouse.html#link8}

          jqLiteOn(element, MOUSE\_EVENT\_MAP[type], \textcolor{keyword}{function}(event) \{
            var target = \textcolor{keyword}{this}, related = \textcolor{keyword}{event}.relatedTarget;
            \textcolor{comment}{// For mousenter/leave call the handler if related is outside the target.}
            \textcolor{comment}{// NB: No relatedTarget if the mouse left/entered the browser window}
            \textcolor{keywordflow}{if} (!related || (related !== target && !target.contains(related))) \{
              handle(event, type);
            \}
          \});

        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (type !== \textcolor{stringliteral}{'$destroy'}) \{
            addEventListenerFn(element, type, handle);
          \}
        \}
        eventFns = events[type];
      \}
      eventFns.push(fn);
    \}
  \},

  off: jqLiteOff,

  one: \textcolor{keyword}{function}(element, type, fn) \{
    element = jqLite(element);

    \textcolor{comment}{//add the listener twice so that when it is called}
    \textcolor{comment}{//you can remove the original function and still be}
    \textcolor{comment}{//able to call element.off(ev, fn) normally}
    element.on(type, \textcolor{keyword}{function} onFn() \{
      element.off(type, fn);
      element.off(type, onFn);
    \});
    element.on(type, fn);
  \},

  replaceWith: \textcolor{keyword}{function}(element, replaceNode) \{
    var index, parent = element.parentNode;
    jqLiteDealoc(element);
    forEach(\textcolor{keyword}{new} JQLite(replaceNode), \textcolor{keyword}{function}(node) \{
      \textcolor{keywordflow}{if} (index) \{
        parent.insertBefore(node, index.nextSibling);
      \} \textcolor{keywordflow}{else} \{
        parent.replaceChild(node, element);
      \}
      index = node;
    \});
  \},

  children: \textcolor{keyword}{function}(element) \{
    var children = [];
    forEach(element.childNodes, \textcolor{keyword}{function}(element) \{
      if (element.nodeType === NODE\_TYPE\_ELEMENT) \{
        children.push(element);
      \}
    \});
    \textcolor{keywordflow}{return} children;
  \},

  contents: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} element.contentDocument || element.childNodes || [];
  \},

  append: \textcolor{keyword}{function}(element, node) \{
    var nodeType = element.nodeType;
    \textcolor{keywordflow}{if} (nodeType !== NODE\_TYPE\_ELEMENT && nodeType !== NODE\_TYPE\_DOCUMENT\_FRAGMENT) \textcolor{keywordflow}{return};

    node = \textcolor{keyword}{new} JQLite(node);

    \textcolor{keywordflow}{for} (var i = 0, ii = node.length; i < ii; i++) \{
      var child = node[i];
      element.appendChild(child);
    \}
  \},

  prepend: \textcolor{keyword}{function}(element, node) \{
    \textcolor{keywordflow}{if} (element.nodeType === NODE\_TYPE\_ELEMENT) \{
      var index = element.firstChild;
      forEach(\textcolor{keyword}{new} JQLite(node), \textcolor{keyword}{function}(child) \{
        element.insertBefore(child, index);
      \});
    \}
  \},

  wrap: \textcolor{keyword}{function}(element, wrapNode) \{
    wrapNode = jqLite(wrapNode).eq(0).clone()[0];
    var parent = element.parentNode;
    \textcolor{keywordflow}{if} (parent) \{
      parent.replaceChild(wrapNode, element);
    \}
    wrapNode.appendChild(element);
  \},

  \textcolor{keyword}{remove}: jqLiteRemove,

  detach: \textcolor{keyword}{function}(element) \{
    jqLiteRemove(element, \textcolor{keyword}{true});
  \},

  after: \textcolor{keyword}{function}(element, newElement) \{
    var index = element, parent = element.parentNode;
    newElement = \textcolor{keyword}{new} JQLite(newElement);

    \textcolor{keywordflow}{for} (var i = 0, ii = newElement.length; i < ii; i++) \{
      var node = newElement[i];
      parent.insertBefore(node, index.nextSibling);
      index = node;
    \}
  \},

  addClass: jqLiteAddClass,
  removeClass: jqLiteRemoveClass,

  toggleClass: \textcolor{keyword}{function}(element, selector, condition) \{
    \textcolor{keywordflow}{if} (selector) \{
      forEach(selector.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(className) \{
        var classCondition = condition;
        \textcolor{keywordflow}{if} (isUndefined(classCondition)) \{
          classCondition = !jqLiteHasClass(element, className);
        \}
        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
      \});
    \}
  \},

  parent: \textcolor{keyword}{function}(element) \{
    var parent = element.parentNode;
    \textcolor{keywordflow}{return} parent && parent.nodeType !== NODE\_TYPE\_DOCUMENT\_FRAGMENT ? parent : null;
  \},

  next: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} element.nextElementSibling;
  \},

  find: \textcolor{keyword}{function}(element, selector) \{
    \textcolor{keywordflow}{if} (element.getElementsByTagName) \{
      \textcolor{keywordflow}{return} element.getElementsByTagName(selector);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} [];
    \}
  \},

  clone: jqLiteClone,

  triggerHandler: \textcolor{keyword}{function}(element, event, extraParameters) \{

    var dummyEvent, eventFnsCopy, handlerArgs;
    var eventName = \textcolor{keyword}{event}.type || event;
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var eventFns = events && events[eventName];

    \textcolor{keywordflow}{if} (eventFns) \{
      \textcolor{comment}{// Create a dummy event to pass to the handlers}
      dummyEvent = \{
        preventDefault: \textcolor{keyword}{function}() \{ this.defaultPrevented = \textcolor{keyword}{true}; \},
        isDefaultPrevented: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} this.defaultPrevented === \textcolor{keyword}{true}; \},
        stopImmediatePropagation: \textcolor{keyword}{function}() \{ this.immediatePropagationStopped = \textcolor{keyword}{true}; \},
        isImmediatePropagationStopped: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} this.immediatePropagationStopped === \textcolor{keyword}{true}; \},
        stopPropagation: noop,
        type: eventName,
        target: element
      \};

      \textcolor{comment}{// If a custom event was provided then extend our dummy event with it}
      \textcolor{keywordflow}{if} (event.type) \{
        dummyEvent = extend(dummyEvent, event);
      \}

      \textcolor{comment}{// Copy event handlers in case event handlers array is modified during execution.}
      eventFnsCopy = shallowCopy(eventFns);
      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];

      forEach(eventFnsCopy, \textcolor{keyword}{function}(fn) \{
        \textcolor{keywordflow}{if} (!dummyEvent.isImmediatePropagationStopped()) \{
          fn.apply(element, handlerArgs);
        \}
      \});
    \}
  \}
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite.prototype[name] = \textcolor{keyword}{function}(arg1, arg2, arg3) \{
    var value;

    \textcolor{keywordflow}{for} (var i = 0, ii = this.length; i < ii; i++) \{
      \textcolor{keywordflow}{if} (isUndefined(value)) \{
        value = fn(\textcolor{keyword}{this}[i], arg1, arg2, arg3);
        \textcolor{keywordflow}{if} (isDefined(value)) \{
          \textcolor{comment}{// any function which returns a value needs to be wrapped}
          value = jqLite(value);
        \}
      \} \textcolor{keywordflow}{else} \{
        jqLiteAddNodes(value, fn(\textcolor{keyword}{this}[i], arg1, arg2, arg3));
      \}
    \}
    \textcolor{keywordflow}{return} isDefined(value) ? value : \textcolor{keyword}{this};
  \};

  \textcolor{comment}{// bind legacy bind/unbind to on/off}
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
\});


\textcolor{comment}{// Provider for private $$jqLite service}
\textcolor{keyword}{function} $$jqLiteProvider() \{
  this.$get = \textcolor{keyword}{function} $$jqLite() \{
    \textcolor{keywordflow}{return} extend(JQLite, \{
      hasClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteHasClass(node, classes);
      \},
      addClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteAddClass(node, classes);
      \},
      removeClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteRemoveClass(node, classes);
      \}
    \});
  \};
\}

\textcolor{keyword}{function} hashKey(obj, nextUidFn) \{
  var key = obj && obj.$$hashKey;

  \textcolor{keywordflow}{if} (key) \{
    \textcolor{keywordflow}{if} (typeof key === \textcolor{stringliteral}{'function'}) \{
      key = obj.$$hashKey();
    \}
    \textcolor{keywordflow}{return} key;
  \}

  var objType = typeof obj;
  \textcolor{keywordflow}{if} (objType == \textcolor{stringliteral}{'function'} || (objType == \textcolor{stringliteral}{'object'} && obj !== null)) \{
    key = obj.$$hashKey = objType + \textcolor{charliteral}{':'} + (nextUidFn || nextUid)();
  \} \textcolor{keywordflow}{else} \{
    key = objType + \textcolor{charliteral}{':'} + obj;
  \}

  \textcolor{keywordflow}{return} key;
\}

\textcolor{keyword}{function} HashMap(array, isolatedUid) \{
  \textcolor{keywordflow}{if} (isolatedUid) \{
    var uid = 0;
    this.nextUid = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} ++uid;
    \};
  \}
  forEach(array, this.put, \textcolor{keyword}{this});
\}
HashMap.prototype = \{
  put: \textcolor{keyword}{function}(key, value) \{
    \textcolor{keyword}{this}[hashKey(key, this.nextUid)] = value;
  \},

  \textcolor{keyword}{get}: \textcolor{keyword}{function}(key) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{this}[hashKey(key, this.nextUid)];
  \},

  \textcolor{keyword}{remove}: \textcolor{keyword}{function}(key) \{
    var value = \textcolor{keyword}{this}[key = hashKey(key, this.nextUid)];
    \textcolor{keyword}{delete} \textcolor{keyword}{this}[key];
    \textcolor{keywordflow}{return} value;
  \}
\};

var $$HashMapProvider = [\textcolor{keyword}{function}() \{
  this.$get = [\textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} HashMap;
  \}];
\}];

var FN\_ARGS = /^[^\(\backslash\)(]*\(\backslash\)(\(\backslash\)s*([^\(\backslash\))]*)\(\backslash\))/m;
var FN\_ARG\_SPLIT = /,/;
var FN\_ARG = /^\(\backslash\)s*(\_?)(\(\backslash\)S+?)\(\backslash\)1\(\backslash\)s*$/;
var STRIP\_COMMENTS = /((\(\backslash\)/\(\backslash\)/.*$)|(\(\backslash\)/\(\backslash\)*[\(\backslash\)s\(\backslash\)S]*?\(\backslash\)*\(\backslash\)/))/mg;
var $injectorMinErr = minErr(\textcolor{stringliteral}{'$injector'});

\textcolor{keyword}{function} anonFn(fn) \{
  \textcolor{comment}{// For anonymous functions, showing at the very least the function signature can help in}
  \textcolor{comment}{// debugging.}
  var fnText = fn.toString().replace(STRIP\_COMMENTS, \textcolor{stringliteral}{''}),
      args = fnText.match(FN\_ARGS);
  \textcolor{keywordflow}{if} (args) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'function('} + (args[1] || \textcolor{stringliteral}{''}).replace(/[\(\backslash\)s\(\backslash\)r\(\backslash\)n]+/, \textcolor{charliteral}{' '}) + \textcolor{charliteral}{')'};
  \}
  \textcolor{keywordflow}{return} \textcolor{stringliteral}{'fn'};
\}

\textcolor{keyword}{function} annotate(fn, strictDi, name) \{
  var $inject,
      fnText,
      argDecl,
      last;

  \textcolor{keywordflow}{if} (typeof fn === \textcolor{stringliteral}{'function'}) \{
    \textcolor{keywordflow}{if} (!($inject = fn.$inject)) \{
      $inject = [];
      \textcolor{keywordflow}{if} (fn.length) \{
        \textcolor{keywordflow}{if} (strictDi) \{
          \textcolor{keywordflow}{if} (!isString(name) || !name) \{
            name = fn.name || anonFn(fn);
          \}
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'strictdi'},
            \textcolor{stringliteral}{'\{0\} is not using explicit annotation and cannot be invoked in strict mode'}, name);
        \}
        fnText = fn.toString().replace(STRIP\_COMMENTS, \textcolor{stringliteral}{''});
        argDecl = fnText.match(FN\_ARGS);
        forEach(argDecl[1].split(FN\_ARG\_SPLIT), \textcolor{keyword}{function}(arg) \{
          arg.replace(FN\_ARG, \textcolor{keyword}{function}(all, underscore, name) \{
            $inject.push(name);
          \});
        \});
      \}
      fn.$inject = $inject;
    \}
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(fn)) \{
    last = fn.length - 1;
    assertArgFn(fn[last], \textcolor{stringliteral}{'fn'});
    $inject = fn.slice(0, last);
  \} \textcolor{keywordflow}{else} \{
    assertArgFn(fn, \textcolor{stringliteral}{'fn'}, \textcolor{keyword}{true});
  \}
  \textcolor{keywordflow}{return} $inject;
\}


\textcolor{keyword}{function} createInjector(modulesToLoad, strictDi) \{
  strictDi = (strictDi === \textcolor{keyword}{true});
  var INSTANTIATING = \{\},
      providerSuffix = \textcolor{stringliteral}{'Provider'},
      path = [],
      loadedModules = \textcolor{keyword}{new} HashMap([], \textcolor{keyword}{true}),
      providerCache = \{
        $provide: \{
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          \}
      \},
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, \textcolor{keyword}{function}(serviceName, caller) \{
            \textcolor{keywordflow}{if} (angular.isString(caller)) \{
              path.push(caller);
            \}
            \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'unpr'}, \textcolor{stringliteral}{"Unknown provider: \{0\}"}, path.join(\textcolor{stringliteral}{' <- '}));
          \})),
      instanceCache = \{\},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, \textcolor{keyword}{function}(serviceName, caller) \{
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            \textcolor{keywordflow}{return} instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
          \}));


  forEach(loadModules(modulesToLoad), \textcolor{keyword}{function}(fn) \{ \textcolor{keywordflow}{if} (fn) instanceInjector.invoke(fn); \});

  \textcolor{keywordflow}{return} instanceInjector;

  \textcolor{comment}{// $provider}
\textcolor{comment}{}
  \textcolor{keyword}{function} supportObject(delegate) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(key, value) \{
      \textcolor{keywordflow}{if} (isObject(key)) \{
        forEach(key, reverseParams(delegate));
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} delegate(key, value);
      \}
    \};
  \}

  \textcolor{keyword}{function} provider(name, provider\_) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'service'});
    \textcolor{keywordflow}{if} (isFunction(provider\_) || isArray(provider\_)) \{
      provider\_ = providerInjector.instantiate(provider\_);
    \}
    \textcolor{keywordflow}{if} (!provider\_.$get) \{
      \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'pget'}, \textcolor{stringliteral}{"Provider '\{0\}' must define $get factory method."}, name);
    \}
    \textcolor{keywordflow}{return} providerCache[name + providerSuffix] = provider\_;
  \}

  \textcolor{keyword}{function} enforceReturnValue(name, factory) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function} enforcedReturnValue() \{
      var result = instanceInjector.invoke(factory, \textcolor{keyword}{this});
      \textcolor{keywordflow}{if} (isUndefined(result)) \{
        \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'undef'}, \textcolor{stringliteral}{"Provider '\{0\}' must return a value from $get factory method."}, name
      );
      \}
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} factory(name, factoryFn, enforce) \{
    \textcolor{keywordflow}{return} provider(name, \{
      $get: enforce !== \textcolor{keyword}{false} ? enforceReturnValue(name, factoryFn) : factoryFn
    \});
  \}

  \textcolor{keyword}{function} service(name, constructor) \{
    \textcolor{keywordflow}{return} factory(name, [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{
      \textcolor{keywordflow}{return} $injector.instantiate(constructor);
    \}]);
  \}

  \textcolor{keyword}{function} value(name, val) \{ \textcolor{keywordflow}{return} factory(name, valueFn(val), \textcolor{keyword}{false}); \}

  \textcolor{keyword}{function} constant(name, value) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'constant'});
    providerCache[name] = value;
    instanceCache[name] = value;
  \}

  \textcolor{keyword}{function} decorator(serviceName, decorFn) \{
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = \textcolor{keyword}{function}() \{
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      \textcolor{keywordflow}{return} instanceInjector.invoke(decorFn, null, \{$delegate: origInstance\});
    \};
  \}

  \textcolor{comment}{// Module Loading}
\textcolor{comment}{}  \textcolor{keyword}{function} loadModules(modulesToLoad) \{
    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), \textcolor{stringliteral}{'modulesToLoad'}, \textcolor{stringliteral}{'not an array'});
    var runBlocks = [], moduleFn;
    forEach(modulesToLoad, \textcolor{keyword}{function}(module) \{
      \textcolor{keywordflow}{if} (loadedModules.get(module)) \textcolor{keywordflow}{return};
      loadedModules.put(module, \textcolor{keyword}{true});

      \textcolor{keyword}{function} runInvokeQueue(queue) \{
        var i, ii;
        \textcolor{keywordflow}{for} (i = 0, ii = queue.length; i < ii; i++) \{
          var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);

          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
        \}
      \}

      \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{if} (isString(module)) \{
          moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn.\_runBlocks);
          runInvokeQueue(moduleFn.\_invokeQueue);
          runInvokeQueue(moduleFn.\_configBlocks);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isFunction(module)) \{
            runBlocks.push(providerInjector.invoke(module));
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(module)) \{
            runBlocks.push(providerInjector.invoke(module));
        \} \textcolor{keywordflow}{else} \{
          assertArgFn(module, \textcolor{stringliteral}{'module'});
        \}
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{keywordflow}{if} (isArray(module)) \{
          module = module[module.length - 1];
        \}
        \textcolor{keywordflow}{if} (e.message && e.stack && e.stack.indexOf(e.message) == -1) \{
          \textcolor{comment}{// Safari & FF's stack traces don't contain error.message content}
          \textcolor{comment}{// unlike those of Chrome and IE}
          \textcolor{comment}{// So if stack doesn't contain message, we create a new string that contains both.}
          \textcolor{comment}{// Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.}
          \textcolor{comment}{/* jshint -W022 */}
          e = e.message + \textcolor{charliteral}{'\(\backslash\)n'} + e.stack;
        \}
        \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'modulerr'}, \textcolor{stringliteral}{"Failed to instantiate module \{0\} due to:\(\backslash\)n\{1\}"},
                  module, e.stack || e.message || e);
      \}
    \});
    \textcolor{keywordflow}{return} runBlocks;
  \}

  \textcolor{comment}{// internal Injector}
\textcolor{comment}{}
  \textcolor{keyword}{function} createInternalInjector(cache, factory) \{

    \textcolor{keyword}{function} getService(serviceName, caller) \{
      \textcolor{keywordflow}{if} (cache.hasOwnProperty(serviceName)) \{
        \textcolor{keywordflow}{if} (cache[serviceName] === INSTANTIATING) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'cdep'}, \textcolor{stringliteral}{'Circular dependency found: \{0\}'},
                    serviceName + \textcolor{stringliteral}{' <- '} + path.join(\textcolor{stringliteral}{' <- '}));
        \}
        \textcolor{keywordflow}{return} cache[serviceName];
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{try} \{
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          \textcolor{keywordflow}{return} cache[serviceName] = factory(serviceName, caller);
        \} \textcolor{keywordflow}{catch} (err) \{
          \textcolor{keywordflow}{if} (cache[serviceName] === INSTANTIATING) \{
            \textcolor{keyword}{delete} cache[serviceName];
          \}
          \textcolor{keywordflow}{throw} err;
        \} \textcolor{keywordflow}{finally} \{
          path.shift();
        \}
      \}
    \}

    \textcolor{keyword}{function} invoke(fn, \textcolor{keyword}{self}, locals, serviceName) \{
      \textcolor{keywordflow}{if} (typeof locals === \textcolor{stringliteral}{'string'}) \{
        serviceName = locals;
        locals = null;
      \}

      var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName),
          length, i,
          key;

      \textcolor{keywordflow}{for} (i = 0, length = $inject.length; i < length; i++) \{
        key = $inject[i];
        \textcolor{keywordflow}{if} (typeof key !== \textcolor{stringliteral}{'string'}) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'itkn'},
                  \textcolor{stringliteral}{'Incorrect injection token! Expected service name as string, got \{0\}'}, key);
        \}
        args.push(
          locals && locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key, serviceName)
        );
      \}
      \textcolor{keywordflow}{if} (isArray(fn)) \{
        fn = fn[length];
      \}

      \textcolor{comment}{// http://jsperf.com/angularjs-invoke-apply-vs-switch}
      \textcolor{comment}{// #5388}
      \textcolor{keywordflow}{return} fn.apply(\textcolor{keyword}{self}, args);
    \}

    \textcolor{keyword}{function} instantiate(Type, locals, serviceName) \{
      \textcolor{comment}{// Check if Type is annotated and use just the given function at n-1 as parameter}
      \textcolor{comment}{// e.g. someModule.factory('greeter', ['$window', function(renamed$window) \{\}]);}
      \textcolor{comment}{// Object creation: http://jsperf.com/create-constructor/2}
      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
      var returnedValue = invoke(Type, instance, locals, serviceName);

      \textcolor{keywordflow}{return} isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
    \}

    \textcolor{keywordflow}{return} \{
      invoke: invoke,
      instantiate: instantiate,
      \textcolor{keyword}{get}: getService,
      annotate: createInjector.$$annotate,
      has: \textcolor{keyword}{function}(name) \{
        \textcolor{keywordflow}{return} providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      \}
    \};
  \}
\}

createInjector.$$annotate = annotate;

\textcolor{keyword}{function} $AnchorScrollProvider() \{

  var autoScrollingEnabled = \textcolor{keyword}{true};

  this.disableAutoScrolling = \textcolor{keyword}{function}() \{
    autoScrollingEnabled = \textcolor{keyword}{false};
  \};

  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$location'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($window, $location, $rootScope) \{
    var document = $window.document;

    \textcolor{comment}{// Helper function to get first anchor from a NodeList}
    \textcolor{comment}{// (using `Array#some()` instead of `angular#forEach()` since it's more performant}
    \textcolor{comment}{//  and working in all supported browsers.)}
    \textcolor{keyword}{function} getFirstAnchor(list) \{
      var result = null;
      Array.prototype.some.call(list, \textcolor{keyword}{function}(element) \{
        \textcolor{keywordflow}{if} (nodeName\_(element) === \textcolor{charliteral}{'a'}) \{
          result = element;
          \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \}
      \});
      \textcolor{keywordflow}{return} result;
    \}

    \textcolor{keyword}{function} getYOffset() \{

      var offset = scroll.yOffset;

      \textcolor{keywordflow}{if} (isFunction(offset)) \{
        offset = offset();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isElement(offset)) \{
        var elem = offset[0];
        var style = $window.getComputedStyle(elem);
        \textcolor{keywordflow}{if} (style.position !== \textcolor{stringliteral}{'fixed'}) \{
          offset = 0;
        \} \textcolor{keywordflow}{else} \{
          offset = elem.getBoundingClientRect().bottom;
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isNumber(offset)) \{
        offset = 0;
      \}

      \textcolor{keywordflow}{return} offset;
    \}

    \textcolor{keyword}{function} scrollTo(elem) \{
      \textcolor{keywordflow}{if} (elem) \{
        elem.scrollIntoView();

        var offset = getYOffset();

        \textcolor{keywordflow}{if} (offset) \{
          \textcolor{comment}{// `offset` is the number of pixels we should scroll UP in order to align `elem` properly.}
          \textcolor{comment}{// This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the}
          \textcolor{comment}{// top of the viewport.}
          \textcolor{comment}{//}
          \textcolor{comment}{// IF the number of pixels from the top of `elem` to the end of the page's content is less}
          \textcolor{comment}{// than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some}
          \textcolor{comment}{// way down the page.}
          \textcolor{comment}{//}
          \textcolor{comment}{// This is often the case for elements near the bottom of the page.}
          \textcolor{comment}{//}
          \textcolor{comment}{// In such cases we do not need to scroll the whole `offset` up, just the difference between}
          \textcolor{comment}{// the top of the element and the offset, which is enough to align the top of `elem` at the}
          \textcolor{comment}{// desired position.}
          var elemTop = elem.getBoundingClientRect().top;
          $window.scrollBy(0, elemTop - offset);
        \}
      \} \textcolor{keywordflow}{else} \{
        $window.scrollTo(0, 0);
      \}
    \}

    \textcolor{keyword}{function} scroll(hash) \{
      hash = isString(hash) ? hash : $location.hash();
      var elm;

      \textcolor{comment}{// empty hash, scroll to the top of the page}
      \textcolor{keywordflow}{if} (!hash) scrollTo(null);

      \textcolor{comment}{// element with given id}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((elm = document.getElementById(hash))) scrollTo(elm);

      \textcolor{comment}{// first anchor with given name :-D}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);

      \textcolor{comment}{// no element and hash == 'top', scroll to the top of the page}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hash === \textcolor{stringliteral}{'top'}) scrollTo(null);
    \}

    \textcolor{comment}{// does not scroll when user clicks on anchor link that is currently on}
    \textcolor{comment}{// (no url change, no $location.hash() change), browser native does scroll}
    \textcolor{keywordflow}{if} (autoScrollingEnabled) \{
      $rootScope.$watch(\textcolor{keyword}{function} autoScrollWatch() \{\textcolor{keywordflow}{return} $location.hash();\},
        \textcolor{keyword}{function} autoScrollWatchAction(newVal, oldVal) \{
          \textcolor{comment}{// skip the initial scroll if $location.hash is empty}
          \textcolor{keywordflow}{if} (newVal === oldVal && newVal === \textcolor{stringliteral}{''}) \textcolor{keywordflow}{return};

          jqLiteDocumentLoaded(\textcolor{keyword}{function}() \{
            $rootScope.$evalAsync(scroll);
          \});
        \});
    \}

    \textcolor{keywordflow}{return} scroll;
  \}];
\}

var $animateMinErr = minErr(\textcolor{stringliteral}{'$animate'});
var ELEMENT\_NODE = 1;
var NG\_ANIMATE\_CLASSNAME = \textcolor{stringliteral}{'ng-animate'};

\textcolor{keyword}{function} mergeClasses(a,b) \{
  \textcolor{keywordflow}{if} (!a && !b) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
  \textcolor{keywordflow}{if} (!a) \textcolor{keywordflow}{return} b;
  \textcolor{keywordflow}{if} (!b) \textcolor{keywordflow}{return} a;
  \textcolor{keywordflow}{if} (isArray(a)) a = a.join(\textcolor{charliteral}{' '});
  \textcolor{keywordflow}{if} (isArray(b)) b = b.join(\textcolor{charliteral}{' '});
  \textcolor{keywordflow}{return} a + \textcolor{charliteral}{' '} + b;
\}

\textcolor{keyword}{function} extractElementNode(element) \{
  \textcolor{keywordflow}{for} (var i = 0; i < element.length; i++) \{
    var elm = element[i];
    \textcolor{keywordflow}{if} (elm.nodeType === ELEMENT\_NODE) \{
      \textcolor{keywordflow}{return} elm;
    \}
  \}
\}

\textcolor{keyword}{function} splitClasses(classes) \{
  \textcolor{keywordflow}{if} (isString(classes)) \{
    classes = classes.split(\textcolor{charliteral}{' '});
  \}

  \textcolor{comment}{// Use createMap() to prevent class assumptions involving property names in}
  \textcolor{comment}{// Object.prototype}
  var obj = createMap();
  forEach(classes, \textcolor{keyword}{function}(klass) \{
    \textcolor{comment}{// sometimes the split leaves empty string values}
    \textcolor{comment}{// incase extra spaces were applied to the options}
    \textcolor{keywordflow}{if} (klass.length) \{
      obj[klass] = true;
    \}
  \});
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{comment}{// if any other type of options value besides an Object value is}
\textcolor{comment}{// passed into the $animate.method() animation then this helper code}
\textcolor{comment}{// will be run which will ignore it. While this patch is not the}
\textcolor{comment}{// greatest solution to this, a lot of existing plugins depend on}
\textcolor{comment}{// $animate to either call the callback (< 1.2) or return a promise}
\textcolor{comment}{// that can be changed. This helper function ensures that the options}
\textcolor{comment}{// are wiped clean incase a callback function is provided.}
\textcolor{keyword}{function} prepareAnimateOptions(options) \{
  \textcolor{keywordflow}{return} isObject(options)
      ? options
      : \{\};
\}

var $$CoreAnimateRunnerProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$$rAF'}, \textcolor{keyword}{function}($q, $$rAF) \{
    \textcolor{keyword}{function} AnimateRunner() \{\}
    AnimateRunner.all = noop;
    AnimateRunner.chain = noop;
    AnimateRunner.prototype = \{
      end: noop,
      cancel: noop,
      resume: noop,
      pause: noop,
      complete: noop,
      then: \textcolor{keyword}{function}(pass, fail) \{
        \textcolor{keywordflow}{return} $q(\textcolor{keyword}{function}(resolve) \{
          $$rAF(\textcolor{keyword}{function}() \{
            resolve();
          \});
        \}).then(pass, fail);
      \}
    \};
    \textcolor{keywordflow}{return} AnimateRunner;
  \}];
\};

\textcolor{comment}{// this is prefixed with Core since it conflicts with}
\textcolor{comment}{// the animateQueueProvider defined in ngAnimate/animateQueue.js}
var $$CoreAnimateQueueProvider = \textcolor{keyword}{function}() \{
  var postDigestQueue = \textcolor{keyword}{new} HashMap();
  var postDigestElements = [];

  this.$get = [\textcolor{stringliteral}{'$$AnimateRunner'}, \textcolor{stringliteral}{'$rootScope'},
       \textcolor{keyword}{function}($$AnimateRunner,   $rootScope) \{
    \textcolor{keywordflow}{return} \{
      enabled: noop,
      on: noop,
      off: noop,
      pin: noop,

      push: \textcolor{keyword}{function}(element, event, options, domOperation) \{
        domOperation        && domOperation();

        options = options || \{\};
        options.from        && element.css(options.from);
        options.to          && element.css(options.to);

        \textcolor{keywordflow}{if} (options.addClass || options.removeClass) \{
          addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{new} $$AnimateRunner(); \textcolor{comment}{// jshint ignore:line}
      \}
    \};

    \textcolor{keyword}{function} addRemoveClassesPostDigest(element, add, \textcolor{keyword}{remove}) \{
      var classVal, data = postDigestQueue.get(element);

      \textcolor{keywordflow}{if} (!data) \{
        postDigestQueue.put(element, data = \{\});
        postDigestElements.push(element);
      \}

      var updateData = \textcolor{keyword}{function}(classes, value) \{
        var changed = \textcolor{keyword}{false};
        \textcolor{keywordflow}{if} (classes) \{
          classes = isString(classes) ? classes.split(\textcolor{charliteral}{' '}) :
                    isArray(classes) ? classes : [];
          forEach(classes, \textcolor{keyword}{function}(className) \{
            \textcolor{keywordflow}{if} (className) \{
              changed = \textcolor{keyword}{true};
              data[className] = value;
            \}
          \});
        \}
        \textcolor{keywordflow}{return} changed;
      \};

      var classesAdded = updateData(add, \textcolor{keyword}{true});
      var classesRemoved = updateData(\textcolor{keyword}{remove}, \textcolor{keyword}{false});
      \textcolor{keywordflow}{if} ((!classesAdded && !classesRemoved) || postDigestElements.length > 1) \textcolor{keywordflow}{return};

      $rootScope.$$postDigest(\textcolor{keyword}{function}() \{
        forEach(postDigestElements, \textcolor{keyword}{function}(element) \{
          var data = postDigestQueue.get(element);
          \textcolor{keywordflow}{if} (data) \{
            var existing = splitClasses(element.attr(\textcolor{stringliteral}{'class'}));
            var toAdd = \textcolor{stringliteral}{''};
            var toRemove = \textcolor{stringliteral}{''};
            forEach(data, \textcolor{keyword}{function}(status, className) \{
              var hasClass = !!existing[className];
              \textcolor{keywordflow}{if} (status !== hasClass) \{
                \textcolor{keywordflow}{if} (status) \{
                  toAdd += (toAdd.length ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + className;
                \} \textcolor{keywordflow}{else} \{
                  toRemove += (toRemove.length ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + className;
                \}
              \}
            \});

            forEach(element, \textcolor{keyword}{function}(elm) \{
              toAdd    && jqLiteAddClass(elm, toAdd);
              toRemove && jqLiteRemoveClass(elm, toRemove);
            \});
            postDigestQueue.remove(element);
          \}
        \});

        postDigestElements.length = 0;
      \});
    \}
  \}];
\};

var $AnimateProvider = [\textcolor{stringliteral}{'$provide'}, \textcolor{keyword}{function}($provide) \{
  var provider = \textcolor{keyword}{this};

  this.$$registeredAnimations = Object.create(null);

  this.\textcolor{keyword}{register} = \textcolor{keyword}{function}(name, factory) \{
    \textcolor{keywordflow}{if} (name && name.charAt(0) !== \textcolor{charliteral}{'.'}) \{
      \textcolor{keywordflow}{throw} $animateMinErr(\textcolor{stringliteral}{'notcsel'}, \textcolor{stringliteral}{"Expecting class selector starting with '.' got '\{0\}'."}, name);
    \}

    var key = name + \textcolor{stringliteral}{'-animation'};
    provider.$$registeredAnimations[name.substr(1)] = key;
    $provide.factory(key, factory);
  \};

  this.classNameFilter = \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{if} (arguments.length === 1) \{
      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
      \textcolor{keywordflow}{if} (this.$$classNameFilter) \{
        var reservedRegex = \textcolor{keyword}{new} RegExp(\textcolor{stringliteral}{"(\(\backslash\)\(\backslash\)s+|\(\backslash\)\(\backslash\)/)"} + NG\_ANIMATE\_CLASSNAME + \textcolor{stringliteral}{"(\(\backslash\)\(\backslash\)s+|\(\backslash\)\(\backslash\)/)"});
        \textcolor{keywordflow}{if} (reservedRegex.test(\textcolor{keyword}{this}.$$classNameFilter.toString())) \{
          \textcolor{keywordflow}{throw} $animateMinErr(\textcolor{stringliteral}{'nongcls'},\textcolor{stringliteral}{'$animateProvider.classNameFilter(regex) prohibits accepting a
       regex value which matches/contains the "\{0\}" CSS class.'}, NG\_ANIMATE\_CLASSNAME);

        \}
      \}
    \}
    \textcolor{keywordflow}{return} this.$$classNameFilter;
  \};

  this.$get = [\textcolor{stringliteral}{'$$animateQueue'}, \textcolor{keyword}{function}($$animateQueue) \{
    \textcolor{keyword}{function} domInsert(element, parentElement, afterElement) \{
      \textcolor{comment}{// if for some reason the previous element was removed}
      \textcolor{comment}{// from the dom sometime before this code runs then let's}
      \textcolor{comment}{// just stick to using the parent element as the anchor}
      \textcolor{keywordflow}{if} (afterElement) \{
        var afterNode = extractElementNode(afterElement);
        \textcolor{keywordflow}{if} (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) \{
          afterElement = null;
        \}
      \}
      afterElement ? afterElement.after(element) : parentElement.prepend(element);
    \}

    \textcolor{keywordflow}{return} \{
      \textcolor{comment}{// we don't call it directly since non-existant arguments may}
      \textcolor{comment}{// be interpreted as null within the sub enabled function}

      on: $$animateQueue.on,

      off: $$animateQueue.off,

      pin: $$animateQueue.pin,

      enabled: $$animateQueue.enabled,

      cancel: \textcolor{keyword}{function}(runner) \{
        runner.end && runner.end();
      \},

      enter: \textcolor{keyword}{function}(element, parent, after, options) \{
        parent = parent && jqLite(parent);
        after = after && jqLite(after);
        parent = parent || after.parent();
        domInsert(element, parent, after);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'enter'}, prepareAnimateOptions(options));
      \},

      move: \textcolor{keyword}{function}(element, parent, after, options) \{
        parent = parent && jqLite(parent);
        after = after && jqLite(after);
        parent = parent || after.parent();
        domInsert(element, parent, after);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'move'}, prepareAnimateOptions(options));
      \},

      leave: \textcolor{keyword}{function}(element, options) \{
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'leave'}, prepareAnimateOptions(options), \textcolor{keyword}{function}() \{
          element.remove();
        \});
      \},

      addClass: \textcolor{keyword}{function}(element, className, options) \{
        options = prepareAnimateOptions(options);
        options.addClass = mergeClasses(options.addclass, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'addClass'}, options);
      \},

      removeClass: \textcolor{keyword}{function}(element, className, options) \{
        options = prepareAnimateOptions(options);
        options.removeClass = mergeClasses(options.removeClass, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'removeClass'}, options);
      \},

      setClass: \textcolor{keyword}{function}(element, add, \textcolor{keyword}{remove}, options) \{
        options = prepareAnimateOptions(options);
        options.addClass = mergeClasses(options.addClass, add);
        options.removeClass = mergeClasses(options.removeClass, \textcolor{keyword}{remove});
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'setClass'}, options);
      \},

      animate: \textcolor{keyword}{function}(element, from, to, className, options) \{
        options = prepareAnimateOptions(options);
        options.from = options.from ? extend(options.from, from) : from;
        options.to   = options.to   ? extend(options.to, to)     : to;

        className = className || \textcolor{stringliteral}{'ng-inline-animate'};
        options.tempClasses = mergeClasses(options.tempClasses, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'animate'}, options);
      \}
    \};
  \}];
\}];

var $CoreAnimateCssProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$$rAF'}, \textcolor{stringliteral}{'$q'}, \textcolor{keyword}{function}($$rAF, $q) \{

    var RAFPromise = \textcolor{keyword}{function}() \{\};
    RAFPromise.prototype = \{
      done: \textcolor{keyword}{function}(cancel) \{
        this.defer && this.defer[cancel === \textcolor{keyword}{true} ? \textcolor{stringliteral}{'reject'} : \textcolor{stringliteral}{'resolve'}]();
      \},
      end: \textcolor{keyword}{function}() \{
        this.done();
      \},
      cancel: \textcolor{keyword}{function}() \{
        this.done(\textcolor{keyword}{true});
      \},
      getPromise: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!this.defer) \{
          this.defer = $q.defer();
        \}
        \textcolor{keywordflow}{return} this.defer.promise;
      \},
      then: \textcolor{keyword}{function}(f1,f2) \{
        \textcolor{keywordflow}{return} this.getPromise().then(f1,f2);
      \},
      \textcolor{stringliteral}{'catch'}: \textcolor{keyword}{function}(f1) \{
        \textcolor{keywordflow}{return} this.getPromise().catch(f1);
      \},
      \textcolor{stringliteral}{'finally'}: \textcolor{keyword}{function}(f1) \{
        \textcolor{keywordflow}{return} this.getPromise().finally(f1);
      \}
    \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(element, options) \{
      \textcolor{keywordflow}{if} (options.from) \{
        element.css(options.from);
        options.from = null;
      \}

      var closed, runner = \textcolor{keyword}{new} RAFPromise();
      \textcolor{keywordflow}{return} \{
        start: run,
        end: run
      \};

      \textcolor{keyword}{function} run() \{
        $$rAF(\textcolor{keyword}{function}() \{
          close();
          \textcolor{keywordflow}{if} (!closed) \{
            runner.done();
          \}
          closed = \textcolor{keyword}{true};
        \});
        \textcolor{keywordflow}{return} runner;
      \}

      \textcolor{keyword}{function} close() \{
        \textcolor{keywordflow}{if} (options.addClass) \{
          element.addClass(options.addClass);
          options.addClass = null;
        \}
        \textcolor{keywordflow}{if} (options.removeClass) \{
          element.removeClass(options.removeClass);
          options.removeClass = null;
        \}
        \textcolor{keywordflow}{if} (options.to) \{
          element.css(options.to);
          options.to = null;
        \}
      \}
    \};
  \}];
\};

\textcolor{comment}{/* global stripHash: true */}

\textcolor{keyword}{function} Browser(window, document, $log, $sniffer) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this},
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = \{\};

  \textcolor{keyword}{self}.isMock = \textcolor{keyword}{false};

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  \textcolor{comment}{// TODO(vojta): remove this temporary api}
  \textcolor{keyword}{self}.$$completeOutstandingRequest = completeOutstandingRequest;
  \textcolor{keyword}{self}.$$incOutstandingRequestCount = \textcolor{keyword}{function}() \{ outstandingRequestCount++; \};

  \textcolor{keyword}{function} completeOutstandingRequest(fn) \{
    \textcolor{keywordflow}{try} \{
      fn.apply(null, sliceArgs(arguments, 1));
    \} \textcolor{keywordflow}{finally} \{
      outstandingRequestCount--;
      \textcolor{keywordflow}{if} (outstandingRequestCount === 0) \{
        \textcolor{keywordflow}{while} (outstandingRequestCallbacks.length) \{
          \textcolor{keywordflow}{try} \{
            outstandingRequestCallbacks.pop()();
          \} \textcolor{keywordflow}{catch} (e) \{
            $log.error(e);
          \}
        \}
      \}
    \}
  \}

  \textcolor{keyword}{function} getHash(url) \{
    var index = url.indexOf(\textcolor{charliteral}{'#'});
    \textcolor{keywordflow}{return} index === -1 ? \textcolor{stringliteral}{''} : url.substr(index);
  \}

  \textcolor{keyword}{self}.notifyWhenNoOutstandingRequests = \textcolor{keyword}{function}(callback) \{
    \textcolor{keywordflow}{if} (outstandingRequestCount === 0) \{
      callback();
    \} \textcolor{keywordflow}{else} \{
      outstandingRequestCallbacks.push(callback);
    \}
  \};

  \textcolor{comment}{// URL API}
\textcolor{comment}{}
  var cachedState, lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find(\textcolor{stringliteral}{'base'}),
      reloadLocation = null;

  cacheState();
  lastHistoryState = cachedState;

  \textcolor{keyword}{self}.url = \textcolor{keyword}{function}(url, replace, state) \{
    \textcolor{comment}{// In modern browsers `history.state` is `null` by default; treating it separately}
    \textcolor{comment}{// from `undefined` would cause `$browser.url('/foo')` to change `history.state`}
    \textcolor{comment}{// to undefined via `pushState`. Instead, let's change `undefined` to `null` here.}
    \textcolor{keywordflow}{if} (isUndefined(state)) \{
      state = null;
    \}

    \textcolor{comment}{// Android Browser BFCache causes location, history reference to become stale.}
    \textcolor{keywordflow}{if} (location !== window.location) location = window.location;
    \textcolor{keywordflow}{if} (history !== window.history) history = window.history;

    \textcolor{comment}{// setter}
    \textcolor{keywordflow}{if} (url) \{
      var sameState = lastHistoryState === state;

      \textcolor{comment}{// Don't change anything if previous and current URLs and states match. This also prevents}
      \textcolor{comment}{// IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.}
      \textcolor{comment}{// See https://github.com/angular/angular.js/commit/ffb2701}
      \textcolor{keywordflow}{if} (lastBrowserUrl === url && (!$sniffer.history || sameState)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{self};
      \}
      var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
      lastBrowserUrl = url;
      lastHistoryState = state;
      \textcolor{comment}{// Don't use history API if only the hash changed}
      \textcolor{comment}{// due to a bug in IE10/IE11 which leads}
      \textcolor{comment}{// to not firing a `hashchange` nor `popstate` event}
      \textcolor{comment}{// in some cases (see #9143).}
      \textcolor{keywordflow}{if} ($sniffer.history && (!sameBase || !sameState)) \{
        history[replace ? \textcolor{stringliteral}{'replaceState'} : \textcolor{stringliteral}{'pushState'}](state, \textcolor{stringliteral}{''}, url);
        cacheState();
        \textcolor{comment}{// Do the assignment again so that those two variables are referentially identical.}
        lastHistoryState = cachedState;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (!sameBase || reloadLocation) \{
          reloadLocation = url;
        \}
        \textcolor{keywordflow}{if} (replace) \{
          location.replace(url);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!sameBase) \{
          location.href = url;
        \} \textcolor{keywordflow}{else} \{
          location.hash = getHash(url);
        \}
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{self};
    \textcolor{comment}{// getter}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// - reloadLocation is needed as browsers don't allow to read out}
      \textcolor{comment}{//   the new location.href if a reload happened.}
      \textcolor{comment}{// - the replacement is a workaround for https://bugzilla.mozilla.org/show\_bug.cgi?id=407172}
      \textcolor{keywordflow}{return} reloadLocation || location.href.replace(/%27/g,\textcolor{stringliteral}{"'"});
    \}
  \};

  \textcolor{keyword}{self}.state = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} cachedState;
  \};

  var urlChangeListeners = [],
      urlChangeInit = \textcolor{keyword}{false};

  \textcolor{keyword}{function} cacheStateAndFireUrlChange() \{
    cacheState();
    fireUrlChange();
  \}

  \textcolor{keyword}{function} getCurrentState() \{
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{return} history.state;
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{comment}{// MSIE can reportedly throw when there is no state (UNCONFIRMED).}
    \}
  \}

  \textcolor{comment}{// This variable should be used *only* inside the cacheState function.}
  var lastCachedState = null;
  \textcolor{keyword}{function} cacheState() \{
    \textcolor{comment}{// This should be the only place in $browser where `history.state` is read.}
    cachedState = getCurrentState();
    cachedState = isUndefined(cachedState) ? null : cachedState;

    \textcolor{comment}{// Prevent callbacks fo fire twice if both hashchange & popstate were fired.}
    \textcolor{keywordflow}{if} (equals(cachedState, lastCachedState)) \{
      cachedState = lastCachedState;
    \}
    lastCachedState = cachedState;
  \}

  \textcolor{keyword}{function} fireUrlChange() \{
    \textcolor{keywordflow}{if} (lastBrowserUrl === \textcolor{keyword}{self}.url() && lastHistoryState === cachedState) \{
      \textcolor{keywordflow}{return};
    \}

    lastBrowserUrl = \textcolor{keyword}{self}.url();
    lastHistoryState = cachedState;
    forEach(urlChangeListeners, \textcolor{keyword}{function}(listener) \{
      listener(\textcolor{keyword}{self}.url(), cachedState);
    \});
  \}

  \textcolor{keyword}{self}.onUrlChange = \textcolor{keyword}{function}(callback) \{
    \textcolor{comment}{// TODO(vojta): refactor to use node's syntax for events}
    \textcolor{keywordflow}{if} (!urlChangeInit) \{
      \textcolor{comment}{// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)}
      \textcolor{comment}{// don't fire popstate when user change the address bar and don't fire hashchange when url}
      \textcolor{comment}{// changed by push/replaceState}

      \textcolor{comment}{// html5 history api - popstate event}
      \textcolor{keywordflow}{if} ($sniffer.history) jqLite(window).on(\textcolor{stringliteral}{'popstate'}, cacheStateAndFireUrlChange);
      \textcolor{comment}{// hashchange event}
      jqLite(window).on(\textcolor{stringliteral}{'hashchange'}, cacheStateAndFireUrlChange);

      urlChangeInit = \textcolor{keyword}{true};
    \}

    urlChangeListeners.push(callback);
    \textcolor{keywordflow}{return} callback;
  \};

  \textcolor{keyword}{self}.$$applicationDestroyed = \textcolor{keyword}{function}() \{
    jqLite(window).off(\textcolor{stringliteral}{'hashchange popstate'}, cacheStateAndFireUrlChange);
  \};

  \textcolor{keyword}{self}.$$checkUrlChange = fireUrlChange;

  \textcolor{comment}{// Misc API}
\textcolor{comment}{}
  \textcolor{keyword}{self}.baseHref = \textcolor{keyword}{function}() \{
    var href = baseElement.attr(\textcolor{stringliteral}{'href'});
    \textcolor{keywordflow}{return} href ? href.replace(/^(https?\(\backslash\):)?\(\backslash\)/\(\backslash\)/[^\(\backslash\)/]*/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''};
  \};

  \textcolor{keyword}{self}.defer = \textcolor{keyword}{function}(fn, delay) \{
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(\textcolor{keyword}{function}() \{
      \textcolor{keyword}{delete} pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    \}, delay || 0);
    pendingDeferIds[timeoutId] = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} timeoutId;
  \};


  \textcolor{keyword}{self}.defer.cancel = \textcolor{keyword}{function}(deferId) \{
    \textcolor{keywordflow}{if} (pendingDeferIds[deferId]) \{
      \textcolor{keyword}{delete} pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \};

\}

\textcolor{keyword}{function} $BrowserProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$log'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$document'},
      \textcolor{keyword}{function}($window, $log, $sniffer, $document) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Browser($window, $document, $log, $sniffer);
      \}];
\}

\textcolor{keyword}{function} $CacheFactoryProvider() \{

  this.$get = \textcolor{keyword}{function}() \{
    var caches = \{\};

    \textcolor{keyword}{function} cacheFactory(cacheId, options) \{
      \textcolor{keywordflow}{if} (cacheId in caches) \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'$cacheFactory'})(\textcolor{stringliteral}{'iid'}, \textcolor{stringliteral}{"CacheId '\{0\}' is already taken!"}, cacheId);
      \}

      var size = 0,
          stats = extend(\{\}, options, \{\textcolor{keywordtype}{id}: cacheId\}),
          data = \{\},
          capacity = (options && options.capacity) || Number.MAX\_VALUE,
          lruHash = \{\},
          freshEnd = null,
          staleEnd = null;

      \textcolor{keywordflow}{return} caches[cacheId] = \{

        put: \textcolor{keyword}{function}(key, value) \{
          \textcolor{keywordflow}{if} (isUndefined(value)) \textcolor{keywordflow}{return};
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key] || (lruHash[key] = \{key: key\});

            refresh(lruEntry);
          \}

          \textcolor{keywordflow}{if} (!(key in data)) size++;
          data[key] = value;

          \textcolor{keywordflow}{if} (size > capacity) \{
            this.\textcolor{keyword}{remove}(staleEnd.key);
          \}

          \textcolor{keywordflow}{return} value;
        \},

        \textcolor{keyword}{get}: \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key];

            \textcolor{keywordflow}{if} (!lruEntry) \textcolor{keywordflow}{return};

            refresh(lruEntry);
          \}

          \textcolor{keywordflow}{return} data[key];
        \},


        \textcolor{keyword}{remove}: \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key];

            \textcolor{keywordflow}{if} (!lruEntry) \textcolor{keywordflow}{return};

            \textcolor{keywordflow}{if} (lruEntry == freshEnd) freshEnd = lruEntry.p;
            \textcolor{keywordflow}{if} (lruEntry == staleEnd) staleEnd = lruEntry.n;
            link(lruEntry.n,lruEntry.p);

            \textcolor{keyword}{delete} lruHash[key];
          \}

          \textcolor{keyword}{delete} data[key];
          size--;
        \},


        removeAll: \textcolor{keyword}{function}() \{
          data = \{\};
          size = 0;
          lruHash = \{\};
          freshEnd = staleEnd = null;
        \},


        destroy: \textcolor{keyword}{function}() \{
          data = null;
          stats = null;
          lruHash = null;
          \textcolor{keyword}{delete} caches[cacheId];
        \},


        info: \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} extend(\{\}, stats, \{size: size\});
        \}
      \};


      \textcolor{keyword}{function} refresh(entry) \{
        \textcolor{keywordflow}{if} (entry != freshEnd) \{
          \textcolor{keywordflow}{if} (!staleEnd) \{
            staleEnd = entry;
          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (staleEnd == entry) \{
            staleEnd = entry.n;
          \}

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        \}
      \}


      \textcolor{keyword}{function} link(nextEntry, prevEntry) \{
        \textcolor{keywordflow}{if} (nextEntry != prevEntry) \{
          \textcolor{keywordflow}{if} (nextEntry) nextEntry.p = prevEntry; \textcolor{comment}{//p stands for previous, 'prev' didn't minify}
          \textcolor{keywordflow}{if} (prevEntry) prevEntry.n = nextEntry; \textcolor{comment}{//n stands for next, 'next' didn't minify}
        \}
      \}
    \}


    cacheFactory.info = \textcolor{keyword}{function}() \{
      var info = \{\};
      forEach(caches, \textcolor{keyword}{function}(cache, cacheId) \{
        info[cacheId] = cache.info();
      \});
      \textcolor{keywordflow}{return} info;
    \};


    cacheFactory.get = \textcolor{keyword}{function}(cacheId) \{
      \textcolor{keywordflow}{return} caches[cacheId];
    \};


    \textcolor{keywordflow}{return} cacheFactory;
  \};
\}

\textcolor{keyword}{function} $TemplateCacheProvider() \{
  this.$get = [\textcolor{stringliteral}{'$cacheFactory'}, \textcolor{keyword}{function}($cacheFactory) \{
    \textcolor{keywordflow}{return} $cacheFactory(\textcolor{stringliteral}{'templates'});
  \}];
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

\textcolor{comment}{/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!}
\textcolor{comment}{ *}
\textcolor{comment}{ * DOM-related variables:}
\textcolor{comment}{ *}
\textcolor{comment}{ * - "node" - DOM Node}
\textcolor{comment}{ * - "element" - DOM Element or Node}
\textcolor{comment}{ * - "$node" or "$element" - jqLite-wrapped node or element}
\textcolor{comment}{ *}
\textcolor{comment}{ *}
\textcolor{comment}{ * Compiler related stuff:}
\textcolor{comment}{ *}
\textcolor{comment}{ * - "linkFn" - linking fn of a single directive}
\textcolor{comment}{ * - "nodeLinkFn" - function that aggregates all linking fns for a particular node}
\textcolor{comment}{ * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node}
\textcolor{comment}{ * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)}
\textcolor{comment}{ */}


var $compileMinErr = minErr(\textcolor{stringliteral}{'$compile'});

$CompileProvider.$inject = [\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'$$sanitizeUriProvider'}];
\textcolor{keyword}{function} $CompileProvider($provide, $$sanitizeUriProvider) \{
  var hasDirectives = \{\},
      Suffix = \textcolor{stringliteral}{'Directive'},
      COMMENT\_DIRECTIVE\_REGEXP = /^\(\backslash\)s*directive\(\backslash\):\(\backslash\)s*([\(\backslash\)w\(\backslash\)-]+)\(\backslash\)s+(.*)$/,
      CLASS\_DIRECTIVE\_REGEXP = /(([\(\backslash\)w\(\backslash\)-]+)(?:\(\backslash\):([^;]+))?;?)/,
      ALL\_OR\_NOTHING\_ATTRS = makeMap(\textcolor{stringliteral}{'ngSrc,ngSrcset,src,srcset'}),
      REQUIRE\_PREFIX\_REGEXP = /^(?:(\(\backslash\)^\(\backslash\)^?)?(\(\backslash\)?)?(\(\backslash\)^\(\backslash\)^?)?)?/;

  \textcolor{comment}{// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes}
  \textcolor{comment}{// The assumption is that future DOM event attribute names will begin with}
  \textcolor{comment}{// 'on' and be composed of only English letters.}
  var EVENT\_HANDLER\_ATTR\_REGEXP = /^(on[a-z]+|formaction)$/;

  \textcolor{keyword}{function} parseIsolateBindings(scope, directiveName, isController) \{
    var LOCAL\_REGEXP = /^\(\backslash\)s*([@&]|=(\(\backslash\)*?))(\(\backslash\)??)\(\backslash\)s*(\(\backslash\)w*)\(\backslash\)s*$/;

    var bindings = \{\};

    forEach(scope, \textcolor{keyword}{function}(definition, scopeName) \{
      var match = definition.match(LOCAL\_REGEXP);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'iscp'},
            \textcolor{stringliteral}{"Invalid \{3\} for directive '\{0\}'."} +
            \textcolor{stringliteral}{" Definition: \{... \{1\}: '\{2\}' ...\}"},
            directiveName, scopeName, definition,
            (isController ? \textcolor{stringliteral}{"controller bindings definition"} :
            \textcolor{stringliteral}{"isolate scope definition"}));
      \}

      bindings[scopeName] = \{
        mode: match[1][0],
        collection: match[2] === \textcolor{charliteral}{'*'},
        optional: match[3] === \textcolor{charliteral}{'?'},
        attrName: match[4] || scopeName
      \};
    \});

    \textcolor{keywordflow}{return} bindings;
  \}

  \textcolor{keyword}{function} parseDirectiveBindings(directive, directiveName) \{
    var bindings = \{
      isolateScope: null,
      bindToController: null
    \};
    \textcolor{keywordflow}{if} (isObject(directive.scope)) \{
      \textcolor{keywordflow}{if} (directive.bindToController === \textcolor{keyword}{true}) \{
        bindings.bindToController = parseIsolateBindings(directive.scope,
                                                         directiveName, \textcolor{keyword}{true});
        bindings.isolateScope = \{\};
      \} \textcolor{keywordflow}{else} \{
        bindings.isolateScope = parseIsolateBindings(directive.scope,
                                                     directiveName, \textcolor{keyword}{false});
      \}
    \}
    \textcolor{keywordflow}{if} (isObject(directive.bindToController)) \{
      bindings.bindToController =
          parseIsolateBindings(directive.bindToController, directiveName, \textcolor{keyword}{true});
    \}
    \textcolor{keywordflow}{if} (isObject(bindings.bindToController)) \{
      var controller = directive.controller;
      var controllerAs = directive.controllerAs;
      \textcolor{keywordflow}{if} (!controller) \{
        \textcolor{comment}{// There is no controller, there may or may not be a controllerAs property}
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'noctrl'},
              \textcolor{stringliteral}{"Cannot bind to controller without directive '\{0\}'s controller."},
              directiveName);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!identifierForController(controller, controllerAs)) \{
        \textcolor{comment}{// There is a controller, but no identifier or controllerAs property}
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'noident'},
              \textcolor{stringliteral}{"Cannot bind to controller without identifier for directive '\{0\}'."},
              directiveName);
      \}
    \}
    \textcolor{keywordflow}{return} bindings;
  \}

  \textcolor{keyword}{function} assertValidDirectiveName(name) \{
    var letter = name.charAt(0);
    \textcolor{keywordflow}{if} (!letter || letter !== lowercase(letter)) \{
      \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'baddir'}, \textcolor{stringliteral}{"Directive name '\{0\}' is invalid. The first character must be a
       lowercase letter"}, name);
    \}
    \textcolor{keywordflow}{if} (name !== name.trim()) \{
      \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'baddir'},
            \textcolor{stringliteral}{"Directive name '\{0\}' is invalid. The name should not contain leading or trailing whitespaces"},
            name);
    \}
  \}

   this.directive = \textcolor{keyword}{function} registerDirective(name, directiveFactory) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'directive'});
    \textcolor{keywordflow}{if} (isString(name)) \{
      assertValidDirectiveName(name);
      assertArg(directiveFactory, \textcolor{stringliteral}{'directiveFactory'});
      \textcolor{keywordflow}{if} (!hasDirectives.hasOwnProperty(name)) \{
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$exceptionHandler'},
          \textcolor{keyword}{function}($injector, $exceptionHandler) \{
            var directives = [];
            forEach(hasDirectives[name], \textcolor{keyword}{function}(directiveFactory, index) \{
              \textcolor{keywordflow}{try} \{
                var directive = $injector.invoke(directiveFactory);
                \textcolor{keywordflow}{if} (isFunction(directive)) \{
                  directive = \{ compile: valueFn(directive) \};
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!directive.compile && directive.link) \{
                  directive.compile = valueFn(directive.link);
                \}
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || \textcolor{stringliteral}{'EA'};
                var bindings = directive.$$bindings =
                    parseDirectiveBindings(directive, directive.name);
                \textcolor{keywordflow}{if} (isObject(bindings.isolateScope)) \{
                  directive.$$isolateBindings = bindings.isolateScope;
                \}
                directive.$$moduleName = directiveFactory.$$moduleName;
                directives.push(directive);
              \} \textcolor{keywordflow}{catch} (e) \{
                $exceptionHandler(e);
              \}
            \});
            \textcolor{keywordflow}{return} directives;
          \}]);
      \}
      hasDirectives[name].push(directiveFactory);
    \} \textcolor{keywordflow}{else} \{
      forEach(name, reverseParams(registerDirective));
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};


  this.aHrefSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    \}
  \};


  this.imgSrcSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    \}
  \};

  var debugInfoEnabled = \textcolor{keyword}{true};
  this.debugInfoEnabled = \textcolor{keyword}{function}(enabled) \{
    \textcolor{keywordflow}{if} (isDefined(enabled)) \{
      debugInfoEnabled = enabled;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} debugInfoEnabled;
  \};

  this.$get = [
            \textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$templateRequest'}, \textcolor{stringliteral}{'$parse'},
            \textcolor{stringliteral}{'$controller'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$document'}, \textcolor{stringliteral}{'$sce'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'$$sanitizeUri'},
    \textcolor{keyword}{function}($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) \{

    var Attributes = \textcolor{keyword}{function}(element, attributesToCopy) \{
      \textcolor{keywordflow}{if} (attributesToCopy) \{
        var keys = Object.keys(attributesToCopy);
        var i, l, key;

        \textcolor{keywordflow}{for} (i = 0, l = keys.length; i < l; i++) \{
          key = keys[i];
          \textcolor{keyword}{this}[key] = attributesToCopy[key];
        \}
      \} \textcolor{keywordflow}{else} \{
        this.$attr = \{\};
      \}

      this.$$element = element;
    \};

    Attributes.prototype = \{
      $normalize: directiveNormalize,


      $addClass: \textcolor{keyword}{function}(classVal) \{
        \textcolor{keywordflow}{if} (classVal && classVal.length > 0) \{
          $animate.addClass(this.$$element, classVal);
        \}
      \},

      $removeClass: \textcolor{keyword}{function}(classVal) \{
        \textcolor{keywordflow}{if} (classVal && classVal.length > 0) \{
          $animate.removeClass(this.$$element, classVal);
        \}
      \},

      $updateClass: \textcolor{keyword}{function}(newClasses, oldClasses) \{
        var toAdd = tokenDifference(newClasses, oldClasses);
        \textcolor{keywordflow}{if} (toAdd && toAdd.length) \{
          $animate.addClass(this.$$element, toAdd);
        \}

        var toRemove = tokenDifference(oldClasses, newClasses);
        \textcolor{keywordflow}{if} (toRemove && toRemove.length) \{
          $animate.removeClass(this.$$element, toRemove);
        \}
      \},

      $set: \textcolor{keyword}{function}(key, value, writeAttr, attrName) \{
        \textcolor{comment}{// TODO: decide whether or not to throw an error if "class"}
        \textcolor{comment}{//is set through this function since it may cause $updateClass to}
        \textcolor{comment}{//become unstable.}

        var node = this.$$element[0],
            booleanKey = getBooleanAttrName(node, key),
            aliasedKey = getAliasedAttrName(node, key),
            observer = key,
            nodeName;

        \textcolor{keywordflow}{if} (booleanKey) \{
          this.$$element.prop(key, value);
          attrName = booleanKey;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aliasedKey) \{
          \textcolor{keyword}{this}[aliasedKey] = value;
          observer = aliasedKey;
        \}

        \textcolor{keyword}{this}[key] = value;

        \textcolor{comment}{// translate normalized key to actual key}
        \textcolor{keywordflow}{if} (attrName) \{
          this.$attr[key] = attrName;
        \} \textcolor{keywordflow}{else} \{
          attrName = this.$attr[key];
          \textcolor{keywordflow}{if} (!attrName) \{
            this.$attr[key] = attrName = snake\_case(key, \textcolor{charliteral}{'-'});
          \}
        \}

        nodeName = nodeName\_(this.$$element);

        \textcolor{keywordflow}{if} ((nodeName === \textcolor{charliteral}{'a'} && key === \textcolor{stringliteral}{'href'}) ||
            (nodeName === \textcolor{stringliteral}{'img'} && key === \textcolor{stringliteral}{'src'})) \{
          \textcolor{comment}{// sanitize a[href] and img[src] values}
          \textcolor{keyword}{this}[key] = value = $$sanitizeUri(value, key === \textcolor{stringliteral}{'src'});
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nodeName === \textcolor{stringliteral}{'img'} && key === \textcolor{stringliteral}{'srcset'}) \{
          \textcolor{comment}{// sanitize img[srcset] values}
          var result = \textcolor{stringliteral}{""};

          \textcolor{comment}{// first check if there are spaces because it's not the same pattern}
          var trimmedSrcset = trim(value);
          \textcolor{comment}{//                (   999x   ,|   999w   ,|   ,|,   )}
          var srcPattern = /(\(\backslash\)s+\(\backslash\)d+x\(\backslash\)s*,|\(\backslash\)s+\(\backslash\)d+w\(\backslash\)s*,|\(\backslash\)s+,|,\(\backslash\)s+)/;
          var pattern = /\(\backslash\)s/.test(trimmedSrcset) ? srcPattern : /(,)/;

          \textcolor{comment}{// split srcset into tuple of uri and descriptor except for the last item}
          var rawUris = trimmedSrcset.split(pattern);

          \textcolor{comment}{// for each tuples}
          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
          \textcolor{keywordflow}{for} (var i = 0; i < nbrUrisWith2parts; i++) \{
            var innerIdx = i * 2;
            \textcolor{comment}{// sanitize the uri}
            result += $$sanitizeUri(trim(rawUris[innerIdx]), \textcolor{keyword}{true});
            \textcolor{comment}{// add the descriptor}
            result += (\textcolor{stringliteral}{" "} + trim(rawUris[innerIdx + 1]));
          \}

          \textcolor{comment}{// split the last item into uri and descriptor}
          var lastTuple = trim(rawUris[i * 2]).split(/\(\backslash\)s/);

          \textcolor{comment}{// sanitize the last uri}
          result += $$sanitizeUri(trim(lastTuple[0]), \textcolor{keyword}{true});

          \textcolor{comment}{// and add the last descriptor if any}
          \textcolor{keywordflow}{if} (lastTuple.length === 2) \{
            result += (\textcolor{stringliteral}{" "} + trim(lastTuple[1]));
          \}
          \textcolor{keyword}{this}[key] = value = result;
        \}

        \textcolor{keywordflow}{if} (writeAttr !== \textcolor{keyword}{false}) \{
          \textcolor{keywordflow}{if} (value === null || value === undefined) \{
            this.$$element.removeAttr(attrName);
          \} \textcolor{keywordflow}{else} \{
            this.$$element.attr(attrName, value);
          \}
        \}

        \textcolor{comment}{// fire observers}
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[observer], \textcolor{keyword}{function}(fn) \{
          \textcolor{keywordflow}{try} \{
            fn(value);
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
          \}
        \});
      \},


      $observe: \textcolor{keyword}{function}(key, fn) \{
        var attrs = \textcolor{keyword}{this},
            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) \{
            \textcolor{comment}{// no one registered attribute interpolation function, so lets call it manually}
            fn(attrs[key]);
          \}
        \});

        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          arrayRemove(listeners, fn);
        \};
      \}
    \};


    \textcolor{keyword}{function} safeAddClass($element, className) \{
      \textcolor{keywordflow}{try} \{
        $element.addClass(className);
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{comment}{// ignore, since it means that we are trying to set class on}
        \textcolor{comment}{// SVG element, where class name is read-only.}
      \}
    \}


    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == \textcolor{stringliteral}{'\{\{'} || endSymbol  == \textcolor{stringliteral}{'\}\}'})
            ? identity
            : \textcolor{keyword}{function} denormalizeTemplate(\textcolor{keyword}{template}) \{
              \textcolor{keywordflow}{return} \textcolor{keyword}{template}.replace(/\(\backslash\)\{\(\backslash\)\{/g, startSymbol).replace(/\}\}/g, endSymbol);
        \},
        NG\_ATTR\_BINDING = /^ngAttr[A-Z]/;

    compile.$$addBindingInfo = debugInfoEnabled ? \textcolor{keyword}{function} $$addBindingInfo($element, binding) \{
      var bindings = $element.data(\textcolor{stringliteral}{'$binding'}) || [];

      \textcolor{keywordflow}{if} (isArray(binding)) \{
        bindings = bindings.concat(binding);
      \} \textcolor{keywordflow}{else} \{
        bindings.push(binding);
      \}

      $element.data(\textcolor{stringliteral}{'$binding'}, bindings);
    \} : noop;

    compile.$$addBindingClass = debugInfoEnabled ? \textcolor{keyword}{function} $$addBindingClass($element) \{
      safeAddClass($element, \textcolor{stringliteral}{'ng-binding'});
    \} : noop;

    compile.$$addScopeInfo = debugInfoEnabled ? \textcolor{keyword}{function} $$addScopeInfo($element, scope, isolated, 
      noTemplate) \{
      var dataName = isolated ? (noTemplate ? \textcolor{stringliteral}{'$isolateScopeNoTemplate'} : \textcolor{stringliteral}{'$isolateScope'}) : \textcolor{stringliteral}{'$scope'};
      $element.data(dataName, scope);
    \} : noop;

    compile.$$addScopeClass = debugInfoEnabled ? \textcolor{keyword}{function} $$addScopeClass($element, isolated) \{
      safeAddClass($element, isolated ? \textcolor{stringliteral}{'ng-isolate-scope'} : \textcolor{stringliteral}{'ng-scope'});
    \} : noop;

    \textcolor{keywordflow}{return} compile;

    \textcolor{comment}{//================================}

    \textcolor{keyword}{function} compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) \{
      \textcolor{keywordflow}{if} (!($compileNodes instanceof jqLite)) \{
        \textcolor{comment}{// jquery always rewraps, whereas we need to preserve the original selector so that we can}
        \textcolor{comment}{// modify it.}
        $compileNodes = jqLite($compileNodes);
      \}
      \textcolor{comment}{// We can not compile top level text elements since text nodes can be merged and we will}
      \textcolor{comment}{// not be able to attach scope data to them, so we will wrap them in <span>}
      forEach($compileNodes, \textcolor{keyword}{function}(node, index) \{
        \textcolor{keywordflow}{if} (node.nodeType == NODE\_TYPE\_TEXT && node.nodeValue.match(/\(\backslash\)S+/) \textcolor{comment}{/* non-empty */} ) \{
          $compileNodes[index] = jqLite(node).wrap(\textcolor{stringliteral}{'<span></span>'}).parent()[0];
        \}
      \});
      var compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      compile.$$addScopeClass($compileNodes);
      var \textcolor{keyword}{namespace }= null;
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} publicLinkFn(scope, cloneConnectFn, options) \{
        assertArg(scope, \textcolor{stringliteral}{'scope'});

        options = options || \{\};
        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
          transcludeControllers = options.transcludeControllers,
          futureParentElement = options.futureParentElement;

        \textcolor{comment}{// When `parentBoundTranscludeFn` is passed, it is a}
        \textcolor{comment}{// `controllersBoundTransclude` function (it was previously passed}
        \textcolor{comment}{// as `transclude` to directive.link) so we must unwrap it to get}
        \textcolor{comment}{// its `boundTranscludeFn`}
        \textcolor{keywordflow}{if} (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) \{
          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
        \}

        \textcolor{keywordflow}{if} (!\textcolor{keyword}{namespace}) \{
          \textcolor{keyword}{namespace }= detectNamespaceForChildElements(futureParentElement);
        \}
        var $linkNode;
        \textcolor{keywordflow}{if} (\textcolor{keyword}{namespace} !== \textcolor{stringliteral}{'html'}) \{
          \textcolor{comment}{// When using a directive with replace:true and templateUrl the $compileNodes}
          \textcolor{comment}{// (or a child element inside of them)}
          \textcolor{comment}{// might change, so we need to recreate the namespace adapted compileNodes}
          \textcolor{comment}{// for call to the link function.}
          \textcolor{comment}{// Note: This will already clone the nodes...}
          $linkNode = jqLite(
            wrapTemplate(\textcolor{keyword}{namespace}, jqLite(\textcolor{stringliteral}{'<div>'}).append($compileNodes).html())
          );
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cloneConnectFn) \{
          \textcolor{comment}{// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart}
          \textcolor{comment}{// and sometimes changes the structure of the DOM.}
          $linkNode = JQLitePrototype.clone.call($compileNodes);
        \} \textcolor{keywordflow}{else} \{
          $linkNode = $compileNodes;
        \}

        \textcolor{keywordflow}{if} (transcludeControllers) \{
          \textcolor{keywordflow}{for} (var controllerName in transcludeControllers) \{
            $linkNode.data(\textcolor{charliteral}{'$'} + controllerName + \textcolor{stringliteral}{'Controller'}, transcludeControllers[controllerName].
      instance);
          \}
        \}

        compile.$$addScopeInfo($linkNode, scope);

        \textcolor{keywordflow}{if} (cloneConnectFn) cloneConnectFn($linkNode, scope);
        \textcolor{keywordflow}{if} (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
        \textcolor{keywordflow}{return} $linkNode;
      \};
    \}

    \textcolor{keyword}{function} detectNamespaceForChildElements(parentElement) \{
      \textcolor{comment}{// TODO: Make this detect MathML as well...}
      var node = parentElement && parentElement[0];
      \textcolor{keywordflow}{if} (!node) \{
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{'html'};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} nodeName\_(node) !== \textcolor{stringliteral}{'foreignobject'} && node.toString().match(/SVG/) ? \textcolor{stringliteral}{'svg'} : \textcolor{stringliteral}{'html'};
      \}
    \}

    \textcolor{keyword}{function} compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) \{
      var linkFns = [],
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;

      \textcolor{keywordflow}{for} (var i = 0; i < nodeList.length; i++) \{
        attrs = \textcolor{keyword}{new} Attributes();

        \textcolor{comment}{// we must always refer to nodeList[i] since the nodes can be replaced underneath us.}
        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                                      null, [], [], previousCompileContext)
            : null;

        \textcolor{keywordflow}{if} (nodeLinkFn && nodeLinkFn.scope) \{
          compile.$$addScopeClass(attrs.$$element);
        \}

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                      !(childNodes = nodeList[i].childNodes) ||
                      !childNodes.length)
            ? null
            : compileNodes(childNodes,
                 nodeLinkFn ? (
                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
                     && nodeLinkFn.transclude) : transcludeFn);

        \textcolor{keywordflow}{if} (nodeLinkFn || childLinkFn) \{
          linkFns.push(i, nodeLinkFn, childLinkFn);
          linkFnFound = \textcolor{keyword}{true};
          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
        \}

        \textcolor{comment}{//use the previous context only for the first element in the virtual group}
        previousCompileContext = null;
      \}

      \textcolor{comment}{// return a linking function if we have found anything, null otherwise}
      \textcolor{keywordflow}{return} linkFnFound ? compositeLinkFn : null;

      \textcolor{keyword}{function} compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) \{
        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
        var stableNodeList;


        \textcolor{keywordflow}{if} (nodeLinkFnFound) \{
          \textcolor{comment}{// copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our}
          \textcolor{comment}{// offsets don't get screwed up}
          var nodeListLength = nodeList.length;
          stableNodeList = \textcolor{keyword}{new} Array(nodeListLength);

          \textcolor{comment}{// create a sparse array by only copying the elements which have a linkFn}
          \textcolor{keywordflow}{for} (i = 0; i < linkFns.length; i+=3) \{
            idx = linkFns[i];
            stableNodeList[idx] = nodeList[idx];
          \}
        \} \textcolor{keywordflow}{else} \{
          stableNodeList = nodeList;
        \}

        \textcolor{keywordflow}{for} (i = 0, ii = linkFns.length; i < ii;) \{
          node = stableNodeList[linkFns[i++]];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          \textcolor{keywordflow}{if} (nodeLinkFn) \{
            \textcolor{keywordflow}{if} (nodeLinkFn.scope) \{
              childScope = scope.$new();
              compile.$$addScopeInfo(jqLite(node), childScope);
              var destroyBindings = nodeLinkFn.$$destroyBindings;
              \textcolor{keywordflow}{if} (destroyBindings) \{
                nodeLinkFn.$$destroyBindings = null;
                childScope.$on(\textcolor{stringliteral}{'$destroyed'}, destroyBindings);
              \}
            \} \textcolor{keywordflow}{else} \{
              childScope = scope;
            \}

            \textcolor{keywordflow}{if} (nodeLinkFn.transcludeOnThisElement) \{
              childBoundTranscludeFn = createBoundTranscludeFn(
                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) \{
              childBoundTranscludeFn = parentBoundTranscludeFn;

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!parentBoundTranscludeFn && transcludeFn) \{
              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);

            \} \textcolor{keywordflow}{else} \{
              childBoundTranscludeFn = null;
            \}

            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn,
                       nodeLinkFn);

          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (childLinkFn) \{
            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
          \}
        \}
      \}
    \}

    \textcolor{keyword}{function} createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) \{

      var boundTranscludeFn = \textcolor{keyword}{function}(transcludedScope, cloneFn, controllers, futureParentElement, 
      containingScope) \{

        \textcolor{keywordflow}{if} (!transcludedScope) \{
          transcludedScope = scope.$new(\textcolor{keyword}{false}, containingScope);
          transcludedScope.$$transcluded = \textcolor{keyword}{true};
        \}

        \textcolor{keywordflow}{return} transcludeFn(transcludedScope, cloneFn, \{
          parentBoundTranscludeFn: previousBoundTranscludeFn,
          transcludeControllers: controllers,
          futureParentElement: futureParentElement
        \});
      \};

      \textcolor{keywordflow}{return} boundTranscludeFn;
    \}

    \textcolor{keyword}{function} collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) \{
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      \textcolor{keywordflow}{switch} (nodeType) \{
        \textcolor{keywordflow}{case} NODE\_TYPE\_ELEMENT: \textcolor{comment}{/* Element */}
          \textcolor{comment}{// use the node name: <directive>}
          addDirective(directives,
              directiveNormalize(nodeName\_(node)), \textcolor{charliteral}{'E'}, maxPriority, ignoreDirective);

          \textcolor{comment}{// iterate over the attributes}
          \textcolor{keywordflow}{for} (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) \{
            var attrStartName = \textcolor{keyword}{false};
            var attrEndName = \textcolor{keyword}{false};

            attr = nAttrs[j];
            name = attr.name;
            value = trim(attr.value);

            \textcolor{comment}{// support ngAttr attribute binding}
            ngAttrName = directiveNormalize(name);
            \textcolor{keywordflow}{if} (isNgAttr = NG\_ATTR\_BINDING.test(ngAttrName)) \{
              name = name.replace(PREFIX\_REGEXP, \textcolor{stringliteral}{''})
                .substr(8).replace(/\_(.)/g, \textcolor{keyword}{function}(match, letter) \{
                  \textcolor{keywordflow}{return} letter.toUpperCase();
                \});
            \}

            var directiveNName = ngAttrName.replace(/(Start|End)$/, \textcolor{stringliteral}{''});
            \textcolor{keywordflow}{if} (directiveIsMultiElement(directiveNName)) \{
              \textcolor{keywordflow}{if} (ngAttrName === directiveNName + \textcolor{stringliteral}{'Start'}) \{
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + \textcolor{stringliteral}{'end'};
                name = name.substr(0, name.length - 6);
              \}
            \}

            nName = directiveNormalize(name.toLowerCase());
            attrsMap[nName] = name;
            \textcolor{keywordflow}{if} (isNgAttr || !attrs.hasOwnProperty(nName)) \{
                attrs[nName] = value;
                \textcolor{keywordflow}{if} (getBooleanAttrName(node, nName)) \{
                  attrs[nName] = \textcolor{keyword}{true}; \textcolor{comment}{// presence means true}
                \}
            \}
            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
            addDirective(directives, nName, \textcolor{charliteral}{'A'}, maxPriority, ignoreDirective, attrStartName,
                          attrEndName);
          \}

          \textcolor{comment}{// use class as directive}
          className = node.className;
          \textcolor{keywordflow}{if} (isObject(className)) \{
              \textcolor{comment}{// Maybe SVGAnimatedString}
              className = className.animVal;
          \}
          \textcolor{keywordflow}{if} (isString(className) && className !== \textcolor{stringliteral}{''}) \{
            \textcolor{keywordflow}{while} (match = CLASS\_DIRECTIVE\_REGEXP.exec(className)) \{
              nName = directiveNormalize(match[2]);
              \textcolor{keywordflow}{if} (addDirective(directives, nName, \textcolor{charliteral}{'C'}, maxPriority, ignoreDirective)) \{
                attrs[nName] = trim(match[3]);
              \}
              className = className.substr(match.index + match[0].length);
            \}
          \}
          \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} NODE\_TYPE\_TEXT: \textcolor{comment}{/* Text Node */}
          \textcolor{keywordflow}{if} (msie === 11) \{
            \textcolor{comment}{// Workaround for #11781}
            \textcolor{keywordflow}{while} (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE\_TYPE\_TEXT) \{
              node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
              node.parentNode.removeChild(node.nextSibling);
            \}
          \}
          addTextInterpolateDirective(directives, node.nodeValue);
          \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} NODE\_TYPE\_COMMENT: \textcolor{comment}{/* Comment */}
          \textcolor{keywordflow}{try} \{
            match = COMMENT\_DIRECTIVE\_REGEXP.exec(node.nodeValue);
            \textcolor{keywordflow}{if} (match) \{
              nName = directiveNormalize(match[1]);
              \textcolor{keywordflow}{if} (addDirective(directives, nName, \textcolor{charliteral}{'M'}, maxPriority, ignoreDirective)) \{
                attrs[nName] = trim(match[2]);
              \}
            \}
          \} \textcolor{keywordflow}{catch} (e) \{
            \textcolor{comment}{// turns out that under some circumstances IE9 throws errors when one attempts to read}
            \textcolor{comment}{// comment's node value.}
            \textcolor{comment}{// Just ignore it and continue. (Can't seem to reproduce in test case.)}
          \}
          \textcolor{keywordflow}{break};
      \}

      directives.sort(byPriority);
      \textcolor{keywordflow}{return} directives;
    \}

    \textcolor{keyword}{function} groupScan(node, attrStart, attrEnd) \{
      var nodes = [];
      var depth = 0;
      \textcolor{keywordflow}{if} (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) \{
        \textcolor{keywordflow}{do} \{
          \textcolor{keywordflow}{if} (!node) \{
            \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'uterdir'},
                      \textcolor{stringliteral}{"Unterminated attribute, found '\{0\}' but no matching '\{1\}' found."},
                      attrStart, attrEnd);
          \}
          \textcolor{keywordflow}{if} (node.nodeType == NODE\_TYPE\_ELEMENT) \{
            \textcolor{keywordflow}{if} (node.hasAttribute(attrStart)) depth++;
            \textcolor{keywordflow}{if} (node.hasAttribute(attrEnd)) depth--;
          \}
          nodes.push(node);
          node = node.nextSibling;
        \} \textcolor{keywordflow}{while} (depth > 0);
      \} \textcolor{keywordflow}{else} \{
        nodes.push(node);
      \}

      \textcolor{keywordflow}{return} jqLite(nodes);
    \}

    \textcolor{keyword}{function} groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element, attrs, controllers, transcludeFn) \{
        element = groupScan(element[0], attrStart, attrEnd);
        \textcolor{keywordflow}{return} linkFn(scope, element, attrs, controllers, transcludeFn);
      \};
    \}

    \textcolor{keyword}{function} applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) \{
      previousCompileContext = previousCompileContext || \{\};

      var terminalPriority = -Number.MAX\_VALUE,
          newScopeDirective = previousCompileContext.newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = \textcolor{keyword}{false},
          hasTemplate = \textcolor{keyword}{false},
          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      \textcolor{comment}{// executes all directives on the current element}
      \textcolor{keywordflow}{for} (var i = 0, ii = directives.length; i < ii; i++) \{
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        \textcolor{comment}{// collect multiblock sections}
        \textcolor{keywordflow}{if} (attrStart) \{
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        \}
        $template = undefined;

        \textcolor{keywordflow}{if} (terminalPriority > directive.priority) \{
          \textcolor{keywordflow}{break}; \textcolor{comment}{// prevent further processing of directives}
        \}

        \textcolor{keywordflow}{if} (directiveValue = directive.scope) \{

          \textcolor{comment}{// skip the check for directives with async templates, we'll check the derived sync}
          \textcolor{comment}{// directive when the template arrives}
          \textcolor{keywordflow}{if} (!directive.templateUrl) \{
            \textcolor{keywordflow}{if} (isObject(directiveValue)) \{
              \textcolor{comment}{// This directive is trying to add an isolated scope.}
              \textcolor{comment}{// Check that there is no scope of any kind already}
              assertNoDuplicate(\textcolor{stringliteral}{'new/isolated scope'}, newIsolateScopeDirective || newScopeDirective,
                                directive, $compileNode);
              newIsolateScopeDirective = directive;
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// This directive is trying to add a child scope.}
              \textcolor{comment}{// Check that there is no isolated scope already}
              assertNoDuplicate(\textcolor{stringliteral}{'new/isolated scope'}, newIsolateScopeDirective, directive,
                                $compileNode);
            \}
          \}

          newScopeDirective = newScopeDirective || directive;
        \}

        directiveName = directive.name;

        \textcolor{keywordflow}{if} (!directive.templateUrl && directive.controller) \{
          directiveValue = directive.controller;
          controllerDirectives = controllerDirectives || createMap();
          assertNoDuplicate(\textcolor{stringliteral}{"'"} + directiveName + \textcolor{stringliteral}{"' controller"},
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        \}

        \textcolor{keywordflow}{if} (directiveValue = directive.transclude) \{
          hasTranscludeDirective = \textcolor{keyword}{true};

          \textcolor{comment}{// Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.}
          \textcolor{comment}{// This option should only be used by directives that know how to safely handle element
       transclusion,}
          \textcolor{comment}{// where the transcluded nodes are added or replaced after linking.}
          \textcolor{keywordflow}{if} (!directive.$$tlb) \{
            assertNoDuplicate(\textcolor{stringliteral}{'transclusion'}, nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          \}

          \textcolor{keywordflow}{if} (directiveValue == \textcolor{stringliteral}{'element'}) \{
            hasElementTranscludeDirective = \textcolor{keyword}{true};
            terminalPriority = directive.priority;
            $template = $compileNode;
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(\textcolor{charliteral}{' '} + directiveName + \textcolor{stringliteral}{': '} +
                                              templateAttrs[directiveName] + \textcolor{charliteral}{' '}));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, sliceArgs($template), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name, \{
                                          \textcolor{comment}{// Don't pass in:}
                                          \textcolor{comment}{// - controllerDirectives - otherwise we'll create duplicates
       controllers}
                                          \textcolor{comment}{// - newIsolateScopeDirective or templateDirective - combining
       templates with}
                                          \textcolor{comment}{//   element transclusion doesn't make sense.}
                                          \textcolor{comment}{//}
                                          \textcolor{comment}{// We need only nonTlbTranscludeDirective so that we prevent
       putting transclusion}
                                          \textcolor{comment}{// on the same element more than once.}
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        \});
          \} \textcolor{keywordflow}{else} \{
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.empty(); \textcolor{comment}{// clear contents}
            childTranscludeFn = compile($template, transcludeFn);
          \}
        \}

        \textcolor{keywordflow}{if} (directive.template) \{
          hasTemplate = \textcolor{keyword}{true};
          assertNoDuplicate(\textcolor{stringliteral}{'template'}, templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          \textcolor{keywordflow}{if} (directive.replace) \{
            replaceDirective = directive;
            \textcolor{keywordflow}{if} (jqLiteIsTextNode(directiveValue)) \{
              $template = [];
            \} \textcolor{keywordflow}{else} \{
              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
            \}
            compileNode = $template[0];

            \textcolor{keywordflow}{if} ($template.length != 1 || compileNode.nodeType !== NODE\_TYPE\_ELEMENT) \{
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tplrt'},
                  \textcolor{stringliteral}{"Template for directive '\{0\}' must have exactly one root element. \{1\}"},
                  directiveName, \textcolor{stringliteral}{''});
            \}

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = \{$attr: \{\}\};

            \textcolor{comment}{// combine directives from the original node and from the template:}
            \textcolor{comment}{// - take the array of directives for this element}
            \textcolor{comment}{// - split it into two parts, those that already applied (processed) and those that weren't
       (unprocessed)}
            \textcolor{comment}{// - collect directives from the template and sort them by priority}
            \textcolor{comment}{// - combine directives as: processed + template + unprocessed}
            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));

            \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
              markDirectivesAsIsolate(templateDirectives);
            \}
            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          \} \textcolor{keywordflow}{else} \{
            $compileNode.html(directiveValue);
          \}
        \}

        \textcolor{keywordflow}{if} (directive.templateUrl) \{
          hasTemplate = \textcolor{keyword}{true};
          assertNoDuplicate(\textcolor{stringliteral}{'template'}, templateDirective, directive, $compileNode);
          templateDirective = directive;

          \textcolor{keywordflow}{if} (directive.replace) \{
            replaceDirective = directive;
          \}

          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
              templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, 
      postLinkFns, \{
                controllerDirectives: controllerDirectives,
                newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              \});
          ii = directives.length;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (directive.compile) \{
          \textcolor{keywordflow}{try} \{
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            \textcolor{keywordflow}{if} (isFunction(linkFn)) \{
              addLinkFns(null, linkFn, attrStart, attrEnd);
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (linkFn) \{
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            \}
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e, startingTag($compileNode));
          \}
        \}

        \textcolor{keywordflow}{if} (directive.terminal) \{
          nodeLinkFn.terminal = \textcolor{keyword}{true};
          terminalPriority = Math.max(terminalPriority, directive.priority);
        \}

      \}

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === \textcolor{keyword}{true};
      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
      nodeLinkFn.templateOnThisElement = hasTemplate;
      nodeLinkFn.transclude = childTranscludeFn;

      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;

      \textcolor{comment}{// might be normal or delayed nodeLinkFn depending on if templateUrl is present}
      \textcolor{keywordflow}{return} nodeLinkFn;


      \textcolor{keyword}{function} addLinkFns(pre, post, attrStart, attrEnd) \{
        \textcolor{keywordflow}{if} (pre) \{
          \textcolor{keywordflow}{if} (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          pre.directiveName = directiveName;
          \textcolor{keywordflow}{if} (newIsolateScopeDirective === directive || directive.$$isolateScope) \{
            pre = cloneAndAnnotateFn(pre, \{isolateScope: \textcolor{keyword}{true}\});
          \}
          preLinkFns.push(pre);
        \}
        \textcolor{keywordflow}{if} (post) \{
          \textcolor{keywordflow}{if} (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          post.directiveName = directiveName;
          \textcolor{keywordflow}{if} (newIsolateScopeDirective === directive || directive.$$isolateScope) \{
            post = cloneAndAnnotateFn(post, \{isolateScope: \textcolor{keyword}{true}\});
          \}
          postLinkFns.push(post);
        \}
      \}


      \textcolor{keyword}{function} getControllers(directiveName, require, $element, elementControllers) \{
        var value;

        \textcolor{keywordflow}{if} (isString(require)) \{
          var match = require.match(REQUIRE\_PREFIX\_REGEXP);
          var name = require.substring(match[0].length);
          var inheritType = match[1] || match[3];
          var optional = match[2] === \textcolor{charliteral}{'?'};

          \textcolor{comment}{//If only parents then start at the parent element}
          \textcolor{keywordflow}{if} (inheritType === \textcolor{stringliteral}{'^^'}) \{
            $element = $element.parent();
          \textcolor{comment}{//Otherwise attempt getting the controller from elementControllers in case}
          \textcolor{comment}{//the element is transcluded (and has no data) and to avoid .data if possible}
          \} \textcolor{keywordflow}{else} \{
            value = elementControllers && elementControllers[name];
            value = value && value.instance;
          \}

          \textcolor{keywordflow}{if} (!value) \{
            var dataName = \textcolor{charliteral}{'$'} + name + \textcolor{stringliteral}{'Controller'};
            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
          \}

          \textcolor{keywordflow}{if} (!value && !optional) \{
            \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'ctreq'},
                \textcolor{stringliteral}{"Controller '\{0\}', required by directive '\{1\}', can't be found!"},
                name, directiveName);
          \}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(require)) \{
          value = [];
          \textcolor{keywordflow}{for} (var i = 0, ii = require.length; i < ii; i++) \{
            value[i] = getControllers(directiveName, require[i], $element, elementControllers);
          \}
        \}

        \textcolor{keywordflow}{return} value || null;
      \}

      \textcolor{keyword}{function} setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) \{
        var elementControllers = createMap();
        \textcolor{keywordflow}{for} (var controllerKey in controllerDirectives) \{
          var directive = controllerDirectives[controllerKey];
          var locals = \{
            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : 
      scope,
            $element: $element,
            $attrs: attrs,
            $transclude: transcludeFn
          \};

          var controller = directive.controller;
          \textcolor{keywordflow}{if} (controller == \textcolor{charliteral}{'@'}) \{
            controller = attrs[directive.name];
          \}

          var controllerInstance = $controller(controller, locals, \textcolor{keyword}{true}, directive.controllerAs);

          \textcolor{comment}{// For directives with element transclusion the element is a comment,}
          \textcolor{comment}{// but jQuery .data doesn't support attaching data to comment nodes as it's hard to}
          \textcolor{comment}{// clean up (http://bugs.jquery.com/ticket/8335).}
          \textcolor{comment}{// Instead, we save the controllers for the element in a local hash and attach to .data}
          \textcolor{comment}{// later, once we have the actual element.}
          elementControllers[directive.name] = controllerInstance;
          \textcolor{keywordflow}{if} (!hasElementTranscludeDirective) \{
            $element.data(\textcolor{charliteral}{'$'} + directive.name + \textcolor{stringliteral}{'Controller'}, controllerInstance.instance);
          \}
        \}
        \textcolor{keywordflow}{return} elementControllers;
      \}

      \textcolor{keyword}{function} nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn,
                          thisLinkFn) \{
        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,
            attrs;

        \textcolor{keywordflow}{if} (compileNode === linkNode) \{
          attrs = templateAttrs;
          $element = templateAttrs.$$element;
        \} \textcolor{keywordflow}{else} \{
          $element = jqLite(linkNode);
          attrs = \textcolor{keyword}{new} Attributes($element, templateAttrs);
        \}

        \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
          isolateScope = scope.$new(\textcolor{keyword}{true});
        \}

        \textcolor{keywordflow}{if} (boundTranscludeFn) \{
          \textcolor{comment}{// track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`}
          \textcolor{comment}{// is later passed as `parentBoundTranscludeFn` to `publicLinkFn`}
          transcludeFn = controllersBoundTransclude;
          transcludeFn.$$boundTransclude = boundTranscludeFn;
        \}

        \textcolor{keywordflow}{if} (controllerDirectives) \{
          elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, 
      isolateScope, scope);
        \}

        \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
          \textcolor{comment}{// Initialize isolate scope bindings for new isolate scope directive.}
          compile.$$addScopeInfo($element, isolateScope, \textcolor{keyword}{true}, !(templateDirective && (templateDirective ==
      = newIsolateScopeDirective ||
              templateDirective === newIsolateScopeDirective.$$originalDirective)));
          compile.$$addScopeClass($element, \textcolor{keyword}{true});
          isolateScope.$$isolateBindings =
              newIsolateScopeDirective.$$isolateBindings;
          initializeDirectiveBindings(scope, attrs, isolateScope,
                                      isolateScope.$$isolateBindings,
                                      newIsolateScopeDirective, isolateScope);
        \}
        \textcolor{keywordflow}{if} (elementControllers) \{
          \textcolor{comment}{// Initialize bindToController bindings for new/isolate scopes}
          var scopeDirective = newIsolateScopeDirective || newScopeDirective;
          var bindings;
          var controllerForBindings;
          \textcolor{keywordflow}{if} (scopeDirective && elementControllers[scopeDirective.name]) \{
            bindings = scopeDirective.$$bindings.bindToController;
            controller = elementControllers[scopeDirective.name];

            \textcolor{keywordflow}{if} (controller && controller.identifier && bindings) \{
              controllerForBindings = controller;
              thisLinkFn.$$destroyBindings =
                  initializeDirectiveBindings(scope, attrs, controller.instance,
                                              bindings, scopeDirective);
            \}
          \}
          \textcolor{keywordflow}{for} (i in elementControllers) \{
            controller = elementControllers[i];
            var controllerResult = controller();

            \textcolor{keywordflow}{if} (controllerResult !== controller.instance) \{
              \textcolor{comment}{// If the controller constructor has a return value, overwrite the instance}
              \textcolor{comment}{// from setupControllers and update the element data}
              controller.instance = controllerResult;
              $element.data(\textcolor{charliteral}{'$'} + i + \textcolor{stringliteral}{'Controller'}, controllerResult);
              \textcolor{keywordflow}{if} (controller === controllerForBindings) \{
                \textcolor{comment}{// Remove and re-install bindToController bindings}
                thisLinkFn.$$destroyBindings();
                thisLinkFn.$$destroyBindings =
                  initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
              \}
            \}
          \}
        \}

        \textcolor{comment}{// PRELINKING}
        \textcolor{keywordflow}{for} (i = 0, ii = preLinkFns.length; i < ii; i++) \{
          linkFn = preLinkFns[i];
          invokeLinkFn(linkFn,
              linkFn.isolateScope ? isolateScope : scope,
              $element,
              attrs,
              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, 
      elementControllers),
              transcludeFn
          );
        \}

        \textcolor{comment}{// RECURSION}
        \textcolor{comment}{// We only pass the isolate scope, if the isolate directive has a template,}
        \textcolor{comment}{// otherwise the child elements do not belong to the isolate directive.}
        var scopeToChild = scope;
        \textcolor{keywordflow}{if} (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.
      templateUrl === null)) \{
          scopeToChild = isolateScope;
        \}
        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);

        \textcolor{comment}{// POSTLINKING}
        \textcolor{keywordflow}{for} (i = postLinkFns.length - 1; i >= 0; i--) \{
          linkFn = postLinkFns[i];
          invokeLinkFn(linkFn,
              linkFn.isolateScope ? isolateScope : scope,
              $element,
              attrs,
              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, 
      elementControllers),
              transcludeFn
          );
        \}

        \textcolor{comment}{// This is the function that is injected as `$transclude`.}
        \textcolor{comment}{// Note: all arguments are optional!}
        \textcolor{keyword}{function} controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) \{
          var transcludeControllers;

          \textcolor{comment}{// No scope passed in:}
          \textcolor{keywordflow}{if} (!isScope(scope)) \{
            futureParentElement = cloneAttachFn;
            cloneAttachFn = scope;
            scope = undefined;
          \}

          \textcolor{keywordflow}{if} (hasElementTranscludeDirective) \{
            transcludeControllers = elementControllers;
          \}
          \textcolor{keywordflow}{if} (!futureParentElement) \{
            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
          \}
          \textcolor{keywordflow}{return} boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, 
      scopeToChild);
        \}
      \}
    \}

    \textcolor{keyword}{function} markDirectivesAsIsolate(directives) \{
      \textcolor{comment}{// mark all directives as needing isolate scope.}
      \textcolor{keywordflow}{for} (var j = 0, jj = directives.length; j < jj; j++) \{
        directives[j] = inherit(directives[j], \{$$isolateScope: \textcolor{keyword}{true}\});
      \}
    \}

    \textcolor{keyword}{function} addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
                          endAttrName) \{
      \textcolor{keywordflow}{if} (name === ignoreDirective) \textcolor{keywordflow}{return} null;
      var match = null;
      \textcolor{keywordflow}{if} (hasDirectives.hasOwnProperty(name)) \{
        \textcolor{keywordflow}{for} (var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i < ii; i++) \{
          \textcolor{keywordflow}{try} \{
            directive = directives[i];
            \textcolor{keywordflow}{if} ((maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) \{
              \textcolor{keywordflow}{if} (startAttrName) \{
                directive = inherit(directive, \{$$start: startAttrName, $$end: endAttrName\});
              \}
              tDirectives.push(directive);
              match = directive;
            \}
          \} \textcolor{keywordflow}{catch} (e) \{ $exceptionHandler(e); \}
        \}
      \}
      \textcolor{keywordflow}{return} match;
    \}


    \textcolor{keyword}{function} directiveIsMultiElement(name) \{
      \textcolor{keywordflow}{if} (hasDirectives.hasOwnProperty(name)) \{
        \textcolor{keywordflow}{for} (var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i < ii; i++) \{
          directive = directives[i];
          \textcolor{keywordflow}{if} (directive.multiElement) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}

    \textcolor{keyword}{function} mergeTemplateAttributes(dst, src) \{
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      \textcolor{comment}{// reapply the old attributes to the new element}
      forEach(dst, \textcolor{keyword}{function}(value, key) \{
        \textcolor{keywordflow}{if} (key.charAt(0) != \textcolor{charliteral}{'$'}) \{
          \textcolor{keywordflow}{if} (src[key] && src[key] !== value) \{
            value += (key === \textcolor{stringliteral}{'style'} ? \textcolor{charliteral}{';'} : \textcolor{charliteral}{' '}) + src[key];
          \}
          dst.$set(key, value, \textcolor{keyword}{true}, srcAttr[key]);
        \}
      \});

      \textcolor{comment}{// copy the new attributes on the old attrs object}
      forEach(src, \textcolor{keyword}{function}(value, key) \{
        \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{'class'}) \{
          safeAddClass($element, value);
          dst[\textcolor{stringliteral}{'class'}] = (dst[\textcolor{stringliteral}{'class'}] ? dst[\textcolor{stringliteral}{'class'}] + \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + value;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{'style'}) \{
          $element.attr(\textcolor{stringliteral}{'style'}, $element.attr(\textcolor{stringliteral}{'style'}) + \textcolor{charliteral}{';'} + value);
          dst[\textcolor{stringliteral}{'style'}] = (dst[\textcolor{stringliteral}{'style'}] ? dst[\textcolor{stringliteral}{'style'}] + \textcolor{charliteral}{';'} : \textcolor{stringliteral}{''}) + value;
          \textcolor{comment}{// `dst` will never contain hasOwnProperty as DOM parser won't let it.}
          \textcolor{comment}{// You will get an "InvalidCharacterError: DOM Exception 5" error if you}
          \textcolor{comment}{// have an attribute like "has-own-property" or "data-has-own-property", etc.}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key.charAt(0) != \textcolor{charliteral}{'$'} && !dst.hasOwnProperty(key)) \{
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        \}
      \});
    \}


    \textcolor{keyword}{function} compileTemplateUrl(directives, $compileNode, tAttrs,
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) \{
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          derivedSyncDirective = inherit(origAsyncDirective, \{
            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
          \}),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl,
          templateNamespace = origAsyncDirective.templateNamespace;

      $compileNode.empty();

      $templateRequest(templateUrl)
        .then(\textcolor{keyword}{function}(content) \{
          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;

          content = denormalizeTemplate(content);

          \textcolor{keywordflow}{if} (origAsyncDirective.replace) \{
            \textcolor{keywordflow}{if} (jqLiteIsTextNode(content)) \{
              $template = [];
            \} \textcolor{keywordflow}{else} \{
              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
            \}
            compileNode = $template[0];

            \textcolor{keywordflow}{if} ($template.length != 1 || compileNode.nodeType !== NODE\_TYPE\_ELEMENT) \{
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tplrt'},
                  \textcolor{stringliteral}{"Template for directive '\{0\}' must have exactly one root element. \{1\}"},
                  origAsyncDirective.name, templateUrl);
            \}

            tempTemplateAttrs = \{$attr: \{\}\};
            replaceWith($rootElement, $compileNode, compileNode);
            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);

            \textcolor{keywordflow}{if} (isObject(origAsyncDirective.scope)) \{
              markDirectivesAsIsolate(templateDirectives);
            \}
            directives = templateDirectives.concat(directives);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          \} \textcolor{keywordflow}{else} \{
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          \}

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
              previousCompileContext);
          forEach($rootElement, \textcolor{keyword}{function}(node, i) \{
            \textcolor{keywordflow}{if} (node == compileNode) \{
              $rootElement[i] = $compileNode[0];
            \}
          \});
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);

          \textcolor{keywordflow}{while} (linkQueue.length) \{
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                boundTranscludeFn = linkQueue.shift(),
                linkNode = $compileNode[0];

            \textcolor{keywordflow}{if} (scope.$$destroyed) \textcolor{keywordflow}{continue};

            \textcolor{keywordflow}{if} (beforeTemplateLinkNode !== beforeTemplateCompileNode) \{
              var oldClasses = beforeTemplateLinkNode.className;

              \textcolor{keywordflow}{if} (!(previousCompileContext.hasElementTranscludeDirective &&
                  origAsyncDirective.replace)) \{
                \textcolor{comment}{// it was cloned therefore we have to clone as well.}
                linkNode = jqLiteClone(compileNode);
              \}
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);

              \textcolor{comment}{// Copy in CSS classes from original node}
              safeAddClass(jqLite(linkNode), oldClasses);
            \}
            \textcolor{keywordflow}{if} (afterTemplateNodeLinkFn.transcludeOnThisElement) \{
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, 
      boundTranscludeFn);
            \} \textcolor{keywordflow}{else} \{
              childBoundTranscludeFn = boundTranscludeFn;
            \}
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
              childBoundTranscludeFn, afterTemplateNodeLinkFn);
          \}
          linkQueue = null;
        \});

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) \{
        var childBoundTranscludeFn = boundTranscludeFn;
        \textcolor{keywordflow}{if} (scope.$$destroyed) \textcolor{keywordflow}{return};
        \textcolor{keywordflow}{if} (linkQueue) \{
          linkQueue.push(scope,
                         node,
                         rootElement,
                         childBoundTranscludeFn);
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (afterTemplateNodeLinkFn.transcludeOnThisElement) \{
            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, 
      boundTranscludeFn);
          \}
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, 
      childBoundTranscludeFn,
                                  afterTemplateNodeLinkFn);
        \}
      \};
    \}


    \textcolor{keyword}{function} byPriority(a, b) \{
      var diff = b.priority - a.priority;
      \textcolor{keywordflow}{if} (diff !== 0) \textcolor{keywordflow}{return} diff;
      \textcolor{keywordflow}{if} (a.name !== b.name) \textcolor{keywordflow}{return} (a.name < b.name) ? -1 : 1;
      \textcolor{keywordflow}{return} a.index - b.index;
    \}

    \textcolor{keyword}{function} assertNoDuplicate(what, previousDirective, directive, element) \{

      \textcolor{keyword}{function} wrapModuleNameIfDefined(moduleName) \{
        \textcolor{keywordflow}{return} moduleName ?
          (\textcolor{stringliteral}{' (module: '} + moduleName + \textcolor{charliteral}{')'}) :
          \textcolor{stringliteral}{''};
      \}

      \textcolor{keywordflow}{if} (previousDirective) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'multidir'}, \textcolor{stringliteral}{'Multiple directives [\{0\}\{1\}, \{2\}\{3\}] asking for \{4\} on: \{5\}'},
            previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),
            directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
      \}
    \}


    \textcolor{keyword}{function} addTextInterpolateDirective(directives, text) \{
      var interpolateFn = $interpolate(text, \textcolor{keyword}{true});
      \textcolor{keywordflow}{if} (interpolateFn) \{
        directives.push(\{
          priority: 0,
          compile: \textcolor{keyword}{function} textInterpolateCompileFn(templateNode) \{
            var templateNodeParent = templateNode.parent(),
                hasCompileParent = !!templateNodeParent.length;

            \textcolor{comment}{// When transcluding a template that has bindings in the root}
            \textcolor{comment}{// we don't have a parent and thus need to add the class during linking fn.}
            \textcolor{keywordflow}{if} (hasCompileParent) compile.$$addBindingClass(templateNodeParent);

            \textcolor{keywordflow}{return} \textcolor{keyword}{function} textInterpolateLinkFn(scope, node) \{
              var parent = node.parent();
              \textcolor{keywordflow}{if} (!hasCompileParent) compile.$$addBindingClass(parent);
              compile.$$addBindingInfo(parent, interpolateFn.expressions);
              scope.$watch(interpolateFn, \textcolor{keyword}{function} interpolateFnWatchAction(value) \{
                node[0].nodeValue = value;
              \});
            \};
          \}
        \});
      \}
    \}


    \textcolor{keyword}{function} wrapTemplate(type, \textcolor{keyword}{template}) \{
      type = lowercase(type || \textcolor{stringliteral}{'html'});
      \textcolor{keywordflow}{switch} (type) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'svg'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'math'}:
        var wrapper = document.createElement(\textcolor{stringliteral}{'div'});
        wrapper.innerHTML = \textcolor{charliteral}{'<'} + type + \textcolor{charliteral}{'>'} + \textcolor{keyword}{template} + \textcolor{stringliteral}{'</'} + type + \textcolor{charliteral}{'>'};
        \textcolor{keywordflow}{return} wrapper.childNodes[0].childNodes;
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{template};
      \}
    \}


    \textcolor{keyword}{function} getTrustedContext(node, attrNormalizedName) \{
      \textcolor{keywordflow}{if} (attrNormalizedName == \textcolor{stringliteral}{"srcdoc"}) \{
        \textcolor{keywordflow}{return} $sce.HTML;
      \}
      var tag = nodeName\_(node);
      \textcolor{comment}{// maction[xlink:href] can source SVG.  It's not limited to <maction>.}
      \textcolor{keywordflow}{if} (attrNormalizedName == \textcolor{stringliteral}{"xlinkHref"} ||
          (tag == \textcolor{stringliteral}{"form"} && attrNormalizedName == \textcolor{stringliteral}{"action"}) ||
          (tag != \textcolor{stringliteral}{"img"} && (attrNormalizedName == \textcolor{stringliteral}{"src"} ||
                            attrNormalizedName == \textcolor{stringliteral}{"ngSrc"}))) \{
        \textcolor{keywordflow}{return} $sce.RESOURCE\_URL;
      \}
    \}


    \textcolor{keyword}{function} addAttrInterpolateDirective(node, directives, value, name, allOrNothing) \{
      var trustedContext = getTrustedContext(node, name);
      allOrNothing = ALL\_OR\_NOTHING\_ATTRS[name] || allOrNothing;

      var interpolateFn = $interpolate(value, \textcolor{keyword}{true}, trustedContext, allOrNothing);

      \textcolor{comment}{// no interpolation found -> ignore}
      \textcolor{keywordflow}{if} (!interpolateFn) \textcolor{keywordflow}{return};


      \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{"multiple"} && nodeName\_(node) === \textcolor{stringliteral}{"select"}) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{"selmulti"},
            \textcolor{stringliteral}{"Binding to the 'multiple' attribute is not supported. Element: \{0\}"},
            startingTag(node));
      \}

      directives.push(\{
        priority: 100,
        compile: \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} \{
              pre: \textcolor{keyword}{function} attrInterpolatePreLinkFn(scope, element, attr) \{
                var $$observers = (attr.$$observers || (attr.$$observers = \{\}));

                \textcolor{keywordflow}{if} (EVENT\_HANDLER\_ATTR\_REGEXP.test(name)) \{
                  \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'nodomevents'},
                      \textcolor{stringliteral}{"Interpolations for HTML DOM event attributes are disallowed.  Please use the "} +
                          \textcolor{stringliteral}{"ng- versions (such as ng-click instead of onclick) instead."});
                \}

                \textcolor{comment}{// If the attribute has changed since last $interpolate()ed}
                var newValue = attr[name];
                \textcolor{keywordflow}{if} (newValue !== value) \{
                  \textcolor{comment}{// we need to interpolate again since the attribute value has been updated}
                  \textcolor{comment}{// (e.g. by another directive's compile function)}
                  \textcolor{comment}{// ensure unset/empty values make interpolateFn falsy}
                  interpolateFn = newValue && $interpolate(newValue, \textcolor{keyword}{true}, trustedContext, allOrNothing);
                  value = newValue;
                \}

                \textcolor{comment}{// if attribute was updated so that there is no interpolation going on we don't want to}
                \textcolor{comment}{// register any observers}
                \textcolor{keywordflow}{if} (!interpolateFn) \textcolor{keywordflow}{return};

                \textcolor{comment}{// initialize attr object so that it's ready in case we need the value for isolate}
                \textcolor{comment}{// scope initialization, otherwise the value would not be available from isolate}
                \textcolor{comment}{// directive's linking fn during linking phase}
                attr[name] = interpolateFn(scope);

                ($$observers[name] || ($$observers[name] = [])).$$inter = \textcolor{keyword}{true};
                (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, \textcolor{keyword}{function} interpolateFnWatchAction(newValue, oldValue) \{
                    \textcolor{comment}{//special case for class attribute addition + removal}
                    \textcolor{comment}{//so that class changes can tap into the animation}
                    \textcolor{comment}{//hooks provided by the $animate service. Be sure to}
                    \textcolor{comment}{//skip animations when the first digest occurs (when}
                    \textcolor{comment}{//both the new and the old values are the same) since}
                    \textcolor{comment}{//the CSS classes are the non-interpolated values}
                    \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'class'} && newValue != oldValue) \{
                      attr.$updateClass(newValue, oldValue);
                    \} \textcolor{keywordflow}{else} \{
                      attr.$set(name, newValue);
                    \}
                  \});
              \}
            \};
          \}
      \});
    \}


    \textcolor{keyword}{function} replaceWith($rootElement, elementsToRemove, newNode) \{
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      \textcolor{keywordflow}{if} ($rootElement) \{
        \textcolor{keywordflow}{for} (i = 0, ii = $rootElement.length; i < ii; i++) \{
          \textcolor{keywordflow}{if} ($rootElement[i] == firstElementToRemove) \{
            $rootElement[i++] = newNode;
            \textcolor{keywordflow}{for} (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) \{
              \textcolor{keywordflow}{if} (j2 < jj) \{
                $rootElement[j] = $rootElement[j2];
              \} \textcolor{keywordflow}{else} \{
                \textcolor{keyword}{delete} $rootElement[j];
              \}
            \}
            $rootElement.length -= removeCount - 1;

            \textcolor{comment}{// If the replaced element is also the jQuery .context then replace it}
            \textcolor{comment}{// .context is a deprecated jQuery api, so we should set it only when jQuery set it}
            \textcolor{comment}{// http://api.jquery.com/context/}
            \textcolor{keywordflow}{if} ($rootElement.context === firstElementToRemove) \{
              $rootElement.context = newNode;
            \}
            \textcolor{keywordflow}{break};
          \}
        \}
      \}

      \textcolor{keywordflow}{if} (parent) \{
        parent.replaceChild(newNode, firstElementToRemove);
      \}

      \textcolor{comment}{// TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?}
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);

      \textcolor{keywordflow}{if} (jqLite.hasData(firstElementToRemove)) \{
        \textcolor{comment}{// Copy over user data (that includes Angular's $scope etc.). Don't copy private}
        \textcolor{comment}{// data here because there's no public interface in jQuery to do that and copying over}
        \textcolor{comment}{// event listeners (which is the main use of private data) wouldn't work anyway.}
        jqLite(newNode).data(jqLite(firstElementToRemove).data());

        \textcolor{comment}{// Remove data of the replaced element. We cannot just call .remove()}
        \textcolor{comment}{// on the element it since that would deallocate scope that is needed}
        \textcolor{comment}{// for the new node. Instead, remove the data "manually".}
        \textcolor{keywordflow}{if} (!jQuery) \{
          \textcolor{keyword}{delete} jqLite.cache[firstElementToRemove[jqLite.expando]];
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// jQuery 2.x doesn't expose the data storage. Use jQuery.cleanData to clean up after}
          \textcolor{comment}{// the replaced element. The cleanData version monkey-patched by Angular would cause}
          \textcolor{comment}{// the scope to be trashed and we do need the very same scope to work with the new}
          \textcolor{comment}{// element. However, we cannot just cache the non-patched version and use it here as}
          \textcolor{comment}{// that would break if another library patches the method after Angular does (one}
          \textcolor{comment}{// example is jQuery UI). Instead, set a flag indicating scope destroying should be}
          \textcolor{comment}{// skipped this one time.}
          skipDestroyOnNextJQueryCleanData = \textcolor{keyword}{true};
          jQuery.cleanData([firstElementToRemove]);
        \}
      \}

      \textcolor{keywordflow}{for} (var k = 1, kk = elementsToRemove.length; k < kk; k++) \{
        var element = elementsToRemove[k];
        jqLite(element).remove(); \textcolor{comment}{// must do this way to clean up expando}
        fragment.appendChild(element);
        \textcolor{keyword}{delete} elementsToRemove[k];
      \}

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1;
    \}


    \textcolor{keyword}{function} cloneAndAnnotateFn(fn, annotation) \{
      \textcolor{keywordflow}{return} extend(\textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} fn.apply(null, arguments); \}, fn, annotation);
    \}


    \textcolor{keyword}{function} invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) \{
      \textcolor{keywordflow}{try} \{
        linkFn(scope, $element, attrs, controllers, transcludeFn);
      \} \textcolor{keywordflow}{catch} (e) \{
        $exceptionHandler(e, startingTag($element));
      \}
    \}


    \textcolor{comment}{// Set up $watches for isolate scope and controller bindings. This process}
    \textcolor{comment}{// only occurs for isolate scopes and new scopes with controllerAs.}
    \textcolor{keyword}{function} initializeDirectiveBindings(scope, attrs, destination, bindings,
                                         directive, newScope) \{
      var onNewScopeDestroyed;
      forEach(bindings, \textcolor{keyword}{function}(definition, scopeName) \{
        var attrName = definition.attrName,
        optional = definition.optional,
        mode = definition.mode, \textcolor{comment}{// @, =, or &}
        lastValue,
        parentGet, parentSet, compare;

        \textcolor{keywordflow}{switch} (mode) \{

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'@'}:
            \textcolor{keywordflow}{if} (!optional && !hasOwnProperty.call(attrs, attrName)) \{
              destination[scopeName] = attrs[attrName] = \textcolor{keywordtype}{void} 0;
            \}
            attrs.$observe(attrName, \textcolor{keyword}{function}(value) \{
              \textcolor{keywordflow}{if} (isString(value)) \{
                destination[scopeName] = value;
              \}
            \});
            attrs.$$observers[attrName].$$scope = scope;
            \textcolor{keywordflow}{if} (isString(attrs[attrName])) \{
              \textcolor{comment}{// If the attribute has been provided then we trigger an interpolation to ensure}
              \textcolor{comment}{// the value is there for use in the link fn}
              destination[scopeName] = $interpolate(attrs[attrName])(scope);
            \}
            \textcolor{keywordflow}{break};

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'='}:
            \textcolor{keywordflow}{if} (!hasOwnProperty.call(attrs, attrName)) \{
              \textcolor{keywordflow}{if} (optional) \textcolor{keywordflow}{break};
              attrs[attrName] = \textcolor{keywordtype}{void} 0;
            \}
            \textcolor{keywordflow}{if} (optional && !attrs[attrName]) \textcolor{keywordflow}{break};

            parentGet = $parse(attrs[attrName]);
            \textcolor{keywordflow}{if} (parentGet.literal) \{
              compare = equals;
            \} \textcolor{keywordflow}{else} \{
              compare = \textcolor{keyword}{function}(a, b) \{ \textcolor{keywordflow}{return} a === b || (a !== a && b !== b); \};
            \}
            parentSet = parentGet.assign || \textcolor{keyword}{function}() \{
              \textcolor{comment}{// reset the change, or we will throw this exception on every $digest}
              lastValue = destination[scopeName] = parentGet(scope);
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'nonassign'},
                  \textcolor{stringliteral}{"Expression '\{0\}' used with directive '\{1\}' is non-assignable!"},
                  attrs[attrName], directive.name);
            \};
            lastValue = destination[scopeName] = parentGet(scope);
            var parentValueWatch = \textcolor{keyword}{function} parentValueWatch(parentValue) \{
              \textcolor{keywordflow}{if} (!compare(parentValue, destination[scopeName])) \{
                \textcolor{comment}{// we are out of sync and need to copy}
                \textcolor{keywordflow}{if} (!compare(parentValue, lastValue)) \{
                  \textcolor{comment}{// parent changed and it has precedence}
                  destination[scopeName] = parentValue;
                \} \textcolor{keywordflow}{else} \{
                  \textcolor{comment}{// if the parent can be assigned then do so}
                  parentSet(scope, parentValue = destination[scopeName]);
                \}
              \}
              \textcolor{keywordflow}{return} lastValue = parentValue;
            \};
            parentValueWatch.$stateful = \textcolor{keyword}{true};
            var unwatch;
            \textcolor{keywordflow}{if} (definition.collection) \{
              unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
            \} \textcolor{keywordflow}{else} \{
              unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
            \}
            onNewScopeDestroyed = (onNewScopeDestroyed || []);
            onNewScopeDestroyed.push(unwatch);
            \textcolor{keywordflow}{break};

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'&'}:
            \textcolor{comment}{// Don't assign Object.prototype method to scope}
            parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;

            \textcolor{comment}{// Don't assign noop to destination if expression is not valid}
            \textcolor{keywordflow}{if} (parentGet === noop && optional) \textcolor{keywordflow}{break};

            destination[scopeName] = \textcolor{keyword}{function}(locals) \{
              \textcolor{keywordflow}{return} parentGet(scope, locals);
            \};
            \textcolor{keywordflow}{break};
        \}
      \});
      var destroyBindings = onNewScopeDestroyed ? \textcolor{keyword}{function} destroyBindings() \{
        \textcolor{keywordflow}{for} (var i = 0, ii = onNewScopeDestroyed.length; i < ii; ++i) \{
          onNewScopeDestroyed[i]();
        \}
      \} : noop;
      \textcolor{keywordflow}{if} (newScope && destroyBindings !== noop) \{
        newScope.$on(\textcolor{stringliteral}{'$destroy'}, destroyBindings);
        \textcolor{keywordflow}{return} noop;
      \}
      \textcolor{keywordflow}{return} destroyBindings;
    \}
  \}];
\}

var PREFIX\_REGEXP = /^((?:x|data)[\(\backslash\):\(\backslash\)-\_])/i;
\textcolor{keyword}{function} directiveNormalize(name) \{
  \textcolor{keywordflow}{return} camelCase(name.replace(PREFIX\_REGEXP, \textcolor{stringliteral}{''}));
\}

\textcolor{keyword}{function} nodesetLinkingFn(
  \textcolor{comment}{/* angular.Scope */} scope,
  \textcolor{comment}{/* NodeList */} nodeList,
  \textcolor{comment}{/* Element */} rootElement,
  \textcolor{comment}{/* function(Function) */} boundTranscludeFn
) \{\}

\textcolor{keyword}{function} directiveLinkingFn(
  \textcolor{comment}{/* nodesetLinkingFn */} nodesetLinkingFn,
  \textcolor{comment}{/* angular.Scope */} scope,
  \textcolor{comment}{/* Node */} node,
  \textcolor{comment}{/* Element */} rootElement,
  \textcolor{comment}{/* function(Function) */} boundTranscludeFn
) \{\}

\textcolor{keyword}{function} tokenDifference(str1, str2) \{
  var values = \textcolor{stringliteral}{''},
      tokens1 = str1.split(/\(\backslash\)s+/),
      tokens2 = str2.split(/\(\backslash\)s+/);

  outer:
  \textcolor{keywordflow}{for} (var i = 0; i < tokens1.length; i++) \{
    var token = tokens1[i];
    \textcolor{keywordflow}{for} (var j = 0; j < tokens2.length; j++) \{
      \textcolor{keywordflow}{if} (token == tokens2[j]) \textcolor{keywordflow}{continue} outer;
    \}
    values += (values.length > 0 ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + token;
  \}
  \textcolor{keywordflow}{return} values;
\}

\textcolor{keyword}{function} removeComments(jqNodes) \{
  jqNodes = jqLite(jqNodes);
  var i = jqNodes.length;

  \textcolor{keywordflow}{if} (i <= 1) \{
    \textcolor{keywordflow}{return} jqNodes;
  \}

  \textcolor{keywordflow}{while} (i--) \{
    var node = jqNodes[i];
    \textcolor{keywordflow}{if} (node.nodeType === NODE\_TYPE\_COMMENT) \{
      splice.call(jqNodes, i, 1);
    \}
  \}
  \textcolor{keywordflow}{return} jqNodes;
\}

var $controllerMinErr = minErr(\textcolor{stringliteral}{'$controller'});


var CNTRL\_REG = /^(\(\backslash\)S+)(\(\backslash\)s+as\(\backslash\)s+(\(\backslash\)w+))?$/;
\textcolor{keyword}{function} identifierForController(controller, ident) \{
  \textcolor{keywordflow}{if} (ident && isString(ident)) \textcolor{keywordflow}{return} ident;
  \textcolor{keywordflow}{if} (isString(controller)) \{
    var match = CNTRL\_REG.exec(controller);
    \textcolor{keywordflow}{if} (match) \textcolor{keywordflow}{return} match[3];
  \}
\}


\textcolor{keyword}{function} $ControllerProvider() \{
  var controllers = \{\},
      globals = \textcolor{keyword}{false};

  this.\textcolor{keyword}{register} = \textcolor{keyword}{function}(name, constructor) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'controller'});
    \textcolor{keywordflow}{if} (isObject(name)) \{
      extend(controllers, name);
    \} \textcolor{keywordflow}{else} \{
      controllers[name] = constructor;
    \}
  \};

  this.allowGlobals = \textcolor{keyword}{function}() \{
    globals = \textcolor{keyword}{true};
  \};


  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}($injector, $window) \{

    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(expression, locals, later, ident) \{
      \textcolor{comment}{// PRIVATE API:}
      \textcolor{comment}{//   param `later` --- indicates that the controller's constructor is invoked at a later time.}
      \textcolor{comment}{//                     If true, $controller will allocate the object with the correct}
      \textcolor{comment}{//                     prototype chain, but will not invoke the controller until a returned}
      \textcolor{comment}{//                     callback is invoked.}
      \textcolor{comment}{//   param `ident` --- An optional label which overrides the label parsed from the controller}
      \textcolor{comment}{//                     expression, if any.}
      var instance, match, constructor, identifier;
      later = later === \textcolor{keyword}{true};
      \textcolor{keywordflow}{if} (ident && isString(ident)) \{
        identifier = ident;
      \}

      \textcolor{keywordflow}{if} (isString(expression)) \{
        match = expression.match(CNTRL\_REG);
        \textcolor{keywordflow}{if} (!match) \{
          \textcolor{keywordflow}{throw} $controllerMinErr(\textcolor{stringliteral}{'ctrlfmt'},
            \textcolor{stringliteral}{"Badly formed controller string '\{0\}'. "} +
            \textcolor{stringliteral}{"Must match `\_\_name\_\_ as \_\_id\_\_` or `\_\_name\_\_`."}, expression);
        \}
        constructor = match[1],
        identifier = identifier || match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, \textcolor{keyword}{true}) ||
                (globals ? getter($window, constructor, \textcolor{keyword}{true}) : undefined);

        assertArgFn(expression, constructor, \textcolor{keyword}{true});
      \}

      \textcolor{keywordflow}{if} (later) \{
        \textcolor{comment}{// Instantiate controller later:}
        \textcolor{comment}{// This machinery is used to create an instance of the object before calling the}
        \textcolor{comment}{// controller's constructor itself.}
        \textcolor{comment}{//}
        \textcolor{comment}{// This allows properties to be added to the controller before the constructor is}
        \textcolor{comment}{// invoked. Primarily, this is used for isolate scope bindings in $compile.}
        \textcolor{comment}{//}
        \textcolor{comment}{// This feature is not intended for use by applications, and is thus not documented}
        \textcolor{comment}{// publicly.}
        \textcolor{comment}{// Object creation: http://jsperf.com/create-constructor/2}
        var controllerPrototype = (isArray(expression) ?
          expression[expression.length - 1] : expression).prototype;
        instance = Object.create(controllerPrototype || null);

        \textcolor{keywordflow}{if} (identifier) \{
          addIdentifier(locals, identifier, instance, constructor || expression.name);
        \}

        var instantiate;
        \textcolor{keywordflow}{return} instantiate = extend(\textcolor{keyword}{function}() \{
          var result = $injector.invoke(expression, instance, locals, constructor);
          \textcolor{keywordflow}{if} (result !== instance && (isObject(result) || isFunction(result))) \{
            instance = result;
            \textcolor{keywordflow}{if} (identifier) \{
              \textcolor{comment}{// If result changed, re-assign controllerAs value to scope.}
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            \}
          \}
          \textcolor{keywordflow}{return} instance;
        \}, \{
          instance: instance,
          identifier: identifier
        \});
      \}

      instance = $injector.instantiate(expression, locals, constructor);

      \textcolor{keywordflow}{if} (identifier) \{
        addIdentifier(locals, identifier, instance, constructor || expression.name);
      \}

      \textcolor{keywordflow}{return} instance;
    \};

    \textcolor{keyword}{function} addIdentifier(locals, identifier, instance, name) \{
      \textcolor{keywordflow}{if} (!(locals && isObject(locals.$scope))) \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'$controller'})(\textcolor{stringliteral}{'noscp'},
          \textcolor{stringliteral}{"Cannot export controller '\{0\}' as '\{1\}'! No $scope object provided via `locals`."},
          name, identifier);
      \}

      locals.$scope[identifier] = instance;
    \}
  \}];
\}

\textcolor{keyword}{function} $DocumentProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}(window) \{
    \textcolor{keywordflow}{return} jqLite(window.document);
  \}];
\}

\textcolor{keyword}{function} $ExceptionHandlerProvider() \{
  this.$get = [\textcolor{stringliteral}{'$log'}, \textcolor{keyword}{function}($log) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(exception, cause) \{
      $log.error.apply($log, arguments);
    \};
  \}];
\}

var $$ForceReflowProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$document'}, \textcolor{keyword}{function}($document) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(domNode) \{
      \textcolor{comment}{//the line below will force the browser to perform a repaint so}
      \textcolor{comment}{//that all the animated elements within the animation frame will}
      \textcolor{comment}{//be properly updated and drawn on screen. This is required to}
      \textcolor{comment}{//ensure that the preparation animation is properly flushed so that}
      \textcolor{comment}{//the active state picks up from there. DO NOT REMOVE THIS LINE.}
      \textcolor{comment}{//DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH}
      \textcolor{comment}{//WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND}
      \textcolor{comment}{//WILL TAKE YEARS AWAY FROM YOUR LIFE.}
      \textcolor{keywordflow}{if} (domNode) \{
        \textcolor{keywordflow}{if} (!domNode.nodeType && domNode instanceof jqLite) \{
          domNode = domNode[0];
        \}
      \} \textcolor{keywordflow}{else} \{
        domNode = $document[0].body;
      \}
      \textcolor{keywordflow}{return} domNode.offsetWidth + 1;
    \};
  \}];
\};

var APPLICATION\_JSON = \textcolor{stringliteral}{'application/json'};
var CONTENT\_TYPE\_APPLICATION\_JSON = \{\textcolor{stringliteral}{'Content-Type'}: APPLICATION\_JSON + \textcolor{stringliteral}{';charset=utf-8'}\};
var JSON\_START = /^\(\backslash\)[|^\(\backslash\)\{(?!\(\backslash\)\{)/;
var JSON\_ENDS = \{
  \textcolor{charliteral}{'['}: /]$/,
  \textcolor{charliteral}{'\{'}: /\}$/
\};
var JSON\_PROTECTION\_PREFIX = /^\(\backslash\))\(\backslash\)]\(\backslash\)\}\textcolor{stringliteral}{',?\(\backslash\)n/;}
\textcolor{stringliteral}{var $httpMinErr = minErr('}$http\textcolor{stringliteral}{');}
\textcolor{stringliteral}{var $httpMinErrLegacyFn = function(method) \{}
\textcolor{stringliteral}{  return function() \{}
\textcolor{stringliteral}{    throw $httpMinErr('}legacy\textcolor{stringliteral}{', '}The method `\{0\}` on the promise returned from `$http` has been disabled.\textcolor{stringliteral}{',
       method);}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function serializeValue(v) \{}
\textcolor{stringliteral}{  if (isObject(v)) \{}
\textcolor{stringliteral}{    return isDate(v) ? v.toISOString() : toJson(v);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{  return v;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpParamSerializerProvider() \{}
\textcolor{stringliteral}{  this.$get = function() \{}
\textcolor{stringliteral}{    return function ngParamSerializer(params) \{}
\textcolor{stringliteral}{      if (!params) return '}\textcolor{stringliteral}{';}
\textcolor{stringliteral}{      var parts = [];}
\textcolor{stringliteral}{      forEachSorted(params, function(value, key) \{}
\textcolor{stringliteral}{        if (value === null || isUndefined(value)) return;}
\textcolor{stringliteral}{        if (isArray(value)) \{}
\textcolor{stringliteral}{          forEach(value, function(v, k) \{}
\textcolor{stringliteral}{            parts.push(encodeUriQuery(key)  + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(v)));}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else \{}
\textcolor{stringliteral}{          parts.push(encodeUriQuery(key) + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(value)));}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{      \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{      return parts.join('}&\textcolor{stringliteral}{');}
\textcolor{stringliteral}{    \};}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpParamSerializerJQLikeProvider() \{}
\textcolor{stringliteral}{  this.$get = function() \{}
\textcolor{stringliteral}{    return function jQueryLikeParamSerializer(params) \{}
\textcolor{stringliteral}{      if (!params) return '}\textcolor{stringliteral}{';}
\textcolor{stringliteral}{      var parts = [];}
\textcolor{stringliteral}{      serialize(params, '}\textcolor{stringliteral}{', true);}
\textcolor{stringliteral}{      return parts.join('}&\textcolor{stringliteral}{');}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{      function serialize(toSerialize, prefix, topLevel) \{}
\textcolor{stringliteral}{        if (toSerialize === null || isUndefined(toSerialize)) return;}
\textcolor{stringliteral}{        if (isArray(toSerialize)) \{}
\textcolor{stringliteral}{          forEach(toSerialize, function(value, index) \{}
\textcolor{stringliteral}{            serialize(value, prefix + '}[\textcolor{stringliteral}{' + (isObject(value) ? index : '}\textcolor{stringliteral}{') + '}]\textcolor{stringliteral}{');}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else if (isObject(toSerialize) && !isDate(toSerialize)) \{}
\textcolor{stringliteral}{          forEachSorted(toSerialize, function(value, key) \{}
\textcolor{stringliteral}{            serialize(value, prefix +}
\textcolor{stringliteral}{                (topLevel ? '}\textcolor{stringliteral}{' : '}[\textcolor{stringliteral}{') +}
\textcolor{stringliteral}{                key +}
\textcolor{stringliteral}{                (topLevel ? '}\textcolor{stringliteral}{' : '}]\textcolor{stringliteral}{'));}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else \{}
\textcolor{stringliteral}{          parts.push(encodeUriQuery(prefix) + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(toSerialize)));}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \};}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function defaultHttpResponseTransform(data, headers) \{}
\textcolor{stringliteral}{  if (isString(data)) \{}
\textcolor{stringliteral}{    // Strip json vulnerability protection prefix and trim whitespace}
\textcolor{stringliteral}{    var tempData = data.replace(JSON\_PROTECTION\_PREFIX, '}\textcolor{stringliteral}{').trim();}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    if (tempData) \{}
\textcolor{stringliteral}{      var contentType = headers('}Content-Type\textcolor{stringliteral}{');}
\textcolor{stringliteral}{      if ((contentType && (contentType.indexOf(APPLICATION\_JSON) === 0)) || isJsonLike(tempData)) \{}
\textcolor{stringliteral}{        data = fromJson(tempData);}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return data;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function isJsonLike(str) \{}
\textcolor{stringliteral}{    var jsonStart = str.match(JSON\_START);}
\textcolor{stringliteral}{    return jsonStart && JSON\_ENDS[jsonStart[0]].test(str);}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function parseHeaders(headers) \{}
\textcolor{stringliteral}{  var parsed = createMap(), i;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function fillInParsed(key, val) \{}
\textcolor{stringliteral}{    if (key) \{}
\textcolor{stringliteral}{      parsed[key] = parsed[key] ? parsed[key] + '}, \textcolor{stringliteral}{' + val : val;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  if (isString(headers)) \{}
\textcolor{stringliteral}{    forEach(headers.split('}\(\backslash\)n\textcolor{stringliteral}{'), function(line) \{}
\textcolor{stringliteral}{      i = line.indexOf('}:\textcolor{stringliteral}{');}
\textcolor{stringliteral}{      fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \} else if (isObject(headers)) \{}
\textcolor{stringliteral}{    forEach(headers, function(headerVal, headerKey) \{}
\textcolor{stringliteral}{      fillInParsed(lowercase(headerKey), trim(headerVal));}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return parsed;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function headersGetter(headers) \{}
\textcolor{stringliteral}{  var headersObj;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return function(name) \{}
\textcolor{stringliteral}{    if (!headersObj) headersObj =  parseHeaders(headers);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    if (name) \{}
\textcolor{stringliteral}{      var value = headersObj[lowercase(name)];}
\textcolor{stringliteral}{      if (value === void 0) \{}
\textcolor{stringliteral}{        value = null;}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{      return value;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    return headersObj;}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function transformData(data, headers, status, fns) \{}
\textcolor{stringliteral}{  if (isFunction(fns)) \{}
\textcolor{stringliteral}{    return fns(data, headers, status);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  forEach(fns, function(fn) \{}
\textcolor{stringliteral}{    data = fn(data, headers, status);}
\textcolor{stringliteral}{  \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return data;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function isSuccess(status) \{}
\textcolor{stringliteral}{  return 200 <= status && status < 300;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpProvider() \{}
\textcolor{stringliteral}{  var defaults = this.defaults = \{}
\textcolor{stringliteral}{    // transform incoming response data}
\textcolor{stringliteral}{    transformResponse: [defaultHttpResponseTransform],}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // transform outgoing request data}
\textcolor{stringliteral}{    transformRequest: [function(d) \{}
\textcolor{stringliteral}{      return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;}
\textcolor{stringliteral}{    \}],}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // default headers}
\textcolor{stringliteral}{    headers: \{}
\textcolor{stringliteral}{      common: \{}
\textcolor{stringliteral}{        '}Accept\textcolor{stringliteral}{': '}application/json, text/plain, *\textcolor{comment}{/*'}
\textcolor{comment}{      \},}
\textcolor{comment}{      post:   shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON),}
\textcolor{comment}{      put:    shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON),}
\textcolor{comment}{      patch:  shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON)}
\textcolor{comment}{    \},}
\textcolor{comment}{}
\textcolor{comment}{    xsrfCookieName: 'XSRF-TOKEN',}
\textcolor{comment}{    xsrfHeaderName: 'X-XSRF-TOKEN',}
\textcolor{comment}{}
\textcolor{comment}{    paramSerializer: '$httpParamSerializer'}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var useApplyAsync = false;}
\textcolor{comment}{  this.useApplyAsync = function(value) \{}
\textcolor{comment}{    if (isDefined(value)) \{}
\textcolor{comment}{      useApplyAsync = !!value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \}}
\textcolor{comment}{    return useApplyAsync;}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var useLegacyPromise = true;}
\textcolor{comment}{  this.useLegacyPromiseExtensions = function(value) \{}
\textcolor{comment}{    if (isDefined(value)) \{}
\textcolor{comment}{      useLegacyPromise = !!value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \}}
\textcolor{comment}{    return useLegacyPromise;}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var interceptorFactories = this.interceptors = [];}
\textcolor{comment}{}
\textcolor{comment}{  this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector',}
\textcolor{comment}{      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) \{}
\textcolor{comment}{}
\textcolor{comment}{    var defaultCache = $cacheFactory('$http');}
\textcolor{comment}{}
\textcolor{comment}{    defaults.paramSerializer = isString(defaults.paramSerializer) ?}
\textcolor{comment}{      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;}
\textcolor{comment}{}
\textcolor{comment}{    var reversedInterceptors = [];}
\textcolor{comment}{}
\textcolor{comment}{    forEach(interceptorFactories, function(interceptorFactory) \{}
\textcolor{comment}{      reversedInterceptors.unshift(isString(interceptorFactory)}
\textcolor{comment}{          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));}
\textcolor{comment}{    \});}
\textcolor{comment}{}
\textcolor{comment}{    function $http(requestConfig) \{}
\textcolor{comment}{}
\textcolor{comment}{      if (!angular.isObject(requestConfig)) \{}
\textcolor{comment}{        throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: \{0\}',
       requestConfig);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      var config = extend(\{}
\textcolor{comment}{        method: 'get',}
\textcolor{comment}{        transformRequest: defaults.transformRequest,}
\textcolor{comment}{        transformResponse: defaults.transformResponse,}
\textcolor{comment}{        paramSerializer: defaults.paramSerializer}
\textcolor{comment}{      \}, requestConfig);}
\textcolor{comment}{}
\textcolor{comment}{      config.headers = mergeHeaders(requestConfig);}
\textcolor{comment}{      config.method = uppercase(config.method);}
\textcolor{comment}{      config.paramSerializer = isString(config.paramSerializer) ?}
\textcolor{comment}{        $injector.get(config.paramSerializer) : config.paramSerializer;}
\textcolor{comment}{}
\textcolor{comment}{      var serverRequest = function(config) \{}
\textcolor{comment}{        var headers = config.headers;}
\textcolor{comment}{        var reqData = transformData(config.data, headersGetter(headers), undefined,
       config.transformRequest);}
\textcolor{comment}{}
\textcolor{comment}{        // strip content-type if data is undefined}
\textcolor{comment}{        if (isUndefined(reqData)) \{}
\textcolor{comment}{          forEach(headers, function(value, header) \{}
\textcolor{comment}{            if (lowercase(header) === 'content-type') \{}
\textcolor{comment}{                delete headers[header];}
\textcolor{comment}{            \}}
\textcolor{comment}{          \});}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) \{}
\textcolor{comment}{          config.withCredentials = defaults.withCredentials;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        // send request}
\textcolor{comment}{        return sendReq(config, reqData).then(transformResponse, transformResponse);}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var chain = [serverRequest, undefined];}
\textcolor{comment}{      var promise = $q.when(config);}
\textcolor{comment}{}
\textcolor{comment}{      // apply interceptors}
\textcolor{comment}{      forEach(reversedInterceptors, function(interceptor) \{}
\textcolor{comment}{        if (interceptor.request || interceptor.requestError) \{}
\textcolor{comment}{          chain.unshift(interceptor.request, interceptor.requestError);}
\textcolor{comment}{        \}}
\textcolor{comment}{        if (interceptor.response || interceptor.responseError) \{}
\textcolor{comment}{          chain.push(interceptor.response, interceptor.responseError);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      while (chain.length) \{}
\textcolor{comment}{        var thenFn = chain.shift();}
\textcolor{comment}{        var rejectFn = chain.shift();}
\textcolor{comment}{}
\textcolor{comment}{        promise = promise.then(thenFn, rejectFn);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (useLegacyPromise) \{}
\textcolor{comment}{        promise.success = function(fn) \{}
\textcolor{comment}{          assertArgFn(fn, 'fn');}
\textcolor{comment}{}
\textcolor{comment}{          promise.then(function(response) \{}
\textcolor{comment}{            fn(response.data, response.status, response.headers, config);}
\textcolor{comment}{          \});}
\textcolor{comment}{          return promise;}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        promise.error = function(fn) \{}
\textcolor{comment}{          assertArgFn(fn, 'fn');}
\textcolor{comment}{}
\textcolor{comment}{          promise.then(null, function(response) \{}
\textcolor{comment}{            fn(response.data, response.status, response.headers, config);}
\textcolor{comment}{          \});}
\textcolor{comment}{          return promise;}
\textcolor{comment}{        \};}
\textcolor{comment}{      \} else \{}
\textcolor{comment}{        promise.success = $httpMinErrLegacyFn('success');}
\textcolor{comment}{        promise.error = $httpMinErrLegacyFn('error');}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{}
\textcolor{comment}{      function transformResponse(response) \{}
\textcolor{comment}{        // make a copy since the response must be cacheable}
\textcolor{comment}{        var resp = extend(\{\}, response);}
\textcolor{comment}{        if (!response.data) \{}
\textcolor{comment}{          resp.data = response.data;}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          resp.data = transformData(response.data, response.headers, response.status,
       config.transformResponse);}
\textcolor{comment}{        \}}
\textcolor{comment}{        return (isSuccess(response.status))}
\textcolor{comment}{          ? resp}
\textcolor{comment}{          : $q.reject(resp);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function executeHeaderFns(headers, config) \{}
\textcolor{comment}{        var headerContent, processedHeaders = \{\};}
\textcolor{comment}{}
\textcolor{comment}{        forEach(headers, function(headerFn, header) \{}
\textcolor{comment}{          if (isFunction(headerFn)) \{}
\textcolor{comment}{            headerContent = headerFn(config);}
\textcolor{comment}{            if (headerContent != null) \{}
\textcolor{comment}{              processedHeaders[header] = headerContent;}
\textcolor{comment}{            \}}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            processedHeaders[header] = headerFn;}
\textcolor{comment}{          \}}
\textcolor{comment}{        \});}
\textcolor{comment}{}
\textcolor{comment}{        return processedHeaders;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function mergeHeaders(config) \{}
\textcolor{comment}{        var defHeaders = defaults.headers,}
\textcolor{comment}{            reqHeaders = extend(\{\}, config.headers),}
\textcolor{comment}{            defHeaderName, lowercaseDefHeaderName, reqHeaderName;}
\textcolor{comment}{}
\textcolor{comment}{        defHeaders = extend(\{\}, defHeaders.common, defHeaders[lowercase(config.method)]);}
\textcolor{comment}{}
\textcolor{comment}{        // using for-in instead of forEach to avoid unecessary iteration after header has been found}
\textcolor{comment}{        defaultHeadersIteration:}
\textcolor{comment}{        for (defHeaderName in defHeaders) \{}
\textcolor{comment}{          lowercaseDefHeaderName = lowercase(defHeaderName);}
\textcolor{comment}{}
\textcolor{comment}{          for (reqHeaderName in reqHeaders) \{}
\textcolor{comment}{            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) \{}
\textcolor{comment}{              continue defaultHeadersIteration;}
\textcolor{comment}{            \}}
\textcolor{comment}{          \}}
\textcolor{comment}{}
\textcolor{comment}{          reqHeaders[defHeaderName] = defHeaders[defHeaderName];}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        // execute if header value is a function for merged headers}
\textcolor{comment}{        return executeHeaderFns(reqHeaders, shallowCopy(config));}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    $http.pendingRequests = [];}
\textcolor{comment}{}
\textcolor{comment}{    createShortMethods('get', 'delete', 'head', 'jsonp');}
\textcolor{comment}{}
\textcolor{comment}{    createShortMethodsWithData('post', 'put', 'patch');}
\textcolor{comment}{}
\textcolor{comment}{    $http.defaults = defaults;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    return $http;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function createShortMethods(names) \{}
\textcolor{comment}{      forEach(arguments, function(name) \{}
\textcolor{comment}{        $http[name] = function(url, config) \{}
\textcolor{comment}{          return $http(extend(\{\}, config || \{\}, \{}
\textcolor{comment}{            method: name,}
\textcolor{comment}{            url: url}
\textcolor{comment}{          \}));}
\textcolor{comment}{        \};}
\textcolor{comment}{      \});}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function createShortMethodsWithData(name) \{}
\textcolor{comment}{      forEach(arguments, function(name) \{}
\textcolor{comment}{        $http[name] = function(url, data, config) \{}
\textcolor{comment}{          return $http(extend(\{\}, config || \{\}, \{}
\textcolor{comment}{            method: name,}
\textcolor{comment}{            url: url,}
\textcolor{comment}{            data: data}
\textcolor{comment}{          \}));}
\textcolor{comment}{        \};}
\textcolor{comment}{      \});}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function sendReq(config, reqData) \{}
\textcolor{comment}{      var deferred = $q.defer(),}
\textcolor{comment}{          promise = deferred.promise,}
\textcolor{comment}{          cache,}
\textcolor{comment}{          cachedResp,}
\textcolor{comment}{          reqHeaders = config.headers,}
\textcolor{comment}{          url = buildUrl(config.url, config.paramSerializer(config.params));}
\textcolor{comment}{}
\textcolor{comment}{      $http.pendingRequests.push(config);}
\textcolor{comment}{      promise.then(removePendingReq, removePendingReq);}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      if ((config.cache || defaults.cache) && config.cache !== false &&}
\textcolor{comment}{          (config.method === 'GET' || config.method === 'JSONP')) \{}
\textcolor{comment}{        cache = isObject(config.cache) ? config.cache}
\textcolor{comment}{              : isObject(defaults.cache) ? defaults.cache}
\textcolor{comment}{              : defaultCache;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (cache) \{}
\textcolor{comment}{        cachedResp = cache.get(url);}
\textcolor{comment}{        if (isDefined(cachedResp)) \{}
\textcolor{comment}{          if (isPromiseLike(cachedResp)) \{}
\textcolor{comment}{            // cached request has already been sent, but there is no response yet}
\textcolor{comment}{            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            // serving from cache}
\textcolor{comment}{            if (isArray(cachedResp)) \{}
\textcolor{comment}{              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);}
\textcolor{comment}{            \} else \{}
\textcolor{comment}{              resolvePromise(cachedResp, 200, \{\}, 'OK');}
\textcolor{comment}{            \}}
\textcolor{comment}{          \}}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          // put the promise for the non-transformed response into cache as a placeholder}
\textcolor{comment}{          cache.put(url, promise);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      // if we won't have the response in cache, set the xsrf headers and}
\textcolor{comment}{      // send the request to the backend}
\textcolor{comment}{      if (isUndefined(cachedResp)) \{}
\textcolor{comment}{        var xsrfValue = urlIsSameOrigin(config.url)}
\textcolor{comment}{            ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName]}
\textcolor{comment}{            : undefined;}
\textcolor{comment}{        if (xsrfValue) \{}
\textcolor{comment}{          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,}
\textcolor{comment}{            config.withCredentials, config.responseType);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      function done(status, response, headersString, statusText) \{}
\textcolor{comment}{        if (cache) \{}
\textcolor{comment}{          if (isSuccess(status)) \{}
\textcolor{comment}{            cache.put(url, [status, response, parseHeaders(headersString), statusText]);}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            // remove promise from the cache}
\textcolor{comment}{            cache.remove(url);}
\textcolor{comment}{          \}}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        function resolveHttpPromise() \{}
\textcolor{comment}{          resolvePromise(response, status, headersString, statusText);}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (useApplyAsync) \{}
\textcolor{comment}{          $rootScope.$applyAsync(resolveHttpPromise);}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          resolveHttpPromise();}
\textcolor{comment}{          if (!$rootScope.$$phase) $rootScope.$apply();}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      function resolvePromise(response, status, headers, statusText) \{}
\textcolor{comment}{        // normalize internal statuses to 0}
\textcolor{comment}{        status = Math.max(status, 0);}
\textcolor{comment}{}
\textcolor{comment}{        (isSuccess(status) ? deferred.resolve : deferred.reject)(\{}
\textcolor{comment}{          data: response,}
\textcolor{comment}{          status: status,}
\textcolor{comment}{          headers: headersGetter(headers),}
\textcolor{comment}{          config: config,}
\textcolor{comment}{          statusText: statusText}
\textcolor{comment}{        \});}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function resolvePromiseWithResult(result) \{}
\textcolor{comment}{        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function removePendingReq() \{}
\textcolor{comment}{        var idx = $http.pendingRequests.indexOf(config);}
\textcolor{comment}{        if (idx !== -1) $http.pendingRequests.splice(idx, 1);}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function buildUrl(url, serializedParams) \{}
\textcolor{comment}{      if (serializedParams.length > 0) \{}
\textcolor{comment}{        url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;}
\textcolor{comment}{      \}}
\textcolor{comment}{      return url;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function createXhr() \{}
\textcolor{comment}{    return new window.XMLHttpRequest();}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function $HttpBackendProvider() \{}
\textcolor{comment}{  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) \{}
\textcolor{comment}{    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) \{}
\textcolor{comment}{  // TODO(vojta): fix the signature}
\textcolor{comment}{  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) \{}
\textcolor{comment}{    $browser.$$incOutstandingRequestCount();}
\textcolor{comment}{    url = url || $browser.url();}
\textcolor{comment}{}
\textcolor{comment}{    if (lowercase(method) == 'jsonp') \{}
\textcolor{comment}{      var callbackId = '\_' + (callbacks.counter++).toString(36);}
\textcolor{comment}{      callbacks[callbackId] = function(data) \{}
\textcolor{comment}{        callbacks[callbackId].data = data;}
\textcolor{comment}{        callbacks[callbackId].called = true;}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var jsonpDone = jsonpReq(url.replace('JSON\_CALLBACK', 'angular.callbacks.' + callbackId),}
\textcolor{comment}{          callbackId, function(status, text) \{}
\textcolor{comment}{        completeRequest(callback, status, callbacks[callbackId].data, "", text);}
\textcolor{comment}{        callbacks[callbackId] = noop;}
\textcolor{comment}{      \});}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{}
\textcolor{comment}{      var xhr = createXhr();}
\textcolor{comment}{}
\textcolor{comment}{      xhr.open(method, url, true);}
\textcolor{comment}{      forEach(headers, function(value, key) \{}
\textcolor{comment}{        if (isDefined(value)) \{}
\textcolor{comment}{            xhr.setRequestHeader(key, value);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      xhr.onload = function requestLoaded() \{}
\textcolor{comment}{        var statusText = xhr.statusText || '';}
\textcolor{comment}{}
\textcolor{comment}{        // responseText is the old-school way of retrieving response (supported by IE9)}
\textcolor{comment}{        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)}
\textcolor{comment}{        var response = ('response' in xhr) ? xhr.response : xhr.responseText;}
\textcolor{comment}{}
\textcolor{comment}{        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)}
\textcolor{comment}{        var status = xhr.status === 1223 ? 204 : xhr.status;}
\textcolor{comment}{}
\textcolor{comment}{        // fix status code when it is 0 (0 status is undocumented).}
\textcolor{comment}{        // Occurs when accessing file resources or on Android 4.1 stock browser}
\textcolor{comment}{        // while retrieving files from application cache.}
\textcolor{comment}{        if (status === 0) \{}
\textcolor{comment}{          status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        completeRequest(callback,}
\textcolor{comment}{            status,}
\textcolor{comment}{            response,}
\textcolor{comment}{            xhr.getAllResponseHeaders(),}
\textcolor{comment}{            statusText);}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var requestError = function() \{}
\textcolor{comment}{        // The response is always empty}
\textcolor{comment}{        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/
      #concept-network-error}
\textcolor{comment}{        completeRequest(callback, -1, null, null, '');}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      xhr.onerror = requestError;}
\textcolor{comment}{      xhr.onabort = requestError;}
\textcolor{comment}{}
\textcolor{comment}{      if (withCredentials) \{}
\textcolor{comment}{        xhr.withCredentials = true;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (responseType) \{}
\textcolor{comment}{        try \{}
\textcolor{comment}{          xhr.responseType = responseType;}
\textcolor{comment}{        \} catch (e) \{}
\textcolor{comment}{          // WebKit added support for the json responseType value on 09/03/2013}
\textcolor{comment}{          // https://bugs.webkit.org/show\_bug.cgi?id=73648. Versions of Safari prior to 7 are}
\textcolor{comment}{          // known to throw when setting the value "json" as the response type. Other older}
\textcolor{comment}{          // browsers implementing the responseType}
\textcolor{comment}{          //}
\textcolor{comment}{          // The json response type can be ignored if not supported, because JSON payloads are}
\textcolor{comment}{          // parsed on the client-side regardless.}
\textcolor{comment}{          if (responseType !== 'json') \{}
\textcolor{comment}{            throw e;}
\textcolor{comment}{          \}}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      xhr.send(post);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    if (timeout > 0) \{}
\textcolor{comment}{      var timeoutId = $browserDefer(timeoutRequest, timeout);}
\textcolor{comment}{    \} else if (isPromiseLike(timeout)) \{}
\textcolor{comment}{      timeout.then(timeoutRequest);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function timeoutRequest() \{}
\textcolor{comment}{      jsonpDone && jsonpDone();}
\textcolor{comment}{      xhr && xhr.abort();}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function completeRequest(callback, status, response, headersString, statusText) \{}
\textcolor{comment}{      // cancel timeout and subsequent timeout promise resolution}
\textcolor{comment}{      if (timeoutId !== undefined) \{}
\textcolor{comment}{        $browserDefer.cancel(timeoutId);}
\textcolor{comment}{      \}}
\textcolor{comment}{      jsonpDone = xhr = null;}
\textcolor{comment}{}
\textcolor{comment}{      callback(status, response, headersString, statusText);}
\textcolor{comment}{      $browser.$$completeOutstandingRequest(noop);}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  function jsonpReq(url, callbackId, done) \{}
\textcolor{comment}{    // we can't use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:}
\textcolor{comment}{    // - fetches local scripts via XHR and evals them}
\textcolor{comment}{    // - adds and immediately removes script elements from the document}
\textcolor{comment}{    var script = rawDocument.createElement('script'), callback = null;}
\textcolor{comment}{    script.type = "text/javascript";}
\textcolor{comment}{    script.src = url;}
\textcolor{comment}{    script.async = true;}
\textcolor{comment}{}
\textcolor{comment}{    callback = function(event) \{}
\textcolor{comment}{      removeEventListenerFn(script, "load", callback);}
\textcolor{comment}{      removeEventListenerFn(script, "error", callback);}
\textcolor{comment}{      rawDocument.body.removeChild(script);}
\textcolor{comment}{      script = null;}
\textcolor{comment}{      var status = -1;}
\textcolor{comment}{      var text = "unknown";}
\textcolor{comment}{}
\textcolor{comment}{      if (event) \{}
\textcolor{comment}{        if (event.type === "load" && !callbacks[callbackId].called) \{}
\textcolor{comment}{          event = \{ type: "error" \};}
\textcolor{comment}{        \}}
\textcolor{comment}{        text = event.type;}
\textcolor{comment}{        status = event.type === "error" ? 404 : 200;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (done) \{}
\textcolor{comment}{        done(status, text);}
\textcolor{comment}{      \}}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    addEventListenerFn(script, "load", callback);}
\textcolor{comment}{    addEventListenerFn(script, "error", callback);}
\textcolor{comment}{    rawDocument.body.appendChild(script);}
\textcolor{comment}{    return callback;}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');}
\textcolor{comment}{$interpolateMinErr.throwNoconcat = function(text) \{}
\textcolor{comment}{  throw $interpolateMinErr('noconcat',}
\textcolor{comment}{      "Error while interpolating: \{0\}\(\backslash\)nStrict Contextual Escaping disallows " +}
\textcolor{comment}{      "interpolations that concatenate multiple expressions when a trusted value is " +}
\textcolor{comment}{      "required.  See http://docs.angularjs.org/api/ng.$sce", text);}
\textcolor{comment}{\};}
\textcolor{comment}{}
\textcolor{comment}{$interpolateMinErr.interr = function(text, err) \{}
\textcolor{comment}{  return $interpolateMinErr('interr', "Can't interpolate: \{0\}\(\backslash\)n\{1\}", text, err.toString());}
\textcolor{comment}{\};}
\textcolor{comment}{}
\textcolor{comment}{function $InterpolateProvider() \{}
\textcolor{comment}{  var startSymbol = '\{\{';}
\textcolor{comment}{  var endSymbol = '\}\}';}
\textcolor{comment}{}
\textcolor{comment}{  this.startSymbol = function(value) \{}
\textcolor{comment}{    if (value) \{}
\textcolor{comment}{      startSymbol = value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{      return startSymbol;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  this.endSymbol = function(value) \{}
\textcolor{comment}{    if (value) \{}
\textcolor{comment}{      endSymbol = value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{      return endSymbol;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) \{}
\textcolor{comment}{    var startSymbolLength = startSymbol.length,}
\textcolor{comment}{        endSymbolLength = endSymbol.length,}
\textcolor{comment}{        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),}
\textcolor{comment}{        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');}
\textcolor{comment}{}
\textcolor{comment}{    function escape(ch) \{}
\textcolor{comment}{      return '\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)' + ch;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function unescapeText(text) \{}
\textcolor{comment}{      return text.replace(escapedStartRegexp, startSymbol).}
\textcolor{comment}{        replace(escapedEndRegexp, endSymbol);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function stringify(value) \{}
\textcolor{comment}{      if (value == null) \{ // null || undefined}
\textcolor{comment}{        return '';}
\textcolor{comment}{      \}}
\textcolor{comment}{      switch (typeof value) \{}
\textcolor{comment}{        case 'string':}
\textcolor{comment}{          break;}
\textcolor{comment}{        case 'number':}
\textcolor{comment}{          value = '' + value;}
\textcolor{comment}{          break;}
\textcolor{comment}{        default:}
\textcolor{comment}{          value = toJson(value);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return value;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) \{}
\textcolor{comment}{      allOrNothing = !!allOrNothing;}
\textcolor{comment}{      var startIndex,}
\textcolor{comment}{          endIndex,}
\textcolor{comment}{          index = 0,}
\textcolor{comment}{          expressions = [],}
\textcolor{comment}{          parseFns = [],}
\textcolor{comment}{          textLength = text.length,}
\textcolor{comment}{          exp,}
\textcolor{comment}{          concat = [],}
\textcolor{comment}{          expressionPositions = [];}
\textcolor{comment}{}
\textcolor{comment}{      while (index < textLength) \{}
\textcolor{comment}{        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&}
\textcolor{comment}{             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) \{}
\textcolor{comment}{          if (index !== startIndex) \{}
\textcolor{comment}{            concat.push(unescapeText(text.substring(index, startIndex)));}
\textcolor{comment}{          \}}
\textcolor{comment}{          exp = text.substring(startIndex + startSymbolLength, endIndex);}
\textcolor{comment}{          expressions.push(exp);}
\textcolor{comment}{          parseFns.push($parse(exp, parseStringifyInterceptor));}
\textcolor{comment}{          index = endIndex + endSymbolLength;}
\textcolor{comment}{          expressionPositions.push(concat.length);}
\textcolor{comment}{          concat.push('');}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          // we did not find an interpolation, so we have to add the remainder to the separators array}
\textcolor{comment}{          if (index !== textLength) \{}
\textcolor{comment}{            concat.push(unescapeText(text.substring(index)));}
\textcolor{comment}{          \}}
\textcolor{comment}{          break;}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      // Concatenating expressions makes it hard to reason about whether some combination of}
\textcolor{comment}{      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a}
\textcolor{comment}{      // single expression be used for iframe[src], object[src], etc., we ensure that the value}
\textcolor{comment}{      // that's used is assigned or constructed by some JS code somewhere that is more testable or}
\textcolor{comment}{      // make it obvious that you bound the value to some user controlled value.  This helps reduce}
\textcolor{comment}{      // the load when auditing for XSS issues.}
\textcolor{comment}{      if (trustedContext && concat.length > 1) \{}
\textcolor{comment}{          $interpolateMinErr.throwNoconcat(text);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (!mustHaveExpression || expressions.length) \{}
\textcolor{comment}{        var compute = function(values) \{}
\textcolor{comment}{          for (var i = 0, ii = expressions.length; i < ii; i++) \{}
\textcolor{comment}{            if (allOrNothing && isUndefined(values[i])) return;}
\textcolor{comment}{            concat[expressionPositions[i]] = values[i];}
\textcolor{comment}{          \}}
\textcolor{comment}{          return concat.join('');}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        var getValue = function(value) \{}
\textcolor{comment}{          return trustedContext ?}
\textcolor{comment}{            $sce.getTrusted(trustedContext, value) :}
\textcolor{comment}{            $sce.valueOf(value);}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        return extend(function interpolationFn(context) \{}
\textcolor{comment}{            var i = 0;}
\textcolor{comment}{            var ii = expressions.length;}
\textcolor{comment}{            var values = new Array(ii);}
\textcolor{comment}{}
\textcolor{comment}{            try \{}
\textcolor{comment}{              for (; i < ii; i++) \{}
\textcolor{comment}{                values[i] = parseFns[i](context);}
\textcolor{comment}{              \}}
\textcolor{comment}{}
\textcolor{comment}{              return compute(values);}
\textcolor{comment}{            \} catch (err) \{}
\textcolor{comment}{              $exceptionHandler($interpolateMinErr.interr(text, err));}
\textcolor{comment}{            \}}
\textcolor{comment}{}
\textcolor{comment}{          \}, \{}
\textcolor{comment}{          // all of these properties are undocumented for now}
\textcolor{comment}{          exp: text, //just for compatibility with regular watchers created via $watch}
\textcolor{comment}{          expressions: expressions,}
\textcolor{comment}{          $$watchDelegate: function(scope, listener) \{}
\textcolor{comment}{            var lastValue;}
\textcolor{comment}{            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) \{}
\textcolor{comment}{              var currValue = compute(values);}
\textcolor{comment}{              if (isFunction(listener)) \{}
\textcolor{comment}{                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);}
\textcolor{comment}{              \}}
\textcolor{comment}{              lastValue = currValue;}
\textcolor{comment}{            \});}
\textcolor{comment}{          \}}
\textcolor{comment}{        \});}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function parseStringifyInterceptor(value) \{}
\textcolor{comment}{        try \{}
\textcolor{comment}{          value = getValue(value);}
\textcolor{comment}{          return allOrNothing && !isDefined(value) ? value : stringify(value);}
\textcolor{comment}{        \} catch (err) \{}
\textcolor{comment}{          $exceptionHandler($interpolateMinErr.interr(text, err));}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    $interpolate.startSymbol = function() \{}
\textcolor{comment}{      return startSymbol;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    $interpolate.endSymbol = function() \{}
\textcolor{comment}{      return endSymbol;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    return $interpolate;}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function $IntervalProvider() \{}
\textcolor{comment}{  this.$get = ['$rootScope', '$window', '$q', '$$q',}
\textcolor{comment}{       function($rootScope,   $window,   $q,   $$q) \{}
\textcolor{comment}{    var intervals = \{\};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function interval(fn, delay, count, invokeApply) \{}
\textcolor{comment}{      var hasParams = arguments.length > 4,}
\textcolor{comment}{          args = hasParams ? sliceArgs(arguments, 4) : [],}
\textcolor{comment}{          setInterval = $window.setInterval,}
\textcolor{comment}{          clearInterval = $window.clearInterval,}
\textcolor{comment}{          iteration = 0,}
\textcolor{comment}{          skipApply = (isDefined(invokeApply) && !invokeApply),}
\textcolor{comment}{          deferred = (skipApply ? $$q : $q).defer(),}
\textcolor{comment}{          promise = deferred.promise;}
\textcolor{comment}{}
\textcolor{comment}{      count = isDefined(count) ? count : 0;}
\textcolor{comment}{}
\textcolor{comment}{      promise.then(null, null, (!hasParams) ? fn : function() \{}
\textcolor{comment}{        fn.apply(null, args);}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      promise.$$intervalId = setInterval(function tick() \{}
\textcolor{comment}{        deferred.notify(iteration++);}
\textcolor{comment}{}
\textcolor{comment}{        if (count > 0 && iteration >= count) \{}
\textcolor{comment}{          deferred.resolve(iteration);}
\textcolor{comment}{          clearInterval(promise.$$intervalId);}
\textcolor{comment}{          delete intervals[promise.$$intervalId];}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (!skipApply) $rootScope.$apply();}
\textcolor{comment}{}
\textcolor{comment}{      \}, delay);}
\textcolor{comment}{}
\textcolor{comment}{      intervals[promise.$$intervalId] = deferred;}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    interval.cancel = function(promise) \{}
\textcolor{comment}{      if (promise && promise.$$intervalId in intervals) \{}
\textcolor{comment}{        intervals[promise.$$intervalId].reject('canceled');}
\textcolor{comment}{        $window.clearInterval(promise.$$intervalId);}
\textcolor{comment}{        delete intervals[promise.$$intervalId];}
\textcolor{comment}{        return true;}
\textcolor{comment}{      \}}
\textcolor{comment}{      return false;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    return interval;}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{var PATH\_MATCH = /^([^\(\backslash\)?#]*)(\(\backslash\)?([^#]*))?(#(.*))?$/,}
\textcolor{comment}{    DEFAULT\_PORTS = \{'http': 80, 'https': 443, 'ftp': 21\};}
\textcolor{comment}{var $locationMinErr = minErr('$location');}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function encodePath(path) \{}
\textcolor{comment}{  var segments = path.split('/'),}
\textcolor{comment}{      i = segments.length;}
\textcolor{comment}{}
\textcolor{comment}{  while (i--) \{}
\textcolor{comment}{    segments[i] = encodeUriSegment(segments[i]);}
\textcolor{comment}{  \}}
\textcolor{comment}{}
\textcolor{comment}{  return segments.join('/');}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function parseAbsoluteUrl(absoluteUrl, locationObj) \{}
\textcolor{comment}{  var parsedUrl = urlResolve(absoluteUrl);}
\textcolor{comment}{}
\textcolor{comment}{  locationObj.$$protocol = parsedUrl.protocol;}
\textcolor{comment}{  locationObj.$$host = parsedUrl.hostname;}
\textcolor{comment}{  locationObj.$$port = toInt(parsedUrl.port) || DEFAULT\_PORTS[parsedUrl.protocol] || null;}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function parseAppUrl(relativeUrl, locationObj) \{}
\textcolor{comment}{  var prefixed = (relativeUrl.charAt(0) !== '/');}
\textcolor{comment}{  if (prefixed) \{}
\textcolor{comment}{    relativeUrl = '/' + relativeUrl;}
\textcolor{comment}{  \}}
\textcolor{comment}{  var match = urlResolve(relativeUrl);}
\textcolor{comment}{  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?}
\textcolor{comment}{      match.pathname.substring(1) : match.pathname);}
\textcolor{comment}{  locationObj.$$search = parseKeyValue(match.search);}
\textcolor{comment}{  locationObj.$$hash = decodeURIComponent(match.hash);}
\textcolor{comment}{}
\textcolor{comment}{  // make sure path starts with '/';}
\textcolor{comment}{  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') \{}
\textcolor{comment}{    locationObj.$$path = '/' + locationObj.$$path;}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function beginsWith(begin, whole) \{}
\textcolor{comment}{  if (whole.indexOf(begin) === 0) \{}
\textcolor{comment}{    return whole.substr(begin.length);}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function stripHash(url) \{}
\textcolor{comment}{  var index = url.indexOf('#');}
\textcolor{comment}{  return index == -1 ? url : url.substr(0, index);}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function trimEmptyHash(url) \{}
\textcolor{comment}{  return url.replace(/(#.+)|#$/, '$1');}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function stripFile(url) \{}
\textcolor{comment}{  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{/* return the server only (scheme://host:port) */}
\textcolor{keyword}{function} serverBase(url) \{
  \textcolor{keywordflow}{return} url.substring(0, url.indexOf(\textcolor{charliteral}{'/'}, url.indexOf(\textcolor{stringliteral}{'//'}) + 2));
\}


\textcolor{keyword}{function} LocationHtml5Url(appBase, appBaseNoFile, basePrefix) \{
  this.$$html5 = \textcolor{keyword}{true};
  basePrefix = basePrefix || \textcolor{stringliteral}{''};
  parseAbsoluteUrl(appBase, \textcolor{keyword}{this});


  this.$$parse = \textcolor{keyword}{function}(url) \{
    var pathUrl = beginsWith(appBaseNoFile, url);
    \textcolor{keywordflow}{if} (!isString(pathUrl)) \{
      \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'ipthprfx'}, \textcolor{stringliteral}{'Invalid url "\{0\}", missing path prefix "\{1\}".'}, url,
          appBaseNoFile);
    \}

    parseAppUrl(pathUrl, \textcolor{keyword}{this});

    \textcolor{keywordflow}{if} (!this.$$path) \{
      this.$$path = \textcolor{charliteral}{'/'};
    \}

    this.$$compose();
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); \textcolor{comment}{// first char is always '/'}
  \};

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (relHref && relHref[0] === \textcolor{charliteral}{'#'}) \{
      \textcolor{comment}{// special case for links to hash fragments:}
      \textcolor{comment}{// keep the old url and only replace the hash fragment}
      this.hash(relHref.slice(1));
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    var appUrl, prevAppUrl;
    var rewrittenUrl;

    \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBase, url)) !== undefined) \{
      prevAppUrl = appUrl;
      \textcolor{keywordflow}{if} ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) \{
        rewrittenUrl = appBaseNoFile + (beginsWith(\textcolor{charliteral}{'/'}, appUrl) || appUrl);
      \} \textcolor{keywordflow}{else} \{
        rewrittenUrl = appBase + prevAppUrl;
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) \{
      rewrittenUrl = appBaseNoFile + appUrl;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (appBaseNoFile == url + \textcolor{charliteral}{'/'}) \{
      rewrittenUrl = appBaseNoFile;
    \}
    \textcolor{keywordflow}{if} (rewrittenUrl) \{
      this.$$parse(rewrittenUrl);
    \}
    \textcolor{keywordflow}{return} !!rewrittenUrl;
  \};
\}


\textcolor{keyword}{function} LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) \{

  parseAbsoluteUrl(appBase, \textcolor{keyword}{this});


  this.$$parse = \textcolor{keyword}{function}(url) \{
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl;

    \textcolor{keywordflow}{if} (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === \textcolor{charliteral}{'#'}) \{

      \textcolor{comment}{// The rest of the url starts with a hash so we have}
      \textcolor{comment}{// got either a hashbang path or a plain hash fragment}
      withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
      \textcolor{keywordflow}{if} (isUndefined(withoutHashUrl)) \{
        \textcolor{comment}{// There was no hashbang prefix so we just have a hash fragment}
        withoutHashUrl = withoutBaseUrl;
      \}

    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// There was no hashbang path nor hash fragment:}
      \textcolor{comment}{// If we are in HTML5 mode we use what is left as the path;}
      \textcolor{comment}{// Otherwise we ignore what is left}
      \textcolor{keywordflow}{if} (this.$$html5) \{
        withoutHashUrl = withoutBaseUrl;
      \} \textcolor{keywordflow}{else} \{
        withoutHashUrl = \textcolor{stringliteral}{''};
        \textcolor{keywordflow}{if} (isUndefined(withoutBaseUrl)) \{
          appBase = url;
          this.replace();
        \}
      \}
    \}

    parseAppUrl(withoutHashUrl, \textcolor{keyword}{this});

    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);

    this.$$compose();

    \textcolor{comment}{/*}
\textcolor{comment}{     * In Windows, on an anchor node on documents loaded from}
\textcolor{comment}{     * the filesystem, the browser will return a pathname}
\textcolor{comment}{     * prefixed with the drive name ('/C:/path') when a}
\textcolor{comment}{     * pathname without a drive is set:}
\textcolor{comment}{     *  * a.setAttribute('href', '/foo')}
\textcolor{comment}{     *   * a.pathname === '/C:/foo' //true}
\textcolor{comment}{     *}
\textcolor{comment}{     * Inside of Angular, we're always using pathnames that}
\textcolor{comment}{     * do not include drive names for routing.}
\textcolor{comment}{     */}
    \textcolor{keyword}{function} removeWindowsDriveName(path, url, base) \{
      \textcolor{comment}{/*}
\textcolor{comment}{      Matches paths for file protocol on windows,}
\textcolor{comment}{      such as /C:/foo/bar, and captures only /foo/bar.}
\textcolor{comment}{      */}
      var windowsFilePathExp = /^\(\backslash\)/[A-Z]:(\(\backslash\)/.*)/;

      var firstPathSegmentMatch;

      \textcolor{comment}{//Get the relative path from the input URL.}
      \textcolor{keywordflow}{if} (url.indexOf(base) === 0) \{
        url = url.replace(base, \textcolor{stringliteral}{''});
      \}

      \textcolor{comment}{// The input URL intentionally contains a first path segment that ends with a colon.}
      \textcolor{keywordflow}{if} (windowsFilePathExp.exec(url)) \{
        \textcolor{keywordflow}{return} path;
      \}

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      \textcolor{keywordflow}{return} firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    \}
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : \textcolor{stringliteral}{''});
  \};

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (stripHash(appBase) == stripHash(url)) \{
      this.$$parse(url);
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \};
\}


\textcolor{keyword}{function} LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) \{
  this.$$html5 = \textcolor{keyword}{true};
  LocationHashbangUrl.apply(\textcolor{keyword}{this}, arguments);

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (relHref && relHref[0] === \textcolor{charliteral}{'#'}) \{
      \textcolor{comment}{// special case for links to hash fragments:}
      \textcolor{comment}{// keep the old url and only replace the hash fragment}
      this.hash(relHref.slice(1));
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    var rewrittenUrl;
    var appUrl;

    \textcolor{keywordflow}{if} (appBase == stripHash(url)) \{
      rewrittenUrl = url;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBaseNoFile, url))) \{
      rewrittenUrl = appBase + hashPrefix + appUrl;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (appBaseNoFile === url + \textcolor{charliteral}{'/'}) \{
      rewrittenUrl = appBaseNoFile;
    \}
    \textcolor{keywordflow}{if} (rewrittenUrl) \{
      this.$$parse(rewrittenUrl);
    \}
    \textcolor{keywordflow}{return} !!rewrittenUrl;
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    \textcolor{comment}{// include hashPrefix in $$absUrl when $$url is empty so IE9 does not reload page because of removal of
       '#'}
    this.$$absUrl = appBase + hashPrefix + this.$$url;
  \};

\}


var locationPrototype = \{

  $$html5: \textcolor{keyword}{false},

  $$replace: \textcolor{keyword}{false},

  absUrl: locationGetter(\textcolor{stringliteral}{'$$absUrl'}),

  url: \textcolor{keyword}{function}(url) \{
    \textcolor{keywordflow}{if} (isUndefined(url)) \{
      \textcolor{keywordflow}{return} this.$$url;
    \}

    var match = PATH\_MATCH.exec(url);
    \textcolor{keywordflow}{if} (match[1] || url === \textcolor{stringliteral}{''}) this.path(decodeURIComponent(match[1]));
    \textcolor{keywordflow}{if} (match[2] || match[1] || url === \textcolor{stringliteral}{''}) this.search(match[3] || \textcolor{stringliteral}{''});
    this.hash(match[5] || \textcolor{stringliteral}{''});

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \},

  protocol: locationGetter(\textcolor{stringliteral}{'$$protocol'}),

  host: locationGetter(\textcolor{stringliteral}{'$$host'}),

  port: locationGetter(\textcolor{stringliteral}{'$$port'}),

  path: locationGetterSetter(\textcolor{stringliteral}{'$$path'}, \textcolor{keyword}{function}(path) \{
    path = path !== null ? path.toString() : \textcolor{stringliteral}{''};
    \textcolor{keywordflow}{return} path.charAt(0) == \textcolor{charliteral}{'/'} ? path : \textcolor{charliteral}{'/'} + path;
  \}),

  search: \textcolor{keyword}{function}(search, paramValue) \{
    \textcolor{keywordflow}{switch} (arguments.length) \{
      \textcolor{keywordflow}{case} 0:
        \textcolor{keywordflow}{return} this.$$search;
      \textcolor{keywordflow}{case} 1:
        \textcolor{keywordflow}{if} (isString(search) || isNumber(search)) \{
          search = search.toString();
          this.$$search = parseKeyValue(search);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(search)) \{
          search = copy(search, \{\});
          \textcolor{comment}{// remove object undefined or null properties}
          forEach(search, \textcolor{keyword}{function}(value, key) \{
            \textcolor{keywordflow}{if} (value == null) \textcolor{keyword}{delete} search[key];
          \});

          this.$$search = search;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'isrcharg'},
              \textcolor{stringliteral}{'The first argument of the `$location#search()` call must be a string or an object.'});
        \}
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{if} (isUndefined(paramValue) || paramValue === null) \{
          \textcolor{keyword}{delete} this.$$search[search];
        \} \textcolor{keywordflow}{else} \{
          this.$$search[search] = paramValue;
        \}
    \}

    this.$$compose();
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \},

  hash: locationGetterSetter(\textcolor{stringliteral}{'$$hash'}, \textcolor{keyword}{function}(hash) \{
    \textcolor{keywordflow}{return} hash !== null ? hash.toString() : \textcolor{stringliteral}{''};
  \}),

  replace: \textcolor{keyword}{function}() \{
    this.$$replace = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \}
\};

forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], \textcolor{keyword}{function}(Location) \{
  Location.prototype = Object.create(locationPrototype);

  Location.prototype.state = \textcolor{keyword}{function}(state) \{
    \textcolor{keywordflow}{if} (!arguments.length) \{
      \textcolor{keywordflow}{return} this.$$state;
    \}

    \textcolor{keywordflow}{if} (Location !== LocationHtml5Url || !this.$$html5) \{
      \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'nostate'}, \textcolor{stringliteral}{'History API state support is available only '} +
        \textcolor{stringliteral}{'in HTML5 mode and only in browsers supporting HTML5 History API'});
    \}
    \textcolor{comment}{// The user might modify `stateObject` after invoking `$location.state(stateObject)`}
    \textcolor{comment}{// but we're changing the $$state reference to $browser.state() during the $digest}
    \textcolor{comment}{// so the modification window is narrow.}
    this.$$state = isUndefined(state) ? null : state;

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};
\});


\textcolor{keyword}{function} locationGetter(property) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{this}[property];
  \};
\}


\textcolor{keyword}{function} locationGetterSetter(property, preprocess) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[property];
    \}

    \textcolor{keyword}{this}[property] = preprocess(value);
    this.$$compose();

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};
\}


\textcolor{keyword}{function} $LocationProvider() \{
  var hashPrefix = \textcolor{stringliteral}{''},
      html5Mode = \{
        enabled: \textcolor{keyword}{false},
        requireBase: \textcolor{keyword}{true},
        rewriteLinks: \textcolor{keyword}{true}
      \};

  this.hashPrefix = \textcolor{keyword}{function}(prefix) \{
    \textcolor{keywordflow}{if} (isDefined(prefix)) \{
      hashPrefix = prefix;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} hashPrefix;
    \}
  \};

  this.html5Mode = \textcolor{keyword}{function}(mode) \{
    \textcolor{keywordflow}{if} (isBoolean(mode)) \{
      html5Mode.enabled = mode;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(mode)) \{

      \textcolor{keywordflow}{if} (isBoolean(mode.enabled)) \{
        html5Mode.enabled = mode.enabled;
      \}

      \textcolor{keywordflow}{if} (isBoolean(mode.requireBase)) \{
        html5Mode.requireBase = mode.requireBase;
      \}

      \textcolor{keywordflow}{if} (isBoolean(mode.rewriteLinks)) \{
        html5Mode.rewriteLinks = mode.rewriteLinks;
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} html5Mode;
    \}
  \};

  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$rootElement'}, \textcolor{stringliteral}{'$window'},
      \textcolor{keyword}{function}($rootScope, $browser, $sniffer, $rootElement, $window) \{
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), \textcolor{comment}{// if base[href] is undefined, it defaults to ''}
        initialUrl = $browser.url(),
        appBase;

    \textcolor{keywordflow}{if} (html5Mode.enabled) \{
      \textcolor{keywordflow}{if} (!baseHref && html5Mode.requireBase) \{
        \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'nobase'},
          \textcolor{stringliteral}{"$location in HTML5 mode requires a <base> tag to be present!"});
      \}
      appBase = serverBase(initialUrl) + (baseHref || \textcolor{charliteral}{'/'});
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    \} \textcolor{keywordflow}{else} \{
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    \}
    var appBaseNoFile = stripFile(appBase);

    $location = \textcolor{keyword}{new} LocationMode(appBase, appBaseNoFile, \textcolor{charliteral}{'#'} + hashPrefix);
    $location.$$parseLinkUrl(initialUrl, initialUrl);

    $location.$$state = $browser.state();

    var IGNORE\_URI\_REGEXP = /^\(\backslash\)s*(javascript|mailto):/i;

    \textcolor{keyword}{function} setBrowserUrlWithFallback(url, replace, state) \{
      var oldUrl = $location.url();
      var oldState = $location.$$state;
      \textcolor{keywordflow}{try} \{
        $browser.url(url, replace, state);

        \textcolor{comment}{// Make sure $location.state() returns referentially identical (not just deeply equal)}
        \textcolor{comment}{// state object; this makes possible quick checking if the state changed in the digest}
        \textcolor{comment}{// loop. Checking deep equality would be too expensive.}
        $location.$$state = $browser.state();
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{comment}{// Restore old values if pushState fails}
        $location.url(oldUrl);
        $location.$$state = oldState;

        \textcolor{keywordflow}{throw} e;
      \}
    \}

    $rootElement.on(\textcolor{stringliteral}{'click'}, \textcolor{keyword}{function}(event) \{
      \textcolor{comment}{// TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)}
      \textcolor{comment}{// currently we open nice url link and redirect then}

      \textcolor{keywordflow}{if} (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 
      || event.button == 2) \textcolor{keywordflow}{return};

      var elm = jqLite(event.target);

      \textcolor{comment}{// traverse the DOM up to find first A tag}
      while (nodeName\_(elm[0]) !== \textcolor{charliteral}{'a'}) \{
        \textcolor{comment}{// ignore rewriting if no A tag (reached root element, or no parent - removed from document)}
        \textcolor{keywordflow}{if} (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) \textcolor{keywordflow}{return};
      \}

      var absHref = elm.prop(\textcolor{stringliteral}{'href'});
      \textcolor{comment}{// get the actual href attribute - see}
      \textcolor{comment}{// http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx}
      var relHref = elm.attr(\textcolor{stringliteral}{'href'}) || elm.attr(\textcolor{stringliteral}{'xlink:href'});

      \textcolor{keywordflow}{if} (isObject(absHref) && absHref.toString() === \textcolor{stringliteral}{'[object SVGAnimatedString]'}) \{
        \textcolor{comment}{// SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during}
        \textcolor{comment}{// an animation.}
        absHref = urlResolve(absHref.animVal).href;
      \}

      \textcolor{comment}{// Ignore when url is started with javascript: or mailto:}
      \textcolor{keywordflow}{if} (IGNORE\_URI\_REGEXP.test(absHref)) \textcolor{keywordflow}{return};

      \textcolor{keywordflow}{if} (absHref && !elm.attr(\textcolor{stringliteral}{'target'}) && !event.isDefaultPrevented()) \{
        \textcolor{keywordflow}{if} ($location.$$parseLinkUrl(absHref, relHref)) \{
          \textcolor{comment}{// We do a preventDefault for all urls that are part of the angular application,}
          \textcolor{comment}{// in html5mode and also without, so that we are able to abort navigation without}
          \textcolor{comment}{// getting double entries in the location history.}
          event.preventDefault();
          \textcolor{comment}{// update location manually}
          \textcolor{keywordflow}{if} ($location.absUrl() != $browser.url()) \{
            $rootScope.$apply();
            \textcolor{comment}{// hack to work around FF6 bug 684208 when scenario runner clicks on links}
            $window.angular[\textcolor{stringliteral}{'ff-684208-preventDefault'}] = \textcolor{keyword}{true};
          \}
        \}
      \}
    \});


    \textcolor{comment}{// rewrite hashbang url <> html5 url}
    \textcolor{keywordflow}{if} (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) \{
      $browser.url($location.absUrl(), \textcolor{keyword}{true});
    \}

    var initializing = \textcolor{keyword}{true};

    \textcolor{comment}{// update $location when $browser url changes}
    $browser.onUrlChange(\textcolor{keyword}{function}(newUrl, newState) \{

      \textcolor{keywordflow}{if} (isUndefined(beginsWith(appBaseNoFile, newUrl))) \{
        \textcolor{comment}{// If we are navigating outside of the app then force a reload}
        $window.location.href = newUrl;
        \textcolor{keywordflow}{return};
      \}

      $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
        var oldUrl = $location.absUrl();
        var oldState = $location.$$state;
        var defaultPrevented;

        $location.$$parse(newUrl);
        $location.$$state = newState;

        defaultPrevented = $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeStart'}, newUrl, oldUrl,
            newState, oldState).defaultPrevented;

        \textcolor{comment}{// if the location was changed by a `$locationChangeStart` handler then stop}
        \textcolor{comment}{// processing this location change}
        \textcolor{keywordflow}{if} ($location.absUrl() !== newUrl) \textcolor{keywordflow}{return};

        \textcolor{keywordflow}{if} (defaultPrevented) \{
          $location.$$parse(oldUrl);
          $location.$$state = oldState;
          setBrowserUrlWithFallback(oldUrl, \textcolor{keyword}{false}, oldState);
        \} \textcolor{keywordflow}{else} \{
          initializing = \textcolor{keyword}{false};
          afterLocationChange(oldUrl, oldState);
        \}
      \});
      \textcolor{keywordflow}{if} (!$rootScope.$$phase) $rootScope.$digest();
    \});

    \textcolor{comment}{// update browser}
    $rootScope.$watch(\textcolor{keyword}{function} $locationWatch() \{
      var oldUrl = trimEmptyHash($browser.url());
      var newUrl = trimEmptyHash($location.absUrl());
      var oldState = $browser.state();
      var currentReplace = $location.$$replace;
      var urlOrStateChanged = oldUrl !== newUrl ||
        ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);

      \textcolor{keywordflow}{if} (initializing || urlOrStateChanged) \{
        initializing = \textcolor{keyword}{false};

        $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
          var newUrl = $location.absUrl();
          var defaultPrevented = $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeStart'}, newUrl, oldUrl,
              $location.$$state, oldState).defaultPrevented;

          \textcolor{comment}{// if the location was changed by a `$locationChangeStart` handler then stop}
          \textcolor{comment}{// processing this location change}
          \textcolor{keywordflow}{if} ($location.absUrl() !== newUrl) \textcolor{keywordflow}{return};

          \textcolor{keywordflow}{if} (defaultPrevented) \{
            $location.$$parse(oldUrl);
            $location.$$state = oldState;
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (urlOrStateChanged) \{
              setBrowserUrlWithFallback(newUrl, currentReplace,
                                        oldState === $location.$$state ? null : $location.$$state);
            \}
            afterLocationChange(oldUrl, oldState);
          \}
        \});
      \}

      $location.$$replace = \textcolor{keyword}{false};

      \textcolor{comment}{// we don't need to return anything because $evalAsync will make the digest loop dirty when}
      \textcolor{comment}{// there is a change}
    \});

    \textcolor{keywordflow}{return} $location;

    \textcolor{keyword}{function} afterLocationChange(oldUrl, oldState) \{
      $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeSuccess'}, $location.absUrl(), oldUrl,
        $location.$$state, oldState);
    \}
\}];
\}

\textcolor{keyword}{function} $LogProvider() \{
  var debug = \textcolor{keyword}{true},
      \textcolor{keyword}{self} = \textcolor{keyword}{this};

  this.debugEnabled = \textcolor{keyword}{function}(flag) \{
    \textcolor{keywordflow}{if} (isDefined(flag)) \{
      debug = flag;
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} debug;
    \}
  \};

  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}($window) \{
    \textcolor{keywordflow}{return} \{
      log: consoleLog(\textcolor{stringliteral}{'log'}),

      info: consoleLog(\textcolor{stringliteral}{'info'}),

      warn: consoleLog(\textcolor{stringliteral}{'warn'}),

      error: consoleLog(\textcolor{stringliteral}{'error'}),

      debug: (\textcolor{keyword}{function}() \{
        var fn = consoleLog(\textcolor{stringliteral}{'debug'});

        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (debug) \{
            fn.apply(\textcolor{keyword}{self}, arguments);
          \}
        \};
      \}())
    \};

    \textcolor{keyword}{function} formatError(arg) \{
      \textcolor{keywordflow}{if} (arg instanceof Error) \{
        \textcolor{keywordflow}{if} (arg.stack) \{
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? \textcolor{stringliteral}{'Error: '} + arg.message + \textcolor{charliteral}{'\(\backslash\)n'} + arg.stack
              : arg.stack;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg.sourceURL) \{
          arg = arg.message + \textcolor{charliteral}{'\(\backslash\)n'} + arg.sourceURL + \textcolor{charliteral}{':'} + arg.line;
        \}
      \}
      \textcolor{keywordflow}{return} arg;
    \}

    \textcolor{keyword}{function} consoleLog(type) \{
      var console = $window.console || \{\},
          logFn = console[type] || console.log || noop,
          hasApply = \textcolor{keyword}{false};

      \textcolor{comment}{// Note: reading logFn.apply throws an error in IE11 in IE8 document mode.}
      \textcolor{comment}{// The reason behind this is that console.log has type "object" in IE8...}
      \textcolor{keywordflow}{try} \{
        hasApply = !!logFn.apply;
      \} \textcolor{keywordflow}{catch} (e) \{\}

      \textcolor{keywordflow}{if} (hasApply) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          var args = [];
          forEach(arguments, \textcolor{keyword}{function}(arg) \{
            args.push(formatError(arg));
          \});
          \textcolor{keywordflow}{return} logFn.apply(console, args);
        \};
      \}

      \textcolor{comment}{// we are IE which either doesn't have window.console => this is noop and we do nothing,}
      \textcolor{comment}{// or we are IE where console.log doesn't have apply so we log at least first 2 args}
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(arg1, arg2) \{
        logFn(arg1, arg2 == null ? \textcolor{stringliteral}{''} : arg2);
      \};
    \}
  \}];
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

var $parseMinErr = minErr(\textcolor{stringliteral}{'$parse'});

\textcolor{comment}{// Sandboxing Angular Expressions}
\textcolor{comment}{// ------------------------------}
\textcolor{comment}{// Angular expressions are generally considered safe because these expressions only have direct}
\textcolor{comment}{// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by}
\textcolor{comment}{// obtaining a reference to native JS functions such as the Function constructor.}
\textcolor{comment}{//}
\textcolor{comment}{// As an example, consider the following Angular expression:}
\textcolor{comment}{//}
\textcolor{comment}{//   \{\}.toString.constructor('alert("evil JS code")')}
\textcolor{comment}{//}
\textcolor{comment}{// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits}
\textcolor{comment}{// against the expression language, but not to prevent exploits that were enabled by exposing}
\textcolor{comment}{// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good}
\textcolor{comment}{// practice and therefore we are not even trying to protect against interaction with an object}
\textcolor{comment}{// explicitly exposed in this way.}
\textcolor{comment}{//}
\textcolor{comment}{// In general, it is not possible to access a Window object from an angular expression unless a}
\textcolor{comment}{// window or some DOM object that has a reference to window is published onto a Scope.}
\textcolor{comment}{// Similarly we prevent invocations of function known to be dangerous, as well as assignments to}
\textcolor{comment}{// native objects.}
\textcolor{comment}{//}
\textcolor{comment}{// See https://docs.angularjs.org/guide/security}


\textcolor{keyword}{function} ensureSafeMemberName(name, fullExpression) \{
  \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{"\_\_defineGetter\_\_"} || name === \textcolor{stringliteral}{"\_\_defineSetter\_\_"}
      || name === \textcolor{stringliteral}{"\_\_lookupGetter\_\_"} || name === \textcolor{stringliteral}{"\_\_lookupSetter\_\_"}
      || name === \textcolor{stringliteral}{"\_\_proto\_\_"}) \{
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfld'},
        \textcolor{stringliteral}{'Attempting to access a disallowed field in Angular expressions! '}
        + \textcolor{stringliteral}{'Expression: \{0\}'}, fullExpression);
  \}
  \textcolor{keywordflow}{return} name;
\}

\textcolor{keyword}{function} ensureSafeObject(obj, fullExpression) \{
  \textcolor{comment}{// nifty check if obj is Function that is fast and works across iframes and other contexts}
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (obj.constructor === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfn'},
          \textcolor{stringliteral}{'Referencing Function in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// isWindow(obj)}
        obj.window === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecwindow'},
          \textcolor{stringliteral}{'Referencing the Window in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// isElement(obj)}
        obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecdom'},
          \textcolor{stringliteral}{'Referencing DOM nodes in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// block Object so that we can't get hold of dangerous Object.* methods}
        obj === Object) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecobj'},
          \textcolor{stringliteral}{'Referencing Object in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \}
  \}
  \textcolor{keywordflow}{return} obj;
\}

var CALL = Function.prototype.call;
var APPLY = Function.prototype.apply;
var BIND = Function.prototype.bind;

\textcolor{keyword}{function} ensureSafeFunction(obj, fullExpression) \{
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (obj.constructor === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfn'},
        \textcolor{stringliteral}{'Referencing Function in Angular expressions is disallowed! Expression: \{0\}'},
        fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj === CALL || obj === APPLY || obj === BIND) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecff'},
        \textcolor{stringliteral}{'Referencing call, apply or bind in Angular expressions is disallowed! Expression: \{0\}'},
        fullExpression);
    \}
  \}
\}

var OPERATORS = createMap();
forEach(\textcolor{stringliteral}{'+ - * / % === !== == != < > <= >= && || ! = |'}.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(\textcolor{keyword}{operator}) \{ OPERATORS[\textcolor{keyword}{operator}
      ] = \textcolor{keyword}{true}; \});
var ESCAPE = \{\textcolor{stringliteral}{"n"}:\textcolor{stringliteral}{"\(\backslash\)n"}, \textcolor{stringliteral}{"f"}:\textcolor{stringliteral}{"\(\backslash\)f"}, \textcolor{stringliteral}{"r"}:\textcolor{stringliteral}{"\(\backslash\)r"}, \textcolor{stringliteral}{"t"}:\textcolor{stringliteral}{"\(\backslash\)t"}, \textcolor{stringliteral}{"v"}:\textcolor{stringliteral}{"\(\backslash\)v"}, \textcolor{stringliteral}{"'"}:\textcolor{stringliteral}{"'"}, \textcolor{charliteral}{'"'}:\textcolor{charliteral}{'"'}\};




var Lexer = \textcolor{keyword}{function}(options) \{
  this.options = options;
\};

Lexer.prototype = \{
  constructor: Lexer,

  lex: \textcolor{keyword}{function}(text) \{
    this.text = text;
    this.index = 0;
    this.tokens = [];

    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'"'} || ch === \textcolor{stringliteral}{"'"}) \{
        this.readString(ch);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isNumber(ch) || ch === \textcolor{charliteral}{'.'} && this.isNumber(this.peek())) \{
        this.readNumber();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isIdent(ch)) \{
        this.readIdent();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.is(ch, \textcolor{stringliteral}{'()\{\}[].,;:?'})) \{
        this.tokens.push(\{index: this.index, text: ch\});
        this.index++;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isWhitespace(ch)) \{
        this.index++;
      \} \textcolor{keywordflow}{else} \{
        var ch2 = ch + this.peek();
        var ch3 = ch2 + this.peek(2);
        var op1 = OPERATORS[ch];
        var op2 = OPERATORS[ch2];
        var op3 = OPERATORS[ch3];
        \textcolor{keywordflow}{if} (op1 || op2 || op3) \{
          var token = op3 ? ch3 : (op2 ? ch2 : ch);
          this.tokens.push(\{index: this.index, text: token, \textcolor{keyword}{operator}: \textcolor{keyword}{true}\});
          this.index += token.length;
        \} \textcolor{keywordflow}{else} \{
          this.throwError(\textcolor{stringliteral}{'Unexpected next character '}, this.index, this.index + 1);
        \}
      \}
    \}
    \textcolor{keywordflow}{return} this.tokens;
  \},

  is: \textcolor{keyword}{function}(ch, chars) \{
    \textcolor{keywordflow}{return} chars.indexOf(ch) !== -1;
  \},

  peek: \textcolor{keyword}{function}(i) \{
    var num = i || 1;
    \textcolor{keywordflow}{return} (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : \textcolor{keyword}{false};
  \},

  isNumber: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (\textcolor{charliteral}{'0'} <= ch && ch <= \textcolor{charliteral}{'9'}) && typeof ch === \textcolor{stringliteral}{"string"};
  \},

  isWhitespace: \textcolor{keyword}{function}(ch) \{
    \textcolor{comment}{// IE treats non-breaking space as \(\backslash\)u00A0}
    \textcolor{keywordflow}{return} (ch === \textcolor{charliteral}{' '} || ch === \textcolor{charliteral}{'\(\backslash\)r'} || ch === \textcolor{charliteral}{'\(\backslash\)t'} ||
            ch === \textcolor{charliteral}{'\(\backslash\)n'} || ch === \textcolor{charliteral}{'\(\backslash\)v'} || ch === \textcolor{stringliteral}{'\(\backslash\)u00A0'});
  \},

  isIdent: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (\textcolor{charliteral}{'a'} <= ch && ch <= \textcolor{charliteral}{'z'} ||
            \textcolor{charliteral}{'A'} <= ch && ch <= \textcolor{charliteral}{'Z'} ||
            \textcolor{charliteral}{'\_'} === ch || ch === \textcolor{charliteral}{'$'});
  \},

  isExpOperator: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (ch === \textcolor{charliteral}{'-'} || ch === \textcolor{charliteral}{'+'} || this.isNumber(ch));
  \},

  throwError: \textcolor{keyword}{function}(error, start, end) \{
    end = end || this.index;
    var colStr = (isDefined(start)
            ? \textcolor{stringliteral}{'s '} + start +  \textcolor{charliteral}{'-'} + this.index + \textcolor{stringliteral}{' ['} + this.text.substring(start, end) + \textcolor{charliteral}{']'}
            : \textcolor{charliteral}{' '} + end);
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'lexerr'}, \textcolor{stringliteral}{'Lexer Error: \{0\} at column\{1\} in expression [\{2\}].'},
        error, colStr, this.text);
  \},

  readNumber: \textcolor{keyword}{function}() \{
    var number = \textcolor{stringliteral}{''};
    var start = this.index;
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = lowercase(this.text.charAt(\textcolor{keyword}{this}.index));
      \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'.'} || this.isNumber(ch)) \{
        number += ch;
      \} \textcolor{keywordflow}{else} \{
        var peekCh = this.peek();
        \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'e'} && this.isExpOperator(peekCh)) \{
          number += ch;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isExpOperator(ch) &&
            peekCh && this.isNumber(peekCh) &&
            number.charAt(number.length - 1) == \textcolor{charliteral}{'e'}) \{
          number += ch;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) == \textcolor{charliteral}{'e'}) \{
          this.throwError(\textcolor{stringliteral}{'Invalid exponent'});
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{break};
        \}
      \}
      this.index++;
    \}
    this.tokens.push(\{
      index: start,
      text: number,
      constant: \textcolor{keyword}{true},
      value: Number(number)
    \});
  \},

  readIdent: \textcolor{keyword}{function}() \{
    var start = this.index;
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      \textcolor{keywordflow}{if} (!(this.isIdent(ch) || this.isNumber(ch))) \{
        \textcolor{keywordflow}{break};
      \}
      this.index++;
    \}
    this.tokens.push(\{
      index: start,
      text: this.text.slice(start, this.index),
      identifier: \textcolor{keyword}{true}
    \});
  \},

  readString: \textcolor{keyword}{function}(quote) \{
    var start = this.index;
    this.index++;
    var \textcolor{keywordtype}{string} = \textcolor{stringliteral}{''};
    var rawString = quote;
    var escape = \textcolor{keyword}{false};
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      rawString += ch;
      \textcolor{keywordflow}{if} (escape) \{
        \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'u'}) \{
          var hex = this.text.substring(this.index + 1, this.index + 5);
          \textcolor{keywordflow}{if} (!hex.match(/[\(\backslash\)da-f]\{4\}/i)) \{
            this.throwError(\textcolor{stringliteral}{'Invalid unicode escape [\(\backslash\)\(\backslash\)u'} + hex + \textcolor{charliteral}{']'});
          \}
          this.index += 4;
          \textcolor{keywordtype}{string} += String.fromCharCode(parseInt(hex, 16));
        \} \textcolor{keywordflow}{else} \{
          var rep = ESCAPE[ch];
          \textcolor{keywordtype}{string} = \textcolor{keywordtype}{string} + (rep || ch);
        \}
        escape = \textcolor{keyword}{false};
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
        escape = \textcolor{keyword}{true};
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch === quote) \{
        this.index++;
        this.tokens.push(\{
          index: start,
          text: rawString,
          constant: \textcolor{keyword}{true},
          value: \textcolor{keywordtype}{string}
        \});
        \textcolor{keywordflow}{return};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordtype}{string} += ch;
      \}
      this.index++;
    \}
    this.throwError(\textcolor{stringliteral}{'Unterminated quote'}, start);
  \}
\};

var AST = \textcolor{keyword}{function}(lexer, options) \{
  this.lexer = lexer;
  this.options = options;
\};

AST.Program = \textcolor{stringliteral}{'Program'};
AST.ExpressionStatement = \textcolor{stringliteral}{'ExpressionStatement'};
AST.AssignmentExpression = \textcolor{stringliteral}{'AssignmentExpression'};
AST.ConditionalExpression = \textcolor{stringliteral}{'ConditionalExpression'};
AST.LogicalExpression = \textcolor{stringliteral}{'LogicalExpression'};
AST.BinaryExpression = \textcolor{stringliteral}{'BinaryExpression'};
AST.UnaryExpression = \textcolor{stringliteral}{'UnaryExpression'};
AST.CallExpression = \textcolor{stringliteral}{'CallExpression'};
AST.MemberExpression = \textcolor{stringliteral}{'MemberExpression'};
AST.Identifier = \textcolor{stringliteral}{'Identifier'};
AST.Literal = \textcolor{stringliteral}{'Literal'};
AST.ArrayExpression = \textcolor{stringliteral}{'ArrayExpression'};
AST.Property = \textcolor{stringliteral}{'Property'};
AST.ObjectExpression = \textcolor{stringliteral}{'ObjectExpression'};
AST.ThisExpression = \textcolor{stringliteral}{'ThisExpression'};

\textcolor{comment}{// Internal use only}
AST.NGValueParameter = \textcolor{stringliteral}{'NGValueParameter'};

AST.prototype = \{
  ast: \textcolor{keyword}{function}(text) \{
    this.text = text;
    this.tokens = this.lexer.lex(text);

    var value = this.program();

    \textcolor{keywordflow}{if} (this.tokens.length !== 0) \{
      this.throwError(\textcolor{stringliteral}{'is an unexpected token'}, this.tokens[0]);
    \}

    \textcolor{keywordflow}{return} value;
  \},

  program: \textcolor{keyword}{function}() \{
    var body = [];
    \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
      \textcolor{keywordflow}{if} (this.tokens.length > 0 && !\textcolor{keyword}{this}.peek(\textcolor{charliteral}{'\}'}, \textcolor{charliteral}{')'}, \textcolor{charliteral}{';'}, \textcolor{charliteral}{']'}))
        body.push(\textcolor{keyword}{this}.expressionStatement());
      \textcolor{keywordflow}{if} (!this.expect(\textcolor{charliteral}{';'})) \{
        \textcolor{keywordflow}{return} \{ type: AST.Program, body: body\};
      \}
    \}
  \},

  expressionStatement: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{ type: AST.ExpressionStatement, expression: this.filterChain() \};
  \},

  filterChain: \textcolor{keyword}{function}() \{
    var left = this.expression();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'|'}))) \{
      left = this.filter(left);
    \}
    \textcolor{keywordflow}{return} left;
  \},

  expression: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.assignment();
  \},

  assignment: \textcolor{keyword}{function}() \{
    var result = this.ternary();
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'='})) \{
      result = \{ type: AST.AssignmentExpression, left: result, right: this.assignment(), \textcolor{keyword}{operator}: \textcolor{charliteral}{'='}\};
    \}
    \textcolor{keywordflow}{return} result;
  \},

  ternary: \textcolor{keyword}{function}() \{
    var test = this.logicalOR();
    var alternate;
    var consequent;
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'?'})) \{
      alternate = this.expression();
      \textcolor{keywordflow}{if} (this.consume(\textcolor{charliteral}{':'})) \{
        consequent = this.expression();
        \textcolor{keywordflow}{return} \{ type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent\}
      ;
      \}
    \}
    \textcolor{keywordflow}{return} test;
  \},

  logicalOR: \textcolor{keyword}{function}() \{
    var left = this.logicalAND();
    \textcolor{keywordflow}{while} (this.expect(\textcolor{stringliteral}{'||'})) \{
      left = \{ type: AST.LogicalExpression, \textcolor{keyword}{operator}: \textcolor{stringliteral}{'||'}, left: left, right: this.logicalAND() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  logicalAND: \textcolor{keyword}{function}() \{
    var left = this.equality();
    \textcolor{keywordflow}{while} (this.expect(\textcolor{stringliteral}{'&&'})) \{
      left = \{ type: AST.LogicalExpression, \textcolor{keyword}{operator}: \textcolor{stringliteral}{'&&'}, left: left, right: this.equality()\};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  equality: \textcolor{keyword}{function}() \{
    var left = this.relational();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{stringliteral}{'=='},\textcolor{stringliteral}{'!='},\textcolor{stringliteral}{'==='},\textcolor{stringliteral}{'!=='}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.relational() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  relational: \textcolor{keyword}{function}() \{
    var left = this.additive();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'<'}, \textcolor{charliteral}{'>'}, \textcolor{stringliteral}{'<='}, \textcolor{stringliteral}{'>='}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.additive() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  additive: \textcolor{keyword}{function}() \{
    var left = this.multiplicative();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'+'},\textcolor{charliteral}{'-'}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.multiplicative() \}
      ;
    \}
    \textcolor{keywordflow}{return} left;
  \},

  multiplicative: \textcolor{keyword}{function}() \{
    var left = this.unary();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'*'},\textcolor{charliteral}{'/'},\textcolor{charliteral}{'%'}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.unary() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  unary: \textcolor{keyword}{function}() \{
    var token;
    \textcolor{keywordflow}{if} ((token = this.expect(\textcolor{charliteral}{'+'}, \textcolor{charliteral}{'-'}, \textcolor{charliteral}{'!'}))) \{
      \textcolor{keywordflow}{return} \{ type: AST.UnaryExpression, \textcolor{keyword}{operator}: token.text, prefix: \textcolor{keyword}{true}, argument: this.unary() \};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} this.primary();
    \}
  \},

  primary: \textcolor{keyword}{function}() \{
    var primary;
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'('})) \{
      primary = this.filterChain();
      this.consume(\textcolor{charliteral}{')'});
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'['})) \{
      primary = this.arrayDeclaration();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'\{'})) \{
      primary = this.object();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.constants.hasOwnProperty(\textcolor{keyword}{this}.peek().text)) \{
      primary = copy(this.constants[this.consume().text]);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().identifier) \{
      primary = this.identifier();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().constant) \{
      primary = this.constant();
    \} \textcolor{keywordflow}{else} \{
      this.throwError(\textcolor{stringliteral}{'not a primary expression'}, this.peek());
    \}

    var next;
    \textcolor{keywordflow}{while} ((next = this.expect(\textcolor{charliteral}{'('}, \textcolor{charliteral}{'['}, \textcolor{charliteral}{'.'}))) \{
      \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'('}) \{
        primary = \{type: AST.CallExpression, callee: primary, arguments: this.parseArguments() \};
        this.consume(\textcolor{charliteral}{')'});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'['}) \{
        primary = \{ type: AST.MemberExpression, \textcolor{keywordtype}{object}: primary, property: this.expression(), computed: \textcolor{keyword}{
      true} \};
        this.consume(\textcolor{charliteral}{']'});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'.'}) \{
        primary = \{ type: AST.MemberExpression, \textcolor{keywordtype}{object}: primary, property: this.identifier(), computed: \textcolor{keyword}{
      false} \};
      \} \textcolor{keywordflow}{else} \{
        this.throwError(\textcolor{stringliteral}{'IMPOSSIBLE'});
      \}
    \}
    \textcolor{keywordflow}{return} primary;
  \},

  filter: \textcolor{keyword}{function}(baseExpression) \{
    var args = [baseExpression];
    var result = \{type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: \textcolor{keyword}{true}\};

    \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{':'})) \{
      args.push(this.expression());
    \}

    \textcolor{keywordflow}{return} result;
  \},

  parseArguments: \textcolor{keyword}{function}() \{
    var args = [];
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{')'}) \{
      \textcolor{keywordflow}{do} \{
        args.push(this.expression());
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    \textcolor{keywordflow}{return} args;
  \},

  identifier: \textcolor{keyword}{function}() \{
    var token = this.consume();
    \textcolor{keywordflow}{if} (!token.identifier) \{
      this.throwError(\textcolor{stringliteral}{'is not a valid identifier'}, token);
    \}
    \textcolor{keywordflow}{return} \{ type: AST.Identifier, name: token.text \};
  \},

  constant: \textcolor{keyword}{function}() \{
    \textcolor{comment}{// TODO check that it is a constant}
    \textcolor{keywordflow}{return} \{ type: AST.Literal, value: this.consume().value \};
  \},

  arrayDeclaration: \textcolor{keyword}{function}() \{
    var elements = [];
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{']'}) \{
      \textcolor{keywordflow}{do} \{
        \textcolor{keywordflow}{if} (this.peek(\textcolor{charliteral}{']'})) \{
          \textcolor{comment}{// Support trailing commas per ES5.1.}
          \textcolor{keywordflow}{break};
        \}
        elements.push(this.expression());
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    this.consume(\textcolor{charliteral}{']'});

    \textcolor{keywordflow}{return} \{ type: AST.ArrayExpression, elements: elements \};
  \},

  \textcolor{keywordtype}{object}: \textcolor{keyword}{function}() \{
    var properties = [], property;
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{'\}'}) \{
      \textcolor{keywordflow}{do} \{
        \textcolor{keywordflow}{if} (this.peek(\textcolor{charliteral}{'\}'})) \{
          \textcolor{comment}{// Support trailing commas per ES5.1.}
          \textcolor{keywordflow}{break};
        \}
        property = \{type: AST.Property, kind: \textcolor{stringliteral}{'init'}\};
        \textcolor{keywordflow}{if} (this.peek().constant) \{
          property.key = this.constant();
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().identifier) \{
          property.key = this.identifier();
        \} \textcolor{keywordflow}{else} \{
          this.throwError(\textcolor{stringliteral}{"invalid key"}, this.peek());
        \}
        this.consume(\textcolor{charliteral}{':'});
        property.value = this.expression();
        properties.push(property);
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    this.consume(\textcolor{charliteral}{'\}'});

    \textcolor{keywordflow}{return} \{type: AST.ObjectExpression, properties: properties \};
  \},

  throwError: \textcolor{keyword}{function}(msg, token) \{
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'syntax'},
        \textcolor{stringliteral}{'Syntax Error: Token \(\backslash\)'\{0\}\(\backslash\)' \{1\} at column \{2\} of the expression [\{3\}] starting at [\{4\}].'},
          token.text, msg, (token.index + 1), \textcolor{keyword}{this}.text, \textcolor{keyword}{this}.text.substring(token.index));
  \},

  consume: \textcolor{keyword}{function}(e1) \{
    \textcolor{keywordflow}{if} (this.tokens.length === 0) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'ueoe'}, \textcolor{stringliteral}{'Unexpected end of expression: \{0\}'}, this.text);
    \}

    var token = this.expect(e1);
    \textcolor{keywordflow}{if} (!token) \{
      this.throwError(\textcolor{stringliteral}{'is unexpected, expecting ['} + e1 + \textcolor{charliteral}{']'}, this.peek());
    \}
    \textcolor{keywordflow}{return} token;
  \},

  peekToken: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} (this.tokens.length === 0) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'ueoe'}, \textcolor{stringliteral}{'Unexpected end of expression: \{0\}'}, this.text);
    \}
    \textcolor{keywordflow}{return} this.tokens[0];
  \},

  peek: \textcolor{keyword}{function}(e1, e2, e3, e4) \{
    \textcolor{keywordflow}{return} this.peekAhead(0, e1, e2, e3, e4);
  \},

  peekAhead: \textcolor{keyword}{function}(i, e1, e2, e3, e4) \{
    \textcolor{keywordflow}{if} (this.tokens.length > i) \{
      var token = this.tokens[i];
      var t = token.text;
      \textcolor{keywordflow}{if} (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 && !e2 && !e3 && !e4)) \{
        \textcolor{keywordflow}{return} token;
      \}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \},

  expect: \textcolor{keyword}{function}(e1, e2, e3, e4) \{
    var token = this.peek(e1, e2, e3, e4);
    \textcolor{keywordflow}{if} (token) \{
      this.tokens.shift();
      \textcolor{keywordflow}{return} token;
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \},


  \textcolor{comment}{/* `undefined` is not a constant, it is an identifier,}
\textcolor{comment}{   * but using it as an identifier is not supported}
\textcolor{comment}{   */}
  constants: \{
    \textcolor{stringliteral}{'true'}: \{ type: AST.Literal, value: \textcolor{keyword}{true} \},
    \textcolor{stringliteral}{'false'}: \{ type: AST.Literal, value: \textcolor{keyword}{false} \},
    \textcolor{stringliteral}{'null'}: \{ type: AST.Literal, value: null \},
    \textcolor{stringliteral}{'undefined'}: \{type: AST.Literal, value: undefined \},
    \textcolor{stringliteral}{'this'}: \{type: AST.ThisExpression \}
  \}
\};

\textcolor{keyword}{function} ifDefined(v, d) \{
  \textcolor{keywordflow}{return} typeof v !== \textcolor{stringliteral}{'undefined'} ? v : d;
\}

\textcolor{keyword}{function} plusFn(l, r) \{
  \textcolor{keywordflow}{if} (typeof l === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} r;
  \textcolor{keywordflow}{if} (typeof r === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} l;
  \textcolor{keywordflow}{return} l + r;
\}

\textcolor{keyword}{function} isStateless($filter, filterName) \{
  var fn = $filter(filterName);
  \textcolor{keywordflow}{return} !fn.$stateful;
\}

\textcolor{keyword}{function} findConstantAndWatchExpressions(ast, $filter) \{
  var allConstants;
  var argsToWatch;
  \textcolor{keywordflow}{switch} (ast.type) \{
  \textcolor{keywordflow}{case} AST.Program:
    allConstants = \textcolor{keyword}{true};
    forEach(ast.body, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr.expression, $filter);
      allConstants = allConstants && expr.expression.constant;
    \});
    ast.constant = allConstants;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.Literal:
    ast.constant = \textcolor{keyword}{true};
    ast.toWatch = [];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.UnaryExpression:
    findConstantAndWatchExpressions(ast.argument, $filter);
    ast.constant = ast.argument.constant;
    ast.toWatch = ast.argument.toWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.BinaryExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.LogicalExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ConditionalExpression:
    findConstantAndWatchExpressions(ast.test, $filter);
    findConstantAndWatchExpressions(ast.alternate, $filter);
    findConstantAndWatchExpressions(ast.consequent, $filter);
    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.Identifier:
    ast.constant = \textcolor{keyword}{false};
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.MemberExpression:
    findConstantAndWatchExpressions(ast.object, $filter);
    \textcolor{keywordflow}{if} (ast.computed) \{
      findConstantAndWatchExpressions(ast.property, $filter);
    \}
    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.CallExpression:
    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
    argsToWatch = [];
    forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr, $filter);
      allConstants = allConstants && expr.constant;
      if (!expr.constant) \{
        argsToWatch.push.apply(argsToWatch, expr.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.AssignmentExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ArrayExpression:
    allConstants = \textcolor{keyword}{true};
    argsToWatch = [];
    forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr, $filter);
      allConstants = allConstants && expr.constant;
      if (!expr.constant) \{
        argsToWatch.push.apply(argsToWatch, expr.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ObjectExpression:
    allConstants = \textcolor{keyword}{true};
    argsToWatch = [];
    forEach(ast.properties, \textcolor{keyword}{function}(property) \{
      findConstantAndWatchExpressions(property.value, $filter);
      allConstants = allConstants && property.value.constant;
      if (!property.value.constant) \{
        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ThisExpression:
    ast.constant = \textcolor{keyword}{false};
    ast.toWatch = [];
    \textcolor{keywordflow}{break};
  \}
\}

\textcolor{keyword}{function} getInputs(body) \{
  \textcolor{keywordflow}{if} (body.length != 1) \textcolor{keywordflow}{return};
  var lastExpression = body[0].expression;
  var candidate = lastExpression.toWatch;
  \textcolor{keywordflow}{if} (candidate.length !== 1) \textcolor{keywordflow}{return} candidate;
  \textcolor{keywordflow}{return} candidate[0] !== lastExpression ? candidate : undefined;
\}

\textcolor{keyword}{function} isAssignable(ast) \{
  \textcolor{keywordflow}{return} ast.type === AST.Identifier || ast.type === AST.MemberExpression;
\}

\textcolor{keyword}{function} assignableAST(ast) \{
  \textcolor{keywordflow}{if} (ast.body.length === 1 && isAssignable(ast.body[0].expression)) \{
    \textcolor{keywordflow}{return} \{type: AST.AssignmentExpression, left: ast.body[0].expression, right: \{type: AST.
      NGValueParameter\}, \textcolor{keyword}{operator}: \textcolor{charliteral}{'='}\};
  \}
\}

\textcolor{keyword}{function} isLiteral(ast) \{
  \textcolor{keywordflow}{return} ast.body.length === 0 ||
      ast.body.length === 1 && (
      ast.body[0].expression.type === AST.Literal ||
      ast.body[0].expression.type === AST.ArrayExpression ||
      ast.body[0].expression.type === AST.ObjectExpression);
\}

\textcolor{keyword}{function} isConstant(ast) \{
  \textcolor{keywordflow}{return} ast.constant;
\}

\textcolor{keyword}{function} ASTCompiler(astBuilder, $filter) \{
  this.astBuilder = astBuilder;
  this.$filter = $filter;
\}

ASTCompiler.prototype = \{
  compile: \textcolor{keyword}{function}(expression, expensiveChecks) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    var ast = this.astBuilder.ast(expression);
    this.state = \{
      nextId: 0,
      filters: \{\},
      expensiveChecks: expensiveChecks,
      fn: \{vars: [], body: [], own: \{\}\},
      assign: \{vars: [], body: [], own: \{\}\},
      inputs: []
    \};
    findConstantAndWatchExpressions(ast, \textcolor{keyword}{self}.$filter);
    var extra = \textcolor{stringliteral}{''};
    var assignable;
    this.stage = \textcolor{stringliteral}{'assign'};
    \textcolor{keywordflow}{if} ((assignable = assignableAST(ast))) \{
      this.state.computing = \textcolor{stringliteral}{'assign'};
      var result = this.nextId();
      this.recurse(assignable, result);
      extra = \textcolor{stringliteral}{'fn.assign='} + this.generateFunction(\textcolor{stringliteral}{'assign'}, \textcolor{stringliteral}{'s,v,l'});
    \}
    var toWatch = getInputs(ast.body);
    \textcolor{keyword}{self}.stage = \textcolor{stringliteral}{'inputs'};
    forEach(toWatch, \textcolor{keyword}{function}(watch, key) \{
      var fnKey = \textcolor{stringliteral}{'fn'} + key;
      \textcolor{keyword}{self}.state[fnKey] = \{vars: [], body: [], own: \{\}\};
      \textcolor{keyword}{self}.state.computing = fnKey;
      var intoId = \textcolor{keyword}{self}.nextId();
      \textcolor{keyword}{self}.recurse(watch, intoId);
      \textcolor{keyword}{self}.return\_(intoId);
      \textcolor{keyword}{self}.state.inputs.push(fnKey);
      watch.watchId = key;
    \});
    this.state.computing = \textcolor{stringliteral}{'fn'};
    this.stage = \textcolor{stringliteral}{'main'};
    this.recurse(ast);
    var fnString =
      \textcolor{comment}{// The build and minification steps remove the string "use strict" from the code, but this is done
       using a regex.}
      \textcolor{comment}{// This is a workaround for this until we do a better job at only removing the prefix only when we
       should.}
      \textcolor{charliteral}{'"'} + this.USE + \textcolor{charliteral}{' '} + this.STRICT + \textcolor{stringliteral}{'";\(\backslash\)n'} +
      this.filterPrefix() +
      \textcolor{stringliteral}{'var fn='} + this.generateFunction(\textcolor{stringliteral}{'fn'}, \textcolor{stringliteral}{'s,l,a,i'}) +
      extra +
      this.watchFns() +
      \textcolor{stringliteral}{'return fn;'};

    \textcolor{comment}{/* jshint -W054 */}
    var fn = (\textcolor{keyword}{new} Function(\textcolor{stringliteral}{'$filter'},
        \textcolor{stringliteral}{'ensureSafeMemberName'},
        \textcolor{stringliteral}{'ensureSafeObject'},
        \textcolor{stringliteral}{'ensureSafeFunction'},
        \textcolor{stringliteral}{'ifDefined'},
        \textcolor{stringliteral}{'plus'},
        \textcolor{stringliteral}{'text'},
        fnString))(
          this.$filter,
          ensureSafeMemberName,
          ensureSafeObject,
          ensureSafeFunction,
          ifDefined,
          plusFn,
          expression);
    \textcolor{comment}{/* jshint +W054 */}
    this.state = this.stage = undefined;
    fn.literal = isLiteral(ast);
    fn.constant = isConstant(ast);
    \textcolor{keywordflow}{return} fn;
  \},

  USE: \textcolor{stringliteral}{'use'},

  STRICT: \textcolor{stringliteral}{'strict'},

  watchFns: \textcolor{keyword}{function}() \{
    var result = [];
    var fns = this.state.inputs;
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    forEach(fns, \textcolor{keyword}{function}(name) \{
      result.push(\textcolor{stringliteral}{'var '} + name + \textcolor{charliteral}{'='} + \textcolor{keyword}{self}.generateFunction(name, \textcolor{charliteral}{'s'}));
    \});
    \textcolor{keywordflow}{if} (fns.length) \{
      result.push(\textcolor{stringliteral}{'fn.inputs=['} + fns.join(\textcolor{charliteral}{','}) + \textcolor{stringliteral}{'];'});
    \}
    \textcolor{keywordflow}{return} result.join(\textcolor{stringliteral}{''});
  \},

  generateFunction: \textcolor{keyword}{function}(name, params) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'function('} + params + \textcolor{stringliteral}{')\{'} +
        this.varsPrefix(name) +
        this.body(name) +
        \textcolor{stringliteral}{'\};'};
  \},

  filterPrefix: \textcolor{keyword}{function}() \{
    var parts = [];
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    forEach(this.state.filters, \textcolor{keyword}{function}(\textcolor{keywordtype}{id}, filter) \{
      parts.push(id + \textcolor{stringliteral}{'=$filter('} + self.escape(filter) + \textcolor{stringliteral}{')'});
    \});
    \textcolor{keywordflow}{if} (parts.length) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'var '} + parts.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{';'};
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
  \},

  varsPrefix: \textcolor{keyword}{function}(section) \{
    \textcolor{keywordflow}{return} this.state[section].vars.length ? \textcolor{stringliteral}{'var '} + this.state[section].vars.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{';'} : \textcolor{stringliteral}{''};
  \},

  body: \textcolor{keyword}{function}(section) \{
    \textcolor{keywordflow}{return} this.state[section].body.join(\textcolor{stringliteral}{''});
  \},

  recurse: \textcolor{keyword}{function}(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) \{
    var left, right, \textcolor{keyword}{self} = \textcolor{keyword}{this}, args, expression;
    recursionFn = recursionFn || noop;
    \textcolor{keywordflow}{if} (!skipWatchIdCheck && isDefined(ast.watchId)) \{
      intoId = intoId || this.nextId();
      this.if\_(\textcolor{charliteral}{'i'},
        this.lazyAssign(intoId, this.computedMember(\textcolor{charliteral}{'i'}, ast.watchId)),
        \textcolor{keyword}{this}.lazyRecurse(ast, intoId, nameId, recursionFn, create, \textcolor{keyword}{true})
      );
      \textcolor{keywordflow}{return};
    \}
    \textcolor{keywordflow}{switch} (ast.type) \{
    \textcolor{keywordflow}{case} AST.Program:
      forEach(ast.body, \textcolor{keyword}{function}(expression, pos) \{
        self.recurse(expression.expression, undefined, undefined, function(expr) \{ right = expr; \});
        \textcolor{keywordflow}{if} (pos !== ast.body.length - 1) \{
          \textcolor{keyword}{self}.current().body.push(right, \textcolor{charliteral}{';'});
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keyword}{self}.return\_(right);
        \}
      \});
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.Literal:
      expression = this.escape(ast.value);
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.UnaryExpression:
      this.recurse(ast.argument, undefined, undefined, \textcolor{keyword}{function}(expr) \{ right = expr; \});
      expression = ast.operator + \textcolor{charliteral}{'('} + this.ifDefined(right, 0) + \textcolor{charliteral}{')'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.BinaryExpression:
      this.recurse(ast.left, undefined, undefined, \textcolor{keyword}{function}(expr) \{ left = expr; \});
      this.recurse(ast.right, undefined, undefined, \textcolor{keyword}{function}(expr) \{ right = expr; \});
      \textcolor{keywordflow}{if} (ast.operator === \textcolor{charliteral}{'+'}) \{
        expression = this.plus(left, right);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ast.operator === \textcolor{charliteral}{'-'}) \{
        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
      \} \textcolor{keywordflow}{else} \{
        expression = \textcolor{charliteral}{'('} + left + \textcolor{charliteral}{')'} + ast.operator + \textcolor{charliteral}{'('} + right + \textcolor{charliteral}{')'};
      \}
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.LogicalExpression:
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.left, intoId);
      \textcolor{keyword}{self}.if\_(ast.operator === \textcolor{stringliteral}{'&&'} ? intoId : \textcolor{keyword}{self}.not(intoId), \textcolor{keyword}{self}.lazyRecurse(ast.right, intoId));
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ConditionalExpression:
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.test, intoId);
      \textcolor{keyword}{self}.if\_(intoId, \textcolor{keyword}{self}.lazyRecurse(ast.alternate, intoId), \textcolor{keyword}{self}.lazyRecurse(ast.consequent, intoId));
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.Identifier:
      intoId = intoId || this.nextId();
      \textcolor{keywordflow}{if} (nameId) \{
        nameId.context = \textcolor{keyword}{self}.stage === \textcolor{stringliteral}{'inputs'} ? \textcolor{charliteral}{'s'} : this.assign(this.nextId(), this.getHasOwnProperty(\textcolor{charliteral}{
      'l'}, ast.name) + \textcolor{stringliteral}{'?l:s'});
        nameId.computed = \textcolor{keyword}{false};
        nameId.name = ast.name;
      \}
      ensureSafeMemberName(ast.name);
      \textcolor{keyword}{self}.if\_(\textcolor{keyword}{self}.stage === \textcolor{stringliteral}{'inputs'} || \textcolor{keyword}{self}.not(\textcolor{keyword}{self}.getHasOwnProperty(\textcolor{charliteral}{'l'}, ast.name)),
        \textcolor{keyword}{function}() \{
          self.if\_(self.stage === \textcolor{stringliteral}{'inputs'} || \textcolor{stringliteral}{'s'}, function() \{
            if (create && create !== 1) \{
              self.if\_(
                self.not(self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name)),
                self.lazyAssign(self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name), \textcolor{stringliteral}{'\{\}'}));
            \}
            self.assign(intoId, self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name));
          \});
        \}, intoId && \textcolor{keyword}{self}.lazyAssign(intoId, \textcolor{keyword}{self}.nonComputedMember(\textcolor{charliteral}{'l'}, ast.name))
        );
      \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) \{
        \textcolor{keyword}{self}.addEnsureSafeObject(intoId);
      \}
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.MemberExpression:
      left = nameId && (nameId.context = this.nextId()) || this.nextId();
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.object, left, undefined, \textcolor{keyword}{function}() \{
        self.if\_(self.notNull(left), function() \{
          if (ast.computed) \{
            right = self.nextId();
            self.recurse(ast.property, right);
            self.addEnsureSafeMemberName(right);
            if (create && create !== 1) \{
              self.if\_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left
      , right), \textcolor{stringliteral}{'\{\}'}));
            \}
            expression = self.ensureSafeObject(self.computedMember(left, right));
            self.assign(intoId, expression);
            if (nameId) \{
              nameId.computed = true;
              nameId.name = right;
            \}
          \} else \{
            ensureSafeMemberName(ast.property.name);
            if (create && create !== 1) \{
              self.if\_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonC
      omputedMember(left, ast.property.name), \textcolor{stringliteral}{'\{\}'}));
            \}
            expression = self.nonComputedMember(left, ast.property.name);
            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) \{
              expression = self.ensureSafeObject(expression);
            \}
            self.assign(intoId, expression);
            if (nameId) \{
              nameId.computed = false;
              nameId.name = ast.property.name;
            \}
          \}
        \}, \textcolor{keyword}{function}() \{
          self.assign(intoId, \textcolor{stringliteral}{'undefined'});
        \});
        recursionFn(intoId);
      \}, !!create);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.CallExpression:
      intoId = intoId || this.nextId();
      \textcolor{keywordflow}{if} (ast.filter) \{
        right = \textcolor{keyword}{self}.filter(ast.callee.name);
        args = [];
        forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
          var argument = self.nextId();
          self.recurse(expr, argument);
          args.push(argument);
        \});
        expression = right + \textcolor{charliteral}{'('} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{')'};
        \textcolor{keyword}{self}.assign(intoId, expression);
        recursionFn(intoId);
      \} \textcolor{keywordflow}{else} \{
        right = \textcolor{keyword}{self}.nextId();
        left = \{\};
        args = [];
        \textcolor{keyword}{self}.recurse(ast.callee, right, left, \textcolor{keyword}{function}() \{
          self.if\_(self.notNull(right), function() \{
            self.addEnsureSafeFunction(right);
            forEach(ast.arguments, function(expr) \{
              self.recurse(expr, self.nextId(), undefined, function(argument) \{
                args.push(self.ensureSafeObject(argument));
              \});
            \});
            if (left.name) \{
              if (!self.state.expensiveChecks) \{
                self.addEnsureSafeObject(left.context);
              \}
              expression = self.member(left.context, left.name, left.computed) + \textcolor{stringliteral}{'('} + args.join(\textcolor{stringliteral}{','}) + \textcolor{stringliteral}{')'}
      ;
            \} else \{
              expression = right + \textcolor{stringliteral}{'('} + args.join(\textcolor{stringliteral}{','}) + \textcolor{stringliteral}{')'};
            \}
            expression = self.ensureSafeObject(expression);
            self.assign(intoId, expression);
          \}, \textcolor{keyword}{function}() \{
            self.assign(intoId, \textcolor{stringliteral}{'undefined'});
          \});
          recursionFn(intoId);
        \});
      \}
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.AssignmentExpression:
      right = this.nextId();
      left = \{\};
      \textcolor{keywordflow}{if} (!isAssignable(ast.left)) \{
        \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'lval'}, \textcolor{stringliteral}{'Trying to assing a value to a non l-value'});
      \}
      this.recurse(ast.left, undefined, left, \textcolor{keyword}{function}() \{
        self.if\_(self.notNull(left.context), function() \{
          self.recurse(ast.right, right);
          self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
          self.assign(intoId, expression);
          recursionFn(intoId || expression);
        \});
      \}, 1);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ArrayExpression:
      args = [];
      forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
        self.recurse(expr, self.nextId(), undefined, function(argument) \{
          args.push(argument);
        \});
      \});
      expression = \textcolor{charliteral}{'['} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{']'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ObjectExpression:
      args = [];
      forEach(ast.properties, \textcolor{keyword}{function}(property) \{
        self.recurse(property.value, self.nextId(), undefined, function(expr) \{
          args.push(self.escape(
              property.key.type === AST.Identifier ? property.key.name :
                (\textcolor{stringliteral}{''} + property.key.value)) +
              \textcolor{stringliteral}{':'} + expr);
        \});
      \});
      expression = \textcolor{charliteral}{'\{'} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{'\}'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ThisExpression:
      this.assign(intoId, \textcolor{charliteral}{'s'});
      recursionFn(\textcolor{charliteral}{'s'});
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.NGValueParameter:
      this.assign(intoId, \textcolor{charliteral}{'v'});
      recursionFn(\textcolor{charliteral}{'v'});
      \textcolor{keywordflow}{break};
    \}
  \},

  getHasOwnProperty: \textcolor{keyword}{function}(element, property) \{
    var key = element + \textcolor{charliteral}{'.'} + property;
    var own = this.current().own;
    \textcolor{keywordflow}{if} (!own.hasOwnProperty(key)) \{
      own[key] = this.nextId(\textcolor{keyword}{false}, element + \textcolor{stringliteral}{'&&('} + this.escape(property) + \textcolor{stringliteral}{' in '} + element + \textcolor{charliteral}{')'});
    \}
    \textcolor{keywordflow}{return} own[key];
  \},

  assign: \textcolor{keyword}{function}(id, value) \{
    \textcolor{keywordflow}{if} (!\textcolor{keywordtype}{id}) \textcolor{keywordflow}{return};
    this.current().body.push(\textcolor{keywordtype}{id}, \textcolor{charliteral}{'='}, value, \textcolor{charliteral}{';'});
    \textcolor{keywordflow}{return} id;
  \},

  filter: \textcolor{keyword}{function}(filterName) \{
    \textcolor{keywordflow}{if} (!this.state.filters.hasOwnProperty(filterName)) \{
      this.state.filters[filterName] = this.nextId(\textcolor{keyword}{true});
    \}
    \textcolor{keywordflow}{return} this.state.filters[filterName];
  \},

  ifDefined: \textcolor{keyword}{function}(id, defaultValue) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ifDefined('} + \textcolor{keywordtype}{id} + \textcolor{charliteral}{','} + this.escape(defaultValue) + \textcolor{charliteral}{')'};
  \},

  plus: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'plus('} + left + \textcolor{charliteral}{','} + right + \textcolor{charliteral}{')'};
  \},

  return\_: \textcolor{keyword}{function}(id) \{
    this.current().body.push(\textcolor{stringliteral}{'return '}, \textcolor{keywordtype}{id}, \textcolor{charliteral}{';'});
  \},

  if\_: \textcolor{keyword}{function}(test, alternate, consequent) \{
    \textcolor{keywordflow}{if} (test === \textcolor{keyword}{true}) \{
      alternate();
    \} \textcolor{keywordflow}{else} \{
      var body = this.current().body;
      body.push(\textcolor{stringliteral}{'if('}, test, \textcolor{stringliteral}{')\{'});
      alternate();
      body.push(\textcolor{charliteral}{'\}'});
      \textcolor{keywordflow}{if} (consequent) \{
        body.push(\textcolor{stringliteral}{'else\{'});
        consequent();
        body.push(\textcolor{charliteral}{'\}'});
      \}
    \}
  \},

  not: \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'!('} + expression + \textcolor{charliteral}{')'};
  \},

  notNull: \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{return} expression + \textcolor{stringliteral}{'!=null'};
  \},

  nonComputedMember: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} left + \textcolor{charliteral}{'.'} + right;
  \},

  computedMember: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} left + \textcolor{charliteral}{'['} + right + \textcolor{charliteral}{']'};
  \},

  member: \textcolor{keyword}{function}(left, right, computed) \{
    \textcolor{keywordflow}{if} (computed) \textcolor{keywordflow}{return} this.computedMember(left, right);
    \textcolor{keywordflow}{return} this.nonComputedMember(left, right);
  \},

  addEnsureSafeObject: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeObject(item), \textcolor{charliteral}{';'});
  \},

  addEnsureSafeMemberName: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeMemberName(item), \textcolor{charliteral}{';'});
  \},

  addEnsureSafeFunction: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeFunction(item), \textcolor{charliteral}{';'});
  \},

  ensureSafeObject: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeObject('} + item + \textcolor{stringliteral}{',text)'};
  \},

  ensureSafeMemberName: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeMemberName('} + item + \textcolor{stringliteral}{',text)'};
  \},

  ensureSafeFunction: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeFunction('} + item + \textcolor{stringliteral}{',text)'};
  \},

  lazyRecurse: \textcolor{keyword}{function}(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keyword}{self}.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
    \};
  \},

  lazyAssign: \textcolor{keyword}{function}(id, value) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keyword}{self}.assign(\textcolor{keywordtype}{id}, value);
    \};
  \},

  stringEscapeRegex: /[^ a-zA-Z0-9]/g,

  stringEscapeFn: \textcolor{keyword}{function}(c) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)u'} + (\textcolor{stringliteral}{'0000'} + c.charCodeAt(0).toString(16)).slice(-4);
  \},

  escape: \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (isString(value)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'"} + value.replace(\textcolor{keyword}{this}.stringEscapeRegex, \textcolor{keyword}{this}.stringEscapeFn) + \textcolor{stringliteral}{"'"};
    \textcolor{keywordflow}{if} (isNumber(value)) \textcolor{keywordflow}{return} value.toString();
    \textcolor{keywordflow}{if} (value === \textcolor{keyword}{true}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'true'};
    \textcolor{keywordflow}{if} (value === \textcolor{keyword}{false}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'false'};
    \textcolor{keywordflow}{if} (value === null) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'null'};
    \textcolor{keywordflow}{if} (typeof value === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'undefined'};

    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'esc'}, \textcolor{stringliteral}{'IMPOSSIBLE'});
  \},

  nextId: \textcolor{keyword}{function}(skip, init) \{
    var \textcolor{keywordtype}{id} = \textcolor{charliteral}{'v'} + (this.state.nextId++);
    \textcolor{keywordflow}{if} (!skip) \{
      this.current().vars.push(\textcolor{keywordtype}{id} + (init ? \textcolor{charliteral}{'='} + init : \textcolor{stringliteral}{''}));
    \}
    \textcolor{keywordflow}{return} id;
  \},

  current: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.state[this.state.computing];
  \}
\};


\textcolor{keyword}{function} ASTInterpreter(astBuilder, $filter) \{
  this.astBuilder = astBuilder;
  this.$filter = $filter;
\}

ASTInterpreter.prototype = \{
  compile: \textcolor{keyword}{function}(expression, expensiveChecks) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    var ast = this.astBuilder.ast(expression);
    this.expression = expression;
    this.expensiveChecks = expensiveChecks;
    findConstantAndWatchExpressions(ast, \textcolor{keyword}{self}.$filter);
    var assignable;
    var assign;
    \textcolor{keywordflow}{if} ((assignable = assignableAST(ast))) \{
      assign = this.recurse(assignable);
    \}
    var toWatch = getInputs(ast.body);
    var inputs;
    \textcolor{keywordflow}{if} (toWatch) \{
      inputs = [];
      forEach(toWatch, \textcolor{keyword}{function}(watch, key) \{
        var input = \textcolor{keyword}{self}.recurse(watch);
        watch.input = input;
        inputs.push(input);
        watch.watchId = key;
      \});
    \}
    var expressions = [];
    forEach(ast.body, \textcolor{keyword}{function}(expression) \{
      expressions.push(self.recurse(expression.expression));
    \});
    var fn = ast.body.length === 0 ? \textcolor{keyword}{function}() \{\} :
             ast.body.length === 1 ? expressions[0] :
             \textcolor{keyword}{function}(scope, locals) \{
               var lastValue;
               forEach(expressions, \textcolor{keyword}{function}(exp) \{
                 lastValue = exp(scope, locals);
               \});
               \textcolor{keywordflow}{return} lastValue;
             \};
    \textcolor{keywordflow}{if} (assign) \{
      fn.assign = \textcolor{keyword}{function}(scope, value, locals) \{
        \textcolor{keywordflow}{return} assign(scope, locals, value);
      \};
    \}
    \textcolor{keywordflow}{if} (inputs) \{
      fn.inputs = inputs;
    \}
    fn.literal = isLiteral(ast);
    fn.constant = isConstant(ast);
    \textcolor{keywordflow}{return} fn;
  \},

  recurse: \textcolor{keyword}{function}(ast, context, create) \{
    var left, right, \textcolor{keyword}{self} = \textcolor{keyword}{this}, args, expression;
    \textcolor{keywordflow}{if} (ast.input) \{
      \textcolor{keywordflow}{return} this.inputs(ast.input, ast.watchId);
    \}
    \textcolor{keywordflow}{switch} (ast.type) \{
    \textcolor{keywordflow}{case} AST.Literal:
      \textcolor{keywordflow}{return} this.value(ast.value, context);
    \textcolor{keywordflow}{case} AST.UnaryExpression:
      right = this.recurse(ast.argument);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'unary'} + ast.operator](right, context);
    \textcolor{keywordflow}{case} AST.BinaryExpression:
      left = this.recurse(ast.left);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'binary'} + ast.operator](left, right, context);
    \textcolor{keywordflow}{case} AST.LogicalExpression:
      left = this.recurse(ast.left);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'binary'} + ast.operator](left, right, context);
    \textcolor{keywordflow}{case} AST.ConditionalExpression:
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'ternary?:'}](
        this.recurse(ast.test),
        this.recurse(ast.alternate),
        this.recurse(ast.consequent),
        context
      );
    \textcolor{keywordflow}{case} AST.Identifier:
      ensureSafeMemberName(ast.name, \textcolor{keyword}{self}.expression);
      \textcolor{keywordflow}{return} \textcolor{keyword}{self}.identifier(ast.name,
                             \textcolor{keyword}{self}.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
                             context, create, \textcolor{keyword}{self}.expression);
    \textcolor{keywordflow}{case} AST.MemberExpression:
      left = this.recurse(ast.object, \textcolor{keyword}{false}, !!create);
      \textcolor{keywordflow}{if} (!ast.computed) \{
        ensureSafeMemberName(ast.property.name, \textcolor{keyword}{self}.expression);
        right = ast.property.name;
      \}
      \textcolor{keywordflow}{if} (ast.computed) right = this.recurse(ast.property);
      \textcolor{keywordflow}{return} ast.computed ?
        this.computedMember(left, right, context, create, \textcolor{keyword}{self}.expression) :
        this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
    \textcolor{keywordflow}{case} AST.CallExpression:
      args = [];
      forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
        args.push(self.recurse(expr));
      \});
      \textcolor{keywordflow}{if} (ast.filter) right = this.$filter(ast.callee.name);
      \textcolor{keywordflow}{if} (!ast.filter) right = this.recurse(ast.callee, \textcolor{keyword}{true});
      \textcolor{keywordflow}{return} ast.filter ?
        \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
          var values = [];
          \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
            values.push(args[i](scope, locals, assign, inputs));
          \}
          var value = right.apply(undefined, values, inputs);
          \textcolor{keywordflow}{return} context ? \{context: undefined, name: undefined, value: value\} : value;
        \} :
        \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
          var rhs = right(scope, locals, assign, inputs);
          var value;
          \textcolor{keywordflow}{if} (rhs.value != null) \{
            ensureSafeObject(rhs.context, \textcolor{keyword}{self}.expression);
            ensureSafeFunction(rhs.value, \textcolor{keyword}{self}.expression);
            var values = [];
            \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
              values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), \textcolor{keyword}{self}.expression));
            \}
            value = ensureSafeObject(rhs.value.apply(rhs.context, values), \textcolor{keyword}{self}.expression);
          \}
          \textcolor{keywordflow}{return} context ? \{value: value\} : value;
        \};
    \textcolor{keywordflow}{case} AST.AssignmentExpression:
      left = this.recurse(ast.left, \textcolor{keyword}{true}, 1);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        ensureSafeObject(lhs.value, \textcolor{keyword}{self}.expression);
        lhs.context[lhs.name] = rhs;
        \textcolor{keywordflow}{return} context ? \{value: rhs\} : rhs;
      \};
    \textcolor{keywordflow}{case} AST.ArrayExpression:
      args = [];
      forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
        args.push(self.recurse(expr));
      \});
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var value = [];
        \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
          value.push(args[i](scope, locals, assign, inputs));
        \}
        \textcolor{keywordflow}{return} context ? \{value: value\} : value;
      \};
    \textcolor{keywordflow}{case} AST.ObjectExpression:
      args = [];
      forEach(ast.properties, \textcolor{keyword}{function}(property) \{
        args.push(\{key: property.key.type === AST.Identifier ?
                        property.key.name :
                        (\textcolor{stringliteral}{''} + property.key.value),
                   value: self.recurse(property.value)
        \});
      \});
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var value = \{\};
        \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
          value[args[i].key] = args[i].value(scope, locals, assign, inputs);
        \}
        \textcolor{keywordflow}{return} context ? \{value: value\} : value;
      \};
    \textcolor{keywordflow}{case} AST.ThisExpression:
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope) \{
        \textcolor{keywordflow}{return} context ? \{value: scope\} : scope;
      \};
    \textcolor{keywordflow}{case} AST.NGValueParameter:
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        \textcolor{keywordflow}{return} context ? \{value: assign\} : assign;
      \};
    \}
  \},

  \textcolor{stringliteral}{'unary+'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (isDefined(arg)) \{
        arg = +arg;
      \} \textcolor{keywordflow}{else} \{
        arg = 0;
      \}
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'unary-'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (isDefined(arg)) \{
        arg = -arg;
      \} \textcolor{keywordflow}{else} \{
        arg = 0;
      \}
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'unary!'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = !argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary+'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs = right(scope, locals, assign, inputs);
      var arg = plusFn(lhs, rhs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary-'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs = right(scope, locals, assign, inputs);
      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary*'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary/'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary%'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary==='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary!=='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary=='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary!='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary<'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary>'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary<='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary>='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary&&'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary||'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'ternary?:'}: \textcolor{keyword}{function}(test, alternate, consequent, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent
      (scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  value: \textcolor{keyword}{function}(value, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} context ? \{context: undefined, name: undefined, value: value\} : value; \};
  \},
  identifier: \textcolor{keyword}{function}(name, expensiveChecks, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var base = locals && (name in locals) ? locals : scope;
      \textcolor{keywordflow}{if} (create && create !== 1 && base && !(base[name])) \{
        base[name] = \{\};
      \}
      var value = base ? base[name] : undefined;
      \textcolor{keywordflow}{if} (expensiveChecks) \{
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: base, name: name, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  computedMember: \textcolor{keyword}{function}(left, right, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs;
      var value;
      \textcolor{keywordflow}{if} (lhs != null) \{
        rhs = right(scope, locals, assign, inputs);
        ensureSafeMemberName(rhs, expression);
        \textcolor{keywordflow}{if} (create && create !== 1 && lhs && !(lhs[rhs])) \{
          lhs[rhs] = \{\};
        \}
        value = lhs[rhs];
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: lhs, name: rhs, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  nonComputedMember: \textcolor{keyword}{function}(left, right, expensiveChecks, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (create && create !== 1 && lhs && !(lhs[right])) \{
        lhs[right] = \{\};
      \}
      var value = lhs != null ? lhs[right] : undefined;
      \textcolor{keywordflow}{if} (expensiveChecks || isPossiblyDangerousMemberName(right)) \{
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: lhs, name: right, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  inputs: \textcolor{keyword}{function}(input, watchId) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, value, locals, inputs) \{
      \textcolor{keywordflow}{if} (inputs) \textcolor{keywordflow}{return} inputs[watchId];
      \textcolor{keywordflow}{return} input(scope, value, locals);
    \};
  \}
\};

var Parser = \textcolor{keyword}{function}(lexer, $filter, options) \{
  this.lexer = lexer;
  this.$filter = $filter;
  this.options = options;
  this.ast = \textcolor{keyword}{new} AST(this.lexer);
  this.astCompiler = options.csp ? \textcolor{keyword}{new} ASTInterpreter(this.ast, $filter) :
                                   new ASTCompiler(this.ast, $filter);
\};

Parser.prototype = \{
  constructor: Parser,

  parse: \textcolor{keyword}{function}(text) \{
    \textcolor{keywordflow}{return} this.astCompiler.compile(text, this.options.expensiveChecks);
  \}
\};

var getterFnCacheDefault = createMap();
var getterFnCacheExpensive = createMap();

\textcolor{keyword}{function} isPossiblyDangerousMemberName(name) \{
  \textcolor{keywordflow}{return} name == \textcolor{stringliteral}{'constructor'};
\}

var objectValueOf = Object.prototype.valueOf;

\textcolor{keyword}{function} getValueOf(value) \{
  \textcolor{keywordflow}{return} isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
\}


\textcolor{keyword}{function} $ParseProvider() \{
  var cacheDefault = createMap();
  var cacheExpensive = createMap();

  this.$get = [\textcolor{stringliteral}{'$filter'}, \textcolor{keyword}{function}($filter) \{
    var noUnsafeEval = csp().noUnsafeEval;
    var $parseOptions = \{
          csp: noUnsafeEval,
          expensiveChecks: \textcolor{keyword}{false}
        \},
        $parseOptionsExpensive = \{
          csp: noUnsafeEval,
          expensiveChecks: \textcolor{keyword}{true}
        \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function} $parse(exp, interceptorFn, expensiveChecks) \{
      var parsedExpression, oneTime, cacheKey;

      \textcolor{keywordflow}{switch} (typeof exp) \{
        \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
          exp = exp.trim();
          cacheKey = exp;

          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
          parsedExpression = cache[cacheKey];

          \textcolor{keywordflow}{if} (!parsedExpression) \{
            \textcolor{keywordflow}{if} (exp.charAt(0) === \textcolor{charliteral}{':'} && exp.charAt(1) === \textcolor{charliteral}{':'}) \{
              oneTime = \textcolor{keyword}{true};
              exp = exp.substring(2);
            \}
            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
            var lexer = \textcolor{keyword}{new} Lexer(parseOptions);
            var parser = \textcolor{keyword}{new} Parser(lexer, $filter, parseOptions);
            parsedExpression = parser.parse(exp);
            \textcolor{keywordflow}{if} (parsedExpression.constant) \{
              parsedExpression.$$watchDelegate = constantWatchDelegate;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (oneTime) \{
              parsedExpression.$$watchDelegate = parsedExpression.literal ?
                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parsedExpression.inputs) \{
              parsedExpression.$$watchDelegate = inputsWatchDelegate;
            \}
            cache[cacheKey] = parsedExpression;
          \}
          \textcolor{keywordflow}{return} addInterceptor(parsedExpression, interceptorFn);

        \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
          \textcolor{keywordflow}{return} addInterceptor(exp, interceptorFn);

        \textcolor{keywordflow}{default}:
          \textcolor{keywordflow}{return} noop;
      \}
    \};

    \textcolor{keyword}{function} expressionInputDirtyCheck(newValue, oldValueOfValue) \{

      \textcolor{keywordflow}{if} (newValue == null || oldValueOfValue == null) \{ \textcolor{comment}{// null/undefined}
        \textcolor{keywordflow}{return} newValue === oldValueOfValue;
      \}

      \textcolor{keywordflow}{if} (typeof newValue === \textcolor{stringliteral}{'object'}) \{

        \textcolor{comment}{// attempt to convert the value to a primitive type}
        \textcolor{comment}{// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can}
        \textcolor{comment}{//             be cheaply dirty-checked}
        newValue = getValueOf(newValue);

        \textcolor{keywordflow}{if} (typeof newValue === \textcolor{stringliteral}{'object'}) \{
          \textcolor{comment}{// objects/arrays are not supported - deep-watching them would be too expensive}
          \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{comment}{// fall-through to the primitive equality check}
      \}

      \textcolor{comment}{//Primitive or NaN}
      \textcolor{keywordflow}{return} newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue)
      ;
    \}

    \textcolor{keyword}{function} inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) 
      \{
      var inputExpressions = parsedExpression.inputs;
      var lastResult;

      \textcolor{keywordflow}{if} (inputExpressions.length === 1) \{
        var oldInputValueOf = expressionInputDirtyCheck; \textcolor{comment}{// init to something unique so that equals check
       fails}
        inputExpressions = inputExpressions[0];
        \textcolor{keywordflow}{return} scope.$watch(\textcolor{keyword}{function} expressionInputWatch(scope) \{
          var newInputValue = inputExpressions(scope);
          \textcolor{keywordflow}{if} (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) \{
            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
            oldInputValueOf = newInputValue && getValueOf(newInputValue);
          \}
          \textcolor{keywordflow}{return} lastResult;
        \}, listener, objectEquality, prettyPrintExpression);
      \}

      var oldInputValueOfValues = [];
      var oldInputValues = [];
      \textcolor{keywordflow}{for} (var i = 0, ii = inputExpressions.length; i < ii; i++) \{
        oldInputValueOfValues[i] = expressionInputDirtyCheck; \textcolor{comment}{// init to something unique so that equals
       check fails}
        oldInputValues[i] = null;
      \}

      \textcolor{keywordflow}{return} scope.$watch(\textcolor{keyword}{function} expressionInputsWatch(scope) \{
        var changed = \textcolor{keyword}{false};

        \textcolor{keywordflow}{for} (var i = 0, ii = inputExpressions.length; i < ii; i++) \{
          var newInputValue = inputExpressions[i](scope);
          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) \{
            oldInputValues[i] = newInputValue;
            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
          \}
        \}

        \textcolor{keywordflow}{if} (changed) \{
          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
        \}

        \textcolor{keywordflow}{return} lastResult;
      \}, listener, objectEquality, prettyPrintExpression);
    \}

    \textcolor{keyword}{function} oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch, lastValue;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} oneTimeWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} oneTimeListener(value, old, scope) \{
        lastValue = value;
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.apply(\textcolor{keyword}{this}, arguments);
        \}
        \textcolor{keywordflow}{if} (isDefined(value)) \{
          scope.$$postDigest(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isDefined(lastValue)) \{
              unwatch();
            \}
          \});
        \}
      \}, objectEquality);
    \}

    \textcolor{keyword}{function} oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch, lastValue;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} oneTimeWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} oneTimeListener(value, old, scope) \{
        lastValue = value;
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.call(\textcolor{keyword}{this}, value, old, scope);
        \}
        \textcolor{keywordflow}{if} (isAllDefined(value)) \{
          scope.$$postDigest(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isAllDefined(lastValue)) unwatch();
          \});
        \}
      \}, objectEquality);

      \textcolor{keyword}{function} isAllDefined(value) \{
        var allDefined = \textcolor{keyword}{true};
        forEach(value, \textcolor{keyword}{function}(val) \{
          \textcolor{keywordflow}{if} (!isDefined(val)) allDefined = \textcolor{keyword}{false};
        \});
        \textcolor{keywordflow}{return} allDefined;
      \}
    \}

    \textcolor{keyword}{function} constantWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} constantWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} constantListener(value, old, scope) \{
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.apply(\textcolor{keyword}{this}, arguments);
        \}
        unwatch();
      \}, objectEquality);
    \}

    \textcolor{keyword}{function} addInterceptor(parsedExpression, interceptorFn) \{
      \textcolor{keywordflow}{if} (!interceptorFn) \textcolor{keywordflow}{return} parsedExpression;
      var watchDelegate = parsedExpression.$$watchDelegate;

      var regularWatch =
          watchDelegate !== oneTimeLiteralWatchDelegate &&
          watchDelegate !== oneTimeWatchDelegate;

      var fn = regularWatch ? \textcolor{keyword}{function} regularInterceptedExpression(scope, locals, assign, inputs) \{
        var value = parsedExpression(scope, locals, assign, inputs);
        \textcolor{keywordflow}{return} interceptorFn(value, scope, locals);
      \} : \textcolor{keyword}{function} oneTimeInterceptedExpression(scope, locals, assign, inputs) \{
        var value = parsedExpression(scope, locals, assign, inputs);
        var result = interceptorFn(value, scope, locals);
        \textcolor{comment}{// we only return the interceptor's result if the}
        \textcolor{comment}{// initial value is defined (for bind-once)}
        \textcolor{keywordflow}{return} isDefined(value) ? result : value;
      \};

      \textcolor{comment}{// Propagate $$watchDelegates other then inputsWatchDelegate}
      \textcolor{keywordflow}{if} (parsedExpression.$$watchDelegate &&
          parsedExpression.$$watchDelegate !== inputsWatchDelegate) \{
        fn.$$watchDelegate = parsedExpression.$$watchDelegate;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!interceptorFn.$stateful) \{
        \textcolor{comment}{// If there is an interceptor, but no watchDelegate then treat the interceptor like}
        \textcolor{comment}{// we treat filters - it is assumed to be a pure function unless flagged with $stateful}
        fn.$$watchDelegate = inputsWatchDelegate;
        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
      \}

      \textcolor{keywordflow}{return} fn;
    \}
  \}];
\}

\textcolor{keyword}{function} $QProvider() \{

  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{keyword}{function}($rootScope, $exceptionHandler) \{
    \textcolor{keywordflow}{return} qFactory(\textcolor{keyword}{function}(callback) \{
      $rootScope.$evalAsync(callback);
    \}, $exceptionHandler);
  \}];
\}

\textcolor{keyword}{function} $$QProvider() \{
  this.$get = [\textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{keyword}{function}($browser, $exceptionHandler) \{
    \textcolor{keywordflow}{return} qFactory(\textcolor{keyword}{function}(callback) \{
      $browser.defer(callback);
    \}, $exceptionHandler);
  \}];
\}

\textcolor{keyword}{function} qFactory(nextTick, exceptionHandler) \{
  var $qMinErr = minErr(\textcolor{stringliteral}{'$q'}, TypeError);
  \textcolor{keyword}{function} callOnce(\textcolor{keyword}{self}, resolveFn, rejectFn) \{
    var called = \textcolor{keyword}{false};
    \textcolor{keyword}{function} wrap(fn) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (called) \textcolor{keywordflow}{return};
        called = \textcolor{keyword}{true};
        fn.call(\textcolor{keyword}{self}, value);
      \};
    \}

    \textcolor{keywordflow}{return} [wrap(resolveFn), wrap(rejectFn)];
  \}

  var defer = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Deferred();
  \};

  \textcolor{keyword}{function} Promise() \{
    this.$$state = \{ status: 0 \};
  \}

  extend(Promise.prototype, \{
    then: function(onFulfilled, onRejected, progressBack) \{
      if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) \{
        return this;
      \}
      var result = new Deferred();

      this.$$state.pending = this.$$state.pending || [];
      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
      if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);

      return result.promise;
    \},

    \textcolor{stringliteral}{"catch"}: \textcolor{keyword}{function}(callback) \{
      return this.then(null, callback);
    \},

    \textcolor{stringliteral}{"finally"}: \textcolor{keyword}{function}(callback, progressBack) \{
      return this.then(function(value) \{
        return handleCallback(value, true, callback);
      \}, \textcolor{keyword}{function}(error) \{
        return handleCallback(error, false, callback);
      \}, progressBack);
    \}
  \});

  \textcolor{comment}{//Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native}
  \textcolor{keyword}{function} simpleBind(context, fn) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
      fn.call(context, value);
    \};
  \}

  \textcolor{keyword}{function} processQueue(state) \{
    var fn, deferred, pending;

    pending = state.pending;
    state.processScheduled = \textcolor{keyword}{false};
    state.pending = undefined;
    \textcolor{keywordflow}{for} (var i = 0, ii = pending.length; i < ii; ++i) \{
      deferred = pending[i][0];
      fn = pending[i][state.status];
      \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{if} (isFunction(fn)) \{
          deferred.resolve(fn(state.value));
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state.status === 1) \{
          deferred.resolve(state.value);
        \} \textcolor{keywordflow}{else} \{
          deferred.reject(state.value);
        \}
      \} \textcolor{keywordflow}{catch} (e) \{
        deferred.reject(e);
        exceptionHandler(e);
      \}
    \}
  \}

  \textcolor{keyword}{function} scheduleProcessQueue(state) \{
    \textcolor{keywordflow}{if} (state.processScheduled || !state.pending) \textcolor{keywordflow}{return};
    state.processScheduled = \textcolor{keyword}{true};
    nextTick(\textcolor{keyword}{function}() \{ processQueue(state); \});
  \}

  \textcolor{keyword}{function} Deferred() \{
    this.promise = \textcolor{keyword}{new} Promise();
    \textcolor{comment}{//Necessary to support unbound execution :/}
    this.resolve = simpleBind(\textcolor{keyword}{this}, this.resolve);
    this.reject = simpleBind(\textcolor{keyword}{this}, this.reject);
    this.notify = simpleBind(\textcolor{keyword}{this}, this.notify);
  \}

  extend(Deferred.prototype, \{
    resolve: function(val) \{
      if (this.promise.$$state.status) return;
      if (val === this.promise) \{
        this.$$reject($qMinErr(
          \textcolor{stringliteral}{'qcycle'},
          \textcolor{stringliteral}{"Expected promise to be resolved with value other than itself '\{0\}'"},
          val));
      \} else \{
        this.$$resolve(val);
      \}

    \},

    $$resolve: \textcolor{keyword}{function}(val) \{
      var then, fns;

      fns = callOnce(this, this.$$resolve, this.$$reject);
      try \{
        if ((isObject(val) || isFunction(val))) then = val && val.then;
        if (isFunction(then)) \{
          this.promise.$$state.status = -1;
          then.call(val, fns[0], fns[1], this.notify);
        \} else \{
          this.promise.$$state.value = val;
          this.promise.$$state.status = 1;
          scheduleProcessQueue(this.promise.$$state);
        \}
      \} catch (e) \{
        fns[1](e);
        exceptionHandler(e);
      \}
    \},

    reject: \textcolor{keyword}{function}(reason) \{
      \textcolor{keywordflow}{if} (this.promise.$$state.status) \textcolor{keywordflow}{return};
      this.$$reject(reason);
    \},

    $$reject: \textcolor{keyword}{function}(reason) \{
      this.promise.$$state.value = reason;
      this.promise.$$state.status = 2;
      scheduleProcessQueue(this.promise.$$state);
    \},

    notify: \textcolor{keyword}{function}(progress) \{
      var callbacks = this.promise.$$state.pending;

      \textcolor{keywordflow}{if} ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) \{
        nextTick(\textcolor{keyword}{function}() \{
          var callback, result;
          \textcolor{keywordflow}{for} (var i = 0, ii = callbacks.length; i < ii; i++) \{
            result = callbacks[i][0];
            callback = callbacks[i][3];
            try \{
              result.notify(isFunction(callback) ? callback(progress) : progress);
            \} catch (e) \{
              exceptionHandler(e);
            \}
          \}
        \});
      \}
    \}
  \});

  var reject = \textcolor{keyword}{function}(reason) \{
    var result = \textcolor{keyword}{new} Deferred();
    result.reject(reason);
    \textcolor{keywordflow}{return} result.promise;
  \};

  var makePromise = \textcolor{keyword}{function} makePromise(value, resolved) \{
    var result = \textcolor{keyword}{new} Deferred();
    \textcolor{keywordflow}{if} (resolved) \{
      result.resolve(value);
    \} \textcolor{keywordflow}{else} \{
      result.reject(value);
    \}
    \textcolor{keywordflow}{return} result.promise;
  \};

  var handleCallback = \textcolor{keyword}{function} handleCallback(value, isResolved, callback) \{
    var callbackOutput = null;
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{if} (isFunction(callback)) callbackOutput = callback();
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} makePromise(e, \textcolor{keyword}{false});
    \}
    \textcolor{keywordflow}{if} (isPromiseLike(callbackOutput)) \{
      \textcolor{keywordflow}{return} callbackOutput.then(\textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} makePromise(value, isResolved);
      \}, \textcolor{keyword}{function}(error) \{
        \textcolor{keywordflow}{return} makePromise(error, \textcolor{keyword}{false});
      \});
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} makePromise(value, isResolved);
    \}
  \};

  var when = \textcolor{keyword}{function}(value, callback, errback, progressBack) \{
    var result = \textcolor{keyword}{new} Deferred();
    result.resolve(value);
    \textcolor{keywordflow}{return} result.promise.then(callback, errback, progressBack);
  \};

  var resolve = when;

  \textcolor{keyword}{function} all(promises) \{
    var deferred = \textcolor{keyword}{new} Deferred(),
        counter = 0,
        results = isArray(promises) ? [] : \{\};

    forEach(promises, \textcolor{keyword}{function}(promise, key) \{
      counter++;
      when(promise).then(\textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (results.hasOwnProperty(key)) \textcolor{keywordflow}{return};
        results[key] = value;
        \textcolor{keywordflow}{if} (!(--counter)) deferred.resolve(results);
      \}, \textcolor{keyword}{function}(reason) \{
        \textcolor{keywordflow}{if} (results.hasOwnProperty(key)) \textcolor{keywordflow}{return};
        deferred.reject(reason);
      \});
    \});

    \textcolor{keywordflow}{if} (counter === 0) \{
      deferred.resolve(results);
    \}

    \textcolor{keywordflow}{return} deferred.promise;
  \}

  var $Q = \textcolor{keyword}{function} Q(resolver) \{
    \textcolor{keywordflow}{if} (!isFunction(resolver)) \{
      \textcolor{keywordflow}{throw} $qMinErr(\textcolor{stringliteral}{'norslvr'}, \textcolor{stringliteral}{"Expected resolverFn, got '\{0\}'"}, resolver);
    \}

    \textcolor{keywordflow}{if} (!(\textcolor{keyword}{this} instanceof Q)) \{
      \textcolor{comment}{// More useful when $Q is the Promise itself.}
      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Q(resolver);
    \}

    var deferred = \textcolor{keyword}{new} Deferred();

    \textcolor{keyword}{function} resolveFn(value) \{
      deferred.resolve(value);
    \}

    \textcolor{keyword}{function} rejectFn(reason) \{
      deferred.reject(reason);
    \}

    resolver(resolveFn, rejectFn);

    \textcolor{keywordflow}{return} deferred.promise;
  \};

  $Q.defer = defer;
  $Q.reject = reject;
  $Q.when = when;
  $Q.resolve = resolve;
  $Q.all = all;

  \textcolor{keywordflow}{return} $Q;
\}

\textcolor{keyword}{function} $$RAFProvider() \{ \textcolor{comment}{//rAF}
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$timeout'}, \textcolor{keyword}{function}($window, $timeout) \{
    var requestAnimationFrame = $window.requestAnimationFrame ||
                                $window.webkitRequestAnimationFrame;

    var cancelAnimationFrame = $window.cancelAnimationFrame ||
                               $window.webkitCancelAnimationFrame ||
                               $window.webkitCancelRequestAnimationFrame;

    var rafSupported = !!requestAnimationFrame;
    var rafFn = rafSupported
      ? \textcolor{keyword}{function}(fn) \{
          var \textcolor{keywordtype}{id} = requestAnimationFrame(fn);
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            cancelAnimationFrame(\textcolor{keywordtype}{id});
          \};
        \}
      : \textcolor{keyword}{function}(fn) \{
          var timer = $timeout(fn, 16.66, \textcolor{keyword}{false}); \textcolor{comment}{// 1000 / 60 = 16.666}
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            $timeout.cancel(timer);
          \};
        \};

    queueFn.supported = rafSupported;

    var cancelLastRAF;
    var taskCount = 0;
    var taskQueue = [];
    \textcolor{keywordflow}{return} queueFn;

    \textcolor{keyword}{function} flush() \{
      \textcolor{keywordflow}{for} (var i = 0; i < taskQueue.length; i++) \{
        var task = taskQueue[i];
        \textcolor{keywordflow}{if} (task) \{
          taskQueue[i] = null;
          task();
        \}
      \}
      taskCount = taskQueue.length = 0;
    \}

    \textcolor{keyword}{function} queueFn(asyncFn) \{
      var index = taskQueue.length;

      taskCount++;
      taskQueue.push(asyncFn);

      \textcolor{keywordflow}{if} (index === 0) \{
        cancelLastRAF = rafFn(flush);
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} cancelQueueFn() \{
        \textcolor{keywordflow}{if} (index >= 0) \{
          taskQueue[index] = null;
          index = null;

          \textcolor{keywordflow}{if} (--taskCount === 0 && cancelLastRAF) \{
            cancelLastRAF();
            cancelLastRAF = null;
            taskQueue.length = 0;
          \}
        \}
      \};
    \}
  \}];
\}

\textcolor{keyword}{function} $RootScopeProvider() \{
  var TTL = 10;
  var $rootScopeMinErr = minErr(\textcolor{stringliteral}{'$rootScope'});
  var lastDirtyWatch = null;
  var applyAsyncId = null;

  this.digestTtl = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      TTL = value;
    \}
    \textcolor{keywordflow}{return} TTL;
  \};

  \textcolor{keyword}{function} createChildScopeClass(parent) \{
    \textcolor{keyword}{function} ChildScope() \{
      this.$$watchers = this.$$nextSibling =
          this.$$childHead = this.$$childTail = null;
      this.$$listeners = \{\};
      this.$$listenerCount = \{\};
      this.$$watchersCount = 0;
      this.$id = nextUid();
      this.$$ChildScope = null;
    \}
    ChildScope.prototype = parent;
    \textcolor{keywordflow}{return} ChildScope;
  \}

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$browser'},
      \textcolor{keyword}{function}($injector, $exceptionHandler, $parse, $browser) \{

    \textcolor{keyword}{function} destroyChildScope($event) \{
        $event.currentScope.$$destroyed = \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} Scope() \{
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this.$root = \textcolor{keyword}{this};
      this.$$destroyed = \textcolor{keyword}{false};
      this.$$listeners = \{\};
      this.$$listenerCount = \{\};
      this.$$watchersCount = 0;
      this.$$isolateBindings = null;
    \}

    Scope.prototype = \{
      constructor: Scope,
      $new: \textcolor{keyword}{function}(isolate, parent) \{
        var child;

        parent = parent || \textcolor{keyword}{this};

        \textcolor{keywordflow}{if} (isolate) \{
          child = \textcolor{keyword}{new} Scope();
          child.$root = this.$root;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// Only create a child scope class if somebody asks for one,}
          \textcolor{comment}{// but cache it to allow the VM to optimize lookups.}
          \textcolor{keywordflow}{if} (!this.$$ChildScope) \{
            this.$$ChildScope = createChildScopeClass(\textcolor{keyword}{this});
          \}
          child = \textcolor{keyword}{new} this.$$ChildScope();
        \}
        child.$parent = parent;
        child.$$prevSibling = parent.$$childTail;
        \textcolor{keywordflow}{if} (parent.$$childHead) \{
          parent.$$childTail.$$nextSibling = child;
          parent.$$childTail = child;
        \} \textcolor{keywordflow}{else} \{
          parent.$$childHead = parent.$$childTail = child;
        \}

        \textcolor{comment}{// When the new scope is not isolated or we inherit from `this`, and}
        \textcolor{comment}{// the parent scope is destroyed, the property `$$destroyed` is inherited}
        \textcolor{comment}{// prototypically. In all other cases, this property needs to be set}
        \textcolor{comment}{// when the parent scope is destroyed.}
        \textcolor{comment}{// The listener needs to be added after the parent is set}
        \textcolor{keywordflow}{if} (isolate || parent != \textcolor{keyword}{this}) child.$on(\textcolor{stringliteral}{'$destroy'}, destroyChildScope);

        \textcolor{keywordflow}{return} child;
      \},

      $watch: \textcolor{keyword}{function}(watchExp, listener, objectEquality, prettyPrintExpression) \{
        var \textcolor{keyword}{get} = $parse(watchExp);

        \textcolor{keywordflow}{if} (\textcolor{keyword}{get}.$$watchDelegate) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{get}.$$watchDelegate(\textcolor{keyword}{this}, listener, objectEquality, \textcolor{keyword}{get}, watchExp);
        \}
        var scope = \textcolor{keyword}{this},
            array = scope.$$watchers,
            watcher = \{
              fn: listener,
              last: initWatchVal,
              \textcolor{keyword}{get}: \textcolor{keyword}{get},
              exp: prettyPrintExpression || watchExp,
              eq: !!objectEquality
            \};

        lastDirtyWatch = null;

        \textcolor{keywordflow}{if} (!isFunction(listener)) \{
          watcher.fn = noop;
        \}

        \textcolor{keywordflow}{if} (!array) \{
          array = scope.$$watchers = [];
        \}
        \textcolor{comment}{// we use unshift since we use a while loop in $digest for speed.}
        \textcolor{comment}{// the while loop reads in reverse order.}
        array.unshift(watcher);
        incrementWatchersCount(\textcolor{keyword}{this}, 1);

        \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatch() \{
          \textcolor{keywordflow}{if} (arrayRemove(array, watcher) >= 0) \{
            incrementWatchersCount(scope, -1);
          \}
          lastDirtyWatch = null;
        \};
      \},

      $watchGroup: \textcolor{keyword}{function}(watchExpressions, listener) \{
        var oldValues = \textcolor{keyword}{new} Array(watchExpressions.length);
        var newValues = \textcolor{keyword}{new} Array(watchExpressions.length);
        var deregisterFns = [];
        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        var changeReactionScheduled = \textcolor{keyword}{false};
        var firstRun = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (!watchExpressions.length) \{
          \textcolor{comment}{// No expressions means we call the listener ASAP}
          var shouldCall = \textcolor{keyword}{true};
          \textcolor{keyword}{self}.$evalAsync(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (shouldCall) listener(newValues, newValues, \textcolor{keyword}{self});
          \});
          \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatchGroup() \{
            shouldCall = \textcolor{keyword}{false};
          \};
        \}

        \textcolor{keywordflow}{if} (watchExpressions.length === 1) \{
          \textcolor{comment}{// Special case size of one}
          \textcolor{keywordflow}{return} this.$watch(watchExpressions[0], \textcolor{keyword}{function} watchGroupAction(value, oldValue, scope) \{
            newValues[0] = value;
            oldValues[0] = oldValue;
            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
          \});
        \}

        forEach(watchExpressions, \textcolor{keyword}{function}(expr, i) \{
          var unwatchFn = \textcolor{keyword}{self}.$watch(expr, \textcolor{keyword}{function} watchGroupSubAction(value, oldValue) \{
            newValues[i] = value;
            oldValues[i] = oldValue;
            \textcolor{keywordflow}{if} (!changeReactionScheduled) \{
              changeReactionScheduled = \textcolor{keyword}{true};
              \textcolor{keyword}{self}.$evalAsync(watchGroupAction);
            \}
          \});
          deregisterFns.push(unwatchFn);
        \});

        \textcolor{keyword}{function} watchGroupAction() \{
          changeReactionScheduled = \textcolor{keyword}{false};

          \textcolor{keywordflow}{if} (firstRun) \{
            firstRun = \textcolor{keyword}{false};
            listener(newValues, newValues, \textcolor{keyword}{self});
          \} \textcolor{keywordflow}{else} \{
            listener(newValues, oldValues, \textcolor{keyword}{self});
          \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatchGroup() \{
          \textcolor{keywordflow}{while} (deregisterFns.length) \{
            deregisterFns.shift()();
          \}
        \};
      \},


      $watchCollection: \textcolor{keyword}{function}(obj, listener) \{
        $watchCollectionInterceptor.$stateful = \textcolor{keyword}{true};

        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        \textcolor{comment}{// the current value, updated on each dirty-check run}
        var newValue;
        \textcolor{comment}{// a shallow copy of the newValue from the last dirty-check run,}
        \textcolor{comment}{// updated to match newValue during dirty-check run}
        var oldValue;
        \textcolor{comment}{// a shallow copy of the newValue from when the last change happened}
        var veryOldValue;
        \textcolor{comment}{// only track veryOldValue if the listener is asking for it}
        var trackVeryOldValue = (listener.length > 1);
        var changeDetected = 0;
        var changeDetector = $parse(obj, $watchCollectionInterceptor);
        var internalArray = [];
        var internalObject = \{\};
        var initRun = \textcolor{keyword}{true};
        var oldLength = 0;

        \textcolor{keyword}{function} $watchCollectionInterceptor(\_value) \{
          newValue = \_value;
          var newLength, key, bothNaN, newItem, oldItem;

          \textcolor{comment}{// If the new value is undefined, then return undefined as the watch may be a one-time watch}
          \textcolor{keywordflow}{if} (isUndefined(newValue)) \textcolor{keywordflow}{return};

          \textcolor{keywordflow}{if} (!isObject(newValue)) \{ \textcolor{comment}{// if primitive}
            \textcolor{keywordflow}{if} (oldValue !== newValue) \{
              oldValue = newValue;
              changeDetected++;
            \}
          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArrayLike(newValue)) \{
            \textcolor{keywordflow}{if} (oldValue !== internalArray) \{
              \textcolor{comment}{// we are transitioning from something which was not an array into array.}
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            \}

            newLength = newValue.length;

            \textcolor{keywordflow}{if} (oldLength !== newLength) \{
              \textcolor{comment}{// if lengths do not match we need to trigger change notification}
              changeDetected++;
              oldValue.length = oldLength = newLength;
            \}
            \textcolor{comment}{// copy the items to oldValue and look for changes.}
            \textcolor{keywordflow}{for} (var i = 0; i < newLength; i++) \{
              oldItem = oldValue[i];
              newItem = newValue[i];

              bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
              \textcolor{keywordflow}{if} (!bothNaN && (oldItem !== newItem)) \{
                changeDetected++;
                oldValue[i] = newItem;
              \}
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (oldValue !== internalObject) \{
              \textcolor{comment}{// we are transitioning from something which was not an object into object.}
              oldValue = internalObject = \{\};
              oldLength = 0;
              changeDetected++;
            \}
            \textcolor{comment}{// copy the items to oldValue and look for changes.}
            newLength = 0;
            \textcolor{keywordflow}{for} (key in newValue) \{
              \textcolor{keywordflow}{if} (newValue.hasOwnProperty(key)) \{
                newLength++;
                newItem = newValue[key];
                oldItem = oldValue[key];

                \textcolor{keywordflow}{if} (key in oldValue) \{
                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                  \textcolor{keywordflow}{if} (!bothNaN && (oldItem !== newItem)) \{
                    changeDetected++;
                    oldValue[key] = newItem;
                  \}
                \} \textcolor{keywordflow}{else} \{
                  oldLength++;
                  oldValue[key] = newItem;
                  changeDetected++;
                \}
              \}
            \}
            \textcolor{keywordflow}{if} (oldLength > newLength) \{
              \textcolor{comment}{// we used to have more keys, need to find them and destroy them.}
              changeDetected++;
              \textcolor{keywordflow}{for} (key in oldValue) \{
                \textcolor{keywordflow}{if} (!newValue.hasOwnProperty(key)) \{
                  oldLength--;
                  \textcolor{keyword}{delete} oldValue[key];
                \}
              \}
            \}
          \}
          \textcolor{keywordflow}{return} changeDetected;
        \}

        \textcolor{keyword}{function} $watchCollectionAction() \{
          \textcolor{keywordflow}{if} (initRun) \{
            initRun = \textcolor{keyword}{false};
            listener(newValue, newValue, \textcolor{keyword}{self});
          \} \textcolor{keywordflow}{else} \{
            listener(newValue, veryOldValue, \textcolor{keyword}{self});
          \}

          \textcolor{comment}{// make a copy for the next time a collection is changed}
          \textcolor{keywordflow}{if} (trackVeryOldValue) \{
            \textcolor{keywordflow}{if} (!isObject(newValue)) \{
              \textcolor{comment}{//primitive}
              veryOldValue = newValue;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArrayLike(newValue)) \{
              veryOldValue = \textcolor{keyword}{new} Array(newValue.length);
              \textcolor{keywordflow}{for} (var i = 0; i < newValue.length; i++) \{
                veryOldValue[i] = newValue[i];
              \}
            \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// if object}
              veryOldValue = \{\};
              \textcolor{keywordflow}{for} (var key in newValue) \{
                \textcolor{keywordflow}{if} (hasOwnProperty.call(newValue, key)) \{
                  veryOldValue[key] = newValue[key];
                \}
              \}
            \}
          \}
        \}

        \textcolor{keywordflow}{return} this.$watch(changeDetector, $watchCollectionAction);
      \},

      $digest: \textcolor{keyword}{function}() \{
        var watch, value, last,
            watchers,
            length,
            dirty, ttl = TTL,
            next, current, target = \textcolor{keyword}{this},
            watchLog = [],
            logIdx, logMsg, asyncTask;

        beginPhase(\textcolor{stringliteral}{'$digest'});
        \textcolor{comment}{// Check for changes to browser url that happened in sync before the call to $digest}
        $browser.$$checkUrlChange();

        \textcolor{keywordflow}{if} (\textcolor{keyword}{this} === $rootScope && applyAsyncId !== null) \{
          \textcolor{comment}{// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then}
          \textcolor{comment}{// cancel the scheduled $apply and flush the queue of expressions to be evaluated.}
          $browser.defer.cancel(applyAsyncId);
          flushApplyAsync();
        \}

        lastDirtyWatch = null;

        \textcolor{keywordflow}{do} \{ \textcolor{comment}{// "while dirty" loop}
          dirty = \textcolor{keyword}{false};
          current = target;

          \textcolor{keywordflow}{while} (asyncQueue.length) \{
            \textcolor{keywordflow}{try} \{
              asyncTask = asyncQueue.shift();
              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
            lastDirtyWatch = null;
          \}

          traverseScopesLoop:
          \textcolor{keywordflow}{do} \{ \textcolor{comment}{// "traverse the scopes" loop}
            \textcolor{keywordflow}{if} ((watchers = current.$$watchers)) \{
              \textcolor{comment}{// process our watches}
              length = watchers.length;
              \textcolor{keywordflow}{while} (length--) \{
                \textcolor{keywordflow}{try} \{
                  watch = watchers[length];
                  \textcolor{comment}{// Most common watches are on primitives, in which case we can short}
                  \textcolor{comment}{// circuit it with === operator, only when === fails do we use .equals}
                  \textcolor{keywordflow}{if} (watch) \{
                    \textcolor{keywordflow}{if} ((value = watch.get(current)) !== (last = watch.last) &&
                        !(watch.eq
                            ? equals(value, last)
                            : (typeof value === \textcolor{stringliteral}{'number'} && typeof last === \textcolor{stringliteral}{'number'}
                               && isNaN(value) && isNaN(last)))) \{
                      dirty = \textcolor{keyword}{true};
                      lastDirtyWatch = watch;
                      watch.last = watch.eq ? copy(value, null) : value;
                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
                      \textcolor{keywordflow}{if} (ttl < 5) \{
                        logIdx = 4 - ttl;
                        \textcolor{keywordflow}{if} (!watchLog[logIdx]) watchLog[logIdx] = [];
                        watchLog[logIdx].push(\{
                          msg: isFunction(watch.exp) ? \textcolor{stringliteral}{'fn: '} + (watch.exp.name || watch.exp.toString()) : 
      watch.exp,
                          newVal: value,
                          oldVal: last
                        \});
                      \}
                    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (watch === lastDirtyWatch) \{
                      \textcolor{comment}{// If the most recently dirty watcher is now clean, short circuit since the remaining
       watchers}
                      \textcolor{comment}{// have already been tested.}
                      dirty = \textcolor{keyword}{false};
                      \textcolor{keywordflow}{break} traverseScopesLoop;
                    \}
                  \}
                \} \textcolor{keywordflow}{catch} (e) \{
                  $exceptionHandler(e);
                \}
              \}
            \}

            \textcolor{comment}{// Insanity Warning: scope depth-first traversal}
            \textcolor{comment}{// yes, this code is a bit crazy, but it works and we have tests to prove it!}
            \textcolor{comment}{// this piece should be kept in sync with the traversal in $broadcast}
            \textcolor{keywordflow}{if} (!(next = ((current.$$watchersCount && current.$$childHead) ||
                (current !== target && current.$$nextSibling)))) \{
              \textcolor{keywordflow}{while} (current !== target && !(next = current.$$nextSibling)) \{
                current = current.$parent;
              \}
            \}
          \} \textcolor{keywordflow}{while} ((current = next));

          \textcolor{comment}{// `break traverseScopesLoop;` takes us to here}

          \textcolor{keywordflow}{if} ((dirty || asyncQueue.length) && !(ttl--)) \{
            clearPhase();
            \textcolor{keywordflow}{throw} $rootScopeMinErr(\textcolor{stringliteral}{'infdig'},
                \textcolor{stringliteral}{'\{0\} $digest() iterations reached. Aborting!\(\backslash\)n'} +
                \textcolor{stringliteral}{'Watchers fired in the last 5 iterations: \{1\}'},
                TTL, watchLog);
          \}

        \} \textcolor{keywordflow}{while} (dirty || asyncQueue.length);

        clearPhase();

        \textcolor{keywordflow}{while} (postDigestQueue.length) \{
          \textcolor{keywordflow}{try} \{
            postDigestQueue.shift()();
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
          \}
        \}
      \},


      $destroy: \textcolor{keyword}{function}() \{
        \textcolor{comment}{// We can't destroy a scope that has been already destroyed.}
        \textcolor{keywordflow}{if} (this.$$destroyed) \textcolor{keywordflow}{return};
        var parent = this.$parent;

        this.$broadcast(\textcolor{stringliteral}{'$destroy'});
        this.$$destroyed = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (\textcolor{keyword}{this} === $rootScope) \{
          \textcolor{comment}{//Remove handlers attached to window when $rootScope is removed}
          $browser.$$applicationDestroyed();
        \}

        incrementWatchersCount(\textcolor{keyword}{this}, -this.$$watchersCount);
        \textcolor{keywordflow}{for} (var eventName in this.$$listenerCount) \{
          decrementListenerCount(\textcolor{keyword}{this}, this.$$listenerCount[eventName], eventName);
        \}

        \textcolor{comment}{// sever all the references to parent scopes (after this cleanup, the current scope should}
        \textcolor{comment}{// not be retained by any of our references and should be eligible for garbage collection)}
        \textcolor{keywordflow}{if} (parent && parent.$$childHead == \textcolor{keyword}{this}) parent.$$childHead = this.$$nextSibling;
        \textcolor{keywordflow}{if} (parent && parent.$$childTail == \textcolor{keyword}{this}) parent.$$childTail = this.$$prevSibling;
        \textcolor{keywordflow}{if} (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        \textcolor{keywordflow}{if} (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        \textcolor{comment}{// Disable listeners, watchers and apply/digest methods}
        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
        this.$on = this.$watch = this.$watchGroup = \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} noop; \};
        this.$$listeners = \{\};

        \textcolor{comment}{// All of the code below is bogus code that works around V8's memory leak via optimized code}
        \textcolor{comment}{// and inline caches.}
        \textcolor{comment}{//}
        \textcolor{comment}{// see:}
        \textcolor{comment}{// - https://code.google.com/p/v8/issues/detail?id=2073#c26}
        \textcolor{comment}{// - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909}
        \textcolor{comment}{// - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451}

        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = this.$root = this.$$watchers = null;
      \},

      $eval: \textcolor{keyword}{function}(expr, locals) \{
        \textcolor{keywordflow}{return} $parse(expr)(\textcolor{keyword}{this}, locals);
      \},

      $evalAsync: \textcolor{keyword}{function}(expr, locals) \{
        \textcolor{comment}{// if we are outside of an $digest loop and this is the first time we are scheduling async}
        \textcolor{comment}{// task also schedule async auto-flush}
        \textcolor{keywordflow}{if} (!$rootScope.$$phase && !asyncQueue.length) \{
          $browser.defer(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (asyncQueue.length) \{
              $rootScope.$digest();
            \}
          \});
        \}

        asyncQueue.push(\{scope: \textcolor{keyword}{this}, expression: expr, locals: locals\});
      \},

      $$postDigest: \textcolor{keyword}{function}(fn) \{
        postDigestQueue.push(fn);
      \},

      $apply: \textcolor{keyword}{function}(expr) \{
        \textcolor{keywordflow}{try} \{
          beginPhase(\textcolor{stringliteral}{'$apply'});
          \textcolor{keywordflow}{try} \{
            \textcolor{keywordflow}{return} this.$eval(expr);
          \} \textcolor{keywordflow}{finally} \{
            clearPhase();
          \}
        \} \textcolor{keywordflow}{catch} (e) \{
          $exceptionHandler(e);
        \} \textcolor{keywordflow}{finally} \{
          \textcolor{keywordflow}{try} \{
            $rootScope.$digest();
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
            \textcolor{keywordflow}{throw} e;
          \}
        \}
      \},

      $applyAsync: \textcolor{keyword}{function}(expr) \{
        var scope = \textcolor{keyword}{this};
        expr && applyAsyncQueue.push($applyAsyncExpression);
        scheduleApplyAsync();

        \textcolor{keyword}{function} $applyAsyncExpression() \{
          scope.$eval(expr);
        \}
      \},

      $on: \textcolor{keyword}{function}(name, listener) \{
        var namedListeners = this.$$listeners[name];
        \textcolor{keywordflow}{if} (!namedListeners) \{
          this.$$listeners[name] = namedListeners = [];
        \}
        namedListeners.push(listener);

        var current = \textcolor{keyword}{this};
        \textcolor{keywordflow}{do} \{
          \textcolor{keywordflow}{if} (!current.$$listenerCount[name]) \{
            current.$$listenerCount[name] = 0;
          \}
          current.$$listenerCount[name]++;
        \} \textcolor{keywordflow}{while} ((current = current.$parent));

        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          var indexOfListener = namedListeners.indexOf(listener);
          \textcolor{keywordflow}{if} (indexOfListener !== -1) \{
            namedListeners[indexOfListener] = null;
            decrementListenerCount(\textcolor{keyword}{self}, 1, name);
          \}
        \};
      \},


      $emit: \textcolor{keyword}{function}(name, args) \{
        var empty = [],
            namedListeners,
            scope = \textcolor{keyword}{this},
            stopPropagation = \textcolor{keyword}{false},
            event = \{
              name: name,
              targetScope: scope,
              stopPropagation: \textcolor{keyword}{function}() \{stopPropagation = \textcolor{keyword}{true};\},
              preventDefault: \textcolor{keyword}{function}() \{
                event.defaultPrevented = \textcolor{keyword}{true};
              \},
              defaultPrevented: \textcolor{keyword}{false}
            \},
            listenerArgs = concat([event], arguments, 1),
            i, length;

        \textcolor{keywordflow}{do} \{
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          \textcolor{keywordflow}{for} (i = 0, length = namedListeners.length; i < length; i++) \{

            \textcolor{comment}{// if listeners were deregistered, defragment the array}
            \textcolor{keywordflow}{if} (!namedListeners[i]) \{
              namedListeners.splice(i, 1);
              i--;
              length--;
              \textcolor{keywordflow}{continue};
            \}
            \textcolor{keywordflow}{try} \{
              \textcolor{comment}{//allow all listeners attached to the current scope to run}
              namedListeners[i].apply(null, listenerArgs);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
          \}
          \textcolor{comment}{//if any listener on the current scope stops propagation, prevent bubbling}
          \textcolor{keywordflow}{if} (stopPropagation) \{
            event.currentScope = null;
            \textcolor{keywordflow}{return} event;
          \}
          \textcolor{comment}{//traverse upwards}
          scope = scope.$parent;
        \} \textcolor{keywordflow}{while} (scope);

        event.currentScope = null;

        \textcolor{keywordflow}{return} event;
      \},


      $broadcast: \textcolor{keyword}{function}(name, args) \{
        var target = \textcolor{keyword}{this},
            current = target,
            next = target,
            event = \{
              name: name,
              targetScope: target,
              preventDefault: \textcolor{keyword}{function}() \{
                event.defaultPrevented = \textcolor{keyword}{true};
              \},
              defaultPrevented: \textcolor{keyword}{false}
            \};

        \textcolor{keywordflow}{if} (!target.$$listenerCount[name]) \textcolor{keywordflow}{return} event;

        var listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        \textcolor{comment}{//down while you can, then up and next sibling or up and next sibling until back at root}
        \textcolor{keywordflow}{while} ((current = next)) \{
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          \textcolor{keywordflow}{for} (i = 0, length = listeners.length; i < length; i++) \{
            \textcolor{comment}{// if listeners were deregistered, defragment the array}
            \textcolor{keywordflow}{if} (!listeners[i]) \{
              listeners.splice(i, 1);
              i--;
              length--;
              \textcolor{keywordflow}{continue};
            \}

            \textcolor{keywordflow}{try} \{
              listeners[i].apply(null, listenerArgs);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
          \}

          \textcolor{comment}{// Insanity Warning: scope depth-first traversal}
          \textcolor{comment}{// yes, this code is a bit crazy, but it works and we have tests to prove it!}
          \textcolor{comment}{// this piece should be kept in sync with the traversal in $digest}
          \textcolor{comment}{// (though it differs due to having the extra check for $$listenerCount)}
          \textcolor{keywordflow}{if} (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
              (current !== target && current.$$nextSibling)))) \{
            \textcolor{keywordflow}{while} (current !== target && !(next = current.$$nextSibling)) \{
              current = current.$parent;
            \}
          \}
        \}

        event.currentScope = null;
        \textcolor{keywordflow}{return} event;
      \}
    \};

    var $rootScope = \textcolor{keyword}{new} Scope();

    \textcolor{comment}{//The internal queues. Expose them on the $rootScope for debugging/testing purposes.}
    var asyncQueue = $rootScope.$$asyncQueue = [];
    var postDigestQueue = $rootScope.$$postDigestQueue = [];
    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];

    \textcolor{keywordflow}{return} $rootScope;


    \textcolor{keyword}{function} beginPhase(phase) \{
      \textcolor{keywordflow}{if} ($rootScope.$$phase) \{
        \textcolor{keywordflow}{throw} $rootScopeMinErr(\textcolor{stringliteral}{'inprog'}, \textcolor{stringliteral}{'\{0\} already in progress'}, $rootScope.$$phase);
      \}

      $rootScope.$$phase = phase;
    \}

    \textcolor{keyword}{function} clearPhase() \{
      $rootScope.$$phase = null;
    \}

    \textcolor{keyword}{function} incrementWatchersCount(current, count) \{
      \textcolor{keywordflow}{do} \{
        current.$$watchersCount += count;
      \} \textcolor{keywordflow}{while} ((current = current.$parent));
    \}

    \textcolor{keyword}{function} decrementListenerCount(current, count, name) \{
      \textcolor{keywordflow}{do} \{
        current.$$listenerCount[name] -= count;

        \textcolor{keywordflow}{if} (current.$$listenerCount[name] === 0) \{
          \textcolor{keyword}{delete} current.$$listenerCount[name];
        \}
      \} \textcolor{keywordflow}{while} ((current = current.$parent));
    \}

    \textcolor{keyword}{function} initWatchVal() \{\}

    \textcolor{keyword}{function} flushApplyAsync() \{
      \textcolor{keywordflow}{while} (applyAsyncQueue.length) \{
        \textcolor{keywordflow}{try} \{
          applyAsyncQueue.shift()();
        \} \textcolor{keywordflow}{catch} (e) \{
          $exceptionHandler(e);
        \}
      \}
      applyAsyncId = null;
    \}

    \textcolor{keyword}{function} scheduleApplyAsync() \{
      \textcolor{keywordflow}{if} (applyAsyncId === null) \{
        applyAsyncId = $browser.defer(\textcolor{keyword}{function}() \{
          $rootScope.$apply(flushApplyAsync);
        \});
      \}
    \}
  \}];
\}

\textcolor{keyword}{function} $$SanitizeUriProvider() \{
  var aHrefSanitizationWhitelist = /^\(\backslash\)s*(https?|ftp|mailto|tel|file):/,
    imgSrcSanitizationWhitelist = /^\(\backslash\)s*((https?|ftp|file|blob):|data:image\(\backslash\)/)/;

  this.aHrefSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      aHrefSanitizationWhitelist = regexp;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} aHrefSanitizationWhitelist;
  \};


  this.imgSrcSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      imgSrcSanitizationWhitelist = regexp;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} imgSrcSanitizationWhitelist;
  \};

  this.$get = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function} sanitizeUri(uri, isImage) \{
      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
      var normalizedVal;
      normalizedVal = urlResolve(uri).href;
      \textcolor{keywordflow}{if} (normalizedVal !== \textcolor{stringliteral}{''} && !normalizedVal.match(regex)) \{
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{'unsafe:'} + normalizedVal;
      \}
      \textcolor{keywordflow}{return} uri;
    \};
  \};
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

var $sceMinErr = minErr(\textcolor{stringliteral}{'$sce'});

var SCE\_CONTEXTS = \{
  HTML: \textcolor{stringliteral}{'html'},
  CSS: \textcolor{stringliteral}{'css'},
  URL: \textcolor{stringliteral}{'url'},
  \textcolor{comment}{// RESOURCE\_URL is a subtype of URL used in contexts where a privileged resource is sourced from a}
  \textcolor{comment}{// url.  (e.g. ng-include, script src, templateUrl)}
  RESOURCE\_URL: \textcolor{stringliteral}{'resourceUrl'},
  JS: \textcolor{stringliteral}{'js'}
\};

\textcolor{comment}{// Helper functions follow.}

\textcolor{keyword}{function} adjustMatcher(matcher) \{
  \textcolor{keywordflow}{if} (matcher === \textcolor{stringliteral}{'self'}) \{
    \textcolor{keywordflow}{return} matcher;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(matcher)) \{
    \textcolor{comment}{// Strings match exactly except for 2 wildcards - '*' and '**'.}
    \textcolor{comment}{// '*' matches any character except those from the set ':/.?&'.}
    \textcolor{comment}{// '**' matches any character (like .* in a RegExp).}
    \textcolor{comment}{// More than 2 *'s raises an error as it's ill defined.}
    \textcolor{keywordflow}{if} (matcher.indexOf(\textcolor{stringliteral}{'***'}) > -1) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'iwcard'},
          \textcolor{stringliteral}{'Illegal sequence *** in string matcher.  String: \{0\}'}, matcher);
    \}
    matcher = escapeForRegexp(matcher).
                  replace(\textcolor{stringliteral}{'\(\backslash\)\(\backslash\)*\(\backslash\)\(\backslash\)*'}, \textcolor{stringliteral}{'.*'}).
                  replace(\textcolor{stringliteral}{'\(\backslash\)\(\backslash\)*'}, \textcolor{stringliteral}{'[^:/.?&;]*'});
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} RegExp(\textcolor{charliteral}{'^'} + matcher + \textcolor{charliteral}{'$'});
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(matcher)) \{
    \textcolor{comment}{// The only other type of matcher allowed is a Regexp.}
    \textcolor{comment}{// Match entire URL / disallow partial matches.}
    \textcolor{comment}{// Flags are reset (i.e. no global, ignoreCase or multiline)}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} RegExp(\textcolor{charliteral}{'^'} + matcher.source + \textcolor{charliteral}{'$'});
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'imatcher'},
        \textcolor{stringliteral}{'Matchers may only be "self", string patterns or RegExp objects'});
  \}
\}


\textcolor{keyword}{function} adjustMatchers(matchers) \{
  var adjustedMatchers = [];
  \textcolor{keywordflow}{if} (isDefined(matchers)) \{
    forEach(matchers, \textcolor{keyword}{function}(matcher) \{
      adjustedMatchers.push(adjustMatcher(matcher));
    \});
  \}
  \textcolor{keywordflow}{return} adjustedMatchers;
\}


\textcolor{keyword}{function} $SceDelegateProvider() \{
  this.SCE\_CONTEXTS = SCE\_CONTEXTS;

  \textcolor{comment}{// Resource URLs can also be trusted by policy.}
  var resourceUrlWhitelist = [\textcolor{stringliteral}{'self'}],
      resourceUrlBlacklist = [];

  this.resourceUrlWhitelist = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      resourceUrlWhitelist = adjustMatchers(value);
    \}
    \textcolor{keywordflow}{return} resourceUrlWhitelist;
  \};

  this.resourceUrlBlacklist = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      resourceUrlBlacklist = adjustMatchers(value);
    \}
    \textcolor{keywordflow}{return} resourceUrlBlacklist;
  \};

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{

    var htmlSanitizer = \textcolor{keyword}{function} htmlSanitizer(html) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'unsafe'}, \textcolor{stringliteral}{'Attempting to use an unsafe value in a safe context.'});
    \};

    \textcolor{keywordflow}{if} ($injector.has(\textcolor{stringliteral}{'$sanitize'})) \{
      htmlSanitizer = $injector.get(\textcolor{stringliteral}{'$sanitize'});
    \}


    \textcolor{keyword}{function} matchUrl(matcher, parsedUrl) \{
      \textcolor{keywordflow}{if} (matcher === \textcolor{stringliteral}{'self'}) \{
        \textcolor{keywordflow}{return} urlIsSameOrigin(parsedUrl);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// definitely a regex.  See adjustMatchers()}
        \textcolor{keywordflow}{return} !!matcher.exec(parsedUrl.href);
      \}
    \}

    \textcolor{keyword}{function} isResourceUrlAllowedByPolicy(url) \{
      var parsedUrl = urlResolve(url.toString());
      var i, n, allowed = \textcolor{keyword}{false};
      \textcolor{comment}{// Ensure that at least one item from the whitelist allows this url.}
      \textcolor{keywordflow}{for} (i = 0, n = resourceUrlWhitelist.length; i < n; i++) \{
        \textcolor{keywordflow}{if} (matchUrl(resourceUrlWhitelist[i], parsedUrl)) \{
          allowed = \textcolor{keyword}{true};
          \textcolor{keywordflow}{break};
        \}
      \}
      \textcolor{keywordflow}{if} (allowed) \{
        \textcolor{comment}{// Ensure that no item from the blacklist blocked this url.}
        \textcolor{keywordflow}{for} (i = 0, n = resourceUrlBlacklist.length; i < n; i++) \{
          \textcolor{keywordflow}{if} (matchUrl(resourceUrlBlacklist[i], parsedUrl)) \{
            allowed = \textcolor{keyword}{false};
            \textcolor{keywordflow}{break};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} allowed;
    \}

    \textcolor{keyword}{function} generateHolderType(Base) \{
      var holderType = \textcolor{keyword}{function} TrustedValueHolderType(trustedValue) \{
        this.$$unwrapTrustedValue = \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} trustedValue;
        \};
      \};
      \textcolor{keywordflow}{if} (Base) \{
        holderType.prototype = \textcolor{keyword}{new} Base();
      \}
      holderType.prototype.valueOf = \textcolor{keyword}{function} sceValueOf() \{
        \textcolor{keywordflow}{return} this.$$unwrapTrustedValue();
      \};
      holderType.prototype.toString = \textcolor{keyword}{function} sceToString() \{
        \textcolor{keywordflow}{return} this.$$unwrapTrustedValue().toString();
      \};
      \textcolor{keywordflow}{return} holderType;
    \}

    var trustedValueHolderBase = generateHolderType(),
        byType = \{\};

    byType[SCE\_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.RESOURCE\_URL] = generateHolderType(byType[SCE\_CONTEXTS.URL]);

    \textcolor{keyword}{function} trustAs(type, trustedValue) \{
      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      \textcolor{keywordflow}{if} (!Constructor) \{
        \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'icontext'},
            \textcolor{stringliteral}{'Attempted to trust a value in invalid context. Context: \{0\}; Value: \{1\}'},
            type, trustedValue);
      \}
      \textcolor{keywordflow}{if} (trustedValue === null || trustedValue === undefined || trustedValue === \textcolor{stringliteral}{''}) \{
        \textcolor{keywordflow}{return} trustedValue;
      \}
      \textcolor{comment}{// All the current contexts in SCE\_CONTEXTS happen to be strings.  In order to avoid trusting}
      \textcolor{comment}{// mutable objects, we ensure here that the value passed in is actually a string.}
      \textcolor{keywordflow}{if} (typeof trustedValue !== \textcolor{stringliteral}{'string'}) \{
        \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'itype'},
            \textcolor{stringliteral}{'Attempted to trust a non-string value in a content requiring a string: Context: \{0\}'},
            type);
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Constructor(trustedValue);
    \}

    \textcolor{keyword}{function} valueOf(maybeTrusted) \{
      \textcolor{keywordflow}{if} (maybeTrusted instanceof trustedValueHolderBase) \{
        \textcolor{keywordflow}{return} maybeTrusted.$$unwrapTrustedValue();
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} maybeTrusted;
      \}
    \}

    \textcolor{keyword}{function} getTrusted(type, maybeTrusted) \{
      \textcolor{keywordflow}{if} (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === \textcolor{stringliteral}{''}) \{
        \textcolor{keywordflow}{return} maybeTrusted;
      \}
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      \textcolor{keywordflow}{if} (constructor && maybeTrusted instanceof constructor) \{
        \textcolor{keywordflow}{return} maybeTrusted.$$unwrapTrustedValue();
      \}
      \textcolor{comment}{// If we get here, then we may only take one of two actions.}
      \textcolor{comment}{// 1. sanitize the value for the requested type, or}
      \textcolor{comment}{// 2. throw an exception.}
      \textcolor{keywordflow}{if} (type === SCE\_CONTEXTS.RESOURCE\_URL) \{
        \textcolor{keywordflow}{if} (isResourceUrlAllowedByPolicy(maybeTrusted)) \{
          \textcolor{keywordflow}{return} maybeTrusted;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'insecurl'},
              \textcolor{stringliteral}{'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: \{0\}'},
              maybeTrusted.toString());
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === SCE\_CONTEXTS.HTML) \{
        \textcolor{keywordflow}{return} htmlSanitizer(maybeTrusted);
      \}
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'unsafe'}, \textcolor{stringliteral}{'Attempting to use an unsafe value in a safe context.'});
    \}

    \textcolor{keywordflow}{return} \{ trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf \};
  \}];
\}


\textcolor{comment}{/* jshint maxlen: false*/}

\textcolor{comment}{/* jshint maxlen: 100 */}

\textcolor{keyword}{function} $SceProvider() \{
  var enabled = \textcolor{keyword}{true};

  this.enabled = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      enabled = !!value;
    \}
    \textcolor{keywordflow}{return} enabled;
  \};


  \textcolor{comment}{/* Design notes on the default implementation for SCE.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The API contract for the SCE delegate}
\textcolor{comment}{   * -------------------------------------}
\textcolor{comment}{   * The SCE delegate object must provide the following 3 methods:}
\textcolor{comment}{   *}
\textcolor{comment}{   * - trustAs(contextEnum, value)}
\textcolor{comment}{   *     This method is used to tell the SCE service that the provided value is OK to use in the}
\textcolor{comment}{   *     contexts specified by contextEnum.  It must return an object that will be accepted by}
\textcolor{comment}{   *     getTrusted() for a compatible contextEnum and return this value.}
\textcolor{comment}{   *}
\textcolor{comment}{   * - valueOf(value)}
\textcolor{comment}{   *     For values that were not produced by trustAs(), return them as is.  For values that were}
\textcolor{comment}{   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if}
\textcolor{comment}{   *     trustAs is wrapping the given values into some type, this operation unwraps it when given}
\textcolor{comment}{   *     such a value.}
\textcolor{comment}{   *}
\textcolor{comment}{   * - getTrusted(contextEnum, value)}
\textcolor{comment}{   *     This function should return the a value that is safe to use in the context specified by}
\textcolor{comment}{   *     contextEnum or throw and exception otherwise.}
\textcolor{comment}{   *}
\textcolor{comment}{   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be}
\textcolor{comment}{   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For}
\textcolor{comment}{   * instance, an implementation could maintain a registry of all trusted objects by context.  In}
\textcolor{comment}{   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would}
\textcolor{comment}{   * return the same object passed in if it was found in the registry under a compatible context or}
\textcolor{comment}{   * throw an exception otherwise.  An implementation might only wrap values some of the time based}
\textcolor{comment}{   * on some criteria.  getTrusted() might return a value and not throw an exception for special}
\textcolor{comment}{   * constants or objects even if not wrapped.  All such implementations fulfill this contract.}
\textcolor{comment}{   *}
\textcolor{comment}{   *}
\textcolor{comment}{   * A note on the inheritance model for SCE contexts}
\textcolor{comment}{   * ------------------------------------------------}
\textcolor{comment}{   * I've used inheritance and made RESOURCE\_URL wrapped types a subtype of URL wrapped types.  This}
\textcolor{comment}{   * is purely an implementation details.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The contract is simply this:}
\textcolor{comment}{   *}
\textcolor{comment}{   *     getTrusted($sce.RESOURCE\_URL, value) succeeding implies that getTrusted($sce.URL, value)}
\textcolor{comment}{   *     will also succeed.}
\textcolor{comment}{   *}
\textcolor{comment}{   * Inheritance happens to capture this in a natural way.  In some future, we}
\textcolor{comment}{   * may not use inheritance anymore.  That is OK because no code outside of}
\textcolor{comment}{   * sce.js and sceSpecs.js would need to be aware of this detail.}
\textcolor{comment}{   */}

  this.$get = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$sceDelegate'}, \textcolor{keyword}{function}(
                $parse,   $sceDelegate) \{
    \textcolor{comment}{// Prereq: Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow}
    \textcolor{comment}{// the "expression(javascript expression)" syntax which is insecure.}
    \textcolor{keywordflow}{if} (enabled && msie < 8) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'iequirks'},
        \textcolor{stringliteral}{'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks '} +
        \textcolor{stringliteral}{'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML '} +
        \textcolor{stringliteral}{'document.  See http://docs.angularjs.org/api/ng.$sce for more information.'});
    \}

    var sce = shallowCopy(SCE\_CONTEXTS);

    sce.isEnabled = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} enabled;
    \};
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    \textcolor{keywordflow}{if} (!enabled) \{
      sce.trustAs = sce.getTrusted = \textcolor{keyword}{function}(type, value) \{ \textcolor{keywordflow}{return} value; \};
      sce.valueOf = identity;
    \}

    sce.parseAs = \textcolor{keyword}{function} sceParseAs(type, expr) \{
      var parsed = $parse(expr);
      \textcolor{keywordflow}{if} (parsed.literal && parsed.constant) \{
        \textcolor{keywordflow}{return} parsed;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} $parse(expr, \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} sce.getTrusted(type, value);
        \});
      \}
    \};

    \textcolor{comment}{// Shorthand delegations.}
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    forEach(SCE\_CONTEXTS, \textcolor{keyword}{function}(enumValue, name) \{
      var lName = lowercase(name);
      sce[camelCase(\textcolor{stringliteral}{"parse\_as\_"} + lName)] = \textcolor{keyword}{function}(expr) \{
        \textcolor{keywordflow}{return} parse(enumValue, expr);
      \};
      sce[camelCase(\textcolor{stringliteral}{"get\_trusted\_"} + lName)] = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} getTrusted(enumValue, value);
      \};
      sce[camelCase(\textcolor{stringliteral}{"trust\_as\_"} + lName)] = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} trustAs(enumValue, value);
      \};
    \});

    \textcolor{keywordflow}{return} sce;
  \}];
\}

\textcolor{keyword}{function} $SnifferProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$document'}, \textcolor{keyword}{function}($window, $document) \{
    var eventSupport = \{\},
        android =
          toInt((/android (\(\backslash\)d+)/.exec(lowercase(($window.navigator || \{\}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || \{\}).userAgent),
        document = $document[0] || \{\},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = \textcolor{keyword}{false},
        animations = \textcolor{keyword}{false},
        match;

    \textcolor{keywordflow}{if} (bodyStyle) \{
      \textcolor{keywordflow}{for} (var prop in bodyStyle) \{
        \textcolor{keywordflow}{if} (match = vendorRegex.exec(prop)) \{
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          \textcolor{keywordflow}{break};
        \}
      \}

      \textcolor{keywordflow}{if} (!vendorPrefix) \{
        vendorPrefix = (\textcolor{stringliteral}{'WebkitOpacity'} in bodyStyle) && \textcolor{stringliteral}{'webkit'};
      \}

      transitions = !!((\textcolor{stringliteral}{'transition'} in bodyStyle) || (vendorPrefix + \textcolor{stringliteral}{'Transition'} in bodyStyle));
      animations  = !!((\textcolor{stringliteral}{'animation'} in bodyStyle) || (vendorPrefix + \textcolor{stringliteral}{'Animation'} in bodyStyle));

      \textcolor{keywordflow}{if} (android && (!transitions ||  !animations)) \{
        transitions = isString(bodyStyle.webkitTransition);
        animations = isString(bodyStyle.webkitAnimation);
      \}
    \}


    \textcolor{keywordflow}{return} \{
      \textcolor{comment}{// Android has history.pushState, but it does not update location correctly}
      \textcolor{comment}{// so let's not use the history API at all.}
      \textcolor{comment}{// http://code.google.com/p/android/issues/detail?id=17471}
      \textcolor{comment}{// https://github.com/angular/angular.js/issues/904}

      \textcolor{comment}{// older webkit browser (533.9) on Boxee box has exactly the same problem as Android has}
      \textcolor{comment}{// so let's not use the history API also}
      \textcolor{comment}{// We are purposefully using `!(android < 4)` to cover the case when `android` is undefined}
      \textcolor{comment}{// jshint -W018}
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      \textcolor{comment}{// jshint +W018}
      hasEvent: \textcolor{keyword}{function}(event) \{
        \textcolor{comment}{// IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have}
        \textcolor{comment}{// it. In particular the event is not fired when backspace or delete key are pressed or}
        \textcolor{comment}{// when cut operation is performed.}
        \textcolor{comment}{// IE10+ implements 'input' event but it erroneously fires under various situations,}
        \textcolor{comment}{// e.g. when placeholder changes, or a form is focused.}
        \textcolor{keywordflow}{if} (event === \textcolor{stringliteral}{'input'} && msie <= 11) \textcolor{keywordflow}{return} \textcolor{keyword}{false};

        \textcolor{keywordflow}{if} (isUndefined(eventSupport[event])) \{
          var divElm = document.createElement(\textcolor{stringliteral}{'div'});
          eventSupport[event] = \textcolor{stringliteral}{'on'} + event in divElm;
        \}

        \textcolor{keywordflow}{return} eventSupport[event];
      \},
      csp: csp(),
      vendorPrefix: vendorPrefix,
      transitions: transitions,
      animations: animations,
      android: android
    \};
  \}];
\}

var $compileMinErr = minErr(\textcolor{stringliteral}{'$compile'});

\textcolor{keyword}{function} $TemplateRequestProvider() \{
  this.$get = [\textcolor{stringliteral}{'$templateCache'}, \textcolor{stringliteral}{'$http'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$sce'}, \textcolor{keyword}{function}($templateCache, $http, $q, $sce) \{
    \textcolor{keyword}{function} handleRequestFn(tpl, ignoreRequestError) \{
      handleRequestFn.totalPendingRequests++;

      \textcolor{comment}{// We consider the template cache holds only trusted templates, so}
      \textcolor{comment}{// there's no need to go through whitelisting again for keys that already}
      \textcolor{comment}{// are included in there. This also makes Angular accept any script}
      \textcolor{comment}{// directive, no matter its name. However, we still need to unwrap trusted}
      \textcolor{comment}{// types.}
      \textcolor{keywordflow}{if} (!isString(tpl) || !$templateCache.get(tpl)) \{
        tpl = $sce.getTrustedResourceUrl(tpl);
      \}

      var transformResponse = $http.defaults && $http.defaults.transformResponse;

      \textcolor{keywordflow}{if} (isArray(transformResponse)) \{
        transformResponse = transformResponse.filter(\textcolor{keyword}{function}(transformer) \{
          \textcolor{keywordflow}{return} transformer !== defaultHttpResponseTransform;
        \});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (transformResponse === defaultHttpResponseTransform) \{
        transformResponse = null;
      \}

      var httpOptions = \{
        cache: $templateCache,
        transformResponse: transformResponse
      \};

      \textcolor{keywordflow}{return} $http.get(tpl, httpOptions)
        [\textcolor{stringliteral}{'finally'}](\textcolor{keyword}{function}() \{
          handleRequestFn.totalPendingRequests--;
        \})
        .then(\textcolor{keyword}{function}(response) \{
          $templateCache.put(tpl, response.data);
          \textcolor{keywordflow}{return} response.data;
        \}, handleError);

      \textcolor{keyword}{function} handleError(resp) \{
        \textcolor{keywordflow}{if} (!ignoreRequestError) \{
          \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tpload'}, \textcolor{stringliteral}{'Failed to load template: \{0\} (HTTP status: \{1\} \{2\})'},
            tpl, resp.status, resp.statusText);
        \}
        \textcolor{keywordflow}{return} $q.reject(resp);
      \}
    \}

    handleRequestFn.totalPendingRequests = 0;

    \textcolor{keywordflow}{return} handleRequestFn;
  \}];
\}

\textcolor{keyword}{function} $$TestabilityProvider() \{
  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$location'},
       \textcolor{keyword}{function}($rootScope,   $browser,   $location) \{

    var testability = \{\};

    testability.findBindings = \textcolor{keyword}{function}(element, expression, opt\_exactMatch) \{
      var bindings = element.getElementsByClassName(\textcolor{stringliteral}{'ng-binding'});
      var matches = [];
      forEach(bindings, \textcolor{keyword}{function}(binding) \{
        var dataBinding = angular.element(binding).data(\textcolor{stringliteral}{'$binding'});
        \textcolor{keywordflow}{if} (dataBinding) \{
          forEach(dataBinding, \textcolor{keyword}{function}(bindingName) \{
            \textcolor{keywordflow}{if} (opt\_exactMatch) \{
              var matcher = \textcolor{keyword}{new} RegExp(\textcolor{stringliteral}{'(^|\(\backslash\)\(\backslash\)s)'} + escapeForRegexp(expression) + \textcolor{stringliteral}{'(\(\backslash\)\(\backslash\)s|\(\backslash\)\(\backslash\)||$)'});
              \textcolor{keywordflow}{if} (matcher.test(bindingName)) \{
                matches.push(binding);
              \}
            \} \textcolor{keywordflow}{else} \{
              \textcolor{keywordflow}{if} (bindingName.indexOf(expression) != -1) \{
                matches.push(binding);
              \}
            \}
          \});
        \}
      \});
      \textcolor{keywordflow}{return} matches;
    \};

    testability.findModels = \textcolor{keyword}{function}(element, expression, opt\_exactMatch) \{
      var prefixes = [\textcolor{stringliteral}{'ng-'}, \textcolor{stringliteral}{'data-ng-'}, \textcolor{stringliteral}{'ng\(\backslash\)\(\backslash\):'}];
      \textcolor{keywordflow}{for} (var p = 0; p < prefixes.length; ++p) \{
        var attributeEquals = opt\_exactMatch ? \textcolor{charliteral}{'='} : \textcolor{stringliteral}{'*='};
        var selector = \textcolor{charliteral}{'['} + prefixes[p] + \textcolor{stringliteral}{'model'} + attributeEquals + \textcolor{charliteral}{'"'} + expression + \textcolor{stringliteral}{'"]'};
        var elements = element.querySelectorAll(selector);
        \textcolor{keywordflow}{if} (elements.length) \{
          \textcolor{keywordflow}{return} elements;
        \}
      \}
    \};

    testability.getLocation = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} $location.url();
    \};

    testability.setLocation = \textcolor{keyword}{function}(url) \{
      \textcolor{keywordflow}{if} (url !== $location.url()) \{
        $location.url(url);
        $rootScope.$digest();
      \}
    \};

    testability.whenStable = \textcolor{keyword}{function}(callback) \{
      $browser.notifyWhenNoOutstandingRequests(callback);
    \};

    \textcolor{keywordflow}{return} testability;
  \}];
\}

\textcolor{keyword}{function} $TimeoutProvider() \{
  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$$q'}, \textcolor{stringliteral}{'$exceptionHandler'},
       \textcolor{keyword}{function}($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) \{

    var deferreds = \{\};


    \textcolor{keyword}{function} timeout(fn, delay, invokeApply) \{
      \textcolor{keywordflow}{if} (!isFunction(fn)) \{
        invokeApply = delay;
        delay = fn;
        fn = noop;
      \}

      var args = sliceArgs(arguments, 3),
          skipApply = (isDefined(invokeApply) && !invokeApply),
          deferred = (skipApply ? $$q : $q).defer(),
          promise = deferred.promise,
          timeoutId;

      timeoutId = $browser.defer(\textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{try} \{
          deferred.resolve(fn.apply(null, args));
        \} \textcolor{keywordflow}{catch} (e) \{
          deferred.reject(e);
          $exceptionHandler(e);
        \}
        \textcolor{keywordflow}{finally} \{
          \textcolor{keyword}{delete} deferreds[promise.$$timeoutId];
        \}

        \textcolor{keywordflow}{if} (!skipApply) $rootScope.$apply();
      \}, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      \textcolor{keywordflow}{return} promise;
    \}


    timeout.cancel = \textcolor{keyword}{function}(promise) \{
      \textcolor{keywordflow}{if} (promise && promise.$$timeoutId in deferreds) \{
        deferreds[promise.$$timeoutId].reject(\textcolor{stringliteral}{'canceled'});
        \textcolor{keyword}{delete} deferreds[promise.$$timeoutId];
        \textcolor{keywordflow}{return} $browser.defer.cancel(promise.$$timeoutId);
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \};

    \textcolor{keywordflow}{return} timeout;
  \}];
\}

\textcolor{comment}{// NOTE:  The usage of window and document instead of $window and $document here is}
\textcolor{comment}{// deliberate.  This service depends on the specific behavior of anchor nodes created by the}
\textcolor{comment}{// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and}
\textcolor{comment}{// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it}
\textcolor{comment}{// doesn't know about mocked locations and resolves URLs to the real document - which is}
\textcolor{comment}{// exactly the behavior needed here.  There is little value is mocking these out for this}
\textcolor{comment}{// service.}
var urlParsingNode = document.createElement(\textcolor{stringliteral}{"a"});
var originUrl = urlResolve(window.location.href);


\textcolor{keyword}{function} urlResolve(url) \{
  var href = url;

  \textcolor{keywordflow}{if} (msie) \{
    \textcolor{comment}{// Normalize before parse.  Refer Implementation Notes on why this is}
    \textcolor{comment}{// done in two steps on IE.}
    urlParsingNode.setAttribute(\textcolor{stringliteral}{"href"}, href);
    href = urlParsingNode.href;
  \}

  urlParsingNode.setAttribute(\textcolor{stringliteral}{'href'}, href);

  \textcolor{comment}{// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils}
  \textcolor{keywordflow}{return} \{
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\(\backslash\)?/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: (urlParsingNode.pathname.charAt(0) === \textcolor{charliteral}{'/'})
      ? urlParsingNode.pathname
      : \textcolor{charliteral}{'/'} + urlParsingNode.pathname
  \};
\}

\textcolor{keyword}{function} urlIsSameOrigin(requestUrl) \{
  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
  \textcolor{keywordflow}{return} (parsed.protocol === originUrl.protocol &&
          parsed.host === originUrl.host);
\}

\textcolor{keyword}{function} $WindowProvider() \{
  this.$get = valueFn(window);
\}

\textcolor{keyword}{function} $$CookieReader($document) \{
  var rawDocument = $document[0] || \{\};
  var lastCookies = \{\};
  var lastCookieString = \textcolor{stringliteral}{''};

  \textcolor{keyword}{function} safeDecodeURIComponent(str) \{
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{return} decodeURIComponent(str);
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} str;
    \}
  \}

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    var cookieArray, cookie, i, index, name;
    var currentCookieString = rawDocument.cookie || \textcolor{stringliteral}{''};

    \textcolor{keywordflow}{if} (currentCookieString !== lastCookieString) \{
      lastCookieString = currentCookieString;
      cookieArray = lastCookieString.split(\textcolor{stringliteral}{'; '});
      lastCookies = \{\};

      \textcolor{keywordflow}{for} (i = 0; i < cookieArray.length; i++) \{
        cookie = cookieArray[i];
        index = cookie.indexOf(\textcolor{charliteral}{'='});
        \textcolor{keywordflow}{if} (index > 0) \{ \textcolor{comment}{//ignore nameless cookies}
          name = safeDecodeURIComponent(cookie.substring(0, index));
          \textcolor{comment}{// the first value that is seen for a cookie is the most}
          \textcolor{comment}{// specific one.  values for the same cookie name that}
          \textcolor{comment}{// follow are for less specific paths.}
          \textcolor{keywordflow}{if} (lastCookies[name] === undefined) \{
            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
          \}
        \}
      \}
    \}
    \textcolor{keywordflow}{return} lastCookies;
  \};
\}

$$CookieReader.$inject = [\textcolor{stringliteral}{'$document'}];

\textcolor{keyword}{function} $$CookieReaderProvider() \{
  this.$get = $$CookieReader;
\}

\textcolor{comment}{/* global currencyFilter: true,}
\textcolor{comment}{ dateFilter: true,}
\textcolor{comment}{ filterFilter: true,}
\textcolor{comment}{ jsonFilter: true,}
\textcolor{comment}{ limitToFilter: true,}
\textcolor{comment}{ lowercaseFilter: true,}
\textcolor{comment}{ numberFilter: true,}
\textcolor{comment}{ orderByFilter: true,}
\textcolor{comment}{ uppercaseFilter: true,}
\textcolor{comment}{ */}

$FilterProvider.$inject = [\textcolor{stringliteral}{'$provide'}];
\textcolor{keyword}{function} $FilterProvider($provide) \{
  var suffix = \textcolor{stringliteral}{'Filter'};

  \textcolor{keyword}{function} \textcolor{keyword}{register}(name, factory) \{
    \textcolor{keywordflow}{if} (isObject(name)) \{
      var filters = \{\};
      forEach(name, \textcolor{keyword}{function}(filter, key) \{
        filters[key] = \textcolor{keyword}{register}(key, filter);
      \});
      \textcolor{keywordflow}{return} filters;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $provide.factory(name + suffix, factory);
    \}
  \}
  this.\textcolor{keyword}{register} = \textcolor{keyword}{register};

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(name) \{
      \textcolor{keywordflow}{return} $injector.get(name + suffix);
    \};
  \}];


  \textcolor{comment}{/* global}
\textcolor{comment}{    currencyFilter: false,}
\textcolor{comment}{    dateFilter: false,}
\textcolor{comment}{    filterFilter: false,}
\textcolor{comment}{    jsonFilter: false,}
\textcolor{comment}{    limitToFilter: false,}
\textcolor{comment}{    lowercaseFilter: false,}
\textcolor{comment}{    numberFilter: false,}
\textcolor{comment}{    orderByFilter: false,}
\textcolor{comment}{    uppercaseFilter: false,}
\textcolor{comment}{  */}

  \textcolor{keyword}{register}(\textcolor{stringliteral}{'currency'}, currencyFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'date'}, dateFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'filter'}, filterFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'json'}, jsonFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'limitTo'}, limitToFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'lowercase'}, lowercaseFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'number'}, numberFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'orderBy'}, orderByFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'uppercase'}, uppercaseFilter);
\}

\textcolor{keyword}{function} filterFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(array, expression, comparator) \{
    \textcolor{keywordflow}{if} (!isArrayLike(array)) \{
      \textcolor{keywordflow}{if} (array == null) \{
        \textcolor{keywordflow}{return} array;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'filter'})(\textcolor{stringliteral}{'notarray'}, \textcolor{stringliteral}{'Expected array but received: \{0\}'}, array);
      \}
    \}

    var expressionType = getTypeForFilter(expression);
    var predicateFn;
    var matchAgainstAnyProp;

    \textcolor{keywordflow}{switch} (expressionType) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
        predicateFn = expression;
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'boolean'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'null'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'number'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
        matchAgainstAnyProp = \textcolor{keyword}{true};
        \textcolor{comment}{//jshint -W086}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'object'}:
        \textcolor{comment}{//jshint +W086}
        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} array;
    \}

    \textcolor{keywordflow}{return} Array.prototype.filter.call(array, predicateFn);
  \};
\}

\textcolor{comment}{// Helper functions for `filterFilter`}
\textcolor{keyword}{function} createPredicateFn(expression, comparator, matchAgainstAnyProp) \{
  var shouldMatchPrimitives = isObject(expression) && (\textcolor{charliteral}{'$'} in expression);
  var predicateFn;

  \textcolor{keywordflow}{if} (comparator === \textcolor{keyword}{true}) \{
    comparator = equals;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isFunction(comparator)) \{
    comparator = \textcolor{keyword}{function}(actual, expected) \{
      \textcolor{keywordflow}{if} (isUndefined(actual)) \{
        \textcolor{comment}{// No substring matching against `undefined`}
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
      \textcolor{keywordflow}{if} ((actual === null) || (expected === null)) \{
        \textcolor{comment}{// No substring matching against `null`; only match against `null`}
        \textcolor{keywordflow}{return} actual === expected;
      \}
      \textcolor{keywordflow}{if} (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) \{
        \textcolor{comment}{// Should not compare primitives against objects, unless they have custom `toString` method}
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}

      actual = lowercase(\textcolor{stringliteral}{''} + actual);
      expected = lowercase(\textcolor{stringliteral}{''} + expected);
      \textcolor{keywordflow}{return} actual.indexOf(expected) !== -1;
    \};
  \}

  predicateFn = \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{if} (shouldMatchPrimitives && !isObject(item)) \{
      \textcolor{keywordflow}{return} deepCompare(item, expression.$, comparator, \textcolor{keyword}{false});
    \}
    \textcolor{keywordflow}{return} deepCompare(item, expression, comparator, matchAgainstAnyProp);
  \};

  \textcolor{keywordflow}{return} predicateFn;
\}

\textcolor{keyword}{function} deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) \{
  var actualType = getTypeForFilter(actual);
  var expectedType = getTypeForFilter(expected);

  \textcolor{keywordflow}{if} ((expectedType === \textcolor{stringliteral}{'string'}) && (expected.charAt(0) === \textcolor{charliteral}{'!'})) \{
    \textcolor{keywordflow}{return} !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(actual)) \{
    \textcolor{comment}{// In case `actual` is an array, consider it a match}
    \textcolor{comment}{// if ANY of it's items matches `expected`}
    \textcolor{keywordflow}{return} actual.some(\textcolor{keyword}{function}(item) \{
      \textcolor{keywordflow}{return} deepCompare(item, expected, comparator, matchAgainstAnyProp);
    \});
  \}

  \textcolor{keywordflow}{switch} (actualType) \{
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'object'}:
      var key;
      \textcolor{keywordflow}{if} (matchAgainstAnyProp) \{
        \textcolor{keywordflow}{for} (key in actual) \{
          \textcolor{keywordflow}{if} ((key.charAt(0) !== \textcolor{charliteral}{'$'}) && deepCompare(actual[key], expected, comparator, \textcolor{keyword}{true})) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
          \}
        \}
        \textcolor{keywordflow}{return} dontMatchWholeObject ? \textcolor{keyword}{false} : deepCompare(actual, expected, comparator, \textcolor{keyword}{false});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (expectedType === \textcolor{stringliteral}{'object'}) \{
        \textcolor{keywordflow}{for} (key in expected) \{
          var expectedVal = expected[key];
          \textcolor{keywordflow}{if} (isFunction(expectedVal) || isUndefined(expectedVal)) \{
            \textcolor{keywordflow}{continue};
          \}

          var matchAnyProperty = key === \textcolor{charliteral}{'$'};
          var actualVal = matchAnyProperty ? actual : actual[key];
          \textcolor{keywordflow}{if} (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          \}
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} comparator(actual, expected);
      \}
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \textcolor{keywordflow}{default}:
      \textcolor{keywordflow}{return} comparator(actual, expected);
  \}
\}

\textcolor{comment}{// Used for easily differentiating between `null` and actual `object`}
\textcolor{keyword}{function} getTypeForFilter(val) \{
  \textcolor{keywordflow}{return} (val === null) ? \textcolor{stringliteral}{'null'} : typeof val;
\}

currencyFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} currencyFilter($locale) \{
  var formats = $locale.NUMBER\_FORMATS;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(amount, currencySymbol, fractionSize) \{
    \textcolor{keywordflow}{if} (isUndefined(currencySymbol)) \{
      currencySymbol = formats.CURRENCY\_SYM;
    \}

    \textcolor{keywordflow}{if} (isUndefined(fractionSize)) \{
      fractionSize = formats.PATTERNS[1].maxFrac;
    \}

    \textcolor{comment}{// if null or undefined pass it through}
    \textcolor{keywordflow}{return} (amount == null)
        ? amount
        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP\_SEP, formats.DECIMAL\_SEP, fractionSize).
            replace(/\(\backslash\)u00A4/g, currencySymbol);
  \};
\}

numberFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} numberFilter($locale) \{
  var formats = $locale.NUMBER\_FORMATS;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(number, fractionSize) \{

    \textcolor{comment}{// if null or undefined pass it through}
    \textcolor{keywordflow}{return} (number == null)
        ? number
        : formatNumber(number, formats.PATTERNS[0], formats.GROUP\_SEP, formats.DECIMAL\_SEP,
                       fractionSize);
  \};
\}

var DECIMAL\_SEP = \textcolor{charliteral}{'.'};
\textcolor{keyword}{function} formatNumber(number, pattern, groupSep, decimalSep, fractionSize) \{
  \textcolor{keywordflow}{if} (isObject(number)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};

  var isNegative = number < 0;
  number = Math.abs(number);

  var isInfinity = number === Infinity;
  \textcolor{keywordflow}{if} (!isInfinity && !isFinite(number)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};

  var numStr = number + \textcolor{stringliteral}{''},
      formatedText = \textcolor{stringliteral}{''},
      hasExponent = \textcolor{keyword}{false},
      parts = [];

  \textcolor{keywordflow}{if} (isInfinity) formatedText = \textcolor{stringliteral}{'\(\backslash\)u221e'};

  \textcolor{keywordflow}{if} (!isInfinity && numStr.indexOf(\textcolor{charliteral}{'e'}) !== -1) \{
    var match = numStr.match(/([\(\backslash\)d\(\backslash\).]+)e(-?)(\(\backslash\)d+)/);
    \textcolor{keywordflow}{if} (match && match[2] == \textcolor{charliteral}{'-'} && match[3] > fractionSize + 1) \{
      number = 0;
    \} \textcolor{keywordflow}{else} \{
      formatedText = numStr;
      hasExponent = \textcolor{keyword}{true};
    \}
  \}

  \textcolor{keywordflow}{if} (!isInfinity && !hasExponent) \{
    var fractionLen = (numStr.split(DECIMAL\_SEP)[1] || \textcolor{stringliteral}{''}).length;

    \textcolor{comment}{// determine fractionSize if it is not specified}
    \textcolor{keywordflow}{if} (isUndefined(fractionSize)) \{
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    \}

    \textcolor{comment}{// safely round numbers in JS without hitting imprecisions of floating-point arithmetics}
    \textcolor{comment}{// inspired by:}
    \textcolor{comment}{// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Math/round}
    number = +(Math.round(+(number.toString() + \textcolor{charliteral}{'e'} + fractionSize)).toString() + \textcolor{charliteral}{'e'} + -fractionSize);

    var fraction = (\textcolor{stringliteral}{''} + number).split(DECIMAL\_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || \textcolor{stringliteral}{''};

    var i, pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    \textcolor{keywordflow}{if} (whole.length >= (lgroup + group)) \{
      pos = whole.length - lgroup;
      \textcolor{keywordflow}{for} (i = 0; i < pos; i++) \{
        \textcolor{keywordflow}{if} ((pos - i) % group === 0 && i !== 0) \{
          formatedText += groupSep;
        \}
        formatedText += whole.charAt(i);
      \}
    \}

    \textcolor{keywordflow}{for} (i = pos; i < whole.length; i++) \{
      \textcolor{keywordflow}{if} ((whole.length - i) % lgroup === 0 && i !== 0) \{
        formatedText += groupSep;
      \}
      formatedText += whole.charAt(i);
    \}

    \textcolor{comment}{// format fraction part.}
    \textcolor{keywordflow}{while} (fraction.length < fractionSize) \{
      fraction += \textcolor{charliteral}{'0'};
    \}

    \textcolor{keywordflow}{if} (fractionSize && fractionSize !== \textcolor{stringliteral}{"0"}) formatedText += decimalSep + fraction.substr(0, fractionSize)
      ;
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{if} (fractionSize > 0 && number < 1) \{
      formatedText = number.toFixed(fractionSize);
      number = parseFloat(formatedText);
    \}
  \}

  \textcolor{keywordflow}{if} (number === 0) \{
    isNegative = \textcolor{keyword}{false};
  \}

  parts.push(isNegative ? pattern.negPre : pattern.posPre,
             formatedText,
             isNegative ? pattern.negSuf : pattern.posSuf);
  \textcolor{keywordflow}{return} parts.join(\textcolor{stringliteral}{''});
\}

\textcolor{keyword}{function} padNumber(num, digits, trim) \{
  var neg = \textcolor{stringliteral}{''};
  \textcolor{keywordflow}{if} (num < 0) \{
    neg =  \textcolor{charliteral}{'-'};
    num = -num;
  \}
  num = \textcolor{stringliteral}{''} + num;
  \textcolor{keywordflow}{while} (num.length < digits) num = \textcolor{charliteral}{'0'} + num;
  \textcolor{keywordflow}{if} (trim) \{
    num = num.substr(num.length - digits);
  \}
  \textcolor{keywordflow}{return} neg + num;
\}


\textcolor{keyword}{function} dateGetter(name, size, offset, trim) \{
  offset = offset || 0;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date) \{
    var value = date[\textcolor{stringliteral}{'get'} + name]();
    \textcolor{keywordflow}{if} (offset > 0 || value > -offset) \{
      value += offset;
    \}
    \textcolor{keywordflow}{if} (value === 0 && offset == -12) value = 12;
    \textcolor{keywordflow}{return} padNumber(value, size, trim);
  \};
\}

\textcolor{keyword}{function} dateStrGetter(name, shortForm) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date, formats) \{
    var value = date[\textcolor{stringliteral}{'get'} + name]();
    var \textcolor{keyword}{get} = uppercase(shortForm ? (\textcolor{stringliteral}{'SHORT'} + name) : name);

    \textcolor{keywordflow}{return} formats[\textcolor{keyword}{get}][value];
  \};
\}

\textcolor{keyword}{function} timeZoneGetter(date, formats, offset) \{
  var zone = -1 * offset;
  var paddedZone = (zone >= 0) ? \textcolor{stringliteral}{"+"} : \textcolor{stringliteral}{""};

  paddedZone += padNumber(Math[zone > 0 ? \textcolor{stringliteral}{'floor'} : \textcolor{stringliteral}{'ceil'}](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  \textcolor{keywordflow}{return} paddedZone;
\}

\textcolor{keyword}{function} getFirstThursdayOfYear(year) \{
    \textcolor{comment}{// 0 = index of January}
    var dayOfWeekOnFirst = (\textcolor{keyword}{new} Date(year, 0, 1)).getDay();
    \textcolor{comment}{// 4 = index of Thursday (+1 to account for 1st = 5)}
    \textcolor{comment}{// 11 = index of *next* Thursday (+1 account for 1st = 12)}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
\}

\textcolor{keyword}{function} getThursdayThisWeek(datetime) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(datetime.getFullYear(), datetime.getMonth(),
      \textcolor{comment}{// 4 = index of Thursday}
      datetime.getDate() + (4 - datetime.getDay()));
\}

\textcolor{keyword}{function} weekGetter(size) \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date) \{
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
         thisThurs = getThursdayThisWeek(date);

      var diff = +thisThurs - +firstThurs,
         result = 1 + Math.round(diff / 6.048e8); \textcolor{comment}{// 6.048e8 ms per week}

      \textcolor{keywordflow}{return} padNumber(result, size);
   \};
\}

\textcolor{keyword}{function} ampmGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
\}

\textcolor{keyword}{function} eraGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
\}

\textcolor{keyword}{function} longEraGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
\}

var DATE\_FORMATS = \{
  yyyy: dateGetter(\textcolor{stringliteral}{'FullYear'}, 4),
    yy: dateGetter(\textcolor{stringliteral}{'FullYear'}, 2, 0, \textcolor{keyword}{true}),
     y: dateGetter(\textcolor{stringliteral}{'FullYear'}, 1),
  MMMM: dateStrGetter(\textcolor{stringliteral}{'Month'}),
   MMM: dateStrGetter(\textcolor{stringliteral}{'Month'}, \textcolor{keyword}{true}),
    MM: dateGetter(\textcolor{stringliteral}{'Month'}, 2, 1),
     M: dateGetter(\textcolor{stringliteral}{'Month'}, 1, 1),
    dd: dateGetter(\textcolor{stringliteral}{'Date'}, 2),
     d: dateGetter(\textcolor{stringliteral}{'Date'}, 1),
    HH: dateGetter(\textcolor{stringliteral}{'Hours'}, 2),
     H: dateGetter(\textcolor{stringliteral}{'Hours'}, 1),
    hh: dateGetter(\textcolor{stringliteral}{'Hours'}, 2, -12),
     h: dateGetter(\textcolor{stringliteral}{'Hours'}, 1, -12),
    mm: dateGetter(\textcolor{stringliteral}{'Minutes'}, 2),
     m: dateGetter(\textcolor{stringliteral}{'Minutes'}, 1),
    ss: dateGetter(\textcolor{stringliteral}{'Seconds'}, 2),
     s: dateGetter(\textcolor{stringliteral}{'Seconds'}, 1),
     \textcolor{comment}{// while ISO 8601 requires fractions to be prefixed with `.` or `,`}
     \textcolor{comment}{// we can be just safely rely on using `sss` since we currently don't support single or two digit
       fractions}
   sss: dateGetter(\textcolor{stringliteral}{'Milliseconds'}, 3),
  EEEE: dateStrGetter(\textcolor{stringliteral}{'Day'}),
   EEE: dateStrGetter(\textcolor{stringliteral}{'Day'}, \textcolor{keyword}{true}),
     a: ampmGetter,
     Z: timeZoneGetter,
    ww: weekGetter(2),
     w: weekGetter(1),
     G: eraGetter,
     GG: eraGetter,
     GGG: eraGetter,
     GGGG: longEraGetter
\};

var DATE\_FORMATS\_SPLIT = /((?:[^yMdHhmsaZEwG\textcolor{stringliteral}{']+)|(?:'}(?:[^\textcolor{stringliteral}{']|'}\textcolor{stringliteral}{')*'})|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(
      .*)/,
    NUMBER\_STRING = /^\(\backslash\)-?\(\backslash\)d+$/;

dateFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} dateFilter($locale) \{


  var R\_ISO8601\_STR = /^(\(\backslash\)d\{4\})-?(\(\backslash\)d\(\backslash\)d)-?(\(\backslash\)d\(\backslash\)d)(?:T(\(\backslash\)d\(\backslash\)d)(?::?(\(\backslash\)d\(\backslash\)d)(?::?(\(\backslash\)d\(\backslash\)d)(?:\(\backslash\).(\(\backslash\)d+))?)?)?(Z|([+-])(\(\backslash\)d
      \(\backslash\)d):?(\(\backslash\)d\(\backslash\)d))?)?$/;
                     \textcolor{comment}{// 1        2       3         4          5          6          7          8  9     10 
           11}
  \textcolor{keyword}{function} jsonStringToDate(\textcolor{keywordtype}{string}) \{
    var match;
    \textcolor{keywordflow}{if} (match = \textcolor{keywordtype}{string}.match(R\_ISO8601\_STR)) \{
      var date = \textcolor{keyword}{new} Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      \textcolor{keywordflow}{if} (match[9]) \{
        tzHour = toInt(match[9] + match[10]);
        tzMin = toInt(match[9] + match[11]);
      \}
      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
      var h = toInt(match[4] || 0) - tzHour;
      var m = toInt(match[5] || 0) - tzMin;
      var s = toInt(match[6] || 0);
      var ms = Math.round(parseFloat(\textcolor{stringliteral}{'0.'} + (match[7] || 0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      \textcolor{keywordflow}{return} date;
    \}
    \textcolor{keywordflow}{return} string;
  \}


  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date, format, timezone) \{
    var text = \textcolor{stringliteral}{''},
        parts = [],
        fn, match;

    format = format || \textcolor{stringliteral}{'mediumDate'};
    format = $locale.DATETIME\_FORMATS[format] || format;
    \textcolor{keywordflow}{if} (isString(date)) \{
      date = NUMBER\_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
    \}

    \textcolor{keywordflow}{if} (isNumber(date)) \{
      date = \textcolor{keyword}{new} Date(date);
    \}

    \textcolor{keywordflow}{if} (!isDate(date) || !isFinite(date.getTime())) \{
      \textcolor{keywordflow}{return} date;
    \}

    \textcolor{keywordflow}{while} (format) \{
      match = DATE\_FORMATS\_SPLIT.exec(format);
      \textcolor{keywordflow}{if} (match) \{
        parts = concat(parts, match, 1);
        format = parts.pop();
      \} \textcolor{keywordflow}{else} \{
        parts.push(format);
        format = null;
      \}
    \}

    var dateTimezoneOffset = date.getTimezoneOffset();
    \textcolor{keywordflow}{if} (timezone) \{
      dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      date = convertTimezoneToLocal(date, timezone, \textcolor{keyword}{true});
    \}
    forEach(parts, \textcolor{keyword}{function}(value) \{
      fn = DATE\_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME\_FORMATS, dateTimezoneOffset)
                 : value.replace(/(^\textcolor{stringliteral}{'|'}$)/g, \textcolor{stringliteral}{''}).replace(/\textcolor{stringliteral}{''}/g, \textcolor{stringliteral}{"'"});
    \});

    \textcolor{keywordflow}{return} text;
  \};
\}


\textcolor{keyword}{function} jsonFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(object, spacing) \{
    \textcolor{keywordflow}{if} (isUndefined(spacing)) \{
        spacing = 2;
    \}
    \textcolor{keywordflow}{return} toJson(\textcolor{keywordtype}{object}, spacing);
  \};
\}


var lowercaseFilter = valueFn(lowercase);


var uppercaseFilter = valueFn(uppercase);

\textcolor{keyword}{function} limitToFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(input, limit, begin) \{
    \textcolor{keywordflow}{if} (Math.abs(Number(limit)) === Infinity) \{
      limit = Number(limit);
    \} \textcolor{keywordflow}{else} \{
      limit = toInt(limit);
    \}
    \textcolor{keywordflow}{if} (isNaN(limit)) \textcolor{keywordflow}{return} input;

    \textcolor{keywordflow}{if} (isNumber(input)) input = input.toString();
    \textcolor{keywordflow}{if} (!isArray(input) && !isString(input)) \textcolor{keywordflow}{return} input;

    begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
    begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;

    if (limit >= 0) \{
      \textcolor{keywordflow}{return} input.slice(begin, begin + limit);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (begin === 0) \{
        \textcolor{keywordflow}{return} input.slice(limit, input.length);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} input.slice(Math.max(0, begin + limit), begin);
      \}
    \}
  \};
\}

orderByFilter.$inject = [\textcolor{stringliteral}{'$parse'}];
\textcolor{keyword}{function} orderByFilter($parse) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(array, sortPredicate, reverseOrder) \{

    \textcolor{keywordflow}{if} (!(isArrayLike(array))) \textcolor{keywordflow}{return} array;

    \textcolor{keywordflow}{if} (!isArray(sortPredicate)) \{ sortPredicate = [sortPredicate]; \}
    \textcolor{keywordflow}{if} (sortPredicate.length === 0) \{ sortPredicate = [\textcolor{charliteral}{'+'}]; \}

    var predicates = processPredicates(sortPredicate, reverseOrder);
    \textcolor{comment}{// Add a predicate at the end that evaluates to the element index. This makes the}
    \textcolor{comment}{// sort stable as it works as a tie-breaker when all the input predicates cannot}
    \textcolor{comment}{// distinguish between two elements.}
    predicates.push(\{ \textcolor{keyword}{get}: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} \{\}; \}, descending: reverseOrder ? -1 : 1\});

    \textcolor{comment}{// The next three lines are a version of a Swartzian Transform idiom from Perl}
    \textcolor{comment}{// (sometimes called the Decorate-Sort-Undecorate idiom)}
    \textcolor{comment}{// See https://en.wikipedia.org/wiki/Schwartzian\_transform}
    var compareValues = Array.prototype.map.call(array, getComparisonObject);
    compareValues.sort(doComparison);
    array = compareValues.map(\textcolor{keyword}{function}(item) \{ \textcolor{keywordflow}{return} item.value; \});

    \textcolor{keywordflow}{return} array;

    \textcolor{keyword}{function} getComparisonObject(value, index) \{
      \textcolor{keywordflow}{return} \{
        value: value,
        predicateValues: predicates.map(\textcolor{keyword}{function}(predicate) \{
          \textcolor{keywordflow}{return} getPredicateValue(predicate.get(value), index);
        \})
      \};
    \}

    \textcolor{keyword}{function} doComparison(v1, v2) \{
      var result = 0;
      \textcolor{keywordflow}{for} (var index=0, length = predicates.length; index < length; ++index) \{
        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].
      descending;
        \textcolor{keywordflow}{if} (result) \textcolor{keywordflow}{break};
      \}
      \textcolor{keywordflow}{return} result;
    \}
  \};

  \textcolor{keyword}{function} processPredicates(sortPredicate, reverseOrder) \{
    reverseOrder = reverseOrder ? -1 : 1;
    \textcolor{keywordflow}{return} sortPredicate.map(\textcolor{keyword}{function}(predicate) \{
      var descending = 1, \textcolor{keyword}{get} = identity;

      \textcolor{keywordflow}{if} (isFunction(predicate)) \{
        \textcolor{keyword}{get} = predicate;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(predicate)) \{
        \textcolor{keywordflow}{if} ((predicate.charAt(0) == \textcolor{charliteral}{'+'} || predicate.charAt(0) == \textcolor{charliteral}{'-'})) \{
          descending = predicate.charAt(0) == \textcolor{charliteral}{'-'} ? -1 : 1;
          predicate = predicate.substring(1);
        \}
        \textcolor{keywordflow}{if} (predicate !== \textcolor{stringliteral}{''}) \{
          \textcolor{keyword}{get} = $parse(predicate);
          \textcolor{keywordflow}{if} (\textcolor{keyword}{get}.constant) \{
            var key = \textcolor{keyword}{get}();
            \textcolor{keyword}{get} = \textcolor{keyword}{function}(value) \{ \textcolor{keywordflow}{return} value[key]; \};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} \{ \textcolor{keyword}{get}: \textcolor{keyword}{get}, descending: descending * reverseOrder \};
    \});
  \}

  \textcolor{keyword}{function} isPrimitive(value) \{
    \textcolor{keywordflow}{switch} (typeof value) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'number'}: \textcolor{comment}{/* falls through */}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'boolean'}: \textcolor{comment}{/* falls through */}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
  \}

  \textcolor{keyword}{function} objectValue(value, index) \{
    \textcolor{comment}{// If `valueOf` is a valid function use that}
    \textcolor{keywordflow}{if} (typeof value.valueOf === \textcolor{stringliteral}{'function'}) \{
      value = value.valueOf();
      \textcolor{keywordflow}{if} (isPrimitive(value)) \textcolor{keywordflow}{return} value;
    \}
    \textcolor{comment}{// If `toString` is a valid function and not the one from `Object.prototype` use that}
    \textcolor{keywordflow}{if} (hasCustomToString(value)) \{
      value = value.toString();
      \textcolor{keywordflow}{if} (isPrimitive(value)) \textcolor{keywordflow}{return} value;
    \}
    \textcolor{comment}{// We have a basic object so we use the position of the object in the collection}
    \textcolor{keywordflow}{return} index;
  \}

  \textcolor{keyword}{function} getPredicateValue(value, index) \{
    var type = typeof value;
    \textcolor{keywordflow}{if} (value === null) \{
      type = \textcolor{stringliteral}{'string'};
      value = \textcolor{stringliteral}{'null'};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'string'}) \{
      value = value.toLowerCase();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'object'}) \{
      value = objectValue(value, index);
    \}
    \textcolor{keywordflow}{return} \{ value: value, type: type \};
  \}

  \textcolor{keyword}{function} compare(v1, v2) \{
    var result = 0;
    \textcolor{keywordflow}{if} (v1.type === v2.type) \{
      \textcolor{keywordflow}{if} (v1.value !== v2.value) \{
        result = v1.value < v2.value ? -1 : 1;
      \}
    \} \textcolor{keywordflow}{else} \{
      result = v1.type < v2.type ? -1 : 1;
    \}
    \textcolor{keywordflow}{return} result;
  \}
\}

\textcolor{keyword}{function} ngDirective(directive) \{
  \textcolor{keywordflow}{if} (isFunction(directive)) \{
    directive = \{
      link: directive
    \};
  \}
  directive.restrict = directive.restrict || \textcolor{stringliteral}{'AC'};
  \textcolor{keywordflow}{return} valueFn(directive);
\}

var htmlAnchorDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'E'},
  compile: \textcolor{keyword}{function}(element, attr) \{
    \textcolor{keywordflow}{if} (!attr.href && !attr.xlinkHref) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element) \{
        \textcolor{comment}{// If the linked element is not an anchor tag anymore, do nothing}
        \textcolor{keywordflow}{if} (element[0].nodeName.toLowerCase() !== \textcolor{charliteral}{'a'}) \textcolor{keywordflow}{return};

        \textcolor{comment}{// SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.}
        var href = toString.call(element.prop(\textcolor{stringliteral}{'href'})) === \textcolor{stringliteral}{'[object SVGAnimatedString]'} ?
                   \textcolor{stringliteral}{'xlink:href'} : \textcolor{stringliteral}{'href'};
        element.on(\textcolor{stringliteral}{'click'}, \textcolor{keyword}{function}(event) \{
          \textcolor{comment}{// if we have no href url, then don't navigate anywhere.}
          \textcolor{keywordflow}{if} (!element.attr(href)) \{
            event.preventDefault();
          \}
        \});
      \};
    \}
  \}
\});

var ngAttributeAliasDirectives = \{\};

\textcolor{comment}{// boolean attrs are evaluated}
forEach(BOOLEAN\_ATTR, \textcolor{keyword}{function}(propName, attrName) \{
  \textcolor{comment}{// binding to multiple is not supported}
  \textcolor{keywordflow}{if} (propName == \textcolor{stringliteral}{"multiple"}) \textcolor{keywordflow}{return};

  \textcolor{keyword}{function} defaultLinkFn(scope, element, attr) \{
    scope.$watch(attr[normalized], \textcolor{keyword}{function} ngBooleanAttrWatchAction(value) \{
      attr.$set(attrName, !!value);
    \});
  \}

  var normalized = directiveNormalize(\textcolor{stringliteral}{'ng-'} + attrName);
  var linkFn = defaultLinkFn;

  \textcolor{keywordflow}{if} (propName === \textcolor{stringliteral}{'checked'}) \{
    linkFn = \textcolor{keyword}{function}(scope, element, attr) \{
      \textcolor{comment}{// ensuring ngChecked doesn't interfere with ngModel when both are set on the same input}
      \textcolor{keywordflow}{if} (attr.ngModel !== attr[normalized]) \{
        defaultLinkFn(scope, element, attr);
      \}
    \};
  \}

  ngAttributeAliasDirectives[normalized] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{charliteral}{'A'},
      priority: 100,
      link: linkFn
    \};
  \};
\});

\textcolor{comment}{// aliased input attrs are evaluated}
forEach(ALIASED\_ATTR, \textcolor{keyword}{function}(htmlAttr, ngAttr) \{
  ngAttributeAliasDirectives[ngAttr] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      priority: 100,
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        \textcolor{comment}{//special case ngPattern when a literal regular expression value}
        \textcolor{comment}{//is used as the expression (this way we don't have to watch anything).}
        \textcolor{keywordflow}{if} (ngAttr === \textcolor{stringliteral}{"ngPattern"} && attr.ngPattern.charAt(0) == \textcolor{stringliteral}{"/"}) \{
          var match = attr.ngPattern.match(REGEX\_STRING\_REGEXP);
          \textcolor{keywordflow}{if} (match) \{
            attr.$set(\textcolor{stringliteral}{"ngPattern"}, \textcolor{keyword}{new} RegExp(match[1], match[2]));
            \textcolor{keywordflow}{return};
          \}
        \}

        scope.$watch(attr[ngAttr], \textcolor{keyword}{function} ngAttrAliasWatchAction(value) \{
          attr.$set(ngAttr, value);
        \});
      \}
    \};
  \};
\});

\textcolor{comment}{// ng-src, ng-srcset, ng-href are interpolated}
forEach([\textcolor{stringliteral}{'src'}, \textcolor{stringliteral}{'srcset'}, \textcolor{stringliteral}{'href'}], \textcolor{keyword}{function}(attrName) \{
  var normalized = directiveNormalize(\textcolor{stringliteral}{'ng-'} + attrName);
  ngAttributeAliasDirectives[normalized] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      priority: 99, \textcolor{comment}{// it needs to run after the attributes are interpolated}
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        var propName = attrName,
            name = attrName;

        \textcolor{keywordflow}{if} (attrName === \textcolor{stringliteral}{'href'} &&
            toString.call(element.prop(\textcolor{stringliteral}{'href'})) === \textcolor{stringliteral}{'[object SVGAnimatedString]'}) \{
          name = \textcolor{stringliteral}{'xlinkHref'};
          attr.$attr[name] = \textcolor{stringliteral}{'xlink:href'};
          propName = null;
        \}

        attr.$observe(normalized, \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{if} (!value) \{
            \textcolor{keywordflow}{if} (attrName === \textcolor{stringliteral}{'href'}) \{
              attr.$set(name, null);
            \}
            \textcolor{keywordflow}{return};
          \}

          attr.$set(name, value);

          \textcolor{comment}{// on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist}
          \textcolor{comment}{// then calling element.setAttribute('src', 'foo') doesn't do anything, so we need}
          \textcolor{comment}{// to set the property as well to achieve the desired effect.}
          \textcolor{comment}{// we use attr[attrName] value since $set can sanitize the url.}
          \textcolor{keywordflow}{if} (msie && propName) element.prop(propName, attr[name]);
        \});
      \}
    \};
  \};
\});

\textcolor{comment}{/* global -nullFormCtrl, -SUBMITTED\_CLASS, addSetValidityMethod: true}
\textcolor{comment}{ */}
var nullFormCtrl = \{
  $addControl: noop,
  $$renameControl: nullFormRenameControl,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop,
  $setSubmitted: noop
\},
SUBMITTED\_CLASS = \textcolor{stringliteral}{'ng-submitted'};

\textcolor{keyword}{function} nullFormRenameControl(control, name) \{
  control.$name = name;
\}

\textcolor{comment}{//asks for $scope to fool the BC controller module}
FormController.$inject = [\textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'$interpolate'}];
\textcolor{keyword}{function} FormController(element, attrs, $scope, $animate, $interpolate) \{
  var form = \textcolor{keyword}{this},
      controls = [];

  var parentForm = form.$$parentForm = element.parent().controller(\textcolor{stringliteral}{'form'}) || nullFormCtrl;

  \textcolor{comment}{// init state}
  form.$error = \{\};
  form.$$success = \{\};
  form.$pending = undefined;
  form.$name = $interpolate(attrs.name || attrs.ngForm || \textcolor{stringliteral}{''})($scope);
  form.$dirty = \textcolor{keyword}{false};
  form.$pristine = \textcolor{keyword}{true};
  form.$valid = \textcolor{keyword}{true};
  form.$invalid = \textcolor{keyword}{false};
  form.$submitted = \textcolor{keyword}{false};

  parentForm.$addControl(form);

  form.$rollbackViewValue = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$rollbackViewValue();
    \});
  \};

  form.$commitViewValue = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$commitViewValue();
    \});
  \};

  form.$addControl = \textcolor{keyword}{function}(control) \{
    \textcolor{comment}{// Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored}
    \textcolor{comment}{// and not added to the scope.  Now we throw an error.}
    assertNotHasOwnProperty(control.$name, \textcolor{stringliteral}{'input'});
    controls.push(control);

    \textcolor{keywordflow}{if} (control.$name) \{
      form[control.$name] = control;
    \}
  \};

  \textcolor{comment}{// Private API: rename a form control}
  form.$$renameControl = \textcolor{keyword}{function}(control, newName) \{
    var oldName = control.$name;

    \textcolor{keywordflow}{if} (form[oldName] === control) \{
      \textcolor{keyword}{delete} form[oldName];
    \}
    form[newName] = control;
    control.$name = newName;
  \};

  form.$removeControl = \textcolor{keyword}{function}(control) \{
    \textcolor{keywordflow}{if} (control.$name && form[control.$name] === control) \{
      \textcolor{keyword}{delete} form[control.$name];
    \}
    forEach(form.$pending, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});
    forEach(form.$error, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});
    forEach(form.$$success, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});

    arrayRemove(controls, control);
  \};


  addSetValidityMethod(\{
    ctrl: \textcolor{keyword}{this},
    $element: element,
    set: \textcolor{keyword}{function}(object, property, controller) \{
      var list = \textcolor{keywordtype}{object}[property];
      \textcolor{keywordflow}{if} (!list) \{
        \textcolor{keywordtype}{object}[property] = [controller];
      \} \textcolor{keywordflow}{else} \{
        var index = list.indexOf(controller);
        \textcolor{keywordflow}{if} (index === -1) \{
          list.push(controller);
        \}
      \}
    \},
    unset: \textcolor{keyword}{function}(object, property, controller) \{
      var list = \textcolor{keywordtype}{object}[property];
      \textcolor{keywordflow}{if} (!list) \{
        \textcolor{keywordflow}{return};
      \}
      arrayRemove(list, controller);
      \textcolor{keywordflow}{if} (list.length === 0) \{
        \textcolor{keyword}{delete} \textcolor{keywordtype}{object}[property];
      \}
    \},
    parentForm: parentForm,
    $animate: $animate
  \});

  form.$setDirty = \textcolor{keyword}{function}() \{
    $animate.removeClass(element, PRISTINE\_CLASS);
    $animate.addClass(element, DIRTY\_CLASS);
    form.$dirty = \textcolor{keyword}{true};
    form.$pristine = \textcolor{keyword}{false};
    parentForm.$setDirty();
  \};

  form.$setPristine = \textcolor{keyword}{function}() \{
    $animate.setClass(element, PRISTINE\_CLASS, DIRTY\_CLASS + \textcolor{charliteral}{' '} + SUBMITTED\_CLASS);
    form.$dirty = \textcolor{keyword}{false};
    form.$pristine = \textcolor{keyword}{true};
    form.$submitted = \textcolor{keyword}{false};
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$setPristine();
    \});
  \};

  form.$setUntouched = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$setUntouched();
    \});
  \};

  form.$setSubmitted = \textcolor{keyword}{function}() \{
    $animate.addClass(element, SUBMITTED\_CLASS);
    form.$submitted = \textcolor{keyword}{true};
    parentForm.$setSubmitted();
  \};
\}

var formDirectiveFactory = \textcolor{keyword}{function}(isNgForm) \{
  \textcolor{keywordflow}{return} [\textcolor{stringliteral}{'$timeout'}, \textcolor{stringliteral}{'$parse'}, \textcolor{keyword}{function}($timeout, $parse) \{
    var formDirective = \{
      name: \textcolor{stringliteral}{'form'},
      restrict: isNgForm ? \textcolor{stringliteral}{'EAC'} : \textcolor{charliteral}{'E'},
      controller: FormController,
      compile: \textcolor{keyword}{function} ngFormCompile(formElement, attr) \{
        \textcolor{comment}{// Setup initial state of the control}
        formElement.addClass(PRISTINE\_CLASS).addClass(VALID\_CLASS);

        var nameAttr = attr.name ? \textcolor{stringliteral}{'name'} : (isNgForm && attr.ngForm ? \textcolor{stringliteral}{'ngForm'} : \textcolor{keyword}{false});

        \textcolor{keywordflow}{return} \{
          pre: \textcolor{keyword}{function} ngFormPreLink(scope, formElement, attr, controller) \{
            \textcolor{comment}{// if `action` attr is not present on the form, prevent the default action (submission)}
            \textcolor{keywordflow}{if} (!(\textcolor{stringliteral}{'action'} in attr)) \{
              \textcolor{comment}{// we can't use jq events because if a form is destroyed during submission the default}
              \textcolor{comment}{// action is not prevented. see #1238}
              \textcolor{comment}{//}
              \textcolor{comment}{// IE 9 is not affected because it doesn't fire a submit event and try to do a full}
              \textcolor{comment}{// page reload if the form was destroyed by submission of the form via a click handler}
              \textcolor{comment}{// on a button in the form. Looks like an IE9 specific bug.}
              var handleFormSubmission = \textcolor{keyword}{function}(event) \{
                scope.$apply(\textcolor{keyword}{function}() \{
                  controller.$commitViewValue();
                  controller.$setSubmitted();
                \});

                event.preventDefault();
              \};

              addEventListenerFn(formElement[0], \textcolor{stringliteral}{'submit'}, handleFormSubmission);

              \textcolor{comment}{// unregister the preventDefault listener so that we don't not leak memory but in a}
              \textcolor{comment}{// way that will achieve the prevention of the default action.}
              formElement.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
                $timeout(\textcolor{keyword}{function}() \{
                  removeEventListenerFn(formElement[0], \textcolor{stringliteral}{'submit'}, handleFormSubmission);
                \}, 0, \textcolor{keyword}{false});
              \});
            \}

            var parentFormCtrl = controller.$$parentForm;
            var setter = nameAttr ? getSetter(controller.$name) : noop;

            \textcolor{keywordflow}{if} (nameAttr) \{
              setter(scope, controller);
              attr.$observe(nameAttr, \textcolor{keyword}{function}(newValue) \{
                \textcolor{keywordflow}{if} (controller.$name === newValue) \textcolor{keywordflow}{return};
                setter(scope, undefined);
                parentFormCtrl.$$renameControl(controller, newValue);
                setter = getSetter(controller.$name);
                setter(scope, controller);
              \});
            \}
            formElement.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
              parentFormCtrl.$removeControl(controller);
              setter(scope, undefined);
              extend(controller, nullFormCtrl); \textcolor{comment}{//stop propagating child destruction handlers upwards}
            \});
          \}
        \};
      \}
    \};

    \textcolor{keywordflow}{return} formDirective;

    \textcolor{keyword}{function} getSetter(expression) \{
      \textcolor{keywordflow}{if} (expression === \textcolor{stringliteral}{''}) \{
        \textcolor{comment}{//create an assignable expression, so forms with an empty name can be renamed later}
        \textcolor{keywordflow}{return} $parse(\textcolor{stringliteral}{'this[""]'}).assign;
      \}
      \textcolor{keywordflow}{return} $parse(expression).assign || noop;
    \}
  \}];
\};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(\textcolor{keyword}{true});

\textcolor{comment}{/* global VALID\_CLASS: false,}
\textcolor{comment}{  INVALID\_CLASS: false,}
\textcolor{comment}{  PRISTINE\_CLASS: false,}
\textcolor{comment}{  DIRTY\_CLASS: false,}
\textcolor{comment}{  UNTOUCHED\_CLASS: false,}
\textcolor{comment}{  TOUCHED\_CLASS: false,}
\textcolor{comment}{  ngModelMinErr: false,}
\textcolor{comment}{*/}

\textcolor{comment}{// Regex code is obtained from SO:
       https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231}
var ISO\_DATE\_REGEXP = /\(\backslash\)d\{4\}-[01]\(\backslash\)d-[0-3]\(\backslash\)dT[0-2]\(\backslash\)d:[0-5]\(\backslash\)d:[0-5]\(\backslash\)d\(\backslash\).\(\backslash\)d+([+-][0-2]\(\backslash\)d:[0-5]\(\backslash\)d|Z)/;
var URL\_REGEXP = /^(ftp|http|https):\(\backslash\)/\(\backslash\)/(\(\backslash\)w+:\{0,1\}\(\backslash\)w*@)?(\(\backslash\)S+)(:[0-9]+)?(\(\backslash\)/|\(\backslash\)/([\(\backslash\)w#!:.?+=&%@!\(\backslash\)-\(\backslash\)/]))?$/;
var EMAIL\_REGEXP = /^[a-z0-9!#$%&\textcolor{stringliteral}{'*+\(\backslash\)/=?^\_`\{|\}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\(\backslash\).
      [a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;}
\textcolor{stringliteral}{var NUMBER\_REGEXP = /^\(\backslash\)s*(\(\backslash\)-|\(\backslash\)+)?(\(\backslash\)d+|(\(\backslash\)d*(\(\backslash\).\(\backslash\)d*)))([eE][+-]?\(\backslash\)d+)?\(\backslash\)s*$/;}
\textcolor{stringliteral}{var DATE\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\{2\})-(\(\backslash\)d\{2\})$/;}
\textcolor{stringliteral}{var DATETIMELOCAL\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\(\backslash\)d)-(\(\backslash\)d\(\backslash\)d)T(\(\backslash\)d\(\backslash\)d):(\(\backslash\)d\(\backslash\)d)(?::(\(\backslash\)d\(\backslash\)d)(\(\backslash\).\(\backslash\)d\{1,3\})?)?$/;}
\textcolor{stringliteral}{var WEEK\_REGEXP = /^(\(\backslash\)d\{4\})-W(\(\backslash\)d\(\backslash\)d)$/;}
\textcolor{stringliteral}{var MONTH\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\(\backslash\)d)$/;}
\textcolor{stringliteral}{var TIME\_REGEXP = /^(\(\backslash\)d\(\backslash\)d):(\(\backslash\)d\(\backslash\)d)(?::(\(\backslash\)d\(\backslash\)d)(\(\backslash\).\(\backslash\)d\{1,3\})?)?$/;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{var inputType = \{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}text\textcolor{stringliteral}{': textInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}date\textcolor{stringliteral}{': createDateInputType('}date\textcolor{stringliteral}{', DATE\_REGEXP,}
\textcolor{stringliteral}{         createDateParser(DATE\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{', '}dd\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{         '}yyyy-MM-dd\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}datetime-local\textcolor{stringliteral}{': createDateInputType('}datetimelocal\textcolor{stringliteral}{', DATETIMELOCAL\_REGEXP,}
\textcolor{stringliteral}{      createDateParser(DATETIMELOCAL\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{', '}dd\textcolor{stringliteral}{', '}HH\textcolor{stringliteral}{', '}mm\textcolor{stringliteral}{', '}ss\textcolor{stringliteral}{', '}sss\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{      '}yyyy-MM-ddTHH:mm:ss.sss\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}time\textcolor{stringliteral}{': createDateInputType('}time\textcolor{stringliteral}{', TIME\_REGEXP,}
\textcolor{stringliteral}{      createDateParser(TIME\_REGEXP, ['}HH\textcolor{stringliteral}{', '}mm\textcolor{stringliteral}{', '}ss\textcolor{stringliteral}{', '}sss\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{     '}HH:mm:ss.sss\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}week\textcolor{stringliteral}{': createDateInputType('}week\textcolor{stringliteral}{', WEEK\_REGEXP, weekParser, '}yyyy-Www\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}month\textcolor{stringliteral}{': createDateInputType('}month\textcolor{stringliteral}{', MONTH\_REGEXP,}
\textcolor{stringliteral}{     createDateParser(MONTH\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{     '}yyyy-MM\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}number\textcolor{stringliteral}{': numberInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}url\textcolor{stringliteral}{': urlInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}email\textcolor{stringliteral}{': emailInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}radio\textcolor{stringliteral}{': radioInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}checkbox\textcolor{stringliteral}{': checkboxInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}hidden\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}button\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}submit\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}reset\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}file\textcolor{stringliteral}{': noop}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function stringBasedInputType(ctrl) \{}
\textcolor{stringliteral}{  ctrl.$formatters.push(function(value) \{}
\textcolor{stringliteral}{    return ctrl.$isEmpty(value) ? value : value.toString();}
\textcolor{stringliteral}{  \});}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function textInputType(scope, element, attr, ctrl, $sniffer, $browser) \{}
\textcolor{stringliteral}{  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);}
\textcolor{stringliteral}{  stringBasedInputType(ctrl);}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) \{}
\textcolor{stringliteral}{  var type = lowercase(element[0].type);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  // In composition mode, users are still inputing intermediate text buffer,}
\textcolor{stringliteral}{  // hold the listener until composition is done.}
\textcolor{stringliteral}{  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent}
\textcolor{stringliteral}{  if (!$sniffer.android) \{}
\textcolor{stringliteral}{    var composing = false;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    element.on('}compositionstart\textcolor{stringliteral}{', function(data) \{}
\textcolor{stringliteral}{      composing = true;}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    element.on('}compositionend\textcolor{stringliteral}{', function() \{}
\textcolor{stringliteral}{      composing = false;}
\textcolor{stringliteral}{      listener();}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var listener = function(ev) \{}
\textcolor{stringliteral}{    if (timeout) \{}
\textcolor{stringliteral}{      $browser.defer.cancel(timeout);}
\textcolor{stringliteral}{      timeout = null;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    if (composing) return;}
\textcolor{stringliteral}{    var value = element.val(),}
\textcolor{stringliteral}{        event = ev && ev.type;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // By default we will trim the value}
\textcolor{stringliteral}{    // If the attribute ng-trim exists we will avoid trimming}
\textcolor{stringliteral}{    // If input type is '}password\textcolor{stringliteral}{', the value is never trimmed}
\textcolor{stringliteral}{    if (type !== '}password\textcolor{stringliteral}{' && (!attr.ngTrim || attr.ngTrim !== '}\textcolor{keyword}{false}\textcolor{stringliteral}{')) \{}
\textcolor{stringliteral}{      value = trim(value);}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // If a control is suffering from bad input (due to native validators), browsers discard its}
\textcolor{stringliteral}{    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the}
\textcolor{stringliteral}{    // control'}s value is the same empty value twice in a row.
    \textcolor{keywordflow}{if} (ctrl.$viewValue !== value || (value === \textcolor{stringliteral}{''} && ctrl.$$hasNativeValidators)) \{
      ctrl.$setViewValue(value, event);
    \}
  \};

  \textcolor{comment}{// if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the}
  \textcolor{comment}{// input event on backspace, delete or cut}
  \textcolor{keywordflow}{if} ($sniffer.hasEvent(\textcolor{stringliteral}{'input'})) \{
    element.on(\textcolor{stringliteral}{'input'}, listener);
  \} \textcolor{keywordflow}{else} \{
    var timeout;

    var deferListener = \textcolor{keyword}{function}(ev, input, origValue) \{
      \textcolor{keywordflow}{if} (!timeout) \{
        timeout = $browser.defer(\textcolor{keyword}{function}() \{
          timeout = null;
          \textcolor{keywordflow}{if} (!input || input.value !== origValue) \{
            listener(ev);
          \}
        \});
      \}
    \};

    element.on(\textcolor{stringliteral}{'keydown'}, \textcolor{keyword}{function}(event) \{
      var key = event.keyCode;

      \textcolor{comment}{// ignore}
      \textcolor{comment}{//    command            modifiers                   arrows}
      \textcolor{keywordflow}{if} (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) \textcolor{keywordflow}{return};

      deferListener(event, \textcolor{keyword}{this}, this.value);
    \});

    \textcolor{comment}{// if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it}
    \textcolor{keywordflow}{if} ($sniffer.hasEvent(\textcolor{stringliteral}{'paste'})) \{
      element.on(\textcolor{stringliteral}{'paste cut'}, deferListener);
    \}
  \}

  \textcolor{comment}{// if user paste into input using mouse on older browser}
  \textcolor{comment}{// or form autocomplete on newer browser, we need "change" event to catch it}
  element.on(\textcolor{stringliteral}{'change'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    \textcolor{comment}{// Workaround for Firefox validation #12102.}
    var value = ctrl.$isEmpty(ctrl.$viewValue) ? \textcolor{stringliteral}{''} : ctrl.$viewValue;
    \textcolor{keywordflow}{if} (element.val() !== value) \{
      element.val(value);
    \}
  \};
\}

\textcolor{keyword}{function} weekParser(isoWeek, existingDate) \{
  \textcolor{keywordflow}{if} (isDate(isoWeek)) \{
    \textcolor{keywordflow}{return} isoWeek;
  \}

  \textcolor{keywordflow}{if} (isString(isoWeek)) \{
    WEEK\_REGEXP.lastIndex = 0;
    var parts = WEEK\_REGEXP.exec(isoWeek);
    \textcolor{keywordflow}{if} (parts) \{
      var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;

      \textcolor{keywordflow}{if} (existingDate) \{
        hours = existingDate.getHours();
        minutes = existingDate.getMinutes();
        seconds = existingDate.getSeconds();
        milliseconds = existingDate.getMilliseconds();
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
    \}
  \}

  \textcolor{keywordflow}{return} NaN;
\}

\textcolor{keyword}{function} createDateParser(regexp, mapping) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(iso, date) \{
    var parts, map;

    \textcolor{keywordflow}{if} (isDate(iso)) \{
      \textcolor{keywordflow}{return} iso;
    \}

    \textcolor{keywordflow}{if} (isString(iso)) \{
      \textcolor{comment}{// When a date is JSON'ified to wraps itself inside of an extra}
      \textcolor{comment}{// set of double quotes. This makes the date parsing code unable}
      \textcolor{comment}{// to match the date string and parse it as a date.}
      \textcolor{keywordflow}{if} (iso.charAt(0) == \textcolor{charliteral}{'"'} && iso.charAt(iso.length - 1) == \textcolor{charliteral}{'"'}) \{
        iso = iso.substring(1, iso.length - 1);
      \}
      \textcolor{keywordflow}{if} (ISO\_DATE\_REGEXP.test(iso)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(iso);
      \}
      regexp.lastIndex = 0;
      parts = regexp.exec(iso);

      \textcolor{keywordflow}{if} (parts) \{
        parts.shift();
        \textcolor{keywordflow}{if} (date) \{
          map = \{
            yyyy: date.getFullYear(),
            MM: date.getMonth() + 1,
            dd: date.getDate(),
            HH: date.getHours(),
            mm: date.getMinutes(),
            ss: date.getSeconds(),
            sss: date.getMilliseconds() / 1000
          \};
        \} \textcolor{keywordflow}{else} \{
          map = \{ yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 \};
        \}

        forEach(parts, \textcolor{keyword}{function}(part, index) \{
          \textcolor{keywordflow}{if} (index < mapping.length) \{
            map[mapping[index]] = +part;
          \}
        \});
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
      \}
    \}

    \textcolor{keywordflow}{return} NaN;
  \};
\}

\textcolor{keyword}{function} createDateInputType(type, regexp, parseDate, format) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function} dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) \{
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
    var previousDate;

    ctrl.$$parserName = type;
    ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{if} (ctrl.$isEmpty(value)) \textcolor{keywordflow}{return} null;
      \textcolor{keywordflow}{if} (regexp.test(value)) \{
        \textcolor{comment}{// Note: We cannot read ctrl.$modelValue, as there might be a different}
        \textcolor{comment}{// parser/formatter in the processing chain so that the model}
        \textcolor{comment}{// contains some different data format!}
        var parsedDate = parseDate(value, previousDate);
        \textcolor{keywordflow}{if} (timezone) \{
          parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        \}
        \textcolor{keywordflow}{return} parsedDate;
      \}
      \textcolor{keywordflow}{return} undefined;
    \});

    ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{if} (value && !isDate(value)) \{
        \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'datefmt'}, \textcolor{stringliteral}{'Expected `\{0\}` to be a date'}, value);
      \}
      \textcolor{keywordflow}{if} (isValidDate(value)) \{
        previousDate = value;
        \textcolor{keywordflow}{if} (previousDate && timezone) \{
          previousDate = convertTimezoneToLocal(previousDate, timezone, \textcolor{keyword}{true});
        \}
        \textcolor{keywordflow}{return} $filter(\textcolor{stringliteral}{'date'})(value, format, timezone);
      \} \textcolor{keywordflow}{else} \{
        previousDate = null;
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
      \}
    \});

    \textcolor{keywordflow}{if} (isDefined(attr.min) || attr.ngMin) \{
      var minVal;
      ctrl.$validators.min = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
      \};
      attr.$observe(\textcolor{stringliteral}{'min'}, \textcolor{keyword}{function}(val) \{
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
      \});
    \}

    \textcolor{keywordflow}{if} (isDefined(attr.max) || attr.ngMax) \{
      var maxVal;
      ctrl.$validators.max = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
      \};
      attr.$observe(\textcolor{stringliteral}{'max'}, \textcolor{keyword}{function}(val) \{
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
      \});
    \}

    \textcolor{keyword}{function} isValidDate(value) \{
      \textcolor{comment}{// Invalid Date: getTime() returns NaN}
      \textcolor{keywordflow}{return} value && !(value.getTime && value.getTime() !== value.getTime());
    \}

    \textcolor{keyword}{function} parseObservedDateValue(val) \{
      \textcolor{keywordflow}{return} isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
    \}
  \};
\}

\textcolor{keyword}{function} badInputChecker(scope, element, attr, ctrl) \{
  var node = element[0];
  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
  \textcolor{keywordflow}{if} (nativeValidation) \{
    ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
      var validity = element.prop(VALIDITY\_STATE\_PROPERTY) || \{\};
      \textcolor{comment}{// Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show\_bug.cgi?id=1064430):}
      \textcolor{comment}{// - also sets validity.badInput (should only be validity.typeMismatch).}
      \textcolor{comment}{// - see
       http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)}
      \textcolor{comment}{// - can ignore this case as we can still read out the erroneous email...}
      \textcolor{keywordflow}{return} validity.badInput && !validity.typeMismatch ? undefined : value;
    \});
  \}
\}

\textcolor{keyword}{function} numberInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  badInputChecker(scope, element, attr, ctrl);
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$$parserName = \textcolor{stringliteral}{'number'};
  ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (ctrl.$isEmpty(value))      \textcolor{keywordflow}{return} null;
    \textcolor{keywordflow}{if} (NUMBER\_REGEXP.test(value)) \textcolor{keywordflow}{return} parseFloat(value);
    \textcolor{keywordflow}{return} undefined;
  \});

  ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (!ctrl.$isEmpty(value)) \{
      \textcolor{keywordflow}{if} (!isNumber(value)) \{
        \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'numfmt'}, \textcolor{stringliteral}{'Expected `\{0\}` to be a number'}, value);
      \}
      value = value.toString();
    \}
    \textcolor{keywordflow}{return} value;
  \});

  \textcolor{keywordflow}{if} (isDefined(attr.min) || attr.ngMin) \{
    var minVal;
    ctrl.$validators.min = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
    \};

    attr.$observe(\textcolor{stringliteral}{'min'}, \textcolor{keyword}{function}(val) \{
      \textcolor{keywordflow}{if} (isDefined(val) && !isNumber(val)) \{
        val = parseFloat(val, 10);
      \}
      minVal = isNumber(val) && !isNaN(val) ? val : undefined;
      \textcolor{comment}{// TODO(matsko): implement validateLater to reduce number of validations}
      ctrl.$validate();
    \});
  \}

  \textcolor{keywordflow}{if} (isDefined(attr.max) || attr.ngMax) \{
    var maxVal;
    ctrl.$validators.max = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
    \};

    attr.$observe(\textcolor{stringliteral}{'max'}, \textcolor{keyword}{function}(val) \{
      \textcolor{keywordflow}{if} (isDefined(val) && !isNumber(val)) \{
        val = parseFloat(val, 10);
      \}
      maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
      \textcolor{comment}{// TODO(matsko): implement validateLater to reduce number of validations}
      ctrl.$validate();
    \});
  \}
\}

\textcolor{keyword}{function} urlInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  \textcolor{comment}{// Note: no badInputChecker here by purpose as `url` is only a validation}
  \textcolor{comment}{// in browsers, i.e. we can always read out input.value even if it is not valid!}
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = \textcolor{stringliteral}{'url'};
  ctrl.$validators.url = \textcolor{keyword}{function}(modelValue, viewValue) \{
    var value = modelValue || viewValue;
    \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || URL\_REGEXP.test(value);
  \};
\}

\textcolor{keyword}{function} emailInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  \textcolor{comment}{// Note: no badInputChecker here by purpose as `url` is only a validation}
  \textcolor{comment}{// in browsers, i.e. we can always read out input.value even if it is not valid!}
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = \textcolor{stringliteral}{'email'};
  ctrl.$validators.email = \textcolor{keyword}{function}(modelValue, viewValue) \{
    var value = modelValue || viewValue;
    \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || EMAIL\_REGEXP.test(value);
  \};
\}

\textcolor{keyword}{function} radioInputType(scope, element, attr, ctrl) \{
  \textcolor{comment}{// make the name unique, if not defined}
  \textcolor{keywordflow}{if} (isUndefined(attr.name)) \{
    element.attr(\textcolor{stringliteral}{'name'}, nextUid());
  \}

  var listener = \textcolor{keyword}{function}(ev) \{
    \textcolor{keywordflow}{if} (element[0].checked) \{
      ctrl.$setViewValue(attr.value, ev && ev.type);
    \}
  \};

  element.on(\textcolor{stringliteral}{'click'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  \};

  attr.$observe(\textcolor{stringliteral}{'value'}, ctrl.$render);
\}

\textcolor{keyword}{function} parseConstantExpr($parse, context, name, expression, fallback) \{
  var parseFn;
  \textcolor{keywordflow}{if} (isDefined(expression)) \{
    parseFn = $parse(expression);
    \textcolor{keywordflow}{if} (!parseFn.constant) \{
      \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'constexpr'}, \textcolor{stringliteral}{'Expected constant expression for `\{0\}`, but saw '} +
                                   \textcolor{stringliteral}{'`\{1\}`.'}, name, expression);
    \}
    \textcolor{keywordflow}{return} parseFn(context);
  \}
  \textcolor{keywordflow}{return} fallback;
\}

\textcolor{keyword}{function} checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) \{
  var trueValue = parseConstantExpr($parse, scope, \textcolor{stringliteral}{'ngTrueValue'}, attr.ngTrueValue, \textcolor{keyword}{true});
  var falseValue = parseConstantExpr($parse, scope, \textcolor{stringliteral}{'ngFalseValue'}, attr.ngFalseValue, \textcolor{keyword}{false});

  var listener = \textcolor{keyword}{function}(ev) \{
    ctrl.$setViewValue(element[0].checked, ev && ev.type);
  \};

  element.on(\textcolor{stringliteral}{'click'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    element[0].checked = ctrl.$viewValue;
  \};

  \textcolor{comment}{// Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`}
  \textcolor{comment}{// This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert}
  \textcolor{comment}{// it to a boolean.}
  ctrl.$isEmpty = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} value === \textcolor{keyword}{false};
  \};

  ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} equals(value, trueValue);
  \});

  ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} value ? trueValue : falseValue;
  \});
\}


var inputDirective = [\textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$filter'}, \textcolor{stringliteral}{'$parse'},
    \textcolor{keyword}{function}($browser, $sniffer, $filter, $parse) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    require: [\textcolor{stringliteral}{'?ngModel'}],
    link: \{
      pre: \textcolor{keyword}{function}(scope, element, attr, ctrls) \{
        \textcolor{keywordflow}{if} (ctrls[0]) \{
          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
                                                              $browser, $filter, $parse);
        \}
      \}
    \}
  \};
\}];



var CONSTANT\_VALUE\_REGEXP = /^(\textcolor{keyword}{true}|\textcolor{keyword}{false}|\(\backslash\)d+)$/;
var ngValueDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    priority: 100,
    compile: \textcolor{keyword}{function}(tpl, tplAttr) \{
      \textcolor{keywordflow}{if} (CONSTANT\_VALUE\_REGEXP.test(tplAttr.ngValue)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngValueConstantLink(scope, elm, attr) \{
          attr.$set(\textcolor{stringliteral}{'value'}, scope.$eval(attr.ngValue));
        \};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngValueLink(scope, elm, attr) \{
          scope.$watch(attr.ngValue, \textcolor{keyword}{function} valueWatchAction(value) \{
            attr.$set(\textcolor{stringliteral}{'value'}, value);
          \});
        \};
      \}
    \}
  \};
\};

var ngBindDirective = [\textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($compile) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{stringliteral}{'AC'},
    compile: \textcolor{keyword}{function} ngBindCompile(templateElement) \{
      $compile.$$addBindingClass(templateElement);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindLink(scope, element, attr) \{
        $compile.$$addBindingInfo(element, attr.ngBind);
        element = element[0];
        scope.$watch(attr.ngBind, \textcolor{keyword}{function} ngBindWatchAction(value) \{
          element.textContent = value === undefined ? \textcolor{stringliteral}{''} : value;
        \});
      \};
    \}
  \};
\}];


var ngBindTemplateDirective = [\textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($interpolate, $compile) \{
  \textcolor{keywordflow}{return} \{
    compile: \textcolor{keyword}{function} ngBindTemplateCompile(templateElement) \{
      $compile.$$addBindingClass(templateElement);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindTemplateLink(scope, element, attr) \{
        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
        $compile.$$addBindingInfo(element, interpolateFn.expressions);
        element = element[0];
        attr.$observe(\textcolor{stringliteral}{'ngBindTemplate'}, \textcolor{keyword}{function}(value) \{
          element.textContent = value === undefined ? \textcolor{stringliteral}{''} : value;
        \});
      \};
    \}
  \};
\}];


var ngBindHtmlDirective = [\textcolor{stringliteral}{'$sce'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($sce, $parse, $compile) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    compile: \textcolor{keyword}{function} ngBindHtmlCompile(tElement, tAttrs) \{
      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, \textcolor{keyword}{function} getStringValue(value) \{
        \textcolor{keywordflow}{return} (value || \textcolor{stringliteral}{''}).toString();
      \});
      $compile.$$addBindingClass(tElement);

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindHtmlLink(scope, element, attr) \{
        $compile.$$addBindingInfo(element, attr.ngBindHtml);

        scope.$watch(ngBindHtmlWatch, \textcolor{keyword}{function} ngBindHtmlWatchAction() \{
          \textcolor{comment}{// we re-evaluate the expr because we want a TrustedValueHolderType}
          \textcolor{comment}{// for $sce, not a string}
          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || \textcolor{stringliteral}{''});
        \});
      \};
    \}
  \};
\}];

var ngChangeDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'A'},
  require: \textcolor{stringliteral}{'ngModel'},
  link: \textcolor{keyword}{function}(scope, element, attr, ctrl) \{
    ctrl.$viewChangeListeners.push(\textcolor{keyword}{function}() \{
      scope.$eval(attr.ngChange);
    \});
  \}
\});

\textcolor{keyword}{function} classDirective(name, selector) \{
  name = \textcolor{stringliteral}{'ngClass'} + name;
  \textcolor{keywordflow}{return} [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{stringliteral}{'AC'},
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        var oldVal;

        scope.$watch(attr[name], ngClassWatchAction, \textcolor{keyword}{true});

        attr.$observe(\textcolor{stringliteral}{'class'}, \textcolor{keyword}{function}(value) \{
          ngClassWatchAction(scope.$eval(attr[name]));
        \});


        \textcolor{keywordflow}{if} (name !== \textcolor{stringliteral}{'ngClass'}) \{
          scope.$watch(\textcolor{stringliteral}{'$index'}, \textcolor{keyword}{function}($index, old$index) \{
            \textcolor{comment}{// jshint bitwise: false}
            var mod = $index & 1;
            \textcolor{keywordflow}{if} (mod !== (old$index & 1)) \{
              var classes = arrayClasses(scope.$eval(attr[name]));
              mod === selector ?
                addClasses(classes) :
                removeClasses(classes);
            \}
          \});
        \}

        \textcolor{keyword}{function} addClasses(classes) \{
          var newClasses = digestClassCounts(classes, 1);
          attr.$addClass(newClasses);
        \}

        \textcolor{keyword}{function} removeClasses(classes) \{
          var newClasses = digestClassCounts(classes, -1);
          attr.$removeClass(newClasses);
        \}

        \textcolor{keyword}{function} digestClassCounts(classes, count) \{
          \textcolor{comment}{// Use createMap() to prevent class assumptions involving property}
          \textcolor{comment}{// names in Object.prototype}
          var classCounts = element.data(\textcolor{stringliteral}{'$classCounts'}) || createMap();
          var classesToUpdate = [];
          forEach(classes, \textcolor{keyword}{function}(className) \{
            \textcolor{keywordflow}{if} (count > 0 || classCounts[className]) \{
              classCounts[className] = (classCounts[className] || 0) + count;
              \textcolor{keywordflow}{if} (classCounts[className] === +(count > 0)) \{
                classesToUpdate.push(className);
              \}
            \}
          \});
          element.data(\textcolor{stringliteral}{'$classCounts'}, classCounts);
          \textcolor{keywordflow}{return} classesToUpdate.join(\textcolor{charliteral}{' '});
        \}

        \textcolor{keyword}{function} updateClasses(oldClasses, newClasses) \{
          var toAdd = arrayDifference(newClasses, oldClasses);
          var toRemove = arrayDifference(oldClasses, newClasses);
          toAdd = digestClassCounts(toAdd, 1);
          toRemove = digestClassCounts(toRemove, -1);
          \textcolor{keywordflow}{if} (toAdd && toAdd.length) \{
            $animate.addClass(element, toAdd);
          \}
          \textcolor{keywordflow}{if} (toRemove && toRemove.length) \{
            $animate.removeClass(element, toRemove);
          \}
        \}

        \textcolor{keyword}{function} ngClassWatchAction(newVal) \{
          \textcolor{keywordflow}{if} (selector === \textcolor{keyword}{true} || scope.$index % 2 === selector) \{
            var newClasses = arrayClasses(newVal || []);
            \textcolor{keywordflow}{if} (!oldVal) \{
              addClasses(newClasses);
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!equals(newVal,oldVal)) \{
              var oldClasses = arrayClasses(oldVal);
              updateClasses(oldClasses, newClasses);
            \}
          \}
          oldVal = shallowCopy(newVal);
        \}
      \}
    \};

    \textcolor{keyword}{function} arrayDifference(tokens1, tokens2) \{
      var values = [];

      outer:
      \textcolor{keywordflow}{for} (var i = 0; i < tokens1.length; i++) \{
        var token = tokens1[i];
        \textcolor{keywordflow}{for} (var j = 0; j < tokens2.length; j++) \{
          \textcolor{keywordflow}{if} (token == tokens2[j]) \textcolor{keywordflow}{continue} outer;
        \}
        values.push(token);
      \}
      \textcolor{keywordflow}{return} values;
    \}

    \textcolor{keyword}{function} arrayClasses(classVal) \{
      var classes = [];
      \textcolor{keywordflow}{if} (isArray(classVal)) \{
        forEach(classVal, \textcolor{keyword}{function}(v) \{
          classes = classes.concat(arrayClasses(v));
        \});
        \textcolor{keywordflow}{return} classes;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(classVal)) \{
        \textcolor{keywordflow}{return} classVal.split(\textcolor{charliteral}{' '});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(classVal)) \{
        forEach(classVal, \textcolor{keyword}{function}(v, k) \{
          \textcolor{keywordflow}{if} (v) \{
            classes = classes.concat(k.split(\textcolor{charliteral}{' '}));
          \}
        \});
        \textcolor{keywordflow}{return} classes;
      \}
      \textcolor{keywordflow}{return} classVal;
    \}
  \}];
\}

var ngClassDirective = classDirective(\textcolor{stringliteral}{''}, \textcolor{keyword}{true});

var ngClassOddDirective = classDirective(\textcolor{stringliteral}{'Odd'}, 0);

var ngClassEvenDirective = classDirective(\textcolor{stringliteral}{'Even'}, 1);

var ngCloakDirective = ngDirective(\{
  compile: \textcolor{keyword}{function}(element, attr) \{
    attr.$set(\textcolor{stringliteral}{'ngCloak'}, undefined);
    element.removeClass(\textcolor{stringliteral}{'ng-cloak'});
  \}
\});

var ngControllerDirective = [\textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    scope: \textcolor{keyword}{true},
    controller: \textcolor{charliteral}{'@'},
    priority: 500
  \};
\}];

\textcolor{comment}{// ngCsp is not implemented as a proper directive any more, because we need it be processed while we}
\textcolor{comment}{// bootstrap the system (before $parse is instantiated), for this reason we just have}
\textcolor{comment}{// the csp() fn that looks for the `ng-csp` attribute anywhere in the current doc}

\textcolor{comment}{/*}
\textcolor{comment}{ * A collection of directives that allows creation of custom event handlers that are defined as}
\textcolor{comment}{ * angular expressions and are compiled and executed within the current scope.}
\textcolor{comment}{ */}
var ngEventDirectives = \{\};

\textcolor{comment}{// For events that might fire synchronously during DOM manipulation}
\textcolor{comment}{// we need to execute their event handlers asynchronously using $evalAsync,}
\textcolor{comment}{// so that they are not executed in an inconsistent state.}
var forceAsyncEvents = \{
  \textcolor{stringliteral}{'blur'}: \textcolor{keyword}{true},
  \textcolor{stringliteral}{'focus'}: \textcolor{keyword}{true}
\};
forEach(
  \textcolor{stringliteral}{'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup
       keypress submit focus blur copy cut paste'}.split(\textcolor{charliteral}{' '}),
  \textcolor{keyword}{function}(eventName) \{
    var directiveName = directiveNormalize(\textcolor{stringliteral}{'ng-'} + eventName);
    ngEventDirectives[directiveName] = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($parse, $rootScope) \{
      \textcolor{keywordflow}{return} \{
        restrict: \textcolor{charliteral}{'A'},
        compile: \textcolor{keyword}{function}($element, attr) \{
          \textcolor{comment}{// We expose the powerful $event object on the scope that provides access to the Window,}
          \textcolor{comment}{// etc. that isn't protected by the fast paths in $parse.  We explicitly request better}
          \textcolor{comment}{// checks at the cost of speed since event handler expressions are not executed as}
          \textcolor{comment}{// frequently as regular change detection.}
          var fn = $parse(attr[directiveName], \textcolor{comment}{/* interceptorFn */} null, \textcolor{comment}{/* expensiveChecks */} \textcolor{keyword}{true});
          \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngEventHandler(scope, element) \{
            element.on(eventName, \textcolor{keyword}{function}(event) \{
              var callback = \textcolor{keyword}{function}() \{
                fn(scope, \{$event:event\});
              \};
              \textcolor{keywordflow}{if} (forceAsyncEvents[eventName] && $rootScope.$$phase) \{
                scope.$evalAsync(callback);
              \} \textcolor{keywordflow}{else} \{
                scope.$apply(callback);
              \}
            \});
          \};
        \}
      \};
    \}];
  \}
);

var ngIfDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    multiElement: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    priority: 600,
    terminal: \textcolor{keyword}{true},
    restrict: \textcolor{charliteral}{'A'},
    $$tlb: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}($scope, $element, $attr, ctrl, $transclude) \{
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, \textcolor{keyword}{function} ngIfWatchAction(value) \{

          \textcolor{keywordflow}{if} (value) \{
            \textcolor{keywordflow}{if} (!childScope) \{
              $transclude(\textcolor{keyword}{function}(clone, newScope) \{
                childScope = newScope;
                clone[clone.length++] = document.createComment(\textcolor{stringliteral}{' end ngIf: '} + $attr.ngIf + \textcolor{charliteral}{' '});
                \textcolor{comment}{// Note: We only need the first/last node of the cloned nodes.}
                \textcolor{comment}{// However, we need to keep the reference to the jqlite wrapper as it might be changed
       later}
                \textcolor{comment}{// by a directive with templateUrl when its template arrives.}
                block = \{
                  clone: clone
                \};
                $animate.enter(clone, $element.parent(), $element);
              \});
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (previousElements) \{
              previousElements.remove();
              previousElements = null;
            \}
            \textcolor{keywordflow}{if} (childScope) \{
              childScope.$destroy();
              childScope = null;
            \}
            \textcolor{keywordflow}{if} (block) \{
              previousElements = getBlockNodes(block.clone);
              $animate.leave(previousElements).then(\textcolor{keyword}{function}() \{
                previousElements = null;
              \});
              block = null;
            \}
          \}
        \});
    \}
  \};
\}];

var ngIncludeDirective = [\textcolor{stringliteral}{'$templateRequest'}, \textcolor{stringliteral}{'$anchorScroll'}, \textcolor{stringliteral}{'$animate'},
                  \textcolor{keyword}{function}($templateRequest,   $anchorScroll,   $animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{stringliteral}{'ECA'},
    priority: 400,
    terminal: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    controller: angular.noop,
    compile: \textcolor{keyword}{function}(element, attr) \{
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || \textcolor{stringliteral}{''},
          autoScrollExp = attr.autoscroll;

      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, $element, $attr, ctrl, $transclude) \{
        var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;

        var cleanupLastIncludeContent = \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (previousElement) \{
            previousElement.remove();
            previousElement = null;
          \}
          \textcolor{keywordflow}{if} (currentScope) \{
            currentScope.$destroy();
            currentScope = null;
          \}
          \textcolor{keywordflow}{if} (currentElement) \{
            $animate.leave(currentElement).then(\textcolor{keyword}{function}() \{
              previousElement = null;
            \});
            previousElement = currentElement;
            currentElement = null;
          \}
        \};

        scope.$watch(srcExp, \textcolor{keyword}{function} ngIncludeWatchAction(src) \{
          var afterAnimation = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) \{
              $anchorScroll();
            \}
          \};
          var thisChangeId = ++changeCounter;

          \textcolor{keywordflow}{if} (src) \{
            \textcolor{comment}{//set the 2nd param to true to ignore the template request error so that the inner}
            \textcolor{comment}{//contents and scope can be cleaned up.}
            $templateRequest(src, \textcolor{keyword}{true}).then(\textcolor{keyword}{function}(response) \{
              \textcolor{keywordflow}{if} (thisChangeId !== changeCounter) \textcolor{keywordflow}{return};
              var newScope = scope.$new();
              ctrl.template = response;

              \textcolor{comment}{// Note: This will also link all children of ng-include that were contained in the original}
              \textcolor{comment}{// html. If that content contains controllers, ... they could pollute/change the scope.}
              \textcolor{comment}{// However, using ng-include on an element with additional content does not make sense...}
              \textcolor{comment}{// Note: We can't remove them in the cloneAttchFn of $transclude as that}
              \textcolor{comment}{// function is called before linking the content, which would apply child}
              \textcolor{comment}{// directives to non existing elements.}
              var clone = $transclude(newScope, \textcolor{keyword}{function}(clone) \{
                cleanupLastIncludeContent();
                $animate.enter(clone, null, $element).then(afterAnimation);
              \});

              currentScope = newScope;
              currentElement = clone;

              currentScope.$emit(\textcolor{stringliteral}{'$includeContentLoaded'}, src);
              scope.$eval(onloadExp);
            \}, \textcolor{keyword}{function}() \{
              \textcolor{keywordflow}{if} (thisChangeId === changeCounter) \{
                cleanupLastIncludeContent();
                scope.$emit(\textcolor{stringliteral}{'$includeContentError'}, src);
              \}
            \});
            scope.$emit(\textcolor{stringliteral}{'$includeContentRequested'}, src);
          \} \textcolor{keywordflow}{else} \{
            cleanupLastIncludeContent();
            ctrl.template = null;
          \}
        \});
      \};
    \}
  \};
\}];

\textcolor{comment}{// This directive is called during the $transclude call of the first `ngInclude` directive.}
\textcolor{comment}{// It will replace and compile the content of the element with the loaded template.}
\textcolor{comment}{// We need this directive so that the element content is already filled when}
\textcolor{comment}{// the link function of another directive on the same element as ngInclude}
\textcolor{comment}{// is called.}
var ngIncludeFillContentDirective = [\textcolor{stringliteral}{'$compile'},
  \textcolor{keyword}{function}($compile) \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{stringliteral}{'ECA'},
      priority: -400,
      require: \textcolor{stringliteral}{'ngInclude'},
      link: \textcolor{keyword}{function}(scope, $element, $attr, ctrl) \{
        \textcolor{keywordflow}{if} (/SVG/.test($element[0].toString())) \{
          \textcolor{comment}{// WebKit: https://bugs.webkit.org/show\_bug.cgi?id=135698 --- SVG elements do not}
          \textcolor{comment}{// support innerHTML, so detect this here and try to generate the contents}
          \textcolor{comment}{// specially.}
          $element.empty();
          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
              \textcolor{keyword}{function} namespaceAdaptedClone(clone) \{
            $element.append(clone);
          \}, \{futureParentElement: $element\});
          \textcolor{keywordflow}{return};
        \}

        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      \}
    \};
  \}];

var ngInitDirective = ngDirective(\{
  priority: 450,
  compile: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      pre: \textcolor{keyword}{function}(scope, element, attrs) \{
        scope.$eval(attrs.ngInit);
      \}
    \};
  \}
\});

var ngListDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    priority: 100,
    require: \textcolor{stringliteral}{'ngModel'},
    link: \textcolor{keyword}{function}(scope, element, attr, ctrl) \{
      \textcolor{comment}{// We want to control whitespace trimming so we use this convoluted approach}
      \textcolor{comment}{// to access the ngList attribute, which doesn't pre-trim the attribute}
      var ngList = element.attr(attr.$attr.ngList) || \textcolor{stringliteral}{', '};
      var trimValues = attr.ngTrim !== \textcolor{stringliteral}{'false'};
      var separator = trimValues ? trim(ngList) : ngList;

      var parse = \textcolor{keyword}{function}(viewValue) \{
        \textcolor{comment}{// If the viewValue is invalid (say required but empty) it will be `undefined`}
        \textcolor{keywordflow}{if} (isUndefined(viewValue)) \textcolor{keywordflow}{return};

        var list = [];

        \textcolor{keywordflow}{if} (viewValue) \{
          forEach(viewValue.split(separator), \textcolor{keyword}{function}(value) \{
            \textcolor{keywordflow}{if} (value) list.push(trimValues ? trim(value) : value);
          \});
        \}

        \textcolor{keywordflow}{return} list;
      \};

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (isArray(value)) \{
          \textcolor{keywordflow}{return} value.join(ngList);
        \}

        \textcolor{keywordflow}{return} undefined;
      \});

      \textcolor{comment}{// Override the standard $isEmpty because an empty array means the input is empty.}
      ctrl.$isEmpty = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !value || !value.length;
      \};
    \}
  \};
\};

\textcolor{comment}{/* global VALID\_CLASS: true,}
\textcolor{comment}{  INVALID\_CLASS: true,}
\textcolor{comment}{  PRISTINE\_CLASS: true,}
\textcolor{comment}{  DIRTY\_CLASS: true,}
\textcolor{comment}{  UNTOUCHED\_CLASS: true,}
\textcolor{comment}{  TOUCHED\_CLASS: true,}
\textcolor{comment}{*/}

var VALID\_CLASS = \textcolor{stringliteral}{'ng-valid'},
    INVALID\_CLASS = \textcolor{stringliteral}{'ng-invalid'},
    PRISTINE\_CLASS = \textcolor{stringliteral}{'ng-pristine'},
    DIRTY\_CLASS = \textcolor{stringliteral}{'ng-dirty'},
    UNTOUCHED\_CLASS = \textcolor{stringliteral}{'ng-untouched'},
    TOUCHED\_CLASS = \textcolor{stringliteral}{'ng-touched'},
    PENDING\_CLASS = \textcolor{stringliteral}{'ng-pending'};

var ngModelMinErr = minErr(\textcolor{stringliteral}{'ngModel'});

var NgModelController = [\textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'
      $timeout'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$interpolate'},
    \textcolor{keyword}{function}($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, 
      $interpolate) \{
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$$rawModelValue = undefined; \textcolor{comment}{// stores the parsed modelValue / model set from scope regardless of
       validity.}
  this.$validators = \{\};
  this.$asyncValidators = \{\};
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$untouched = \textcolor{keyword}{true};
  this.$touched = \textcolor{keyword}{false};
  this.$pristine = \textcolor{keyword}{true};
  this.$dirty = \textcolor{keyword}{false};
  this.$valid = \textcolor{keyword}{true};
  this.$invalid = \textcolor{keyword}{false};
  this.$error = \{\}; \textcolor{comment}{// keep invalid keys here}
  this.$$success = \{\}; \textcolor{comment}{// keep valid keys here}
  this.$pending = undefined; \textcolor{comment}{// keep pending keys here}
  this.$name = $interpolate($attr.name || \textcolor{stringliteral}{''}, \textcolor{keyword}{false})($scope);


  var parsedNgModel = $parse($attr.ngModel),
      parsedNgModelAssign = parsedNgModel.assign,
      ngModelGet = parsedNgModel,
      ngModelSet = parsedNgModelAssign,
      pendingDebounce = null,
      parserValid,
      ctrl = \textcolor{keyword}{this};

  this.$$setOptions = \textcolor{keyword}{function}(options) \{
    ctrl.$options = options;
    \textcolor{keywordflow}{if} (options && options.getterSetter) \{
      var invokeModelGetter = $parse($attr.ngModel + \textcolor{stringliteral}{'()'}),
          invokeModelSetter = $parse($attr.ngModel + \textcolor{stringliteral}{'($$$p)'});

      ngModelGet = \textcolor{keyword}{function}($scope) \{
        var modelValue = parsedNgModel($scope);
        \textcolor{keywordflow}{if} (isFunction(modelValue)) \{
          modelValue = invokeModelGetter($scope);
        \}
        \textcolor{keywordflow}{return} modelValue;
      \};
      ngModelSet = \textcolor{keyword}{function}($scope, newValue) \{
        \textcolor{keywordflow}{if} (isFunction(parsedNgModel($scope))) \{
          invokeModelSetter($scope, \{$$$p: ctrl.$modelValue\});
        \} \textcolor{keywordflow}{else} \{
          parsedNgModelAssign($scope, ctrl.$modelValue);
        \}
      \};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!parsedNgModel.assign) \{
      \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'nonassign'}, \textcolor{stringliteral}{"Expression '\{0\}' is non-assignable. Element: \{1\}"},
          $attr.ngModel, startingTag($element));
    \}
  \};

  this.$render = noop;

  this.$isEmpty = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} isUndefined(value) || value === \textcolor{stringliteral}{''} || value === null || value !== value;
  \};

  var parentForm = $element.inheritedData(\textcolor{stringliteral}{'$formController'}) || nullFormCtrl,
      currentValidationRunId = 0;

  addSetValidityMethod(\{
    ctrl: \textcolor{keyword}{this},
    $element: $element,
    set: \textcolor{keyword}{function}(object, property) \{
      \textcolor{keywordtype}{object}[property] = \textcolor{keyword}{true};
    \},
    unset: \textcolor{keyword}{function}(object, property) \{
      \textcolor{keyword}{delete} \textcolor{keywordtype}{object}[property];
    \},
    parentForm: parentForm,
    $animate: $animate
  \});

  this.$setPristine = \textcolor{keyword}{function}() \{
    ctrl.$dirty = \textcolor{keyword}{false};
    ctrl.$pristine = \textcolor{keyword}{true};
    $animate.removeClass($element, DIRTY\_CLASS);
    $animate.addClass($element, PRISTINE\_CLASS);
  \};

  this.$setDirty = \textcolor{keyword}{function}() \{
    ctrl.$dirty = \textcolor{keyword}{true};
    ctrl.$pristine = \textcolor{keyword}{false};
    $animate.removeClass($element, PRISTINE\_CLASS);
    $animate.addClass($element, DIRTY\_CLASS);
    parentForm.$setDirty();
  \};

  this.$setUntouched = \textcolor{keyword}{function}() \{
    ctrl.$touched = \textcolor{keyword}{false};
    ctrl.$untouched = \textcolor{keyword}{true};
    $animate.setClass($element, UNTOUCHED\_CLASS, TOUCHED\_CLASS);
  \};

  this.$setTouched = \textcolor{keyword}{function}() \{
    ctrl.$touched = \textcolor{keyword}{true};
    ctrl.$untouched = \textcolor{keyword}{false};
    $animate.setClass($element, TOUCHED\_CLASS, UNTOUCHED\_CLASS);
  \};

  this.$rollbackViewValue = \textcolor{keyword}{function}() \{
    $timeout.cancel(pendingDebounce);
    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
    ctrl.$render();
  \};

  this.$validate = \textcolor{keyword}{function}() \{
    \textcolor{comment}{// ignore $validate before model is initialized}
    \textcolor{keywordflow}{if} (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) \{
      \textcolor{keywordflow}{return};
    \}

    var viewValue = ctrl.$$lastCommittedViewValue;
    \textcolor{comment}{// Note: we use the $$rawModelValue as $modelValue might have been}
    \textcolor{comment}{// set to undefined during a view -> model update that found validation}
    \textcolor{comment}{// errors. We can't parse the view here, since that could change}
    \textcolor{comment}{// the model although neither viewValue nor the model on the scope changed}
    var modelValue = ctrl.$$rawModelValue;

    var prevValid = ctrl.$valid;
    var prevModelValue = ctrl.$modelValue;

    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;

    ctrl.$$runValidators(modelValue, viewValue, \textcolor{keyword}{function}(allValid) \{
      \textcolor{comment}{// If there was no change in validity, don't update the model}
      \textcolor{comment}{// This prevents changing an invalid modelValue to undefined}
      \textcolor{keywordflow}{if} (!allowInvalid && prevValid !== allValid) \{
        \textcolor{comment}{// Note: Don't check ctrl.$valid here, as we could have}
        \textcolor{comment}{// external validators (e.g. calculated on the server),}
        \textcolor{comment}{// that just call $setValidity and need the model value}
        \textcolor{comment}{// to calculate their validity.}
        ctrl.$modelValue = allValid ? modelValue : undefined;

        \textcolor{keywordflow}{if} (ctrl.$modelValue !== prevModelValue) \{
          ctrl.$$writeModelToScope();
        \}
      \}
    \});

  \};

  this.$$runValidators = \textcolor{keyword}{function}(modelValue, viewValue, doneCallback) \{
    currentValidationRunId++;
    var localValidationRunId = currentValidationRunId;

    \textcolor{comment}{// check parser error}
    \textcolor{keywordflow}{if} (!processParseErrors()) \{
      validationDone(\textcolor{keyword}{false});
      \textcolor{keywordflow}{return};
    \}
    \textcolor{keywordflow}{if} (!processSyncValidators()) \{
      validationDone(\textcolor{keyword}{false});
      \textcolor{keywordflow}{return};
    \}
    processAsyncValidators();

    \textcolor{keyword}{function} processParseErrors() \{
      var errorKey = ctrl.$$parserName || \textcolor{stringliteral}{'parse'};
      \textcolor{keywordflow}{if} (parserValid === undefined) \{
        setValidity(errorKey, null);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (!parserValid) \{
          forEach(ctrl.$validators, \textcolor{keyword}{function}(v, name) \{
            setValidity(name, null);
          \});
          forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(v, name) \{
            setValidity(name, null);
          \});
        \}
        \textcolor{comment}{// Set the parse error last, to prevent unsetting it, should a $validators key == parserName}
        setValidity(errorKey, parserValid);
        \textcolor{keywordflow}{return} parserValid;
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} processSyncValidators() \{
      var syncValidatorsValid = \textcolor{keyword}{true};
      forEach(ctrl.$validators, \textcolor{keyword}{function}(validator, name) \{
        var result = validator(modelValue, viewValue);
        syncValidatorsValid = syncValidatorsValid && result;
        setValidity(name, result);
      \});
      \textcolor{keywordflow}{if} (!syncValidatorsValid) \{
        forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(v, name) \{
          setValidity(name, null);
        \});
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} processAsyncValidators() \{
      var validatorPromises = [];
      var allValid = \textcolor{keyword}{true};
      forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(validator, name) \{
        var promise = validator(modelValue, viewValue);
        if (!isPromiseLike(promise)) \{
          throw ngModelMinErr(\textcolor{stringliteral}{"$asyncValidators"},
            \textcolor{stringliteral}{"Expected asynchronous validator to return a promise but got '\{0\}' instead."}, promise);
        \}
        setValidity(name, undefined);
        validatorPromises.push(promise.then(\textcolor{keyword}{function}() \{
          setValidity(name, true);
        \}, \textcolor{keyword}{function}(error) \{
          allValid = false;
          setValidity(name, false);
        \}));
      \});
      \textcolor{keywordflow}{if} (!validatorPromises.length) \{
        validationDone(\textcolor{keyword}{true});
      \} \textcolor{keywordflow}{else} \{
        $q.all(validatorPromises).then(\textcolor{keyword}{function}() \{
          validationDone(allValid);
        \}, noop);
      \}
    \}

    \textcolor{keyword}{function} setValidity(name, isValid) \{
      \textcolor{keywordflow}{if} (localValidationRunId === currentValidationRunId) \{
        ctrl.$setValidity(name, isValid);
      \}
    \}

    \textcolor{keyword}{function} validationDone(allValid) \{
      \textcolor{keywordflow}{if} (localValidationRunId === currentValidationRunId) \{

        doneCallback(allValid);
      \}
    \}
  \};

  this.$commitViewValue = \textcolor{keyword}{function}() \{
    var viewValue = ctrl.$viewValue;

    $timeout.cancel(pendingDebounce);

    \textcolor{comment}{// If the view value has not changed then we should just exit, except in the case where there is}
    \textcolor{comment}{// a native validator on the element. In this case the validation state may have changed even though}
    \textcolor{comment}{// the viewValue has stayed empty.}
    \textcolor{keywordflow}{if} (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== \textcolor{stringliteral}{''} || !ctrl.$$hasNativeValidators)) \{
      \textcolor{keywordflow}{return};
    \}
    ctrl.$$lastCommittedViewValue = viewValue;

    \textcolor{comment}{// change to dirty}
    \textcolor{keywordflow}{if} (ctrl.$pristine) \{
      this.$setDirty();
    \}
    this.$$parseAndValidate();
  \};

  this.$$parseAndValidate = \textcolor{keyword}{function}() \{
    var viewValue = ctrl.$$lastCommittedViewValue;
    var modelValue = viewValue;
    parserValid = isUndefined(modelValue) ? undefined : \textcolor{keyword}{true};

    \textcolor{keywordflow}{if} (parserValid) \{
      \textcolor{keywordflow}{for} (var i = 0; i < ctrl.$parsers.length; i++) \{
        modelValue = ctrl.$parsers[i](modelValue);
        \textcolor{keywordflow}{if} (isUndefined(modelValue)) \{
          parserValid = \textcolor{keyword}{false};
          \textcolor{keywordflow}{break};
        \}
      \}
    \}
    \textcolor{keywordflow}{if} (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) \{
      \textcolor{comment}{// ctrl.$modelValue has not been touched yet...}
      ctrl.$modelValue = ngModelGet($scope);
    \}
    var prevModelValue = ctrl.$modelValue;
    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
    ctrl.$$rawModelValue = modelValue;

    \textcolor{keywordflow}{if} (allowInvalid) \{
      ctrl.$modelValue = modelValue;
      writeToModelIfNeeded();
    \}

    \textcolor{comment}{// Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.}
    \textcolor{comment}{// This can happen if e.g. $setViewValue is called from inside a parser}
    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, \textcolor{keyword}{function}(allValid) \{
      if (!allowInvalid) \{
        \textcolor{comment}{// Note: Don't check ctrl.$valid here, as we could have}
        \textcolor{comment}{// external validators (e.g. calculated on the server),}
        \textcolor{comment}{// that just call $setValidity and need the model value}
        \textcolor{comment}{// to calculate their validity.}
        ctrl.$modelValue = allValid ? modelValue : undefined;
        writeToModelIfNeeded();
      \}
    \});

    \textcolor{keyword}{function} writeToModelIfNeeded() \{
      \textcolor{keywordflow}{if} (ctrl.$modelValue !== prevModelValue) \{
        ctrl.$$writeModelToScope();
      \}
    \}
  \};

  this.$$writeModelToScope = \textcolor{keyword}{function}() \{
    ngModelSet($scope, ctrl.$modelValue);
    forEach(ctrl.$viewChangeListeners, \textcolor{keyword}{function}(listener) \{
      try \{
        listener();
      \} catch (e) \{
        $exceptionHandler(e);
      \}
    \});
  \};

  this.$setViewValue = \textcolor{keyword}{function}(value, trigger) \{
    ctrl.$viewValue = value;
    \textcolor{keywordflow}{if} (!ctrl.$options || ctrl.$options.updateOnDefault) \{
      ctrl.$$debounceViewValueCommit(trigger);
    \}
  \};

  this.$$debounceViewValueCommit = \textcolor{keyword}{function}(trigger) \{
    var debounceDelay = 0,
        options = ctrl.$options,
        debounce;

    \textcolor{keywordflow}{if} (options && isDefined(options.debounce)) \{
      debounce = options.debounce;
      \textcolor{keywordflow}{if} (isNumber(debounce)) \{
        debounceDelay = debounce;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isNumber(debounce[trigger])) \{
        debounceDelay = debounce[trigger];
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isNumber(debounce[\textcolor{stringliteral}{'default'}])) \{
        debounceDelay = debounce[\textcolor{stringliteral}{'default'}];
      \}
    \}

    $timeout.cancel(pendingDebounce);
    \textcolor{keywordflow}{if} (debounceDelay) \{
      pendingDebounce = $timeout(\textcolor{keyword}{function}() \{
        ctrl.$commitViewValue();
      \}, debounceDelay);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ($rootScope.$$phase) \{
      ctrl.$commitViewValue();
    \} \textcolor{keywordflow}{else} \{
      $scope.$apply(\textcolor{keyword}{function}() \{
        ctrl.$commitViewValue();
      \});
    \}
  \};

  \textcolor{comment}{// model -> value}
  \textcolor{comment}{// Note: we cannot use a normal scope.$watch as we want to detect the following:}
  \textcolor{comment}{// 1. scope value is 'a'}
  \textcolor{comment}{// 2. user enters 'b'}
  \textcolor{comment}{// 3. ng-change kicks in and reverts scope value to 'a'}
  \textcolor{comment}{//    -> scope value did not change since the last digest as}
  \textcolor{comment}{//       ng-change executes in apply phase}
  \textcolor{comment}{// 4. view should be changed back to 'a'}
  $scope.$watch(\textcolor{keyword}{function} ngModelWatch() \{
    var modelValue = ngModelGet($scope);

    \textcolor{comment}{// if scope model value and ngModel value are out of sync}
    \textcolor{comment}{// TODO(perf): why not move this to the action fn?}
    \textcolor{keywordflow}{if} (modelValue !== ctrl.$modelValue &&
       \textcolor{comment}{// checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator}
       (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
    ) \{
      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
      parserValid = undefined;

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      var viewValue = modelValue;
      \textcolor{keywordflow}{while} (idx--) \{
        viewValue = formatters[idx](viewValue);
      \}
      \textcolor{keywordflow}{if} (ctrl.$viewValue !== viewValue) \{
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
        ctrl.$render();

        ctrl.$$runValidators(modelValue, viewValue, noop);
      \}
    \}

    \textcolor{keywordflow}{return} modelValue;
  \});
\}];


var ngModelDirective = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($rootScope) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: [\textcolor{stringliteral}{'ngModel'}, \textcolor{stringliteral}{'^?form'}, \textcolor{stringliteral}{'^?ngModelOptions'}],
    controller: NgModelController,
    \textcolor{comment}{// Prelink needs to run before any input directive}
    \textcolor{comment}{// so that we can set the NgModelOptions in NgModelController}
    \textcolor{comment}{// before anyone else uses it.}
    priority: 1,
    compile: \textcolor{keyword}{function} ngModelCompile(element) \{
      \textcolor{comment}{// Setup initial state of the control}
      element.addClass(PRISTINE\_CLASS).addClass(UNTOUCHED\_CLASS).addClass(VALID\_CLASS);

      \textcolor{keywordflow}{return} \{
        pre: \textcolor{keyword}{function} ngModelPreLink(scope, element, attr, ctrls) \{
          var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || nullFormCtrl;

          modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);

          \textcolor{comment}{// notify others, especially parent forms}
          formCtrl.$addControl(modelCtrl);

          attr.$observe(\textcolor{stringliteral}{'name'}, \textcolor{keyword}{function}(newValue) \{
            \textcolor{keywordflow}{if} (modelCtrl.$name !== newValue) \{
              formCtrl.$$renameControl(modelCtrl, newValue);
            \}
          \});

          scope.$on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
            formCtrl.$removeControl(modelCtrl);
          \});
        \},
        post: \textcolor{keyword}{function} ngModelPostLink(scope, element, attr, ctrls) \{
          var modelCtrl = ctrls[0];
          \textcolor{keywordflow}{if} (modelCtrl.$options && modelCtrl.$options.updateOn) \{
            element.on(modelCtrl.$options.updateOn, \textcolor{keyword}{function}(ev) \{
              modelCtrl.$$debounceViewValueCommit(ev && ev.type);
            \});
          \}

          element.on(\textcolor{stringliteral}{'blur'}, \textcolor{keyword}{function}(ev) \{
            \textcolor{keywordflow}{if} (modelCtrl.$touched) \textcolor{keywordflow}{return};

            if ($rootScope.$$phase) \{
              scope.$evalAsync(modelCtrl.$setTouched);
            \} \textcolor{keywordflow}{else} \{
              scope.$apply(modelCtrl.$setTouched);
            \}
          \});
        \}
      \};
    \}
  \};
\}];

var DEFAULT\_REGEXP = /(\(\backslash\)s+|^)\textcolor{keywordflow}{default}(\(\backslash\)s+|$)/;

var ngModelOptionsDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    controller: [\textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{keyword}{function}($scope, $attrs) \{
      var that = \textcolor{keyword}{this};
      this.$options = copy($scope.$eval($attrs.ngModelOptions));
      \textcolor{comment}{// Allow adding/overriding bound events}
      \textcolor{keywordflow}{if} (this.$options.updateOn !== undefined) \{
        this.$options.updateOnDefault = \textcolor{keyword}{false};
        \textcolor{comment}{// extract "default" pseudo-event from list of events that can trigger a model update}
        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT\_REGEXP, \textcolor{keyword}{function}() \{
          that.$options.updateOnDefault = true;
          return \textcolor{stringliteral}{' '};
        \}));
      \} \textcolor{keywordflow}{else} \{
        this.$options.updateOnDefault = \textcolor{keyword}{true};
      \}
    \}]
  \};
\};



\textcolor{comment}{// helper methods}
\textcolor{keyword}{function} addSetValidityMethod(context) \{
  var ctrl = context.ctrl,
      $element = context.$element,
      classCache = \{\},
      set = context.set,
      unset = context.unset,
      parentForm = context.parentForm,
      $animate = context.$animate;

  classCache[INVALID\_CLASS] = !(classCache[VALID\_CLASS] = $element.hasClass(VALID\_CLASS));

  ctrl.$setValidity = setValidity;

  \textcolor{keyword}{function} setValidity(validationErrorKey, state, controller) \{
    \textcolor{keywordflow}{if} (state === undefined) \{
      createAndSet(\textcolor{stringliteral}{'$pending'}, validationErrorKey, controller);
    \} \textcolor{keywordflow}{else} \{
      unsetAndCleanup(\textcolor{stringliteral}{'$pending'}, validationErrorKey, controller);
    \}
    \textcolor{keywordflow}{if} (!isBoolean(state)) \{
      unset(ctrl.$error, validationErrorKey, controller);
      unset(ctrl.$$success, validationErrorKey, controller);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (state) \{
        unset(ctrl.$error, validationErrorKey, controller);
        set(ctrl.$$success, validationErrorKey, controller);
      \} \textcolor{keywordflow}{else} \{
        set(ctrl.$error, validationErrorKey, controller);
        unset(ctrl.$$success, validationErrorKey, controller);
      \}
    \}
    \textcolor{keywordflow}{if} (ctrl.$pending) \{
      cachedToggleClass(PENDING\_CLASS, \textcolor{keyword}{true});
      ctrl.$valid = ctrl.$invalid = undefined;
      toggleValidationCss(\textcolor{stringliteral}{''}, null);
    \} \textcolor{keywordflow}{else} \{
      cachedToggleClass(PENDING\_CLASS, \textcolor{keyword}{false});
      ctrl.$valid = isObjectEmpty(ctrl.$error);
      ctrl.$invalid = !ctrl.$valid;
      toggleValidationCss(\textcolor{stringliteral}{''}, ctrl.$valid);
    \}

    \textcolor{comment}{// re-read the state as the set/unset methods could have}
    \textcolor{comment}{// combined state in ctrl.$error[validationError] (used for forms),}
    \textcolor{comment}{// where setting/unsetting only increments/decrements the value,}
    \textcolor{comment}{// and does not replace it.}
    var combinedState;
    \textcolor{keywordflow}{if} (ctrl.$pending && ctrl.$pending[validationErrorKey]) \{
      combinedState = undefined;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ctrl.$error[validationErrorKey]) \{
      combinedState = \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ctrl.$$success[validationErrorKey]) \{
      combinedState = \textcolor{keyword}{true};
    \} \textcolor{keywordflow}{else} \{
      combinedState = null;
    \}

    toggleValidationCss(validationErrorKey, combinedState);
    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
  \}

  \textcolor{keyword}{function} createAndSet(name, value, controller) \{
    \textcolor{keywordflow}{if} (!ctrl[name]) \{
      ctrl[name] = \{\};
    \}
    set(ctrl[name], value, controller);
  \}

  \textcolor{keyword}{function} unsetAndCleanup(name, value, controller) \{
    \textcolor{keywordflow}{if} (ctrl[name]) \{
      unset(ctrl[name], value, controller);
    \}
    \textcolor{keywordflow}{if} (isObjectEmpty(ctrl[name])) \{
      ctrl[name] = undefined;
    \}
  \}

  \textcolor{keyword}{function} cachedToggleClass(className, switchValue) \{
    \textcolor{keywordflow}{if} (switchValue && !classCache[className]) \{
      $animate.addClass($element, className);
      classCache[className] = \textcolor{keyword}{true};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!switchValue && classCache[className]) \{
      $animate.removeClass($element, className);
      classCache[className] = \textcolor{keyword}{false};
    \}
  \}

  \textcolor{keyword}{function} toggleValidationCss(validationErrorKey, isValid) \{
    validationErrorKey = validationErrorKey ? \textcolor{charliteral}{'-'} + snake\_case(validationErrorKey, \textcolor{charliteral}{'-'}) : \textcolor{stringliteral}{''};

    cachedToggleClass(VALID\_CLASS + validationErrorKey, isValid === \textcolor{keyword}{true});
    cachedToggleClass(INVALID\_CLASS + validationErrorKey, isValid === \textcolor{keyword}{false});
  \}
\}

\textcolor{keyword}{function} isObjectEmpty(obj) \{
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{for} (var prop in obj) \{
      \textcolor{keywordflow}{if} (obj.hasOwnProperty(prop)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
    \}
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}

var ngNonBindableDirective = ngDirective(\{ terminal: \textcolor{keyword}{true}, priority: 1000 \});

\textcolor{comment}{/* global jqLiteRemove */}

var ngOptionsMinErr = minErr(\textcolor{stringliteral}{'ngOptions'});

\textcolor{comment}{// jshint maxlen: false}
\textcolor{comment}{//                    
       //00001111111111000000000002222222222000000000000000000000333333333300000000000000000
      000000004444444444400000000000005555555555555550000000006666666666666660000000777777777777777000000000000000888888888800000000000000000009999999999}
var NG\_OPTIONS\_REGEXP = /^\(\backslash\)s*([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+as\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+group\(\backslash\)s+by\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+disable\(\backslash\)
      s+when\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?\(\backslash\)s+\textcolor{keywordflow}{for}\(\backslash\)s+(?:([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)|(?:\(\backslash\)(\(\backslash\)s*([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)\(\backslash\)s*,\(\backslash\)s*([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)\(\backslash\)s*\(\backslash\))))\(\backslash\)s+in\(\backslash\)s
      +([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+track\(\backslash\)s+by\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?$/;
                        \textcolor{comment}{// 1: value expression (valueFn)}
                        \textcolor{comment}{// 2: label expression (displayFn)}
                        \textcolor{comment}{// 3: group by expression (groupByFn)}
                        \textcolor{comment}{// 4: disable when expression (disableWhenFn)}
                        \textcolor{comment}{// 5: array item variable name}
                        \textcolor{comment}{// 6: object item key variable name}
                        \textcolor{comment}{// 7: object item value variable name}
                        \textcolor{comment}{// 8: collection expression}
                        \textcolor{comment}{// 9: track by expression}
\textcolor{comment}{// jshint maxlen: 100}


var ngOptionsDirective = [\textcolor{stringliteral}{'$compile'}, \textcolor{stringliteral}{'$parse'}, \textcolor{keyword}{function}($compile, $parse) \{

  \textcolor{keyword}{function} parseOptionsExpression(optionsExp, selectElement, scope) \{

    var match = optionsExp.match(NG\_OPTIONS\_REGEXP);
    \textcolor{keywordflow}{if} (!(match)) \{
      \textcolor{keywordflow}{throw} ngOptionsMinErr(\textcolor{stringliteral}{'iexp'},
        \textcolor{stringliteral}{"Expected expression in form of "} +
        \textcolor{stringliteral}{"'\_select\_ (as \_label\_)? for (\_key\_,)?\_value\_ in \_collection\_'"} +
        \textcolor{stringliteral}{" but got '\{0\}'. Element: \{1\}"},
        optionsExp, startingTag(selectElement));
    \}

    \textcolor{comment}{// Extract the parts from the ngOptions expression}

    \textcolor{comment}{// The variable name for the value of the item in the collection}
    var valueName = match[5] || match[7];
    \textcolor{comment}{// The variable name for the key of the item in the collection}
    var keyName = match[6];

    \textcolor{comment}{// An expression that generates the viewValue for an option if there is a label expression}
    var selectAs = / as /.test(match[0]) && match[1];
    \textcolor{comment}{// An expression that is used to track the id of each object in the options collection}
    var trackBy = match[9];
    \textcolor{comment}{// An expression that generates the viewValue for an option if there is no label expression}
    var valueFn = $parse(match[2] ? match[1] : valueName);
    var selectAsFn = selectAs && $parse(selectAs);
    var viewValueFn = selectAsFn || valueFn;
    var trackByFn = trackBy && $parse(trackBy);

    \textcolor{comment}{// Get the value by which we are going to track the option}
    \textcolor{comment}{// if we have a trackFn then use that (passing scope and locals)}
    \textcolor{comment}{// otherwise just hash the given viewValue}
    var getTrackByValueFn = trackBy ?
                              \textcolor{keyword}{function}(value, locals) \{ \textcolor{keywordflow}{return} trackByFn(scope, locals); \} :
                              \textcolor{keyword}{function} getHashOfValue(value) \{ \textcolor{keywordflow}{return} hashKey(value); \};
    var getTrackByValue = \textcolor{keyword}{function}(value, key) \{
      \textcolor{keywordflow}{return} getTrackByValueFn(value, getLocals(value, key));
    \};

    var displayFn = $parse(match[2] || match[1]);
    var groupByFn = $parse(match[3] || \textcolor{stringliteral}{''});
    var disableWhenFn = $parse(match[4] || \textcolor{stringliteral}{''});
    var valuesFn = $parse(match[8]);

    var locals = \{\};
    var getLocals = keyName ? \textcolor{keyword}{function}(value, key) \{
      locals[keyName] = key;
      locals[valueName] = value;
      \textcolor{keywordflow}{return} locals;
    \} : \textcolor{keyword}{function}(value) \{
      locals[valueName] = value;
      \textcolor{keywordflow}{return} locals;
    \};


    \textcolor{keyword}{function} Option(selectValue, viewValue, label, group, disabled) \{
      this.selectValue = selectValue;
      this.viewValue = viewValue;
      this.label = label;
      this.group = group;
      this.disabled = disabled;
    \}

    \textcolor{keyword}{function} getOptionValuesKeys(optionValues) \{
      var optionValuesKeys;

      \textcolor{keywordflow}{if} (!keyName && isArrayLike(optionValues)) \{
        optionValuesKeys = optionValues;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// if object, extract keys, in enumeration order, unsorted}
        optionValuesKeys = [];
        \textcolor{keywordflow}{for} (var itemKey in optionValues) \{
          \textcolor{keywordflow}{if} (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== \textcolor{charliteral}{'$'}) \{
            optionValuesKeys.push(itemKey);
          \}
        \}
      \}
      \textcolor{keywordflow}{return} optionValuesKeys;
    \}

    \textcolor{keywordflow}{return} \{
      trackBy: trackBy,
      getTrackByValue: getTrackByValue,
      getWatchables: $parse(valuesFn, \textcolor{keyword}{function}(optionValues) \{
        \textcolor{comment}{// Create a collection of things that we would like to watch (watchedArray)}
        \textcolor{comment}{// so that they can all be watched using a single $watchCollection}
        \textcolor{comment}{// that only runs the handler once if anything changes}
        var watchedArray = [];
        optionValues = optionValues || [];

        var optionValuesKeys = getOptionValuesKeys(optionValues);
        var optionValuesLength = optionValuesKeys.length;
        \textcolor{keywordflow}{for} (var index = 0; index < optionValuesLength; index++) \{
          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
          var value = optionValues[key];

          var locals = getLocals(optionValues[key], key);
          var selectValue = getTrackByValueFn(optionValues[key], locals);
          watchedArray.push(selectValue);

          \textcolor{comment}{// Only need to watch the displayFn if there is a specific label expression}
          \textcolor{keywordflow}{if} (match[2] || match[1]) \{
            var label = displayFn(scope, locals);
            watchedArray.push(label);
          \}

          \textcolor{comment}{// Only need to watch the disableWhenFn if there is a specific disable expression}
          \textcolor{keywordflow}{if} (match[4]) \{
            var disableWhen = disableWhenFn(scope, locals);
            watchedArray.push(disableWhen);
          \}
        \}
        \textcolor{keywordflow}{return} watchedArray;
      \}),

      getOptions: \textcolor{keyword}{function}() \{

        var optionItems = [];
        var selectValueMap = \{\};

        \textcolor{comment}{// The option values were already computed in the `getWatchables` fn,}
        \textcolor{comment}{// which must have been called to trigger `getOptions`}
        var optionValues = valuesFn(scope) || [];
        var optionValuesKeys = getOptionValuesKeys(optionValues);
        var optionValuesLength = optionValuesKeys.length;

        \textcolor{keywordflow}{for} (var index = 0; index < optionValuesLength; index++) \{
          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
          var value = optionValues[key];
          var locals = getLocals(value, key);
          var viewValue = viewValueFn(scope, locals);
          var selectValue = getTrackByValueFn(viewValue, locals);
          var label = displayFn(scope, locals);
          var group = groupByFn(scope, locals);
          var disabled = disableWhenFn(scope, locals);
          var optionItem = \textcolor{keyword}{new} Option(selectValue, viewValue, label, group, disabled);

          optionItems.push(optionItem);
          selectValueMap[selectValue] = optionItem;
        \}

        \textcolor{keywordflow}{return} \{
          items: optionItems,
          selectValueMap: selectValueMap,
          getOptionFromViewValue: \textcolor{keyword}{function}(value) \{
            \textcolor{keywordflow}{return} selectValueMap[getTrackByValue(value)];
          \},
          getViewValueFromOption: \textcolor{keyword}{function}(option) \{
            \textcolor{comment}{// If the viewValue could be an object that may be mutated by the application,}
            \textcolor{comment}{// we need to make a copy and not return the reference to the value on the option.}
            \textcolor{keywordflow}{return} trackBy ? angular.copy(option.viewValue) : option.viewValue;
          \}
        \};
      \}
    \};
  \}


  \textcolor{comment}{// we can't just jqLite('<option>') since jqLite is not smart enough}
  \textcolor{comment}{// to create it in <select> and IE barfs otherwise.}
  var optionTemplate = document.createElement(\textcolor{stringliteral}{'option'}),
      optGroupTemplate = document.createElement(\textcolor{stringliteral}{'optgroup'});

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    terminal: \textcolor{keyword}{true},
    require: [\textcolor{stringliteral}{'select'}, \textcolor{stringliteral}{'?ngModel'}],
    link: \textcolor{keyword}{function}(scope, selectElement, attr, ctrls) \{

      \textcolor{comment}{// if ngModel is not defined, we don't need to do anything}
      var ngModelCtrl = ctrls[1];
      \textcolor{keywordflow}{if} (!ngModelCtrl) \textcolor{keywordflow}{return};

      var selectCtrl = ctrls[0];
      var multiple = attr.multiple;

      \textcolor{comment}{// The emptyOption allows the application developer to provide their own custom "empty"}
      \textcolor{comment}{// option when the viewValue does not match any of the option values.}
      var emptyOption;
      \textcolor{keywordflow}{for} (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) \{
        \textcolor{keywordflow}{if} (children[i].value === \textcolor{stringliteral}{''}) \{
          emptyOption = children.eq(i);
          \textcolor{keywordflow}{break};
        \}
      \}

      var providedEmptyOption = !!emptyOption;

      var unknownOption = jqLite(optionTemplate.cloneNode(\textcolor{keyword}{false}));
      unknownOption.val(\textcolor{charliteral}{'?'});

      var options;
      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);


      var renderEmptyOption = \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!providedEmptyOption) \{
          selectElement.prepend(emptyOption);
        \}
        selectElement.val(\textcolor{stringliteral}{''});
        emptyOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// needed for IE}
        emptyOption.attr(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true});
      \};

      var removeEmptyOption = \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!providedEmptyOption) \{
          emptyOption.remove();
        \}
      \};


      var renderUnknownOption = \textcolor{keyword}{function}() \{
        selectElement.prepend(unknownOption);
        selectElement.val(\textcolor{charliteral}{'?'});
        unknownOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// needed for IE}
        unknownOption.attr(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true});
      \};

      var removeUnknownOption = \textcolor{keyword}{function}() \{
        unknownOption.remove();
      \};


      \textcolor{comment}{// Update the controller methods for multiple selectable options}
      \textcolor{keywordflow}{if} (!multiple) \{

        selectCtrl.writeValue = \textcolor{keyword}{function} writeNgOptionsValue(value) \{
          var option = options.getOptionFromViewValue(value);

          \textcolor{keywordflow}{if} (option && !option.disabled) \{
            \textcolor{keywordflow}{if} (selectElement[0].value !== option.selectValue) \{
              removeUnknownOption();
              removeEmptyOption();

              selectElement[0].value = option.selectValue;
              option.element.selected = \textcolor{keyword}{true};
              option.element.setAttribute(\textcolor{stringliteral}{'selected'}, \textcolor{stringliteral}{'selected'});
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (value === null || providedEmptyOption) \{
              removeUnknownOption();
              renderEmptyOption();
            \} \textcolor{keywordflow}{else} \{
              removeEmptyOption();
              renderUnknownOption();
            \}
          \}
        \};

        selectCtrl.readValue = \textcolor{keyword}{function} readNgOptionsValue() \{

          var selectedOption = options.selectValueMap[selectElement.val()];

          \textcolor{keywordflow}{if} (selectedOption && !selectedOption.disabled) \{
            removeEmptyOption();
            removeUnknownOption();
            \textcolor{keywordflow}{return} options.getViewValueFromOption(selectedOption);
          \}
          \textcolor{keywordflow}{return} null;
        \};

        \textcolor{comment}{// If we are using `track by` then we must watch the tracked value on the model}
        \textcolor{comment}{// since ngModel only watches for object identity change}
        \textcolor{keywordflow}{if} (ngOptions.trackBy) \{
          scope.$watch(
            \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} ngOptions.getTrackByValue(ngModelCtrl.$viewValue); \},
            \textcolor{keyword}{function}() \{ ngModelCtrl.$render(); \}
          );
        \}

      \} \textcolor{keywordflow}{else} \{

        ngModelCtrl.$isEmpty = \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} !value || value.length === 0;
        \};


        selectCtrl.writeValue = \textcolor{keyword}{function} writeNgOptionsMultiple(value) \{
          options.items.forEach(\textcolor{keyword}{function}(option) \{
            option.element.selected = \textcolor{keyword}{false};
          \});

          \textcolor{keywordflow}{if} (value) \{
            value.forEach(\textcolor{keyword}{function}(item) \{
              var option = options.getOptionFromViewValue(item);
              \textcolor{keywordflow}{if} (option && !option.disabled) option.element.selected = \textcolor{keyword}{true};
            \});
          \}
        \};


        selectCtrl.readValue = \textcolor{keyword}{function} readNgOptionsMultiple() \{
          var selectedValues = selectElement.val() || [],
              selections = [];

          forEach(selectedValues, \textcolor{keyword}{function}(value) \{
            var option = options.selectValueMap[value];
            \textcolor{keywordflow}{if} (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
          \});

          \textcolor{keywordflow}{return} selections;
        \};

        \textcolor{comment}{// If we are using `track by` then we must watch these tracked values on the model}
        \textcolor{comment}{// since ngModel only watches for object identity change}
        \textcolor{keywordflow}{if} (ngOptions.trackBy) \{

          scope.$watchCollection(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isArray(ngModelCtrl.$viewValue)) \{
              return ngModelCtrl.$viewValue.map(function(value) \{
                return ngOptions.getTrackByValue(value);
              \});
            \}
          \}, \textcolor{keyword}{function}() \{
            ngModelCtrl.$render();
          \});

        \}
      \}


      \textcolor{keywordflow}{if} (providedEmptyOption) \{

        \textcolor{comment}{// we need to remove it before calling selectElement.empty() because otherwise IE will}
        \textcolor{comment}{// remove the label from the element. wtf?}
        emptyOption.remove();

        \textcolor{comment}{// compile the element since there might be bindings in it}
        $compile(emptyOption)(scope);

        \textcolor{comment}{// remove the class, which is added automatically because we recompile the element and it}
        \textcolor{comment}{// becomes the compilation root}
        emptyOption.removeClass(\textcolor{stringliteral}{'ng-scope'});
      \} \textcolor{keywordflow}{else} \{
        emptyOption = jqLite(optionTemplate.cloneNode(\textcolor{keyword}{false}));
      \}

      \textcolor{comment}{// We need to do this here to ensure that the options object is defined}
      \textcolor{comment}{// when we first hit it in writeNgOptionsValue}
      updateOptions();

      \textcolor{comment}{// We will re-render the option elements if the option values or labels change}
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);

      \textcolor{comment}{// ------------------------------------------------------------------ //}


      \textcolor{keyword}{function} updateOptionElement(option, element) \{
        option.element = element;
        element.disabled = option.disabled;
        \textcolor{keywordflow}{if} (option.value !== element.value) element.value = option.selectValue;
        \textcolor{keywordflow}{if} (option.label !== element.label) \{
          element.label = option.label;
          element.textContent = option.label;
        \}
      \}

      \textcolor{keyword}{function} addOrReuseElement(parent, current, type, templateElement) \{
        var element;
        \textcolor{comment}{// Check whether we can reuse the next element}
        \textcolor{keywordflow}{if} (current && lowercase(current.nodeName) === type) \{
          \textcolor{comment}{// The next element is the right type so reuse it}
          element = current;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// The next element is not the right type so create a new one}
          element = templateElement.cloneNode(\textcolor{keyword}{false});
          \textcolor{keywordflow}{if} (!current) \{
            \textcolor{comment}{// There are no more elements so just append it to the select}
            parent.appendChild(element);
          \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// The next element is not a group so insert the new one}
            parent.insertBefore(element, current);
          \}
        \}
        \textcolor{keywordflow}{return} element;
      \}


      \textcolor{keyword}{function} removeExcessElements(current) \{
        var next;
        \textcolor{keywordflow}{while} (current) \{
          next = current.nextSibling;
          jqLiteRemove(current);
          current = next;
        \}
      \}


      \textcolor{keyword}{function} skipEmptyAndUnknownOptions(current) \{
        var emptyOption\_ = emptyOption && emptyOption[0];
        var unknownOption\_ = unknownOption && unknownOption[0];

        \textcolor{keywordflow}{if} (emptyOption\_ || unknownOption\_) \{
          \textcolor{keywordflow}{while} (current &&
                (current === emptyOption\_ ||
                current === unknownOption\_)) \{
            current = current.nextSibling;
          \}
        \}
        \textcolor{keywordflow}{return} current;
      \}


      \textcolor{keyword}{function} updateOptions() \{

        var previousValue = options && selectCtrl.readValue();

        options = ngOptions.getOptions();

        var groupMap = \{\};
        var currentElement = selectElement[0].firstChild;

        \textcolor{comment}{// Ensure that the empty option is always there if it was explicitly provided}
        \textcolor{keywordflow}{if} (providedEmptyOption) \{
          selectElement.prepend(emptyOption);
        \}

        currentElement = skipEmptyAndUnknownOptions(currentElement);

        options.items.forEach(\textcolor{keyword}{function} updateOption(option) \{
          var group;
          var groupElement;
          var optionElement;

          \textcolor{keywordflow}{if} (option.group) \{

            \textcolor{comment}{// This option is to live in a group}
            \textcolor{comment}{// See if we have already created this group}
            group = groupMap[option.group];

            if (!group) \{

              \textcolor{comment}{// We have not already created this group}
              groupElement = addOrReuseElement(selectElement[0],
                                               currentElement,
                                               \textcolor{stringliteral}{'optgroup'},
                                               optGroupTemplate);
              \textcolor{comment}{// Move to the next element}
              currentElement = groupElement.nextSibling;

              \textcolor{comment}{// Update the label on the group element}
              groupElement.label = option.group;

              \textcolor{comment}{// Store it for use later}
              group = groupMap[option.group] = \{
                groupElement: groupElement,
                currentOptionElement: groupElement.firstChild
              \};

            \}

            \textcolor{comment}{// So now we have a group for this option we add the option to the group}
            optionElement = addOrReuseElement(group.groupElement,
                                              group.currentOptionElement,
                                              \textcolor{stringliteral}{'option'},
                                              optionTemplate);
            updateOptionElement(option, optionElement);
            \textcolor{comment}{// Move to the next element}
            group.currentOptionElement = optionElement.nextSibling;

          \} \textcolor{keywordflow}{else} \{

            \textcolor{comment}{// This option is not in a group}
            optionElement = addOrReuseElement(selectElement[0],
                                              currentElement,
                                              \textcolor{stringliteral}{'option'},
                                              optionTemplate);
            updateOptionElement(option, optionElement);
            \textcolor{comment}{// Move to the next element}
            currentElement = optionElement.nextSibling;
          \}
        \});


        \textcolor{comment}{// Now remove all excess options and group}
        Object.keys(groupMap).forEach(\textcolor{keyword}{function}(key) \{
          removeExcessElements(groupMap[key].currentOptionElement);
        \});
        removeExcessElements(currentElement);

        ngModelCtrl.$render();

        \textcolor{comment}{// Check to see if the value has changed due to the update to the options}
        \textcolor{keywordflow}{if} (!ngModelCtrl.$isEmpty(previousValue)) \{
          var nextValue = selectCtrl.readValue();
          \textcolor{keywordflow}{if} (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) \{
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          \}
        \}

      \}

    \}
  \};
\}];

var ngPluralizeDirective = [\textcolor{stringliteral}{'$locale'}, \textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$log'}, \textcolor{keyword}{function}($locale, $interpolate, $log) \{
  var BRACE = /\{\}/g,
      IS\_WHEN = /^when(Minus)?(.+)$/;

  \textcolor{keywordflow}{return} \{
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when), \textcolor{comment}{// we have \{\{\}\} in attrs}
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || \{\},
          whensExpFns = \{\},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          braceReplacement = startSymbol + numberExp + \textcolor{charliteral}{'-'} + offset + endSymbol,
          watchRemover = angular.noop,
          lastCount;

      forEach(attr, \textcolor{keyword}{function}(expression, attributeName) \{
        var tmpMatch = IS\_WHEN.exec(attributeName);
        \textcolor{keywordflow}{if} (tmpMatch) \{
          var whenKey = (tmpMatch[1] ? \textcolor{charliteral}{'-'} : \textcolor{stringliteral}{''}) + lowercase(tmpMatch[2]);
          whens[whenKey] = element.attr(attr.$attr[attributeName]);
        \}
      \});
      forEach(whens, \textcolor{keyword}{function}(expression, key) \{
        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));

      \});

      scope.$watch(numberExp, \textcolor{keyword}{function} ngPluralizeWatchAction(newVal) \{
        var count = parseFloat(newVal);
        var countIsNaN = isNaN(count);

        \textcolor{keywordflow}{if} (!countIsNaN && !(count in whens)) \{
          \textcolor{comment}{// If an explicit number rule such as 1, 2, 3... is defined, just use it.}
          \textcolor{comment}{// Otherwise, check it against pluralization rules in $locale service.}
          count = $locale.pluralCat(count - offset);
        \}

        \textcolor{comment}{// If both `count` and `lastCount` are NaN, we don't need to re-register a watch.}
        \textcolor{comment}{// In JS `NaN !== NaN`, so we have to exlicitly check.}
        \textcolor{keywordflow}{if} ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) \{
          watchRemover();
          var whenExpFn = whensExpFns[count];
          \textcolor{keywordflow}{if} (isUndefined(whenExpFn)) \{
            \textcolor{keywordflow}{if} (newVal != null) \{
              $log.debug(\textcolor{stringliteral}{"ngPluralize: no rule defined for '"} + count + \textcolor{stringliteral}{"' in "} + whenExp);
            \}
            watchRemover = noop;
            updateElementText();
          \} \textcolor{keywordflow}{else} \{
            watchRemover = scope.$watch(whenExpFn, updateElementText);
          \}
          lastCount = count;
        \}
      \});

      \textcolor{keyword}{function} updateElementText(newText) \{
        element.text(newText || \textcolor{stringliteral}{''});
      \}
    \}
  \};
\}];

var ngRepeatDirective = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($parse, $animate) \{
  var NG\_REMOVED = \textcolor{stringliteral}{'$$NG\_REMOVED'};
  var ngRepeatMinErr = minErr(\textcolor{stringliteral}{'ngRepeat'});

  var updateScope = \textcolor{keyword}{function}(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) \{
    \textcolor{comment}{// TODO(perf): generate setters to shave off ~40ms or 1-1.5%}
    scope[valueIdentifier] = value;
    \textcolor{keywordflow}{if} (keyIdentifier) scope[keyIdentifier] = key;
    scope.$index = index;
    scope.$first = (index === 0);
    scope.$last = (index === (arrayLength - 1));
    scope.$middle = !(scope.$first || scope.$last);
    \textcolor{comment}{// jshint bitwise: false}
    scope.$odd = !(scope.$even = (index&1) === 0);
    \textcolor{comment}{// jshint bitwise: true}
  \};

  var getBlockStart = \textcolor{keyword}{function}(block) \{
    \textcolor{keywordflow}{return} block.clone[0];
  \};

  var getBlockEnd = \textcolor{keyword}{function}(block) \{
    \textcolor{keywordflow}{return} block.clone[block.clone.length - 1];
  \};


  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    priority: 1000,
    terminal: \textcolor{keyword}{true},
    $$tlb: \textcolor{keyword}{true},
    compile: \textcolor{keyword}{function} ngRepeatCompile($element, $attr) \{
      var expression = $attr.ngRepeat;
      var ngRepeatEndComment = document.createComment(\textcolor{stringliteral}{' end ngRepeat: '} + expression + \textcolor{charliteral}{' '});

      var match = expression.match(/^\(\backslash\)s*([\(\backslash\)s\(\backslash\)S]+?)\(\backslash\)s+in\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+as\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+track\(\backslash\)s+by
      \(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?\(\backslash\)s*$/);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'iexp'}, \textcolor{stringliteral}{"Expected expression in form of '\_item\_ in \_collection\_[ track by
       \_id\_]' but got '\{0\}'."},
            expression);
      \}

      var lhs = match[1];
      var rhs = match[2];
      var aliasAs = match[3];
      var trackByExp = match[4];

      match = lhs.match(/^(?:(\(\backslash\)s*[\(\backslash\)$\(\backslash\)w]+)|\(\backslash\)(\(\backslash\)s*([\(\backslash\)$\(\backslash\)w]+)\(\backslash\)s*,\(\backslash\)s*([\(\backslash\)$\(\backslash\)w]+)\(\backslash\)s*\(\backslash\)))$/);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'iidexp'}, \textcolor{stringliteral}{"'\_item\_' in '\_item\_ in \_collection\_' should be an identifier or
       '(\_key\_, \_value\_)' expression, but got '\{0\}'."},
            lhs);
      \}
      var valueIdentifier = match[3] || match[1];
      var keyIdentifier = match[2];

      \textcolor{keywordflow}{if} (aliasAs && (!/^[$a-zA-Z\_][$a-zA-Z0-9\_]*$/.test(aliasAs) ||
          /^(null|undefined|\textcolor{keyword}{this}|\(\backslash\)$index|\(\backslash\)$first|\(\backslash\)$middle|\(\backslash\)$last|\(\backslash\)$even|\(\backslash\)$odd|\(\backslash\)$parent|\(\backslash\)$root|\(\backslash\)$id)$/.test(
      aliasAs))) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'badident'}, \textcolor{stringliteral}{"alias '\{0\}' is invalid --- must be a valid JS identifier which is
       not a reserved name."},
          aliasAs);
      \}

      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
      var hashFnLocals = \{$id: hashKey\};

      \textcolor{keywordflow}{if} (trackByExp) \{
        trackByExpGetter = $parse(trackByExp);
      \} \textcolor{keywordflow}{else} \{
        trackByIdArrayFn = \textcolor{keyword}{function}(key, value) \{
          \textcolor{keywordflow}{return} hashKey(value);
        \};
        trackByIdObjFn = \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{return} key;
        \};
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngRepeatLink($scope, $element, $attr, ctrl, $transclude) \{

        \textcolor{keywordflow}{if} (trackByExpGetter) \{
          trackByIdExpFn = \textcolor{keyword}{function}(key, value, index) \{
            \textcolor{comment}{// assign key, value, and $index to the locals so that they can be used in hash functions}
            \textcolor{keywordflow}{if} (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            \textcolor{keywordflow}{return} trackByExpGetter($scope, hashFnLocals);
          \};
        \}

        \textcolor{comment}{// Store a list of elements from previous run. This is a hash where key is the item from the}
        \textcolor{comment}{// iterator, and the value is objects with following properties.}
        \textcolor{comment}{//   - scope: bound scope}
        \textcolor{comment}{//   - element: previous element.}
        \textcolor{comment}{//   - index: position}
        \textcolor{comment}{//}
        \textcolor{comment}{// We are using no-proto object so that we don't need to guard against inherited props via}
        \textcolor{comment}{// hasOwnProperty.}
        var lastBlockMap = createMap();

        \textcolor{comment}{//watch props}
        $scope.$watchCollection(rhs, \textcolor{keyword}{function} ngRepeatAction(collection) \{
          var index, length,
              previousNode = $element[0],     \textcolor{comment}{// node that cloned nodes should be inserted after}
                                              \textcolor{comment}{// initialized to the comment node anchor}
              nextNode,
              \textcolor{comment}{// Same as lastBlockMap but it has the current state. It will become the}
              \textcolor{comment}{// lastBlockMap on the next iteration.}
              nextBlockMap = createMap(),
              collectionLength,
              key, value, \textcolor{comment}{// key/value of iteration}
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       \textcolor{comment}{// last object information \{scope, element, id\}}
              nextBlockOrder,
              elementsToRemove;

          \textcolor{keywordflow}{if} (aliasAs) \{
            $scope[aliasAs] = collection;
          \}

          \textcolor{keywordflow}{if} (isArrayLike(collection)) \{
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          \} \textcolor{keywordflow}{else} \{
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            \textcolor{comment}{// if object, extract keys, in enumeration order, unsorted}
            collectionKeys = [];
            \textcolor{keywordflow}{for} (var itemKey in collection) \{
              \textcolor{keywordflow}{if} (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== \textcolor{charliteral}{'$'}) \{
                collectionKeys.push(itemKey);
              \}
            \}
          \}

          collectionLength = collectionKeys.length;
          nextBlockOrder = \textcolor{keyword}{new} Array(collectionLength);

          \textcolor{comment}{// locate existing items}
          \textcolor{keywordflow}{for} (index = 0; index < collectionLength; index++) \{
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);
            \textcolor{keywordflow}{if} (lastBlockMap[trackById]) \{
              \textcolor{comment}{// found previously seen block}
              block = lastBlockMap[trackById];
              \textcolor{keyword}{delete} lastBlockMap[trackById];
              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextBlockMap[trackById]) \{
              \textcolor{comment}{// if collision detected. restore lastBlockMap and throw an error}
              forEach(nextBlockOrder, \textcolor{keyword}{function}(block) \{
                \textcolor{keywordflow}{if} (block && block.scope) lastBlockMap[block.id] = block;
              \});
              \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'dupes'},
                  \textcolor{stringliteral}{"Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique
       keys. Repeater: \{0\}, Duplicate key: \{1\}, Duplicate value: \{2\}"},
                  expression, trackById, value);
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// new never before seen block}
              nextBlockOrder[index] = \{\textcolor{keywordtype}{id}: trackById, scope: undefined, clone: undefined\};
              nextBlockMap[trackById] = \textcolor{keyword}{true};
            \}
          \}

          \textcolor{comment}{// remove leftover items}
          \textcolor{keywordflow}{for} (var blockKey in lastBlockMap) \{
            block = lastBlockMap[blockKey];
            elementsToRemove = getBlockNodes(block.clone);
            $animate.leave(elementsToRemove);
            \textcolor{keywordflow}{if} (elementsToRemove[0].parentNode) \{
              \textcolor{comment}{// if the element was not removed yet because of pending animation, mark it as deleted}
              \textcolor{comment}{// so that we can ignore it later}
              \textcolor{keywordflow}{for} (index = 0, length = elementsToRemove.length; index < length; index++) \{
                elementsToRemove[index][NG\_REMOVED] = \textcolor{keyword}{true};
              \}
            \}
            block.scope.$destroy();
          \}

          \textcolor{comment}{// we are not using forEach for perf reasons (trying to avoid #call)}
          \textcolor{keywordflow}{for} (index = 0; index < collectionLength; index++) \{
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            \textcolor{keywordflow}{if} (block.scope) \{
              \textcolor{comment}{// if we have already seen this object, then we need to reuse the}
              \textcolor{comment}{// associated scope/element}

              nextNode = previousNode;

              \textcolor{comment}{// skip nodes that are already pending removal via leave animation}
              \textcolor{keywordflow}{do} \{
                nextNode = nextNode.nextSibling;
              \} \textcolor{keywordflow}{while} (nextNode && nextNode[NG\_REMOVED]);

              \textcolor{keywordflow}{if} (getBlockStart(block) != nextNode) \{
                \textcolor{comment}{// existing item which got moved}
                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
              \}
              previousNode = getBlockEnd(block);
              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
      ;
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// new item which we don't know about}
              $transclude(\textcolor{keyword}{function} ngRepeatTransclude(clone, scope) \{
                block.scope = scope;
                \textcolor{comment}{// http://jsperf.com/clone-vs-createcomment}
                var endNode = ngRepeatEndComment.cloneNode(\textcolor{keyword}{false});
                clone[clone.length++] = endNode;

                \textcolor{comment}{// TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?}
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = endNode;
                \textcolor{comment}{// Note: We only need the first/last node of the cloned nodes.}
                \textcolor{comment}{// However, we need to keep the reference to the jqlite wrapper as it might be changed
       later}
                \textcolor{comment}{// by a directive with templateUrl when its template arrives.}
                block.clone = clone;
                nextBlockMap[block.id] = block;
                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, 
      collectionLength);
              \});
            \}
          \}
          lastBlockMap = nextBlockMap;
        \});
      \};
    \}
  \};
\}];

var NG\_HIDE\_CLASS = \textcolor{stringliteral}{'ng-hide'};
var NG\_HIDE\_IN\_PROGRESS\_CLASS = \textcolor{stringliteral}{'ng-hide-animate'};
var ngShowDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      scope.$watch(attr.ngShow, \textcolor{keyword}{function} ngShowWatchAction(value) \{
        \textcolor{comment}{// we're adding a temporary, animation-specific class for ng-hide since this way}
        \textcolor{comment}{// we can control when the element is actually displayed on screen without having}
        \textcolor{comment}{// to have a global/greedy CSS selector that breaks when other animations are run.}
        \textcolor{comment}{// Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845}
        $animate[value ? \textcolor{stringliteral}{'removeClass'} : \textcolor{stringliteral}{'addClass'}](element, NG\_HIDE\_CLASS, \{
          tempClasses: NG\_HIDE\_IN\_PROGRESS\_CLASS
        \});
      \});
    \}
  \};
\}];


var ngHideDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      scope.$watch(attr.ngHide, \textcolor{keyword}{function} ngHideWatchAction(value) \{
        \textcolor{comment}{// The comment inside of the ngShowDirective explains why we add and}
        \textcolor{comment}{// remove a temporary class for the show/hide animation}
        $animate[value ? \textcolor{stringliteral}{'addClass'} : \textcolor{stringliteral}{'removeClass'}](element,NG\_HIDE\_CLASS, \{
          tempClasses: NG\_HIDE\_IN\_PROGRESS\_CLASS
        \});
      \});
    \}
  \};
\}];

var ngStyleDirective = ngDirective(\textcolor{keyword}{function}(scope, element, attr) \{
  scope.$watch(attr.ngStyle, \textcolor{keyword}{function} ngStyleWatchAction(newStyles, oldStyles) \{
    \textcolor{keywordflow}{if} (oldStyles && (newStyles !== oldStyles)) \{
      forEach(oldStyles, \textcolor{keyword}{function}(val, style) \{ element.css(style, \textcolor{stringliteral}{''});\});
    \}
    \textcolor{keywordflow}{if} (newStyles) element.css(newStyles);
  \}, \textcolor{keyword}{true});
\});

var ngSwitchDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    require: \textcolor{stringliteral}{'ngSwitch'},

    \textcolor{comment}{// asks for $scope to fool the BC controller module}
    controller: [\textcolor{stringliteral}{'$scope'}, \textcolor{keyword}{function} ngSwitchController() \{
     this.cases = \{\};
    \}],
    link: \textcolor{keyword}{function}(scope, element, attr, ngSwitchController) \{
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes = [],
          selectedElements = [],
          previousLeaveAnimations = [],
          selectedScopes = [];

      var spliceFactory = \textcolor{keyword}{function}(array, index) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{ array.splice(index, 1); \};
      \};

      scope.$watch(watchExpr, \textcolor{keyword}{function} ngSwitchWatchAction(value) \{
        var i, ii;
        \textcolor{keywordflow}{for} (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) \{
          $animate.cancel(previousLeaveAnimations[i]);
        \}
        previousLeaveAnimations.length = 0;

        for (i = 0, ii = selectedScopes.length; i < ii; ++i) \{
          var selected = getBlockNodes(selectedElements[i].clone);
          selectedScopes[i].$destroy();
          var promise = previousLeaveAnimations[i] = $animate.leave(selected);
          promise.then(spliceFactory(previousLeaveAnimations, i));
        \}

        selectedElements.length = 0;
        selectedScopes.length = 0;

        if ((selectedTranscludes = ngSwitchController.cases[\textcolor{charliteral}{'!'} + value] || ngSwitchController.cases[\textcolor{charliteral}{'?'}]))
       \{
          forEach(selectedTranscludes, function(selectedTransclude) \{
            selectedTransclude.transclude(function(caseElement, selectedScope) \{
              selectedScopes.push(selectedScope);
              var anchor = selectedTransclude.element;
              caseElement[caseElement.length++] = document.createComment(\textcolor{stringliteral}{' end ngSwitchWhen: '});
              var block = \{ clone: caseElement \};

              selectedElements.push(block);
              $animate.enter(caseElement, anchor.parent(), anchor);
            \});
          \});
        \}
      \});
    \}
  \};
\}];

var ngSwitchWhenDirective = ngDirective(\{
  transclude: \textcolor{stringliteral}{'element'},
  priority: 1200,
  require: \textcolor{stringliteral}{'^ngSwitch'},
  multiElement: \textcolor{keyword}{true},
  link: \textcolor{keyword}{function}(scope, element, attrs, ctrl, $transclude) \{
    ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen] = (ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen] || []);
    ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen].push(\{ transclude: $transclude, element: element \});
  \}
\});

var ngSwitchDefaultDirective = ngDirective(\{
  transclude: \textcolor{stringliteral}{'element'},
  priority: 1200,
  require: \textcolor{stringliteral}{'^ngSwitch'},
  multiElement: \textcolor{keyword}{true},
  link: \textcolor{keyword}{function}(scope, element, attr, ctrl, $transclude) \{
    ctrl.cases[\textcolor{charliteral}{'?'}] = (ctrl.cases[\textcolor{charliteral}{'?'}] || []);
    ctrl.cases[\textcolor{charliteral}{'?'}].push(\{ transclude: $transclude, element: element \});
   \}
\});

var ngTranscludeDirective = ngDirective(\{
  restrict: \textcolor{stringliteral}{'EAC'},
  link: \textcolor{keyword}{function}($scope, $element, $attrs, controller, $transclude) \{
    \textcolor{keywordflow}{if} (!$transclude) \{
      \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'ngTransclude'})(\textcolor{stringliteral}{'orphan'},
       \textcolor{stringliteral}{'Illegal use of ngTransclude directive in the template! '} +
       \textcolor{stringliteral}{'No parent directive that requires a transclusion found. '} +
       \textcolor{stringliteral}{'Element: \{0\}'},
       startingTag($element));
    \}

    $transclude(\textcolor{keyword}{function}(clone) \{
      $element.empty();
      $element.append(clone);
    \});
  \}
\});

var scriptDirective = [\textcolor{stringliteral}{'$templateCache'}, \textcolor{keyword}{function}($templateCache) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    terminal: \textcolor{keyword}{true},
    compile: \textcolor{keyword}{function}(element, attr) \{
      \textcolor{keywordflow}{if} (attr.type == \textcolor{stringliteral}{'text/ng-template'}) \{
        var templateUrl = attr.id,
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      \}
    \}
  \};
\}];

var noopNgModelController = \{ $setViewValue: noop, $render: noop \};

var SelectController =
        [\textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{keyword}{function}($element, $scope, $attrs) \{

  var \textcolor{keyword}{self} = \textcolor{keyword}{this},
      optionsMap = \textcolor{keyword}{new} HashMap();

  \textcolor{comment}{// If the ngModel doesn't get provided then provide a dummy noop version to prevent errors}
  \textcolor{keyword}{self}.ngModelCtrl = noopNgModelController;

  \textcolor{comment}{// The "unknown" option is one that is prepended to the list if the viewValue}
  \textcolor{comment}{// does not match any of the options. When it is rendered the value of the unknown}
  \textcolor{comment}{// option is '? XXX ?' where XXX is the hashKey of the value that is not known.}
  \textcolor{comment}{//}
  \textcolor{comment}{// We can't just jqLite('<option>') since jqLite is not smart enough}
  \textcolor{comment}{// to create it in <select> and IE barfs otherwise.}
  \textcolor{keyword}{self}.unknownOption = jqLite(document.createElement(\textcolor{stringliteral}{'option'}));
  \textcolor{keyword}{self}.renderUnknownOption = \textcolor{keyword}{function}(val) \{
    var unknownVal = \textcolor{stringliteral}{'? '} + hashKey(val) + \textcolor{stringliteral}{' ?'};
    \textcolor{keyword}{self}.unknownOption.val(unknownVal);
    $element.prepend(\textcolor{keyword}{self}.unknownOption);
    $element.val(unknownVal);
  \};

  $scope.$on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
    \textcolor{comment}{// disable unknown option so that we don't do work when the whole select is being destroyed}
    \textcolor{keyword}{self}.renderUnknownOption = noop;
  \});

  \textcolor{keyword}{self}.removeUnknownOption = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.unknownOption.parent()) \textcolor{keyword}{self}.unknownOption.remove();
  \};


  \textcolor{comment}{// Read the value of the select control, the implementation of this changes depending}
  \textcolor{comment}{// upon whether the select can have multiple values and whether ngOptions is at work.}
  \textcolor{keyword}{self}.readValue = \textcolor{keyword}{function} readSingleValue() \{
    \textcolor{keyword}{self}.removeUnknownOption();
    \textcolor{keywordflow}{return} $element.val();
  \};


  \textcolor{comment}{// Write the value to the select control, the implementation of this changes depending}
  \textcolor{comment}{// upon whether the select can have multiple values and whether ngOptions is at work.}
  \textcolor{keyword}{self}.writeValue = \textcolor{keyword}{function} writeSingleValue(value) \{
    \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.hasOption(value)) \{
      \textcolor{keyword}{self}.removeUnknownOption();
      $element.val(value);
      \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \textcolor{keyword}{self}.emptyOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// to make IE9 happy}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (value == null && \textcolor{keyword}{self}.emptyOption) \{
        \textcolor{keyword}{self}.removeUnknownOption();
        $element.val(\textcolor{stringliteral}{''});
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keyword}{self}.renderUnknownOption(value);
      \}
    \}
  \};


  \textcolor{comment}{// Tell the select control that an option, with the given value, has been added}
  \textcolor{keyword}{self}.addOption = \textcolor{keyword}{function}(value, element) \{
    assertNotHasOwnProperty(value, \textcolor{stringliteral}{'"option value"'});
    \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \{
      \textcolor{keyword}{self}.emptyOption = element;
    \}
    var count = optionsMap.get(value) || 0;
    optionsMap.put(value, count + 1);
  \};

  \textcolor{comment}{// Tell the select control that an option, with the given value, has been removed}
  \textcolor{keyword}{self}.removeOption = \textcolor{keyword}{function}(value) \{
    var count = optionsMap.get(value);
    \textcolor{keywordflow}{if} (count) \{
      \textcolor{keywordflow}{if} (count === 1) \{
        optionsMap.remove(value);
        \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \{
          \textcolor{keyword}{self}.emptyOption = undefined;
        \}
      \} \textcolor{keywordflow}{else} \{
        optionsMap.put(value, count - 1);
      \}
    \}
  \};

  \textcolor{comment}{// Check whether the select control has an option matching the given value}
  \textcolor{keyword}{self}.hasOption = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} !!optionsMap.get(value);
  \};
\}];

var selectDirective = \textcolor{keyword}{function}() \{

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    require: [\textcolor{stringliteral}{'select'}, \textcolor{stringliteral}{'?ngModel'}],
    controller: SelectController,
    link: \textcolor{keyword}{function}(scope, element, attr, ctrls) \{

      \textcolor{comment}{// if ngModel is not defined, we don't need to do anything}
      var ngModelCtrl = ctrls[1];
      \textcolor{keywordflow}{if} (!ngModelCtrl) \textcolor{keywordflow}{return};

      var selectCtrl = ctrls[0];

      selectCtrl.ngModelCtrl = ngModelCtrl;

      \textcolor{comment}{// We delegate rendering to the `writeValue` method, which can be changed}
      \textcolor{comment}{// if the select can have multiple selected values or if the options are being}
      \textcolor{comment}{// generated by `ngOptions`}
      ngModelCtrl.$render = \textcolor{keyword}{function}() \{
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      \};

      \textcolor{comment}{// When the selected item(s) changes we delegate getting the value of the select control}
      \textcolor{comment}{// to the `readValue` method, which can be changed if the select can have multiple}
      \textcolor{comment}{// selected values or if the options are being generated by `ngOptions`}
      element.on(\textcolor{stringliteral}{'change'}, \textcolor{keyword}{function}() \{
        scope.$apply(\textcolor{keyword}{function}() \{
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        \});
      \});

      \textcolor{comment}{// If the select allows multiple values then we need to modify how we read and write}
      \textcolor{comment}{// values from and to the control; also what it means for the value to be empty and}
      \textcolor{comment}{// we have to add an extra watch since ngModel doesn't work well with arrays - it}
      \textcolor{comment}{// doesn't trigger rendering if only an item in the array changes.}
      \textcolor{keywordflow}{if} (attr.multiple) \{

        \textcolor{comment}{// Read value now needs to check each option to see if it is selected}
        selectCtrl.readValue = \textcolor{keyword}{function} readMultipleValue() \{
          var array = [];
          forEach(element.find(\textcolor{stringliteral}{'option'}), \textcolor{keyword}{function}(option) \{
            \textcolor{keywordflow}{if} (option.selected) \{
              array.push(option.value);
            \}
          \});
          \textcolor{keywordflow}{return} array;
        \};

        \textcolor{comment}{// Write value now needs to set the selected property of each matching option}
        selectCtrl.writeValue = \textcolor{keyword}{function} writeMultipleValue(value) \{
          var items = \textcolor{keyword}{new} HashMap(value);
          forEach(element.find(\textcolor{stringliteral}{'option'}), \textcolor{keyword}{function}(option) \{
            option.selected = isDefined(items.get(option.value));
          \});
        \};

        \textcolor{comment}{// we have to do it on each watch since ngModel watches reference, but}
        \textcolor{comment}{// we need to work of an array, so we need to see if anything was inserted/removed}
        var lastView, lastViewRef = NaN;
        scope.$watch(\textcolor{keyword}{function} selectMultipleWatch() \{
          \textcolor{keywordflow}{if} (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) \{
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          \}
          lastViewRef = ngModelCtrl.$viewValue;
        \});

        \textcolor{comment}{// If we are a multiple select then value is now a collection}
        \textcolor{comment}{// so the meaning of $isEmpty changes}
        ngModelCtrl.$isEmpty = \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} !value || value.length === 0;
        \};

      \}
    \}
  \};
\};


\textcolor{comment}{// The option directive is purely designed to communicate the existence (or lack of)}
\textcolor{comment}{// of dynamically created (and destroyed) option elements to their containing select}
\textcolor{comment}{// directive via its controller.}
var optionDirective = [\textcolor{stringliteral}{'$interpolate'}, \textcolor{keyword}{function}($interpolate) \{

  \textcolor{keyword}{function} chromeHack(optionElement) \{
    \textcolor{comment}{// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459}
    \textcolor{comment}{// Adding an <option selected="selected"> element to a <select required="required"> should}
    \textcolor{comment}{// automatically select the new element}
    \textcolor{keywordflow}{if} (optionElement[0].hasAttribute(\textcolor{stringliteral}{'selected'})) \{
      optionElement[0].selected = \textcolor{keyword}{true};
    \}
  \}

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    priority: 100,
    compile: \textcolor{keyword}{function}(element, attr) \{

      \textcolor{comment}{// If the value attribute is not defined then we fall back to the}
      \textcolor{comment}{// text content of the option element, which may be interpolated}
      \textcolor{keywordflow}{if} (isUndefined(attr.value)) \{
        var interpolateFn = $interpolate(element.text(), \textcolor{keyword}{true});
        \textcolor{keywordflow}{if} (!interpolateFn) \{
          attr.$set(\textcolor{stringliteral}{'value'}, element.text());
        \}
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element, attr) \{

        \textcolor{comment}{// This is an optimization over using ^^ since we don't want to have to search}
        \textcolor{comment}{// all the way to the root of the DOM for every single option element}
        var selectCtrlName = \textcolor{stringliteral}{'$selectController'},
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); \textcolor{comment}{// in case we are in optgroup}

        \textcolor{comment}{// Only update trigger option updates if this is an option within a `select`}
        \textcolor{comment}{// that also has `ngModel` attached}
        \textcolor{keywordflow}{if} (selectCtrl && selectCtrl.ngModelCtrl) \{

          \textcolor{keywordflow}{if} (interpolateFn) \{
            scope.$watch(interpolateFn, \textcolor{keyword}{function} interpolateWatchAction(newVal, oldVal) \{
              attr.$set(\textcolor{stringliteral}{'value'}, newVal);
              \textcolor{keywordflow}{if} (oldVal !== newVal) \{
                selectCtrl.removeOption(oldVal);
              \}
              selectCtrl.addOption(newVal, element);
              selectCtrl.ngModelCtrl.$render();
              chromeHack(element);
            \});
          \} \textcolor{keywordflow}{else} \{
            selectCtrl.addOption(attr.value, element);
            selectCtrl.ngModelCtrl.$render();
            chromeHack(element);
          \}

          element.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
            selectCtrl.removeOption(attr.value);
            selectCtrl.ngModelCtrl.$render();
          \});
        \}
      \};
    \}
  \};
\}];

var styleDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'E'},
  terminal: \textcolor{keyword}{false}
\});

var requiredDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};
      attr.required = \textcolor{keyword}{true}; \textcolor{comment}{// force truthy in case we are on non input element}

      ctrl.$validators.required = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} !attr.required || !ctrl.$isEmpty(viewValue);
      \};

      attr.$observe(\textcolor{stringliteral}{'required'}, \textcolor{keyword}{function}() \{
        ctrl.$validate();
      \});
    \}
  \};
\};


var patternDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var regexp, patternExp = attr.ngPattern || attr.pattern;
      attr.$observe(\textcolor{stringliteral}{'pattern'}, \textcolor{keyword}{function}(regex) \{
        \textcolor{keywordflow}{if} (isString(regex) && regex.length > 0) \{
          regex = new RegExp(\textcolor{stringliteral}{'^'} + regex + \textcolor{stringliteral}{'$'});
        \}

        if (regex && !regex.test) \{
          throw minErr(\textcolor{stringliteral}{'ngPattern'})(\textcolor{stringliteral}{'noregexp'},
            \textcolor{stringliteral}{'Expected \{0\} to be a RegExp but was \{1\}. Element: \{2\}'}, patternExp,
            regex, startingTag(elm));
        \}

        regexp = regex || undefined;
        ctrl.$validate();
      \});

      ctrl.$validators.pattern = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
      \};
    \}
  \};
\};


var maxlengthDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var maxlength = -1;
      attr.$observe(\textcolor{stringliteral}{'maxlength'}, \textcolor{keyword}{function}(value) \{
        var intVal = toInt(value);
        maxlength = isNaN(intVal) ? -1 : intVal;
        ctrl.$validate();
      \});
      ctrl.$validators.maxlength = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
      \};
    \}
  \};
\};

var minlengthDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var minlength = 0;
      attr.$observe(\textcolor{stringliteral}{'minlength'}, \textcolor{keyword}{function}(value) \{
        minlength = toInt(value) || 0;
        ctrl.$validate();
      \});
      ctrl.$validators.minlength = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
      \};
    \}
  \};
\};

\textcolor{keywordflow}{if} (window.angular.bootstrap) \{
  \textcolor{comment}{//AngularJS is already loaded, so we can return here...}
  console.log(\textcolor{stringliteral}{'WARNING: Tried to load angular more than once.'});
  \textcolor{keywordflow}{return};
\}

\textcolor{comment}{//try to bind to jquery now so that one can write jqLite(document).ready()}
\textcolor{comment}{//but we will rebind on bootstrap again.}
bindJQuery();

publishExternalAPI(angular);

angular.module(\textcolor{stringliteral}{"ngLocale"}, [], [\textcolor{stringliteral}{"$provide"}, \textcolor{keyword}{function}($provide) \{
var PLURAL\_CATEGORY = \{ZERO: \textcolor{stringliteral}{"zero"}, ONE: \textcolor{stringliteral}{"one"}, TWO: \textcolor{stringliteral}{"two"}, FEW: \textcolor{stringliteral}{"few"}, MANY: \textcolor{stringliteral}{"many"}, OTHER: \textcolor{stringliteral}{"other"}\};
\textcolor{keyword}{function} getDecimals(n) \{
  n = n + \textcolor{stringliteral}{''};
  var i = n.indexOf(\textcolor{charliteral}{'.'});
  \textcolor{keywordflow}{return} (i == -1) ? 0 : n.length - i - 1;
\}

\textcolor{keyword}{function} getVF(n, opt\_precision) \{
  var v = opt\_precision;

  \textcolor{keywordflow}{if} (undefined === v) \{
    v = Math.min(getDecimals(n), 3);
  \}

  var base = Math.pow(10, v);
  var f = ((n * base) | 0) % base;
  \textcolor{keywordflow}{return} \{v: v, f: f\};
\}

$provide.value(\textcolor{stringliteral}{"$locale"}, \{
  \textcolor{stringliteral}{"DATETIME\_FORMATS"}: \{
    \textcolor{stringliteral}{"AMPMS"}: [
      \textcolor{stringliteral}{"AM"},
      \textcolor{stringliteral}{"PM"}
    ],
    \textcolor{stringliteral}{"DAY"}: [
      \textcolor{stringliteral}{"Sunday"},
      \textcolor{stringliteral}{"Monday"},
      \textcolor{stringliteral}{"Tuesday"},
      \textcolor{stringliteral}{"Wednesday"},
      \textcolor{stringliteral}{"Thursday"},
      \textcolor{stringliteral}{"Friday"},
      \textcolor{stringliteral}{"Saturday"}
    ],
    \textcolor{stringliteral}{"ERANAMES"}: [
      \textcolor{stringliteral}{"Before Christ"},
      \textcolor{stringliteral}{"Anno Domini"}
    ],
    \textcolor{stringliteral}{"ERAS"}: [
      \textcolor{stringliteral}{"BC"},
      \textcolor{stringliteral}{"AD"}
    ],
    \textcolor{stringliteral}{"FIRSTDAYOFWEEK"}: 6,
    \textcolor{stringliteral}{"MONTH"}: [
      \textcolor{stringliteral}{"January"},
      \textcolor{stringliteral}{"February"},
      \textcolor{stringliteral}{"March"},
      \textcolor{stringliteral}{"April"},
      \textcolor{stringliteral}{"May"},
      \textcolor{stringliteral}{"June"},
      \textcolor{stringliteral}{"July"},
      \textcolor{stringliteral}{"August"},
      \textcolor{stringliteral}{"September"},
      \textcolor{stringliteral}{"October"},
      \textcolor{stringliteral}{"November"},
      \textcolor{stringliteral}{"December"}
    ],
    \textcolor{stringliteral}{"SHORTDAY"}: [
      \textcolor{stringliteral}{"Sun"},
      \textcolor{stringliteral}{"Mon"},
      \textcolor{stringliteral}{"Tue"},
      \textcolor{stringliteral}{"Wed"},
      \textcolor{stringliteral}{"Thu"},
      \textcolor{stringliteral}{"Fri"},
      \textcolor{stringliteral}{"Sat"}
    ],
    \textcolor{stringliteral}{"SHORTMONTH"}: [
      \textcolor{stringliteral}{"Jan"},
      \textcolor{stringliteral}{"Feb"},
      \textcolor{stringliteral}{"Mar"},
      \textcolor{stringliteral}{"Apr"},
      \textcolor{stringliteral}{"May"},
      \textcolor{stringliteral}{"Jun"},
      \textcolor{stringliteral}{"Jul"},
      \textcolor{stringliteral}{"Aug"},
      \textcolor{stringliteral}{"Sep"},
      \textcolor{stringliteral}{"Oct"},
      \textcolor{stringliteral}{"Nov"},
      \textcolor{stringliteral}{"Dec"}
    ],
    \textcolor{stringliteral}{"WEEKENDRANGE"}: [
      5,
      6
    ],
    \textcolor{stringliteral}{"fullDate"}: \textcolor{stringliteral}{"EEEE, MMMM d, y"},
    \textcolor{stringliteral}{"longDate"}: \textcolor{stringliteral}{"MMMM d, y"},
    \textcolor{stringliteral}{"medium"}: \textcolor{stringliteral}{"MMM d, y h:mm:ss a"},
    \textcolor{stringliteral}{"mediumDate"}: \textcolor{stringliteral}{"MMM d, y"},
    \textcolor{stringliteral}{"mediumTime"}: \textcolor{stringliteral}{"h:mm:ss a"},
    \textcolor{stringliteral}{"short"}: \textcolor{stringliteral}{"M/d/yy h:mm a"},
    \textcolor{stringliteral}{"shortDate"}: \textcolor{stringliteral}{"M/d/yy"},
    \textcolor{stringliteral}{"shortTime"}: \textcolor{stringliteral}{"h:mm a"}
  \},
  \textcolor{stringliteral}{"NUMBER\_FORMATS"}: \{
    \textcolor{stringliteral}{"CURRENCY\_SYM"}: \textcolor{stringliteral}{"$"},
    \textcolor{stringliteral}{"DECIMAL\_SEP"}: \textcolor{stringliteral}{"."},
    \textcolor{stringliteral}{"GROUP\_SEP"}: \textcolor{stringliteral}{","},
    \textcolor{stringliteral}{"PATTERNS"}: [
      \{
        \textcolor{stringliteral}{"gSize"}: 3,
        \textcolor{stringliteral}{"lgSize"}: 3,
        \textcolor{stringliteral}{"maxFrac"}: 3,
        \textcolor{stringliteral}{"minFrac"}: 0,
        \textcolor{stringliteral}{"minInt"}: 1,
        \textcolor{stringliteral}{"negPre"}: \textcolor{stringliteral}{"-"},
        \textcolor{stringliteral}{"negSuf"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posPre"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posSuf"}: \textcolor{stringliteral}{""}
      \},
      \{
        \textcolor{stringliteral}{"gSize"}: 3,
        \textcolor{stringliteral}{"lgSize"}: 3,
        \textcolor{stringliteral}{"maxFrac"}: 2,
        \textcolor{stringliteral}{"minFrac"}: 2,
        \textcolor{stringliteral}{"minInt"}: 1,
        \textcolor{stringliteral}{"negPre"}: \textcolor{stringliteral}{"-\(\backslash\)u00a4"},
        \textcolor{stringliteral}{"negSuf"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posPre"}: \textcolor{stringliteral}{"\(\backslash\)u00a4"},
        \textcolor{stringliteral}{"posSuf"}: \textcolor{stringliteral}{""}
      \}
    ]
  \},
  \textcolor{stringliteral}{"id"}: \textcolor{stringliteral}{"en-us"},
  \textcolor{stringliteral}{"pluralCat"}: \textcolor{keyword}{function}(n, opt\_precision) \{  var i = n | 0;  var vf = getVF(n, opt\_precision);  \textcolor{keywordflow}{if} (i == 1 
      && vf.v == 0) \{    \textcolor{keywordflow}{return} PLURAL\_CATEGORY.ONE;  \}  \textcolor{keywordflow}{return} PLURAL\_CATEGORY.OTHER;\}
\});
\}]);

\textcolor{comment}{// Public namespace}
angular.scenario = angular.scenario || \{\};

angular.scenario.jQuery = \_jQuery;

angular.scenario.output = angular.scenario.output || \textcolor{keyword}{function}(name, fn) \{
  angular.scenario.output[name] = fn;
\};

angular.scenario.dsl = angular.scenario.dsl || \textcolor{keyword}{function}(name, fn) \{
  angular.scenario.dsl[name] = \textcolor{keyword}{function}() \{
    \textcolor{comment}{/* jshint -W040 */}\textcolor{comment}{/* The dsl binds `this` for us when calling chained functions */}
    \textcolor{keyword}{function} executeStatement(statement, args) \{
      var result = statement.apply(\textcolor{keyword}{this}, args);
      \textcolor{keywordflow}{if} (angular.isFunction(result) || result instanceof angular.scenario.Future) \{
        \textcolor{keywordflow}{return} result;
      \}
      var \textcolor{keyword}{self} = \textcolor{keyword}{this};
      var chain = angular.extend(\{\}, result);
      angular.forEach(chain, \textcolor{keyword}{function}(value, name) \{
        \textcolor{keywordflow}{if} (angular.isFunction(value)) \{
          chain[name] = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} executeStatement.call(\textcolor{keyword}{self}, value, arguments);
          \};
        \} \textcolor{keywordflow}{else} \{
          chain[name] = value;
        \}
      \});
      \textcolor{keywordflow}{return} chain;
    \}
    var statement = fn.apply(\textcolor{keyword}{this}, arguments);
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} executeStatement.call(\textcolor{keyword}{this}, statement, arguments);
    \};
  \};
\};

angular.scenario.matcher = angular.scenario.matcher || \textcolor{keyword}{function}(name, fn) \{
  angular.scenario.matcher[name] = \textcolor{keyword}{function}(expected) \{
    var description = this.future.name +
                      (this.inverse ? \textcolor{stringliteral}{' not '} : \textcolor{charliteral}{' '}) + name +
                      \textcolor{charliteral}{' '} + angular.toJson(expected);
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    this.addFuture(\textcolor{stringliteral}{'expect '} + description,
      \textcolor{keyword}{function}(done) \{
        var error;
        \textcolor{keyword}{self}.actual = \textcolor{keyword}{self}.future.value;
        \textcolor{keywordflow}{if} ((\textcolor{keyword}{self}.inverse && fn.call(\textcolor{keyword}{self}, expected)) ||
            (!\textcolor{keyword}{self}.inverse && !fn.call(\textcolor{keyword}{self}, expected))) \{
          error = \textcolor{stringliteral}{'expected '} + description +
            \textcolor{stringliteral}{' but was '} + angular.toJson(\textcolor{keyword}{self}.actual);
        \}
        done(error);
    \});
  \};
\};

angular.scenario.setUpAndRun = \textcolor{keyword}{function}(config) \{
  var href = window.location.href;
  var body = \_jQuery(document.body);
  var output = [];
  var objModel = \textcolor{keyword}{new} angular.scenario.ObjectModel($runner);

  \textcolor{keywordflow}{if} (config && config.scenario\_output) \{
    output = config.scenario\_output.split(\textcolor{charliteral}{','});
  \}

  angular.forEach(angular.scenario.output, \textcolor{keyword}{function}(fn, name) \{
    if (!output.length || output.indexOf(name) != -1) \{
      var context = body.append(\textcolor{stringliteral}{'<div></div>'}).find(\textcolor{stringliteral}{'div:last'});
      context.attr(\textcolor{stringliteral}{'id'}, name);
      fn.call(\{\}, context, $runner, objModel);
    \}
  \});

  \textcolor{keywordflow}{if} (!/^http/.test(href) && !/^https/.test(href)) \{
    body.append(\textcolor{stringliteral}{'<p id="system-error"></p>'});
    body.find(\textcolor{stringliteral}{'#system-error'}).text(
      \textcolor{stringliteral}{'Scenario runner must be run using http or https. The protocol '} +
      href.split(\textcolor{charliteral}{':'})[0] + \textcolor{stringliteral}{':// is not supported.'}
    );
    \textcolor{keywordflow}{return};
  \}

  var appFrame = body.append(\textcolor{stringliteral}{'<div id="application"></div>'}).find(\textcolor{stringliteral}{'#application'});
  var application = \textcolor{keyword}{new} angular.scenario.Application(appFrame);

  $runner.on(\textcolor{stringliteral}{'RunnerEnd'}, \textcolor{keyword}{function}() \{
    appFrame.css(\textcolor{stringliteral}{'display'}, \textcolor{stringliteral}{'none'});
    appFrame.find(\textcolor{stringliteral}{'iframe'}).attr(\textcolor{stringliteral}{'src'}, \textcolor{stringliteral}{'about:blank'});
  \});

  $runner.on(\textcolor{stringliteral}{'RunnerError'}, \textcolor{keyword}{function}(error) \{
    \textcolor{keywordflow}{if} (window.console) \{
      console.log(formatException(error));
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// Do something for IE}
      alert(error);
    \}
  \});

  $runner.run(application);
\};

\textcolor{keyword}{function} asyncForEach(list, iterator, done) \{
  var i = 0;
  \textcolor{keyword}{function} loop(error, index) \{
    \textcolor{keywordflow}{if} (index && index > i) \{
      i = index;
    \}
    \textcolor{keywordflow}{if} (error || i >= list.length) \{
      done(error);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{try} \{
        iterator(list[i++], loop);
      \} \textcolor{keywordflow}{catch} (e) \{
        done(e);
      \}
    \}
  \}
  loop();
\}

\textcolor{keyword}{function} formatException(error, maxStackLines) \{
  maxStackLines = maxStackLines || 5;
  var message = error.toString();
  \textcolor{keywordflow}{if} (error.stack) \{
    var stack = error.stack.split(\textcolor{charliteral}{'\(\backslash\)n'});
    \textcolor{keywordflow}{if} (stack[0].indexOf(message) === -1) \{
      maxStackLines++;
      stack.unshift(error.message);
    \}
    message = stack.slice(0, maxStackLines).join(\textcolor{charliteral}{'\(\backslash\)n'});
  \}
  \textcolor{keywordflow}{return} message;
\}

\textcolor{keyword}{function} callerFile(offset) \{
  var error = \textcolor{keyword}{new} Error();

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    var line = (error.stack || \textcolor{stringliteral}{''}).split(\textcolor{charliteral}{'\(\backslash\)n'})[offset];

    \textcolor{comment}{// Clean up the stack trace line}
    \textcolor{keywordflow}{if} (line) \{
      \textcolor{keywordflow}{if} (line.indexOf(\textcolor{charliteral}{'@'}) !== -1) \{
        \textcolor{comment}{// Firefox}
        line = line.substring(line.indexOf(\textcolor{charliteral}{'@'}) + 1);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Chrome}
        line = line.substring(line.indexOf(\textcolor{charliteral}{'('}) + 1).replace(\textcolor{charliteral}{')'}, \textcolor{stringliteral}{''});
      \}
    \}

    \textcolor{keywordflow}{return} line || \textcolor{stringliteral}{''};
  \};
\}


(\textcolor{keyword}{function}(fn) \{
  \textcolor{comment}{// We need a handle to the original trigger function for input tests.}
  var parentTrigger = fn.\_originalTrigger = fn.trigger;
  fn.trigger = \textcolor{keyword}{function}(type) \{
    \textcolor{keywordflow}{if} (/(click|change|keydown|blur|input|mousedown|mouseup)/.test(type)) \{
      var processDefaults = [];
      this.each(\textcolor{keyword}{function}(index, node) \{
        processDefaults.push(browserTrigger(node, type));
      \});

      \textcolor{comment}{// this is not compatible with jQuery - we return an array of returned values,}
      \textcolor{comment}{// so that scenario runner know whether JS code has preventDefault() of the event or not...}
      \textcolor{keywordflow}{return} processDefaults;
    \}
    \textcolor{keywordflow}{return} parentTrigger.apply(\textcolor{keyword}{this}, arguments);
  \};
\})(\_jQuery.fn);

\_jQuery.fn.bindings = \textcolor{keyword}{function}(windowJquery, bindExp) \{
  var result = [], match,
      bindSelector = \textcolor{stringliteral}{'.ng-binding:visible'};
  \textcolor{keywordflow}{if} (angular.isString(bindExp)) \{
    bindExp = bindExp.replace(/\(\backslash\)s/g, \textcolor{stringliteral}{''});
    match = \textcolor{keyword}{function}(actualExp) \{
      \textcolor{keywordflow}{if} (actualExp) \{
        actualExp = actualExp.replace(/\(\backslash\)s/g, \textcolor{stringliteral}{''});
        \textcolor{keywordflow}{if} (actualExp == bindExp) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \textcolor{keywordflow}{if} (actualExp.indexOf(bindExp) === 0) \{
          \textcolor{keywordflow}{return} actualExp.charAt(bindExp.length) == \textcolor{charliteral}{'|'};
        \}
      \}
    \};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bindExp) \{
    match = \textcolor{keyword}{function}(actualExp) \{
      \textcolor{keywordflow}{return} actualExp && bindExp.exec(actualExp);
    \};
  \} \textcolor{keywordflow}{else} \{
    match = \textcolor{keyword}{function}(actualExp) \{
      \textcolor{keywordflow}{return} !!actualExp;
    \};
  \}
  var selection = this.find(bindSelector);
  \textcolor{keywordflow}{if} (this.is(bindSelector)) \{
    selection = selection.add(\textcolor{keyword}{this});
  \}

  \textcolor{keyword}{function} push(value) \{
    \textcolor{keywordflow}{if} (value === undefined) \{
      value = \textcolor{stringliteral}{''};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof value !== \textcolor{stringliteral}{'string'}) \{
      value = angular.toJson(value);
    \}
    result.push(\textcolor{stringliteral}{''} + value);
  \}

  selection.each(\textcolor{keyword}{function}() \{
    var element = windowJquery(\textcolor{keyword}{this}),
        bindings;
    \textcolor{keywordflow}{if} (bindings = element.data(\textcolor{stringliteral}{'$binding'})) \{
      \textcolor{keywordflow}{for} (var expressions = [], binding, j=0, jj=bindings.length; j < jj; j++) \{
        binding = bindings[j];

        \textcolor{keywordflow}{if} (binding.expressions) \{
          expressions = binding.expressions;
        \} \textcolor{keywordflow}{else} \{
          expressions = [binding];
        \}
        \textcolor{keywordflow}{for} (var scope, expression, i = 0, ii = expressions.length; i < ii; i++) \{
          expression = expressions[i];
          \textcolor{keywordflow}{if} (match(expression)) \{
            scope = scope || element.scope();
            push(scope.$eval(expression));
          \}
        \}
      \}
    \}
  \});
  \textcolor{keywordflow}{return} result;
\};

(\textcolor{keyword}{function}() \{
  window.browserTrigger = \textcolor{keyword}{function} browserTrigger(element, eventType, eventData) \{
    \textcolor{keywordflow}{if} (element && !element.nodeName) element = element[0];
    \textcolor{keywordflow}{if} (!element) \textcolor{keywordflow}{return};

    eventData = eventData || \{\};
    var keys = eventData.keys;
    var x = eventData.x;
    var y = eventData.y;

    var inputType = (element.type) ? element.type.toLowerCase() : null,
        nodeName = element.nodeName.toLowerCase();
    \textcolor{keywordflow}{if} (!eventType) \{
      eventType = \{
        \textcolor{stringliteral}{'text'}:            \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'textarea'}:        \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'hidden'}:          \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'password'}:        \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'button'}:          \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'submit'}:          \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'reset'}:           \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'image'}:           \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'checkbox'}:        \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'radio'}:           \textcolor{stringliteral}{'click'},
        \textcolor{stringliteral}{'select-one'}:      \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'select-multiple'}: \textcolor{stringliteral}{'change'},
        \textcolor{stringliteral}{'\_default\_'}:       \textcolor{stringliteral}{'click'}
      \}[inputType || \textcolor{stringliteral}{'\_default\_'}];
    \}

    \textcolor{keywordflow}{if} (nodeName == \textcolor{stringliteral}{'option'}) \{
      element.parentNode.value = element.value;
      element = element.parentNode;
      eventType = \textcolor{stringliteral}{'change'};
    \}

    keys = keys || [];
    \textcolor{keyword}{function} pressed(key) \{
      \textcolor{keywordflow}{return} keys.indexOf(key) !== -1;
    \}

    var evnt;
    \textcolor{keywordflow}{if} (/transitionend/.test(eventType)) \{
      \textcolor{keywordflow}{if} (window.WebKitTransitionEvent) \{
        evnt = \textcolor{keyword}{new} WebKitTransitionEvent(eventType, eventData);
        evnt.initEvent(eventType, \textcolor{keyword}{false}, \textcolor{keyword}{true});
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{try} \{
          evnt = \textcolor{keyword}{new} TransitionEvent(eventType, eventData);
        \}
        \textcolor{keywordflow}{catch} (e) \{
          evnt = document.createEvent(\textcolor{stringliteral}{'TransitionEvent'});
          evnt.initTransitionEvent(eventType, null, null, null, eventData.elapsedTime || 0);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (/animationend/.test(eventType)) \{
      \textcolor{keywordflow}{if} (window.WebKitAnimationEvent) \{
        evnt = \textcolor{keyword}{new} WebKitAnimationEvent(eventType, eventData);
        evnt.initEvent(eventType, \textcolor{keyword}{false}, \textcolor{keyword}{true});
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{try} \{
          evnt = \textcolor{keyword}{new} AnimationEvent(eventType, eventData);
        \}
        \textcolor{keywordflow}{catch} (e) \{
          evnt = document.createEvent(\textcolor{stringliteral}{'AnimationEvent'});
          evnt.initAnimationEvent(eventType, null, null, null, eventData.elapsedTime || 0);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (/touch/.test(eventType) && supportsTouchEvents()) \{
      evnt = createTouchEvent(element, eventType, x, y);
    \} \textcolor{keywordflow}{else} \{
      evnt = document.createEvent(\textcolor{stringliteral}{'MouseEvents'});
      x = x || 0;
      y = y || 0;
      evnt.initMouseEvent(eventType, \textcolor{keyword}{true}, \textcolor{keyword}{true}, window, 0, x, y, x, y, pressed(\textcolor{stringliteral}{'ctrl'}),
          pressed(\textcolor{stringliteral}{'alt'}), pressed(\textcolor{stringliteral}{'shift'}), pressed(\textcolor{stringliteral}{'meta'}), 0, element);
    \}

    \textcolor{comment}{/* we're unable to change the timeStamp value directly so this}
\textcolor{comment}{     * is only here to allow for testing where the timeStamp value is}
\textcolor{comment}{     * read */}
    evnt.$manualTimeStamp = eventData.timeStamp;

    \textcolor{keywordflow}{if} (!evnt) \textcolor{keywordflow}{return};

    var originalPreventDefault = evnt.preventDefault,
        appWindow = element.ownerDocument.defaultView,
        fakeProcessDefault = \textcolor{keyword}{true},
        finalProcessDefault,
        angular = appWindow.angular || \{\};

    \textcolor{comment}{// igor: temporary fix for https://bugzilla.mozilla.org/show\_bug.cgi?id=684208}
    angular[\textcolor{stringliteral}{'ff-684208-preventDefault'}] = \textcolor{keyword}{false};
    evnt.preventDefault = \textcolor{keyword}{function}() \{
      fakeProcessDefault = \textcolor{keyword}{false};
      \textcolor{keywordflow}{return} originalPreventDefault.apply(evnt, arguments);
    \};

    element.dispatchEvent(evnt);
    finalProcessDefault = !(angular[\textcolor{stringliteral}{'ff-684208-preventDefault'}] || !fakeProcessDefault);

    \textcolor{keyword}{delete} angular[\textcolor{stringliteral}{'ff-684208-preventDefault'}];

    \textcolor{keywordflow}{return} finalProcessDefault;
  \};

  \textcolor{keyword}{function} supportsTouchEvents() \{
    \textcolor{keywordflow}{if} (\textcolor{stringliteral}{'\_cached'} in supportsTouchEvents) \{
      \textcolor{keywordflow}{return} supportsTouchEvents.\_cached;
    \}
    \textcolor{keywordflow}{if} (!document.createTouch || !document.createTouchList) \{
      supportsTouchEvents.\_cached = \textcolor{keyword}{false};
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
    \textcolor{keywordflow}{try} \{
      document.createEvent(\textcolor{stringliteral}{'TouchEvent'});
    \} \textcolor{keywordflow}{catch} (e) \{
      supportsTouchEvents.\_cached = \textcolor{keyword}{false};
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
    supportsTouchEvents.\_cached = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}

  \textcolor{keyword}{function} createTouchEvent(element, eventType, x, y) \{
    var evnt = \textcolor{keyword}{new} Event(eventType);
    x = x || 0;
    y = y || 0;

    var touch = document.createTouch(window, element, Date.now(), x, y, x, y);
    var touches = document.createTouchList(touch);

    evnt.touches = touches;

    \textcolor{keywordflow}{return} evnt;
  \}
\}());

angular.scenario.Application = \textcolor{keyword}{function}(context) \{
  this.context = context;
  context.append(
    \textcolor{stringliteral}{'<h2>Current URL: <a href="about:blank">None</a></h2>'} +
    \textcolor{stringliteral}{'<div id="test-frames"></div>'}
  );
\};

angular.scenario.Application.prototype.getFrame\_ = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.context.find(\textcolor{stringliteral}{'#test-frames iframe:last'});
\};

angular.scenario.Application.prototype.getWindow\_ = \textcolor{keyword}{function}() \{
  var contentWindow = this.getFrame\_().prop(\textcolor{stringliteral}{'contentWindow'});
  \textcolor{keywordflow}{if} (!contentWindow) \{
    \textcolor{keywordflow}{throw} \textcolor{stringliteral}{'Frame window is not accessible.'};
  \}
  \textcolor{keywordflow}{return} contentWindow;
\};

angular.scenario.Application.prototype.navigateTo = \textcolor{keyword}{function}(url, loadFn, errorFn) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  var frame = \textcolor{keyword}{self}.getFrame\_();
  \textcolor{comment}{//TODO(esprehn): Refactor to use rethrow()}
  errorFn = errorFn || \textcolor{keyword}{function}(e) \{ \textcolor{keywordflow}{throw} e; \};
  \textcolor{keywordflow}{if} (url === \textcolor{stringliteral}{'about:blank'}) \{
    errorFn(\textcolor{stringliteral}{'Sandbox Error: Navigating to about:blank is not allowed.'});
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (url.charAt(0) === \textcolor{charliteral}{'#'}) \{
    url = frame.attr(\textcolor{stringliteral}{'src'}).split(\textcolor{charliteral}{'#'})[0] + url;
    frame.attr(\textcolor{stringliteral}{'src'}, url);
    \textcolor{keyword}{self}.executeAction(loadFn);
  \} \textcolor{keywordflow}{else} \{
    frame.remove();
    \textcolor{keyword}{self}.context.find(\textcolor{stringliteral}{'#test-frames'}).append(\textcolor{stringliteral}{'<iframe>'});
    frame = \textcolor{keyword}{self}.getFrame\_();

    frame.load(\textcolor{keyword}{function}() \{
      frame.off();
      \textcolor{keywordflow}{try} \{
        var $window = \textcolor{keyword}{self}.getWindow\_();

        \textcolor{keywordflow}{if} (!$window.angular) \{
          \textcolor{keyword}{self}.executeAction(loadFn);
          \textcolor{keywordflow}{return};
        \}

        \textcolor{keywordflow}{if} (!$window.angular.resumeBootstrap) \{
          $window.angular.resumeDeferredBootstrap = resumeDeferredBootstrap;
        \} \textcolor{keywordflow}{else} \{
          resumeDeferredBootstrap();
        \}

      \} \textcolor{keywordflow}{catch} (e) \{
        errorFn(e);
      \}

      \textcolor{keyword}{function} resumeDeferredBootstrap() \{
        \textcolor{comment}{// Disable animations}
        var $injector = $window.angular.resumeBootstrap([[\textcolor{stringliteral}{'$provide'}, \textcolor{keyword}{function}($provide) \{
          \textcolor{keywordflow}{return} [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
            $animate.enabled(\textcolor{keyword}{false});
          \}];
        \}]]);
        \textcolor{keyword}{self}.rootElement = $injector.get(\textcolor{stringliteral}{'$rootElement'})[0];
        \textcolor{keyword}{self}.executeAction(loadFn);
      \}
    \}).attr(\textcolor{stringliteral}{'src'}, url);

    \textcolor{comment}{// for IE compatibility set the name *after* setting the frame url}
    frame[0].contentWindow.name = \textcolor{stringliteral}{"NG\_DEFER\_BOOTSTRAP!"};
  \}
  \textcolor{keyword}{self}.context.find(\textcolor{stringliteral}{'> h2 a'}).attr(\textcolor{stringliteral}{'href'}, url).text(url);
\};

angular.scenario.Application.prototype.executeAction = \textcolor{keyword}{function}(action) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  var $window = this.getWindow\_();
  \textcolor{keywordflow}{if} (!$window.document) \{
    \textcolor{keywordflow}{throw} \textcolor{stringliteral}{'Sandbox Error: Application document not accessible.'};
  \}
  \textcolor{keywordflow}{if} (!$window.angular) \{
    \textcolor{keywordflow}{return} action.call(\textcolor{keyword}{this}, $window, \_jQuery($window.document));
  \}

  \textcolor{keywordflow}{if} (!!this.rootElement) \{
    executeWithElement(this.rootElement);
  \} \textcolor{keywordflow}{else} \{
    angularInit($window.document, angular.bind(\textcolor{keyword}{this}, executeWithElement));
  \}

  \textcolor{keyword}{function} executeWithElement(element) \{
    var $injector = $window.angular.element(element).injector();
    var $element = \_jQuery(element);

    $element.injector = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} $injector;
    \};

    $injector.invoke(\textcolor{keyword}{function}($browser) \{
      $browser.notifyWhenNoOutstandingRequests(\textcolor{keyword}{function}() \{
        action.call(\textcolor{keyword}{self}, $window, $element);
      \});
    \});
  \}
\};

angular.scenario.Describe = \textcolor{keyword}{function}(descName, parent) \{
  this.only = parent && parent.only;
  this.beforeEachFns = [];
  this.afterEachFns = [];
  this.its = [];
  this.children = [];
  this.name = descName;
  this.parent = parent;
  this.\textcolor{keywordtype}{id} = angular.scenario.Describe.id++;

  var beforeEachFns = this.beforeEachFns;
  this.setupBefore = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} (parent) parent.setupBefore.call(\textcolor{keyword}{this});
    angular.forEach(beforeEachFns, \textcolor{keyword}{function}(fn) \{ fn.call(\textcolor{keyword}{this}); \}, \textcolor{keyword}{this});
  \};

  var afterEachFns = this.afterEachFns;
  this.setupAfter  = \textcolor{keyword}{function}() \{
    angular.forEach(afterEachFns, \textcolor{keyword}{function}(fn) \{ fn.call(\textcolor{keyword}{this}); \}, \textcolor{keyword}{this});
    \textcolor{keywordflow}{if} (parent) parent.setupAfter.call(\textcolor{keyword}{this});
  \};
\};

\textcolor{comment}{// Shared Unique ID generator for every describe block}
angular.scenario.Describe.id = 0;

\textcolor{comment}{// Shared Unique ID generator for every it (spec)}
angular.scenario.Describe.specId = 0;

angular.scenario.Describe.prototype.beforeEach = \textcolor{keyword}{function}(body) \{
  this.beforeEachFns.push(body);
\};

angular.scenario.Describe.prototype.afterEach = \textcolor{keyword}{function}(body) \{
  this.afterEachFns.push(body);
\};

angular.scenario.Describe.prototype.describe = \textcolor{keyword}{function}(name, body) \{
  var child = \textcolor{keyword}{new} angular.scenario.Describe(name, \textcolor{keyword}{this});
  this.children.push(child);
  body.call(child);
\};

angular.scenario.Describe.prototype.ddescribe = \textcolor{keyword}{function}(name, body) \{
  var child = \textcolor{keyword}{new} angular.scenario.Describe(name, \textcolor{keyword}{this});
  child.only = \textcolor{keyword}{true};
  this.children.push(child);
  body.call(child);
\};

angular.scenario.Describe.prototype.xdescribe = angular.noop;

angular.scenario.Describe.prototype.it = \textcolor{keyword}{function}(name, body) \{
  this.its.push(\{
    \textcolor{keywordtype}{id}: angular.scenario.Describe.specId++,
    definition: \textcolor{keyword}{this},
    only: this.only,
    name: name,
    before: this.setupBefore,
    body: body,
    after: this.setupAfter
  \});
\};

angular.scenario.Describe.prototype.iit = \textcolor{keyword}{function}(name, body) \{
  this.it.apply(\textcolor{keyword}{this}, arguments);
  this.its[this.its.length - 1].only = \textcolor{keyword}{true};
\};

angular.scenario.Describe.prototype.xit = angular.noop;

angular.scenario.Describe.prototype.getSpecs = \textcolor{keyword}{function}() \{
  var specs = arguments[0] || [];
  angular.forEach(this.children, \textcolor{keyword}{function}(child) \{
    child.getSpecs(specs);
  \});
  angular.forEach(this.its, \textcolor{keyword}{function}(it) \{
    specs.push(it);
  \});
  var only = [];
  angular.forEach(specs, \textcolor{keyword}{function}(it) \{
    \textcolor{keywordflow}{if} (it.only) \{
      only.push(it);
    \}
  \});
  \textcolor{keywordflow}{return} (only.length && only) || specs;
\};

angular.scenario.Future = \textcolor{keyword}{function}(name, behavior, line) \{
  this.name = name;
  this.behavior = behavior;
  this.fulfilled = \textcolor{keyword}{false};
  this.value = undefined;
  this.parser = angular.identity;
  this.line = line || \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{''}; \};
\};

angular.scenario.Future.prototype.execute = \textcolor{keyword}{function}(doneFn) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  this.behavior(\textcolor{keyword}{function}(error, result) \{
    \textcolor{keyword}{self}.fulfilled = \textcolor{keyword}{true};
    \textcolor{keywordflow}{if} (result) \{
      \textcolor{keywordflow}{try} \{
        result = \textcolor{keyword}{self}.parser(result);
      \} \textcolor{keywordflow}{catch} (e) \{
        error = e;
      \}
    \}
    \textcolor{keyword}{self}.value = error || result;
    doneFn(error, result);
  \});
\};

angular.scenario.Future.prototype.parsedWith = \textcolor{keyword}{function}(fn) \{
  this.parser = fn;
  \textcolor{keywordflow}{return} \textcolor{keyword}{this};
\};

angular.scenario.Future.prototype.fromJson = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.parsedWith(angular.fromJson);
\};

angular.scenario.Future.prototype.toJson = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.parsedWith(angular.toJson);
\};

angular.scenario.ObjectModel = \textcolor{keyword}{function}(runner) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};

  this.specMap = \{\};
  this.listeners = [];
  this.value = \{
    name: \textcolor{stringliteral}{''},
    children: \{\}
  \};

  runner.on(\textcolor{stringliteral}{'SpecBegin'}, \textcolor{keyword}{function}(spec) \{
    var block = \textcolor{keyword}{self}.value,
        definitions = [];

    angular.forEach(\textcolor{keyword}{self}.getDefinitionPath(spec), \textcolor{keyword}{function}(def) \{
      \textcolor{keywordflow}{if} (!block.children[def.name]) \{
        block.children[def.name] = \{
          id: def.id,
          name: def.name,
          children: \{\},
          specs: \{\}
        \};
      \}
      block = block.children[def.name];
      definitions.push(def.name);
    \});

    var it = \textcolor{keyword}{self}.specMap[spec.id] =
             block.specs[spec.name] =
             \textcolor{keyword}{new} angular.scenario.ObjectModel.Spec(spec.id, spec.name, definitions);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'SpecBegin'}, it);
  \});

  runner.on(\textcolor{stringliteral}{'SpecError'}, \textcolor{keyword}{function}(spec, error) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id);
    it.status = \textcolor{stringliteral}{'error'};
    it.error = error;

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'SpecError'}, it, error);
  \});

  runner.on(\textcolor{stringliteral}{'SpecEnd'}, \textcolor{keyword}{function}(spec) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id);
    complete(it);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'SpecEnd'}, it);
  \});

  runner.on(\textcolor{stringliteral}{'StepBegin'}, \textcolor{keyword}{function}(spec, step) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id);
    step = \textcolor{keyword}{new} angular.scenario.ObjectModel.Step(step.name);
    it.steps.push(step);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepBegin'}, it, step);
  \});

  runner.on(\textcolor{stringliteral}{'StepEnd'}, \textcolor{keyword}{function}(spec) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id);
    var step = it.getLastStep();
    \textcolor{keywordflow}{if} (step.name !== step.name) \{
      \textcolor{keywordflow}{throw} \textcolor{stringliteral}{'Events fired in the wrong order. Step names don\(\backslash\)'t match.'};
    \}
    complete(step);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepEnd'}, it, step);
  \});

  runner.on(\textcolor{stringliteral}{'StepFailure'}, \textcolor{keyword}{function}(spec, step, error) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id),
        modelStep = it.getLastStep();

    modelStep.setErrorStatus(\textcolor{stringliteral}{'failure'}, error, step.line());
    it.setStatusFromStep(modelStep);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepFailure'}, it, modelStep, error);
  \});

  runner.on(\textcolor{stringliteral}{'StepError'}, \textcolor{keyword}{function}(spec, step, error) \{
    var it = \textcolor{keyword}{self}.getSpec(spec.id),
        modelStep = it.getLastStep();

    modelStep.setErrorStatus(\textcolor{stringliteral}{'error'}, error, step.line());
    it.setStatusFromStep(modelStep);

    \textcolor{comment}{// forward the event}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepError'}, it, modelStep, error);
  \});

  runner.on(\textcolor{stringliteral}{'RunnerBegin'}, \textcolor{keyword}{function}() \{
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'RunnerBegin'});
  \});
  runner.on(\textcolor{stringliteral}{'RunnerEnd'}, \textcolor{keyword}{function}() \{
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'RunnerEnd'});
  \});

  \textcolor{keyword}{function} complete(item) \{
    item.endTime = Date.now();
    item.duration = item.endTime - item.startTime;
    item.status = item.status || \textcolor{stringliteral}{'success'};
  \}
\};

angular.scenario.ObjectModel.prototype.on = \textcolor{keyword}{function}(eventName, listener) \{
  eventName = eventName.toLowerCase();
  this.listeners[eventName] = this.listeners[eventName] || [];
  this.listeners[eventName].push(listener);
\};

angular.scenario.ObjectModel.prototype.emit = \textcolor{keyword}{function}(eventName) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this},
      args = Array.prototype.slice.call(arguments, 1);

  eventName = eventName.toLowerCase();

  \textcolor{keywordflow}{if} (this.listeners[eventName]) \{
    angular.forEach(this.listeners[eventName], \textcolor{keyword}{function}(listener) \{
      listener.apply(\textcolor{keyword}{self}, args);
    \});
  \}
\};

angular.scenario.ObjectModel.prototype.getDefinitionPath = \textcolor{keyword}{function}(spec) \{
  var path = [];
  var currentDefinition = spec.definition;
  \textcolor{keywordflow}{while} (currentDefinition && currentDefinition.name) \{
    path.unshift(currentDefinition);
    currentDefinition = currentDefinition.parent;
  \}
  \textcolor{keywordflow}{return} path;
\};

angular.scenario.ObjectModel.prototype.getSpec = \textcolor{keyword}{function}(id) \{
  \textcolor{keywordflow}{return} this.specMap[id];
\};

angular.scenario.ObjectModel.Spec = \textcolor{keyword}{function}(id, name, definitionNames) \{
  this.\textcolor{keywordtype}{id} = id;
  this.name = name;
  this.startTime = Date.now();
  this.steps = [];
  this.fullDefinitionName = (definitionNames || []).join(\textcolor{charliteral}{' '});
\};

angular.scenario.ObjectModel.Spec.prototype.addStep = \textcolor{keyword}{function}(name) \{
  var step = \textcolor{keyword}{new} angular.scenario.ObjectModel.Step(name);
  this.steps.push(step);
  \textcolor{keywordflow}{return} step;
\};

angular.scenario.ObjectModel.Spec.prototype.getLastStep = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.steps[this.steps.length - 1];
\};

angular.scenario.ObjectModel.Spec.prototype.setStatusFromStep = \textcolor{keyword}{function}(step) \{
  \textcolor{keywordflow}{if} (!this.status || step.status == \textcolor{stringliteral}{'error'}) \{
    this.status = step.status;
    this.error = step.error;
    this.line = step.line;
  \}
\};

angular.scenario.ObjectModel.Step = \textcolor{keyword}{function}(name) \{
  this.name = name;
  this.startTime = Date.now();
\};

angular.scenario.ObjectModel.Step.prototype.setErrorStatus = \textcolor{keyword}{function}(status, error, line) \{
  this.status = status;
  this.error = error;
  this.line = line;
\};

angular.scenario.Runner = \textcolor{keyword}{function}($window) \{
  this.listeners = [];
  this.$window = $window;
  this.rootDescribe = \textcolor{keyword}{new} angular.scenario.Describe();
  this.currentDescribe = this.rootDescribe;
  this.api = \{
    it: this.it,
    iit: this.iit,
    xit: angular.noop,
    describe: this.describe,
    ddescribe: this.ddescribe,
    xdescribe: angular.noop,
    beforeEach: this.beforeEach,
    afterEach: this.afterEach
  \};
  angular.forEach(this.api, angular.bind(\textcolor{keyword}{this}, \textcolor{keyword}{function}(fn, key) \{
    this.$window[key] = angular.bind(this, fn);
  \}));
\};

angular.scenario.Runner.prototype.emit = \textcolor{keyword}{function}(eventName) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  var args = Array.prototype.slice.call(arguments, 1);
  eventName = eventName.toLowerCase();
  \textcolor{keywordflow}{if} (!this.listeners[eventName]) \{
    \textcolor{keywordflow}{return};
  \}
  angular.forEach(this.listeners[eventName], \textcolor{keyword}{function}(listener) \{
    listener.apply(\textcolor{keyword}{self}, args);
  \});
\};

angular.scenario.Runner.prototype.on = \textcolor{keyword}{function}(eventName, listener) \{
  eventName = eventName.toLowerCase();
  this.listeners[eventName] = this.listeners[eventName] || [];
  this.listeners[eventName].push(listener);
\};

angular.scenario.Runner.prototype.describe = \textcolor{keyword}{function}(name, body) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  this.currentDescribe.describe(name, \textcolor{keyword}{function}() \{
    var parentDescribe = \textcolor{keyword}{self}.currentDescribe;
    \textcolor{keyword}{self}.currentDescribe = \textcolor{keyword}{this};
    \textcolor{keywordflow}{try} \{
      body.call(\textcolor{keyword}{this});
    \} \textcolor{keywordflow}{finally} \{
      \textcolor{keyword}{self}.currentDescribe = parentDescribe;
    \}
  \});
\};

angular.scenario.Runner.prototype.ddescribe = \textcolor{keyword}{function}(name, body) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  this.currentDescribe.ddescribe(name, \textcolor{keyword}{function}() \{
    var parentDescribe = \textcolor{keyword}{self}.currentDescribe;
    \textcolor{keyword}{self}.currentDescribe = \textcolor{keyword}{this};
    \textcolor{keywordflow}{try} \{
      body.call(\textcolor{keyword}{this});
    \} \textcolor{keywordflow}{finally} \{
      \textcolor{keyword}{self}.currentDescribe = parentDescribe;
    \}
  \});
\};

angular.scenario.Runner.prototype.it = \textcolor{keyword}{function}(name, body) \{
  this.currentDescribe.it(name, body);
\};

angular.scenario.Runner.prototype.iit = \textcolor{keyword}{function}(name, body) \{
  this.currentDescribe.iit(name, body);
\};

angular.scenario.Runner.prototype.beforeEach = \textcolor{keyword}{function}(body) \{
  this.currentDescribe.beforeEach(body);
\};

angular.scenario.Runner.prototype.afterEach = \textcolor{keyword}{function}(body) \{
  this.currentDescribe.afterEach(body);
\};

angular.scenario.Runner.prototype.createSpecRunner\_ = \textcolor{keyword}{function}(scope) \{
  var child = scope.$new();
  var Cls = angular.scenario.SpecRunner;

  \textcolor{comment}{// Export all the methods to child scope manually as now we don't mess controllers with scopes}
  \textcolor{comment}{// TODO(vojta): refactor scenario runner so that these objects are not tightly coupled as current}
  \textcolor{keywordflow}{for} (var name in Cls.prototype) \{
    child[name] = angular.bind(child, Cls.prototype[name]);
  \}

  Cls.call(child);
  \textcolor{keywordflow}{return} child;
\};

angular.scenario.Runner.prototype.run = \textcolor{keyword}{function}(application) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  var $root = angular.injector([\textcolor{stringliteral}{'ng'}]).get(\textcolor{stringliteral}{'$rootScope'});
  angular.extend($root, \textcolor{keyword}{this});
  angular.forEach(angular.scenario.Runner.prototype, \textcolor{keyword}{function}(fn, name) \{
    $root[name] = angular.bind(self, fn);
  \});
  $root.application = application;
  $root.emit(\textcolor{stringliteral}{'RunnerBegin'});
  asyncForEach(this.rootDescribe.getSpecs(), \textcolor{keyword}{function}(spec, specDone) \{
    var dslCache = \{\};
    var runner = \textcolor{keyword}{self}.createSpecRunner\_($root);
    angular.forEach(angular.scenario.dsl, \textcolor{keyword}{function}(fn, key) \{
      dslCache[key] = fn.call($root);
    \});
    angular.forEach(angular.scenario.dsl, \textcolor{keyword}{function}(fn, key) \{
      self.$window[key] = function() \{
        var line = callerFile(3);
        var scope = runner.$new();

        \textcolor{comment}{// Make the dsl accessible on the current chain}
        scope.dsl = \{\};
        angular.forEach(dslCache, function(fn, key) \{
          scope.dsl[key] = function() \{
            return dslCache[key].apply(scope, arguments);
          \};
        \});

        \textcolor{comment}{// Make these methods work on the current chain}
        scope.addFuture = function() \{
          Array.prototype.push.call(arguments, line);
          return angular.scenario.SpecRunner.
            prototype.addFuture.apply(scope, arguments);
        \};
        scope.addFutureAction = function() \{
          Array.prototype.push.call(arguments, line);
          return angular.scenario.SpecRunner.
            prototype.addFutureAction.apply(scope, arguments);
        \};

        return scope.dsl[key].apply(scope, arguments);
      \};
    \});
    runner.run(spec, \textcolor{keyword}{function}() \{
      runner.$destroy();
      specDone.apply(\textcolor{keyword}{this}, arguments);
    \});
  \},
  \textcolor{keyword}{function}(error) \{
    \textcolor{keywordflow}{if} (error) \{
      \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'RunnerError'}, error);
    \}
    \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'RunnerEnd'});
  \});
\};

angular.scenario.SpecRunner = \textcolor{keyword}{function}() \{
  this.futures = [];
  this.afterIndex = 0;
\};

angular.scenario.SpecRunner.prototype.run = \textcolor{keyword}{function}(spec, specDone) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  this.spec = spec;

  this.emit(\textcolor{stringliteral}{'SpecBegin'}, spec);

  \textcolor{keywordflow}{try} \{
    spec.before.call(\textcolor{keyword}{this});
    spec.body.call(\textcolor{keyword}{this});
    this.afterIndex = this.futures.length;
    spec.after.call(\textcolor{keyword}{this});
  \} \textcolor{keywordflow}{catch} (e) \{
    this.emit(\textcolor{stringliteral}{'SpecError'}, spec, e);
    this.emit(\textcolor{stringliteral}{'SpecEnd'}, spec);
    specDone();
    \textcolor{keywordflow}{return};
  \}

  var handleError = \textcolor{keyword}{function}(error, done) \{
    \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.error) \{
      \textcolor{keywordflow}{return} done();
    \}
    \textcolor{keyword}{self}.error = \textcolor{keyword}{true};
    done(null, \textcolor{keyword}{self}.afterIndex);
  \};

  asyncForEach(
    this.futures,
    \textcolor{keyword}{function}(future, futureDone) \{
      \textcolor{keyword}{self}.step = future;
      \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepBegin'}, spec, future);
      \textcolor{keywordflow}{try} \{
        future.execute(\textcolor{keyword}{function}(error) \{
          \textcolor{keywordflow}{if} (error) \{
            \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepFailure'}, spec, future, error);
            \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepEnd'}, spec, future);
            \textcolor{keywordflow}{return} handleError(error, futureDone);
          \}
          \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepEnd'}, spec, future);
          \textcolor{keyword}{self}.$window.setTimeout(\textcolor{keyword}{function}() \{ futureDone(); \}, 0);
        \});
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepError'}, spec, future, e);
        \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'StepEnd'}, spec, future);
        handleError(e, futureDone);
      \}
    \},
    \textcolor{keyword}{function}(e) \{
      \textcolor{keywordflow}{if} (e) \{
        \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'SpecError'}, spec, e);
      \}
      \textcolor{keyword}{self}.emit(\textcolor{stringliteral}{'SpecEnd'}, spec);
      \textcolor{comment}{// Call done in a timeout so exceptions don't recursively}
      \textcolor{comment}{// call this function}
      \textcolor{keyword}{self}.$window.setTimeout(\textcolor{keyword}{function}() \{ specDone(); \}, 0);
    \}
  );
\};

angular.scenario.SpecRunner.prototype.addFuture = \textcolor{keyword}{function}(name, behavior, line) \{
  var future = \textcolor{keyword}{new} angular.scenario.Future(name, angular.bind(\textcolor{keyword}{this}, behavior), line);
  this.futures.push(future);
  \textcolor{keywordflow}{return} future;
\};

angular.scenario.SpecRunner.prototype.addFutureAction = \textcolor{keyword}{function}(name, behavior, line) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this};
  var NG = /\(\backslash\)[ng\(\backslash\)\(\backslash\)\(\backslash\):/;
  \textcolor{keywordflow}{return} this.addFuture(name, \textcolor{keyword}{function}(done) \{
    this.application.executeAction(\textcolor{keyword}{function}($window, $document) \{

      \textcolor{comment}{//TODO(esprehn): Refactor this so it doesn't need to be in here.}
      $document.elements = \textcolor{keyword}{function}(selector) \{
        var args = Array.prototype.slice.call(arguments, 1);
        selector = (\textcolor{keyword}{self}.selector || \textcolor{stringliteral}{''}) + \textcolor{charliteral}{' '} + (selector || \textcolor{stringliteral}{''});
        selector = \_jQuery.trim(selector) || \textcolor{charliteral}{'*'};
        angular.forEach(args, \textcolor{keyword}{function}(value, index) \{
          selector = selector.replace(\textcolor{charliteral}{'$'} + (index + 1), value);
        \});
        var result = $document.find(selector);
        \textcolor{keywordflow}{if} (selector.match(NG)) \{
          angular.forEach([\textcolor{stringliteral}{'[ng-'},\textcolor{stringliteral}{'[data-ng-'},\textcolor{stringliteral}{'[x-ng-'}], \textcolor{keyword}{function}(value, index) \{
            result = result.add(selector.replace(NG, value), $document);
          \});
        \}
        \textcolor{keywordflow}{if} (!result.length) \{
          \textcolor{keywordflow}{throw} \{
            type: \textcolor{stringliteral}{'selector'},
            message: \textcolor{stringliteral}{'Selector '} + selector + \textcolor{stringliteral}{' did not match any elements.'}
          \};
        \}

        \textcolor{keywordflow}{return} result;
      \};

      \textcolor{keywordflow}{try} \{
        behavior.call(\textcolor{keyword}{self}, $window, $document, done);
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{keywordflow}{if} (e.type && e.type === \textcolor{stringliteral}{'selector'}) \{
          done(e.message);
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{throw} e;
        \}
      \}
    \});
  \}, line);
\};

angular.scenario.dsl(\textcolor{stringliteral}{'pause'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFuture(\textcolor{stringliteral}{'pausing for you to resume'}, \textcolor{keyword}{function}(done) \{
      this.emit(\textcolor{stringliteral}{'InteractivePause'}, this.spec, this.step);
      this.$window.resume = \textcolor{keyword}{function}() \{ done(); \};
    \});
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'sleep'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(time) \{
    \textcolor{keywordflow}{return} this.addFuture(\textcolor{stringliteral}{'sleep for '} + time + \textcolor{stringliteral}{' seconds'}, \textcolor{keyword}{function}(done) \{
      this.$window.setTimeout(\textcolor{keyword}{function}() \{ done(null, time * 1000); \}, time * 1000);
    \});
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'browser'}, \textcolor{keyword}{function}() \{
  var chain = \{\};

  chain.navigateTo = \textcolor{keyword}{function}(url, delegate) \{
    var application = this.application;
    \textcolor{keywordflow}{return} this.addFuture(\textcolor{stringliteral}{"browser navigate to '"} + url + \textcolor{stringliteral}{"'"}, \textcolor{keyword}{function}(done) \{
      \textcolor{keywordflow}{if} (delegate) \{
        url = delegate.call(\textcolor{keyword}{this}, url);
      \}
      application.navigateTo(url, \textcolor{keyword}{function}() \{
        done(null, url);
      \}, done);
    \});
  \};

  chain.reload = \textcolor{keyword}{function}() \{
    var application = this.application;
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'browser reload'}, \textcolor{keyword}{function}($window, $document, done) \{
      var href = $window.location.href;
      application.navigateTo(href, \textcolor{keyword}{function}() \{
        done(null, href);
      \}, done);
    \});
  \};

  chain.window = \textcolor{keyword}{function}() \{
    var api = \{\};

    api.href = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'window.location.href'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $window.location.href);
      \});
    \};

    api.path = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'window.location.path'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $window.location.pathname);
      \});
    \};

    api.search = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'window.location.search'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $window.location.search);
      \});
    \};

    api.hash = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'window.location.hash'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $window.location.hash.replace(\textcolor{charliteral}{'#'}, \textcolor{stringliteral}{''}));
      \});
    \};

    \textcolor{keywordflow}{return} api;
  \};

  chain.location = \textcolor{keyword}{function}() \{
    var api = \{\};

    api.url = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'$location.url()'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $document.injector().get(\textcolor{stringliteral}{'$location'}).url());
      \});
    \};

    api.path = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'$location.path()'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $document.injector().get(\textcolor{stringliteral}{'$location'}).path());
      \});
    \};

    api.search = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'$location.search()'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $document.injector().get(\textcolor{stringliteral}{'$location'}).search());
      \});
    \};

    api.hash = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'$location.hash()'}, \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $document.injector().get(\textcolor{stringliteral}{'$location'}).hash());
      \});
    \};

    \textcolor{keywordflow}{return} api;
  \};

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} chain;
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'expect'}, \textcolor{keyword}{function}() \{
  var chain = angular.extend(\{\}, angular.scenario.matcher);

  chain.not = \textcolor{keyword}{function}() \{
    this.inverse = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} chain;
  \};

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(future) \{
    this.future = future;
    \textcolor{keywordflow}{return} chain;
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'using'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(selector, label) \{
    this.selector = \_jQuery.trim((this.selector || \textcolor{stringliteral}{''}) + \textcolor{charliteral}{' '} + selector);
    \textcolor{keywordflow}{if} (angular.isString(label) && label.length) \{
      this.label = label + \textcolor{stringliteral}{' ( '} + this.selector + \textcolor{stringliteral}{' )'};
    \} \textcolor{keywordflow}{else} \{
      this.label = this.selector;
    \}
    \textcolor{keywordflow}{return} this.dsl;
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'binding'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(name) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"select binding '"} + name + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var values = $document.elements().bindings($window.angular.element, name);
        \textcolor{keywordflow}{if} (!values.length) \{
          \textcolor{keywordflow}{return} done(\textcolor{stringliteral}{"Binding selector '"} + name + \textcolor{stringliteral}{"' did not match."});
        \}
        done(null, values[0]);
    \});
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'input'}, \textcolor{keyword}{function}() \{
  var chain = \{\};
  var supportInputEvent = \textcolor{stringliteral}{'oninput'} in document.createElement(\textcolor{stringliteral}{'div'}) && !(msie && msie <= 11);

  chain.enter = \textcolor{keyword}{function}(value, event) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"input '"} + this.name + \textcolor{stringliteral}{"' enter '"} + value + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var input = $document.elements(\textcolor{stringliteral}{'[ng\(\backslash\)\(\backslash\):model="$1"]'}, this.name).filter(\textcolor{stringliteral}{':input'});
        input.val(value);
        input.trigger(event || (supportInputEvent ? \textcolor{stringliteral}{'input'} : \textcolor{stringliteral}{'change'}));
        done();
    \});
  \};

  chain.check = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"checkbox '"} + this.name + \textcolor{stringliteral}{"' toggle"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var input = $document.elements(\textcolor{stringliteral}{'[ng\(\backslash\)\(\backslash\):model="$1"]'}, this.name).filter(\textcolor{stringliteral}{':checkbox'});
        input.trigger(\textcolor{stringliteral}{'click'});
        done();
    \});
  \};

  chain.select = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"radio button '"} + this.name + \textcolor{stringliteral}{"' toggle '"} + value + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var input = $document.
          elements(\textcolor{stringliteral}{'[ng\(\backslash\)\(\backslash\):model="$1"][value="$2"]'}, this.name, value).filter(\textcolor{stringliteral}{':radio'});
        input.trigger(\textcolor{stringliteral}{'click'});
        done();
    \});
  \};

  chain.val = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"return input val"}, \textcolor{keyword}{function}($window, $document, done) \{
      var input = $document.elements(\textcolor{stringliteral}{'[ng\(\backslash\)\(\backslash\):model="$1"]'}, this.name).filter(\textcolor{stringliteral}{':input'});
      done(null,input.val());
    \});
  \};

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(name) \{
    this.name = name;
    \textcolor{keywordflow}{return} chain;
  \};
\});


angular.scenario.dsl(\textcolor{stringliteral}{'repeater'}, \textcolor{keyword}{function}() \{
  var chain = \{\};

  chain.count = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"repeater '"} + this.label + \textcolor{stringliteral}{"' count"},
      \textcolor{keyword}{function}($window, $document, done) \{
        \textcolor{keywordflow}{try} \{
          done(null, $document.elements().length);
        \} \textcolor{keywordflow}{catch} (e) \{
          done(null, 0);
        \}
    \});
  \};

  chain.column = \textcolor{keyword}{function}(binding) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"repeater '"} + this.label + \textcolor{stringliteral}{"' column '"} + binding + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        done(null, $document.elements().bindings($window.angular.element, binding));
    \});
  \};

  chain.row = \textcolor{keyword}{function}(index) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"repeater '"} + this.label + \textcolor{stringliteral}{"' row '"} + index + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var matches = $document.elements().slice(index, index + 1);
        \textcolor{keywordflow}{if} (!matches.length) \{
          \textcolor{keywordflow}{return} done(\textcolor{stringliteral}{'row '} + index + \textcolor{stringliteral}{' out of bounds'});
        \}
        done(null, matches.bindings($window.angular.element));
    \});
  \};

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(selector, label) \{
    this.dsl.using(selector, label);
    \textcolor{keywordflow}{return} chain;
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'select'}, \textcolor{keyword}{function}() \{
  var chain = \{\};

  chain.option = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"select '"} + this.name + \textcolor{stringliteral}{"' option '"} + value + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var select = $document.elements(\textcolor{stringliteral}{'select[ng\(\backslash\)\(\backslash\):model="$1"]'}, this.name);
        var option = select.find(\textcolor{stringliteral}{'option[value="'} + value + \textcolor{stringliteral}{'"]'});
        \textcolor{keywordflow}{if} (option.length) \{
          select.val(value);
        \} \textcolor{keywordflow}{else} \{
          option = select.find(\textcolor{stringliteral}{'option'}).filter(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} \_jQuery(\textcolor{keyword}{this}).text() === value;
          \});
          \textcolor{keywordflow}{if} (!option.length) \{
            option = select.find(\textcolor{stringliteral}{'option:contains("'} + value + \textcolor{stringliteral}{'")'});
          \}
          \textcolor{keywordflow}{if} (option.length) \{
            select.val(option.val());
          \} \textcolor{keywordflow}{else} \{
              \textcolor{keywordflow}{return} done(\textcolor{stringliteral}{"option '"} + value + \textcolor{stringliteral}{"' not found"});
          \}
        \}
        select.trigger(\textcolor{stringliteral}{'change'});
        done();
    \});
  \};

  chain.options = \textcolor{keyword}{function}() \{
    var values = arguments;
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"select '"} + this.name + \textcolor{stringliteral}{"' options '"} + values + \textcolor{stringliteral}{"'"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var select = $document.elements(\textcolor{stringliteral}{'select[multiple][ng\(\backslash\)\(\backslash\):model="$1"]'}, this.name);
        select.val(values);
        select.trigger(\textcolor{stringliteral}{'change'});
        done();
    \});
  \};

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(name) \{
    this.name = name;
    \textcolor{keywordflow}{return} chain;
  \};
\});

angular.scenario.dsl(\textcolor{stringliteral}{'element'}, \textcolor{keyword}{function}() \{
  var KEY\_VALUE\_METHODS = [\textcolor{stringliteral}{'attr'}, \textcolor{stringliteral}{'css'}, \textcolor{stringliteral}{'prop'}];
  var VALUE\_METHODS = [
    \textcolor{stringliteral}{'val'}, \textcolor{stringliteral}{'text'}, \textcolor{stringliteral}{'html'}, \textcolor{stringliteral}{'height'}, \textcolor{stringliteral}{'innerHeight'}, \textcolor{stringliteral}{'outerHeight'}, \textcolor{stringliteral}{'width'},
    \textcolor{stringliteral}{'innerWidth'}, \textcolor{stringliteral}{'outerWidth'}, \textcolor{stringliteral}{'position'}, \textcolor{stringliteral}{'scrollLeft'}, \textcolor{stringliteral}{'scrollTop'}, \textcolor{stringliteral}{'offset'}
  ];
  var chain = \{\};

  chain.count = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' count"},
      \textcolor{keyword}{function}($window, $document, done) \{
        \textcolor{keywordflow}{try} \{
          done(null, $document.elements().length);
        \} \textcolor{keywordflow}{catch} (e) \{
          done(null, 0);
        \}
    \});
  \};

  chain.click = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' click"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var elements = $document.elements();
        var href = elements.attr(\textcolor{stringliteral}{'href'});
        var eventProcessDefault = elements.trigger(\textcolor{stringliteral}{'click'})[0];

        \textcolor{keywordflow}{if} (href && elements[0].nodeName.toLowerCase() === \textcolor{charliteral}{'a'} && eventProcessDefault) \{
          this.application.navigateTo(href, \textcolor{keyword}{function}() \{
            done();
          \}, done);
        \} \textcolor{keywordflow}{else} \{
          done();
        \}
    \});
  \};

  chain.dblclick = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' dblclick"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var elements = $document.elements();
        var href = elements.attr(\textcolor{stringliteral}{'href'});
        var eventProcessDefault = elements.trigger(\textcolor{stringliteral}{'dblclick'})[0];

        \textcolor{keywordflow}{if} (href && elements[0].nodeName.toLowerCase() === \textcolor{charliteral}{'a'} && eventProcessDefault) \{
          this.application.navigateTo(href, \textcolor{keyword}{function}() \{
            done();
          \}, done);
        \} \textcolor{keywordflow}{else} \{
          done();
        \}
    \});
  \};

  chain.mouseover = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' mouseover"},
      \textcolor{keyword}{function}($window, $document, done) \{
        var elements = $document.elements();
        elements.trigger(\textcolor{stringliteral}{'mouseover'});
        done();
    \});
  \};

  chain.mousedown = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' mousedown"},
        \textcolor{keyword}{function}($window, $document, done) \{
          var elements = $document.elements();
          elements.trigger(\textcolor{stringliteral}{'mousedown'});
          done();
      \});
    \};

  chain.mouseup = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' mouseup"},
        \textcolor{keyword}{function}($window, $document, done) \{
          var elements = $document.elements();
          elements.trigger(\textcolor{stringliteral}{'mouseup'});
          done();
      \});
    \};

  chain.query = \textcolor{keyword}{function}(fn) \{
    \textcolor{keywordflow}{return} this.addFutureAction(\textcolor{stringliteral}{'element '} + this.label + \textcolor{stringliteral}{' custom query'},
      \textcolor{keyword}{function}($window, $document, done) \{
        fn.call(\textcolor{keyword}{this}, $document.elements(), done);
    \});
  \};

  angular.forEach(KEY\_VALUE\_METHODS, \textcolor{keyword}{function}(methodName) \{
    chain[methodName] = \textcolor{keyword}{function}(name, value) \{
      var args = arguments,
          futureName = (args.length == 1)
              ? \textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' get "} + methodName + \textcolor{stringliteral}{" '"} + name + \textcolor{stringliteral}{"'"}
              : \textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' set "} + methodName + \textcolor{stringliteral}{" '"} + name + \textcolor{stringliteral}{"' to "} + \textcolor{stringliteral}{"'"} +
                value + \textcolor{stringliteral}{"'"};

      \textcolor{keywordflow}{return} this.addFutureAction(futureName, \textcolor{keyword}{function}($window, $document, done) \{
        var element = $document.elements();
        done(null, element[methodName].apply(element, args));
      \});
    \};
  \});

  angular.forEach(VALUE\_METHODS, \textcolor{keyword}{function}(methodName) \{
    chain[methodName] = \textcolor{keyword}{function}(value) \{
      var args = arguments,
          futureName = (args.length === 0)
              ? \textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' "} + methodName
              : \textcolor{stringliteral}{"element '"} + this.label + \textcolor{stringliteral}{"' set "} + methodName + \textcolor{stringliteral}{" to '"} + value + \textcolor{stringliteral}{"'"};

      \textcolor{keywordflow}{return} this.addFutureAction(futureName, \textcolor{keyword}{function}($window, $document, done) \{
        var element = $document.elements();
        done(null, element[methodName].apply(element, args));
      \});
    \};
  \});

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(selector, label) \{
    this.dsl.using(selector, label);
    \textcolor{keywordflow}{return} chain;
  \};
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toEqual'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} angular.equals(this.actual, expected);
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBe'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} this.actual === expected;
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeDefined'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} angular.isDefined(this.actual);
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeTruthy'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.actual;
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeFalsy'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} !this.actual;
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toMatch'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{new} RegExp(expected).test(this.actual);
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeNull'}, \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} this.actual === null;
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toContain'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} includes(this.actual, expected);
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeLessThan'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} this.actual < expected;
\});

angular.scenario.matcher(\textcolor{stringliteral}{'toBeGreaterThan'}, \textcolor{keyword}{function}(expected) \{
  \textcolor{keywordflow}{return} this.actual > expected;
\});

angular.scenario.output(\textcolor{stringliteral}{'html'}, \textcolor{keyword}{function}(context, runner, model) \{
  var specUiMap = \{\},
      lastStepUiMap = \{\};

  context.append(
    \textcolor{stringliteral}{'<div id="header">'} +
    \textcolor{stringliteral}{'  <h1><span class="angular">AngularJS</span>: Scenario Test Runner</h1>'} +
    \textcolor{stringliteral}{'  <ul id="status-legend" class="status-display">'} +
    \textcolor{stringliteral}{'    <li class="status-error">0 Errors</li>'} +
    \textcolor{stringliteral}{'    <li class="status-failure">0 Failures</li>'} +
    \textcolor{stringliteral}{'    <li class="status-success">0 Passed</li>'} +
    \textcolor{stringliteral}{'  </ul>'} +
    \textcolor{stringliteral}{'</div>'} +
    \textcolor{stringliteral}{'<div id="specs">'} +
    \textcolor{stringliteral}{'  <div class="test-children"></div>'} +
    \textcolor{stringliteral}{'</div>'}
  );

  runner.on(\textcolor{stringliteral}{'InteractivePause'}, \textcolor{keyword}{function}(spec) \{
    var ui = lastStepUiMap[spec.id];
    ui.find(\textcolor{stringliteral}{'.test-title'}).
      html(\textcolor{stringliteral}{'paused... <a href="javascript:resume()">resume</a> when ready.'});
  \});

  runner.on(\textcolor{stringliteral}{'SpecBegin'}, \textcolor{keyword}{function}(spec) \{
    var ui = findContext(spec);
    ui.find(\textcolor{stringliteral}{'> .tests'}).append(
      \textcolor{stringliteral}{'<li class="status-pending test-it"></li>'}
    );
    ui = ui.find(\textcolor{stringliteral}{'> .tests li:last'});
    ui.append(
      \textcolor{stringliteral}{'<div class="test-info">'} +
      \textcolor{stringliteral}{'  <p class="test-title">'} +
      \textcolor{stringliteral}{'    <span class="timer-result"></span>'} +
      \textcolor{stringliteral}{'    <span class="test-name"></span>'} +
      \textcolor{stringliteral}{'  </p>'} +
      \textcolor{stringliteral}{'</div>'} +
      \textcolor{stringliteral}{'<div class="scrollpane">'} +
      \textcolor{stringliteral}{'  <ol class="test-actions"></ol>'} +
      \textcolor{stringliteral}{'</div>'}
    );
    ui.find(\textcolor{stringliteral}{'> .test-info .test-name'}).text(spec.name);
    ui.find(\textcolor{stringliteral}{'> .test-info'}).click(\textcolor{keyword}{function}() \{
      var scrollpane = ui.find(\textcolor{stringliteral}{'> .scrollpane'});
      var actions = scrollpane.find(\textcolor{stringliteral}{'> .test-actions'});
      var name = context.find(\textcolor{stringliteral}{'> .test-info .test-name'});
      \textcolor{keywordflow}{if} (actions.find(\textcolor{stringliteral}{':visible'}).length) \{
        actions.hide();
        name.removeClass(\textcolor{stringliteral}{'open'}).addClass(\textcolor{stringliteral}{'closed'});
      \} \textcolor{keywordflow}{else} \{
        actions.show();
        scrollpane.attr(\textcolor{stringliteral}{'scrollTop'}, scrollpane.attr(\textcolor{stringliteral}{'scrollHeight'}));
        name.removeClass(\textcolor{stringliteral}{'closed'}).addClass(\textcolor{stringliteral}{'open'});
      \}
    \});

    specUiMap[spec.id] = ui;
  \});

  runner.on(\textcolor{stringliteral}{'SpecError'}, \textcolor{keyword}{function}(spec, error) \{
    var ui = specUiMap[spec.id];
    ui.append(\textcolor{stringliteral}{'<pre></pre>'});
    ui.find(\textcolor{stringliteral}{'> pre'}).text(formatException(error));
  \});

  runner.on(\textcolor{stringliteral}{'SpecEnd'}, \textcolor{keyword}{function}(spec) \{
    var ui = specUiMap[spec.id];
    spec = model.getSpec(spec.id);
    ui.removeClass(\textcolor{stringliteral}{'status-pending'});
    ui.addClass(\textcolor{stringliteral}{'status-'} + spec.status);
    ui.find(\textcolor{stringliteral}{"> .test-info .timer-result"}).text(spec.duration + \textcolor{stringliteral}{"ms"});
    \textcolor{keywordflow}{if} (spec.status === \textcolor{stringliteral}{'success'}) \{
      ui.find(\textcolor{stringliteral}{'> .test-info .test-name'}).addClass(\textcolor{stringliteral}{'closed'});
      ui.find(\textcolor{stringliteral}{'> .scrollpane .test-actions'}).hide();
    \}
    updateTotals(spec.status);
  \});

  runner.on(\textcolor{stringliteral}{'StepBegin'}, \textcolor{keyword}{function}(spec, step) \{
    var ui = specUiMap[spec.id];
    spec = model.getSpec(spec.id);
    step = spec.getLastStep();
    ui.find(\textcolor{stringliteral}{'> .scrollpane .test-actions'}).append(\textcolor{stringliteral}{'<li class="status-pending"></li>'});
    var stepUi = lastStepUiMap[spec.id] = ui.find(\textcolor{stringliteral}{'> .scrollpane .test-actions li:last'});
    stepUi.append(
      \textcolor{stringliteral}{'<div class="timer-result"></div>'} +
      \textcolor{stringliteral}{'<div class="test-title"></div>'}
    );
    stepUi.find(\textcolor{stringliteral}{'> .test-title'}).text(step.name);
    var scrollpane = stepUi.parents(\textcolor{stringliteral}{'.scrollpane'});
    scrollpane.attr(\textcolor{stringliteral}{'scrollTop'}, scrollpane.attr(\textcolor{stringliteral}{'scrollHeight'}));
  \});

  runner.on(\textcolor{stringliteral}{'StepFailure'}, \textcolor{keyword}{function}(spec, step, error) \{
    var ui = lastStepUiMap[spec.id];
    addError(ui, step.line, error);
  \});

  runner.on(\textcolor{stringliteral}{'StepError'}, \textcolor{keyword}{function}(spec, step, error) \{
    var ui = lastStepUiMap[spec.id];
    addError(ui, step.line, error);
  \});

  runner.on(\textcolor{stringliteral}{'StepEnd'}, \textcolor{keyword}{function}(spec, step) \{
    var stepUi = lastStepUiMap[spec.id];
    spec = model.getSpec(spec.id);
    step = spec.getLastStep();
    stepUi.find(\textcolor{stringliteral}{'.timer-result'}).text(step.duration + \textcolor{stringliteral}{'ms'});
    stepUi.removeClass(\textcolor{stringliteral}{'status-pending'});
    stepUi.addClass(\textcolor{stringliteral}{'status-'} + step.status);
    var scrollpane = specUiMap[spec.id].find(\textcolor{stringliteral}{'> .scrollpane'});
    scrollpane.attr(\textcolor{stringliteral}{'scrollTop'}, scrollpane.attr(\textcolor{stringliteral}{'scrollHeight'}));
  \});

  \textcolor{keyword}{function} findContext(spec) \{
    var currentContext = context.find(\textcolor{stringliteral}{'#specs'});
    angular.forEach(model.getDefinitionPath(spec), \textcolor{keyword}{function}(defn) \{
      var \textcolor{keywordtype}{id} = \textcolor{stringliteral}{'describe-'} + defn.id;
      \textcolor{keywordflow}{if} (!context.find(\textcolor{charliteral}{'#'} + \textcolor{keywordtype}{id}).length) \{
        currentContext.find(\textcolor{stringliteral}{'> .test-children'}).append(
          \textcolor{stringliteral}{'<div class="test-describe" id="'} + \textcolor{keywordtype}{id} + \textcolor{stringliteral}{'">'} +
          \textcolor{stringliteral}{'  <h2></h2>'} +
          \textcolor{stringliteral}{'  <div class="test-children"></div>'} +
          \textcolor{stringliteral}{'  <ul class="tests"></ul>'} +
          \textcolor{stringliteral}{'</div>'}
        );
        context.find(\textcolor{charliteral}{'#'} + \textcolor{keywordtype}{id}).find(\textcolor{stringliteral}{'> h2'}).text(\textcolor{stringliteral}{'describe: '} + defn.name);
      \}
      currentContext = context.find(\textcolor{charliteral}{'#'} + \textcolor{keywordtype}{id});
    \});
    \textcolor{keywordflow}{return} context.find(\textcolor{stringliteral}{'#describe-'} + spec.definition.id);
  \}

  \textcolor{keyword}{function} updateTotals(status) \{
    var legend = context.find(\textcolor{stringliteral}{'#status-legend .status-'} + status);
    var parts = legend.text().split(\textcolor{charliteral}{' '});
    var value = (parts[0] * 1) + 1;
    legend.text(value + \textcolor{charliteral}{' '} + parts[1]);
  \}

  \textcolor{keyword}{function} addError(context, line, error) \{
    context.find(\textcolor{stringliteral}{'.test-title'}).append(\textcolor{stringliteral}{'<pre></pre>'});
    var message = \_jQuery.trim(line() + \textcolor{stringliteral}{'\(\backslash\)n\(\backslash\)n'} + formatException(error));
    context.find(\textcolor{stringliteral}{'.test-title pre:last'}).text(message);
  \}
\});

angular.scenario.output(\textcolor{stringliteral}{'json'}, \textcolor{keyword}{function}(context, runner, model) \{
  model.on(\textcolor{stringliteral}{'RunnerEnd'}, \textcolor{keyword}{function}() \{
    context.text(angular.toJson(model.value));
  \});
\});

angular.scenario.output(\textcolor{stringliteral}{'xml'}, \textcolor{keyword}{function}(context, runner, model) \{
  var $ = \textcolor{keyword}{function}(args) \{\textcolor{keywordflow}{return} \textcolor{keyword}{new} context.init(args);\};
  model.on(\textcolor{stringliteral}{'RunnerEnd'}, \textcolor{keyword}{function}() \{
    var scenario = $(\textcolor{stringliteral}{'<scenario></scenario>'});
    context.append(scenario);
    serializeXml(scenario, model.value);
  \});

  \textcolor{keyword}{function} serializeXml(context, tree) \{
     angular.forEach(tree.children, \textcolor{keyword}{function}(child) \{
       var describeContext = $(\textcolor{stringliteral}{'<describe></describe>'});
       describeContext.attr(\textcolor{stringliteral}{'id'}, child.id);
       describeContext.attr(\textcolor{stringliteral}{'name'}, child.name);
       context.append(describeContext);
       serializeXml(describeContext, child);
     \});
     var its = $(\textcolor{stringliteral}{'<its></its>'});
     context.append(its);
     angular.forEach(tree.specs, \textcolor{keyword}{function}(spec) \{
       var it = $(\textcolor{stringliteral}{'<it></it>'});
       it.attr(\textcolor{stringliteral}{'id'}, spec.id);
       it.attr(\textcolor{stringliteral}{'name'}, spec.name);
       it.attr(\textcolor{stringliteral}{'duration'}, spec.duration);
       it.attr(\textcolor{stringliteral}{'status'}, spec.status);
       its.append(it);
       angular.forEach(spec.steps, function(step) \{
         var stepContext = $(\textcolor{stringliteral}{'<step></step>'});
         stepContext.attr(\textcolor{stringliteral}{'name'}, step.name);
         stepContext.attr(\textcolor{stringliteral}{'duration'}, step.duration);
         stepContext.attr(\textcolor{stringliteral}{'status'}, step.status);
         it.append(stepContext);
         if (step.error) \{
           var error = $(\textcolor{stringliteral}{'<error></error>'});
           stepContext.append(error);
           error.text(formatException(step.error));
         \}
       \});
     \});
   \}
\});

angular.scenario.output(\textcolor{stringliteral}{'object'}, \textcolor{keyword}{function}(context, runner, model) \{
  runner.$window.$result = model.value;
\});

bindJQuery();
publishExternalAPI(angular);

var $runner = \textcolor{keyword}{new} angular.scenario.Runner(window),
    scripts = document.getElementsByTagName(\textcolor{stringliteral}{'script'}),
    script = scripts[scripts.length - 1],
    config = \{\};

angular.forEach(script.attributes, \textcolor{keyword}{function}(attr) \{
  var match = attr.name.match(/ng[:\(\backslash\)-](.*)/);
  if (match) \{
    config[match[1]] = attr.value || true;
  \}
\});

\textcolor{keywordflow}{if} (config.autotest) \{
  JQLite(document).ready(\textcolor{keyword}{function}() \{
    angular.scenario.setUpAndRun(config);
  \});
\}
\})(window, document);


!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(\textcolor{stringliteral}{'<style
       type="text/css">@charset "UTF-8";\(\backslash\)n\(\backslash\)n[ng\(\backslash\)\(\backslash\):cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak],\(\backslash\)n.ng-cloak, .x-ng-cloak,\(\backslash\)n
      .ng-hide:not(.ng-hide-animate) \{\(\backslash\)n  display: none !important;\(\backslash\)n\}\(\backslash\)n\(\backslash\)nng\(\backslash\)\(\backslash\):form \{\(\backslash\)n  display: block;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      .ng-animate-shim \{\(\backslash\)n  visibility:hidden;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.ng-anchor \{\(\backslash\)n  position:absolute;\(\backslash\)n\}\(\backslash\)n</style>'});
!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(\textcolor{stringliteral}{'<style
       type="text/css">@charset "UTF-8";\(\backslash\)n/* CSS Document */\(\backslash\)n\(\backslash\)n/** Structure */\(\backslash\)nbody \{\(\backslash\)n  font-family: Arial, sans-serif;\(\backslash\)n 
       margin: 0;\(\backslash\)n  font-size: 14px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#system-error \{\(\backslash\)n  font-size: 1.5em;\(\backslash\)n  text-align: center;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      #json, #xml \{\(\backslash\)n  display: none;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#header \{\(\backslash\)n  position: fixed;\(\backslash\)n  width: 100%;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#specs \{\(\backslash\)n 
       padding-top: 50px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#header .angular \{\(\backslash\)n  font-family: Courier New, monospace;\(\backslash\)n  font-weight: bold;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#header
       h1 \{\(\backslash\)n  font-weight: normal;\(\backslash\)n  float: left;\(\backslash\)n  font-size: 30px;\(\backslash\)n  line-height: 30px;\(\backslash\)n  margin: 0;\(\backslash\)n 
       padding: 10px 10px;\(\backslash\)n  height: 30px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#application h2,\(\backslash\)n#specs h2 \{\(\backslash\)n  margin: 0;\(\backslash\)n  padding: 0.5em;\(\backslash\)n 
       font-size: 1.1em;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#status-legend \{\(\backslash\)n  margin-top: 10px;\(\backslash\)n  margin-right: 10px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#header,\(\backslash\)n
      #application,\(\backslash\)n.test-info,\(\backslash\)n.test-actions li \{\(\backslash\)n  overflow: hidden;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#application \{\(\backslash\)n  margin: 10px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      #application iframe \{\(\backslash\)n  width: 100%;\(\backslash\)n  height: 758px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#application .popout \{\(\backslash\)n  float: right;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      #application iframe \{\(\backslash\)n  border: none;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.tests li,\(\backslash\)n.test-actions li,\(\backslash\)n.test-it li,\(\backslash\)n.test-it ol,\(\backslash\)n
      .status-display \{\(\backslash\)n  list-style-type: none;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.tests,\(\backslash\)n.test-it ol,\(\backslash\)n.status-display \{\(\backslash\)n  margin: 0;\(\backslash\)n  padding:
       0;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-info \{\(\backslash\)n  margin-left: 1em;\(\backslash\)n  margin-top: 0.5em;\(\backslash\)n  border-radius: 8px 0 0 8px;\(\backslash\)n 
       -webkit-border-radius: 8px 0 0 8px;\(\backslash\)n  -moz-border-radius: 8px 0 0 8px;\(\backslash\)n  cursor: pointer;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-info:hover
       .test-name \{\(\backslash\)n  text-decoration: underline;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-info .closed:before \{\(\backslash\)n  content: \(\backslash\)'\(\backslash\)\(\backslash\)25b8\(\backslash\)\(\backslash\)00A0\(\backslash\)';\(\backslash\)n\}
      \(\backslash\)n\(\backslash\)n.test-info .open:before \{\(\backslash\)n  content: \(\backslash\)'\(\backslash\)\(\backslash\)25be\(\backslash\)\(\backslash\)00A0\(\backslash\)';\(\backslash\)n  font-weight: bold;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-it ol \{\(\backslash\)n 
       margin-left: 2.5em;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display,\(\backslash\)n.status-display li \{\(\backslash\)n  float: right;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display li \{\(\backslash\)n 
       padding: 5px 10px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.timer-result,\(\backslash\)n.test-title \{\(\backslash\)n  display: inline-block;\(\backslash\)n  margin: 0;\(\backslash\)n  padding:
       4px;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions .test-title,\(\backslash\)n.test-actions .test-result \{\(\backslash\)n  display: table-cell;\(\backslash\)n  padding-left:
       0.5em;\(\backslash\)n  padding-right: 0.5em;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions \{\(\backslash\)n  display: table;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions li \{\(\backslash\)n 
       display: table-row;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.timer-result \{\(\backslash\)n  width: 4em;\(\backslash\)n  padding: 0 10px;\(\backslash\)n  text-align: right;\(\backslash\)n  font-family:
       monospace;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-it pre,\(\backslash\)n.test-actions pre \{\(\backslash\)n  clear: left;\(\backslash\)n  color: black;\(\backslash\)n  margin-left: 6em;\(\backslash\)n
      \}\(\backslash\)n\(\backslash\)n.test-describe \{\(\backslash\)n  padding-bottom: 0.5em;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-describe .test-describe \{\(\backslash\)n  margin: 5px 5px
       10px 2em;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions .status-pending .test-title:before \{\(\backslash\)n  content: \(\backslash\)'\(\backslash\)\(\backslash\)00bb\(\backslash\)\(\backslash\)00A0\(\backslash\)';\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      .scrollpane \{\(\backslash\)n   max-height: 20em;\(\backslash\)n   overflow: auto;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n/** Colors */\(\backslash\)n\(\backslash\)n#header \{\(\backslash\)n  background-color:
       #F2C200;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#specs h2 \{\(\backslash\)n  border-top: 2px solid #BABAD1;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#specs h2,\(\backslash\)n#application h2 \{\(\backslash\)n 
       background-color: #efefef;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n#application \{\(\backslash\)n  border: 1px solid #BABAD1;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-describe .test-describe \{\(\backslash\)n 
       border-left: 1px solid #BABAD1;\(\backslash\)n  border-right: 1px solid #BABAD1;\(\backslash\)n  border-bottom: 1px solid #BABAD1;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n
      .status-display \{\(\backslash\)n  border: 1px solid #777;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display .status-pending,\(\backslash\)n.status-pending
       .test-info \{\(\backslash\)n  background-color: #F9EEBC;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display .status-success,\(\backslash\)n.status-success .test-info \{\(\backslash\)n 
       background-color: #B1D7A1;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display .status-failure,\(\backslash\)n.status-failure .test-info \{\(\backslash\)n 
       background-color: #FF8286;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.status-display .status-error,\(\backslash\)n.status-error .test-info \{\(\backslash\)n  background-color:
       black;\(\backslash\)n  color: white;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions .status-success .test-title \{\(\backslash\)n  color: #30B30A;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions
       .status-failure .test-title \{\(\backslash\)n  color: #DF0000;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions .status-error .test-title \{\(\backslash\)n  color:
       black;\(\backslash\)n\}\(\backslash\)n\(\backslash\)n.test-actions .timer-result \{\(\backslash\)n  color: #888;\(\backslash\)n\}\(\backslash\)n</style>'});
\end{DoxyCodeInclude}
 