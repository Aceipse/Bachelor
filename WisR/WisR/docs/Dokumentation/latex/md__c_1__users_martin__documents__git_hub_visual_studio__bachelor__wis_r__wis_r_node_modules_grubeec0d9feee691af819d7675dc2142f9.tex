Javascript lacks complete string manipulation operations. This an attempt to fill that gap. List of build-\/in methods can be found for example from \href{http://www.diveintojavascript.com/core-javascript-reference/the-string-object}{\tt Dive Into Java\+Script}.

As name states this an extension for \href{http://documentcloud.github.com/underscore/}{\tt Underscore.\+js}, but it can be used independently from $\ast$$\ast$\+\_\+s$\ast$$\ast$-\/global variable. But with Underscore.\+js you can use Object-\/\+Oriented style and chaining\+:


\begin{DoxyCode}
1 \_("   epeli  ").chain().trim().capitalize().value()
2 => "Epeli"
\end{DoxyCode}


\subsection*{Download}


\begin{DoxyItemize}
\item \href{https://raw.github.com/epeli/underscore.string/master/lib/underscore.string.js}{\tt Development version} {\itshape Uncompressed with Comments 18kb}
\item \href{https://github.com/epeli/underscore.string/raw/master/dist/underscore.string.min.js}{\tt Production version} {\itshape Minified 7kb}
\end{DoxyItemize}

\subsection*{Node.\+js installation}

{\bfseries npm package} \begin{DoxyVerb}npm install underscore.string
\end{DoxyVerb}


{\bfseries Standalone usage}\+:


\begin{DoxyCode}
1 var \_s = require('underscore.string');
\end{DoxyCode}


{\bfseries Integrate with Underscore.\+js}\+:


\begin{DoxyCode}
1 var \_  = require('underscore');
2 
3 // Import Underscore.string to separate object, because there are conflict functions (include, reverse,
       contains)
4 \_.str = require('underscore.string');
5 
6 // Mix in non-conflict functions to Underscore namespace if you want
7 \_.mixin(\_.str.exports());
8 
9 // All functions, include conflict, will be available through \_.str object
10 \_.str.include('Underscore.string', 'string'); // => true
\end{DoxyCode}


{\bfseries Or Integrate with Underscore.\+js without module loading}

Run the following expression after Underscore.\+js and Underscore.\+string are loaded 
\begin{DoxyCode}
1 // \_.str becomes a global variable if no module loading is detected
2 // Mix in non-conflict functions to Underscore namespace
3 \_.mixin(\_.str.exports());
\end{DoxyCode}


\subsection*{String Functions}

For availability of functions in this way you need to mix in Underscore.\+string functions\+:


\begin{DoxyCode}
1 \_.mixin(\_.string.exports());
\end{DoxyCode}


otherwise functions from examples will be available through \+\_\+.\+string or \+\_\+.\+str objects\+:


\begin{DoxyCode}
1 \_.str.capitalize('epeli')
2 => "Epeli"
\end{DoxyCode}


{\bfseries number\+Format} \+\_\+.\+number\+Format(number, \mbox{[} decimals=0, decimal\+Separator=\textquotesingle{}.\textquotesingle{}, order\+Separator=\textquotesingle{},\textquotesingle{}\mbox{]})

Formats the numbers.


\begin{DoxyCode}
1 \_.numberFormat(1000, 2)
2 => "1,000.00"
3 
4 \_.numberFormat(123456789.123, 5, '.', ',')
5 => "123,456,789.12300"
\end{DoxyCode}


{\bfseries levenshtein} \+\_\+.\+levenshtein(string1, string2)

Calculates \href{http://en.wikipedia.org/wiki/Levenshtein_distance}{\tt Levenshtein distance} between two strings.


\begin{DoxyCode}
1 \_.levenshtein('kitten', 'kittah')
2 => 2
\end{DoxyCode}


{\bfseries capitalize} \+\_\+.\+capitalize(string)

Converts first letter of the string to uppercase.


\begin{DoxyCode}
1 \_.capitalize("foo Bar")
2 => "Foo Bar"
\end{DoxyCode}


{\bfseries chop} \+\_\+.\+chop(string, step)


\begin{DoxyCode}
1 \_.chop('whitespace', 3)
2 => ['whi','tes','pac','e']
\end{DoxyCode}


{\bfseries clean} \+\_\+.\+clean(str)

Compress some whitespaces to one.


\begin{DoxyCode}
1 \_.clean(" foo    bar   ")
2 => 'foo bar'
\end{DoxyCode}


{\bfseries chars} \+\_\+.\+chars(str)


\begin{DoxyCode}
1 \_.chars('Hello')
2 => ['H','e','l','l','o']
\end{DoxyCode}


{\bfseries swap\+Case} \+\_\+.\+swap\+Case(str)

Returns a copy of the string in which all the case-\/based characters have had their case swapped.


\begin{DoxyCode}
1 \_.swapCase('hELLO')
2 => 'Hello'
\end{DoxyCode}


{\bfseries include} available only through \+\_\+.\+str object, because Underscore has function with the same name.


\begin{DoxyCode}
1 \_.str.include("foobar", "ob")
2 => true
\end{DoxyCode}


(removed) {\bfseries includes} \+\_\+.\+includes(string, substring)

Tests if string contains a substring.


\begin{DoxyCode}
1 \_.includes("foobar", "ob")
2 => true
\end{DoxyCode}


{\bfseries includes} function was removed

But you can create it in this way, for compatibility with previous versions\+:


\begin{DoxyCode}
1 \_.includes = \_.str.include
\end{DoxyCode}


{\bfseries count} \+\_\+.\+count(string, substring)


\begin{DoxyCode}
1 \_('Hello world').count('l')
2 => 3
\end{DoxyCode}


{\bfseries escape\+H\+T\+M\+L} \+\_\+.\+escape\+H\+T\+M\+L(string)

Converts H\+T\+M\+L special characters to their entity equivalents.


\begin{DoxyCode}
1 \_('<div>Blah blah blah</div>').escapeHTML();
2 => '&lt;div&gt;Blah blah blah&lt;/div&gt;'
\end{DoxyCode}


{\bfseries unescape\+H\+T\+M\+L} \+\_\+.\+unescape\+H\+T\+M\+L(string)

Converts entity characters to H\+T\+M\+L equivalents.


\begin{DoxyCode}
1 \_('&lt;div&gt;Blah blah blah&lt;/div&gt;').unescapeHTML();
2 => '<div>Blah blah blah</div>'
\end{DoxyCode}


{\bfseries insert} \+\_\+.\+insert(string, index, substing)


\begin{DoxyCode}
1 \_('Hello ').insert(6, 'world')
2 => 'Hello world'
\end{DoxyCode}


{\bfseries is\+Blank} \+\_\+.\+is\+Blank(string)


\begin{DoxyCode}
1 \_('').isBlank(); // => true
2 \_('\(\backslash\)n').isBlank(); // => true
3 \_(' ').isBlank(); // => true
4 \_('a').isBlank(); // => false
\end{DoxyCode}


{\bfseries join} \+\_\+.\+join(separator, $\ast$strings)

Joins strings together with given separator


\begin{DoxyCode}
1 \_.join(" ", "foo", "bar")
2 => "foo bar"
\end{DoxyCode}


{\bfseries lines} \+\_\+.\+lines(str)


\begin{DoxyCode}
1 \_.lines("Hello\(\backslash\)nWorld")
2 => ["Hello", "World"]
\end{DoxyCode}


{\bfseries reverse} available only through \+\_\+.\+str object, because Underscore has function with the same name.

Return reversed string\+:


\begin{DoxyCode}
1 \_.str.reverse("foobar")
2 => 'raboof'
\end{DoxyCode}


{\bfseries splice} \+\_\+.\+splice(string, index, howmany, substring)

Like a array splice.


\begin{DoxyCode}
1 \_('https://edtsech@bitbucket.org/edtsech/underscore.strings').splice(30, 7, 'epeli')
2 => 'https://edtsech@bitbucket.org/epeli/underscore.strings'
\end{DoxyCode}


{\bfseries starts\+With} \+\_\+.\+starts\+With(string, starts)

This method checks whether string starts with starts.


\begin{DoxyCode}
1 \_("image.gif").startsWith("image")
2 => true
\end{DoxyCode}


{\bfseries ends\+With} \+\_\+.\+ends\+With(string, ends)

This method checks whether string ends with ends.


\begin{DoxyCode}
1 \_("image.gif").endsWith("gif")
2 => true
\end{DoxyCode}


{\bfseries succ} \+\_\+.\+succ(str)

Returns the successor to str.


\begin{DoxyCode}
1 \_('a').succ()
2 => 'b'
3 
4 \_('A').succ()
5 => 'B'
\end{DoxyCode}


{\bfseries supplant}

Supplant function was removed, use Underscore.\+js \href{http://documentcloud.github.com/underscore/#template}{\tt template function}.

{\bfseries strip} alias for {\itshape trim}

{\bfseries lstrip} alias for {\itshape ltrim}

{\bfseries rstrip} alias for {\itshape rtrim}

{\bfseries titleize} \+\_\+.\+titleize(string)


\begin{DoxyCode}
1 \_('my name is epeli').titleize()
2 => 'My Name Is Epeli'
\end{DoxyCode}


{\bfseries camelize} \+\_\+.\+camelize(string)

Converts underscored or dasherized string to a camelized one


\begin{DoxyCode}
1 \_('-moz-transform').camelize()
2 => 'MozTransform'
\end{DoxyCode}


{\bfseries classify} \+\_\+.\+classify(string)

Converts string to camelized class name


\begin{DoxyCode}
1 \_('some\_class\_name').classify()
2 => 'SomeClassName'
\end{DoxyCode}


{\bfseries underscored} \+\_\+.\+underscored(string)

Converts a camelized or dasherized string into an underscored one


\begin{DoxyCode}
1 \_('MozTransform').underscored()
2 => 'moz\_transform'
\end{DoxyCode}


{\bfseries dasherize} \+\_\+.\+dasherize(string)

Converts a underscored or camelized string into an dasherized one


\begin{DoxyCode}
1 \_('MozTransform').dasherize()
2 => '-moz-transform'
\end{DoxyCode}


{\bfseries humanize} \+\_\+.\+humanize(string)

Converts an underscored, camelized, or dasherized string into a humanized one. Also removes beginning and ending whitespace, and removes the postfix \textquotesingle{}\+\_\+id\textquotesingle{}.


\begin{DoxyCode}
1 \_('  capitalize dash-CamelCase\_underscore trim  ').humanize()
2 => 'Capitalize dash camel case underscore trim'
\end{DoxyCode}


{\bfseries trim} \+\_\+.\+trim(string, \mbox{[}characters\mbox{]})

trims defined characters from begining and ending of the string. Defaults to whitespace characters.


\begin{DoxyCode}
1 \_.trim("  foobar   ")
2 => "foobar"
3 
4 \_.trim("\_-foobar-\_", "\_-")
5 => "foobar"
\end{DoxyCode}


{\bfseries ltrim} \+\_\+.\+ltrim(string, \mbox{[}characters\mbox{]})

Left trim. Similar to trim, but only for left side.

{\bfseries rtrim} \+\_\+.\+rtrim(string, \mbox{[}characters\mbox{]})

Right trim. Similar to trim, but only for right side.

{\bfseries truncate} \+\_\+.\+truncate(string, length, truncate\+String)


\begin{DoxyCode}
1 \_('Hello world').truncate(5)
2 => 'Hello...'
3 
4 \_('Hello').truncate(10)
5 => 'Hello'
\end{DoxyCode}


{\bfseries prune} \+\_\+.\+prune(string, length, prune\+String)

Elegant version of truncate. Makes sure the pruned string does not exceed the original length. Avoid half-\/chopped words when truncating.


\begin{DoxyCode}
1 \_('Hello, world').prune(5)
2 => 'Hello...'
3 
4 \_('Hello, world').prune(8)
5 => 'Hello...'
6 
7 \_('Hello, world').prune(5, ' (read a lot more)')
8 => 'Hello, world' (as adding "(read a lot more)" would be longer than the original string)
9 
10 \_('Hello, cruel world').prune(15)
11 => 'Hello, cruel...'
12 
13 \_('Hello').prune(10)
14 => 'Hello'
\end{DoxyCode}


{\bfseries words} \+\_\+.\+words(str, delimiter=/+/)

Split string by delimiter (String or Reg\+Exp), /+/ by default.


\begin{DoxyCode}
1 \_.words("   I   love   you   ")
2 => ["I","love","you"]
3 
4 \_.words("I\_love\_you", "\_")
5 => ["I","love","you"]
6 
7 \_.words("I-love-you", /-/)
8 => ["I","love","you"]
9 
10 \_.words("   ")
11 => []
\end{DoxyCode}


{\bfseries sprintf} \+\_\+.\+sprintf(string format, $\ast$arguments)

C like string formatting. Credits goes to \href{http://www.diveintojavascript.com/projects/sprintf-for-javascript}{\tt Alexandru Marasteanu}. For more detailed documentation, see the \href{http://www.diveintojavascript.com/projects/sprintf-for-javascript}{\tt original page}.


\begin{DoxyCode}
1 \_.sprintf("%.1f", 1.17)
2 "1.2"
\end{DoxyCode}


{\bfseries pad} \+\_\+.\+pad(str, length, \mbox{[}pad\+Str, type\mbox{]})

pads the {\ttfamily str} with characters until the total string length is equal to the passed {\ttfamily length} parameter. By default, pads on the {\bfseries left} with the space char ({\ttfamily \char`\"{} \char`\"{}}). {\ttfamily pad\+Str} is truncated to a single character if necessary.


\begin{DoxyCode}
1 \_.pad("1", 8)
2 -> "       1";
3 
4 \_.pad("1", 8, '0')
5 -> "00000001";
6 
7 \_.pad("1", 8, '0', 'right')
8 -> "10000000";
9 
10 \_.pad("1", 8, '0', 'both')
11 -> "00001000";
12 
13 \_.pad("1", 8, 'bleepblorp', 'both')
14 -> "bbbb1bbb";
\end{DoxyCode}


{\bfseries lpad} \+\_\+.\+lpad(str, length, \mbox{[}pad\+Str\mbox{]})

left-\/pad a string. Alias for `pad(str, length, pad\+Str, \textquotesingle{}left\textquotesingle{})`


\begin{DoxyCode}
1 \_.lpad("1", 8, '0')
2 -> "00000001";
\end{DoxyCode}


{\bfseries rpad} \+\_\+.\+rpad(str, length, \mbox{[}pad\+Str\mbox{]})

right-\/pad a string. Alias for `pad(str, length, pad\+Str, \textquotesingle{}right\textquotesingle{})`


\begin{DoxyCode}
1 \_.rpad("1", 8, '0')
2 -> "10000000";
\end{DoxyCode}


{\bfseries lrpad} \+\_\+.\+lrpad(str, length, \mbox{[}pad\+Str\mbox{]})

left/right-\/pad a string. Alias for `pad(str, length, pad\+Str, \textquotesingle{}both\textquotesingle{})`


\begin{DoxyCode}
1 \_.lrpad("1", 8, '0')
2 -> "00001000";
\end{DoxyCode}


{\bfseries center} alias for {\bfseries lrpad}

{\bfseries ljust} alias for {\itshape rpad}

{\bfseries rjust} alias for {\itshape lpad}

{\bfseries to\+Number} \+\_\+.\+to\+Number(string, \mbox{[}decimals\mbox{]})

Parse string to number. Returns Na\+N if string can\textquotesingle{}t be parsed to number.


\begin{DoxyCode}
1 \_('2.556').toNumber()
2 => 3
3 
4 \_('2.556').toNumber(1)
5 => 2.6
\end{DoxyCode}


{\bfseries str\+Right} \+\_\+.\+str\+Right(string, pattern)

Searches a string from left to right for a pattern and returns a substring consisting of the characters in the string that are to the right of the pattern or all string if no match found.


\begin{DoxyCode}
1 \_('This\_is\_a\_test\_string').strRight('\_')
2 => "is\_a\_test\_string";
\end{DoxyCode}


{\bfseries str\+Right\+Back} \+\_\+.\+str\+Right\+Back(string, pattern)

Searches a string from right to left for a pattern and returns a substring consisting of the characters in the string that are to the right of the pattern or all string if no match found.


\begin{DoxyCode}
1 \_('This\_is\_a\_test\_string').strRightBack('\_')
2 => "string";
\end{DoxyCode}


{\bfseries str\+Left} \+\_\+.\+str\+Left(string, pattern)

Searches a string from left to right for a pattern and returns a substring consisting of the characters in the string that are to the left of the pattern or all string if no match found.


\begin{DoxyCode}
1 \_('This\_is\_a\_test\_string').strLeft('\_')
2 => "This";
\end{DoxyCode}


{\bfseries str\+Left\+Back} \+\_\+.\+str\+Left\+Back(string, pattern)

Searches a string from right to left for a pattern and returns a substring consisting of the characters in the string that are to the left of the pattern or all string if no match found.


\begin{DoxyCode}
1 \_('This\_is\_a\_test\_string').strLeftBack('\_')
2 => "This\_is\_a\_test";
\end{DoxyCode}


{\bfseries strip\+Tags}

Removes all html tags from string.


\begin{DoxyCode}
1 \_('a <a href="#">link</a>').stripTags()
2 => 'a link'
3 
4 \_('a <a href="#">link</a><script>alert("hello world!")</script>').stripTags()
5 => 'a linkalert("hello world!")'
\end{DoxyCode}


{\bfseries to\+Sentence} \+\_\+.\+to\+Sentence(array, \mbox{[}delimiter, last\+Delimiter\mbox{]})

Join an array into a human readable sentence.


\begin{DoxyCode}
1 \_.toSentence(['jQuery', 'Mootools', 'Prototype'])
2 => 'jQuery, Mootools and Prototype';
3 
4 \_.toSentence(['jQuery', 'Mootools', 'Prototype'], ', ', ' unt ')
5 => 'jQuery, Mootools unt Prototype';
\end{DoxyCode}


{\bfseries to\+Sentence\+Serial} \+\_\+.\+to\+Sentence\+Serial(array, \mbox{[}delimiter, last\+Delimiter\mbox{]})

The same as {\ttfamily to\+Sentence}, but adjusts delimeters to use \href{http://en.wikipedia.org/wiki/Serial_comma}{\tt Serial comma}.


\begin{DoxyCode}
1 \_.toSentenceSerial(['jQuery', 'Mootools'])
2 => 'jQuery and Mootools';
3 
4 \_.toSentenceSerial(['jQuery', 'Mootools', 'Prototype'])
5 => 'jQuery, Mootools, and Prototype'
6 
7 \_.toSentenceSerial(['jQuery', 'Mootools', 'Prototype'], ', ', ' unt ');
8 => 'jQuery, Mootools, unt Prototype';
\end{DoxyCode}


{\bfseries repeat} \+\_\+.\+repeat(string, count, \mbox{[}separator\mbox{]})

Repeats a string count times.


\begin{DoxyCode}
1 \_.repeat("foo", 3)
2 => 'foofoofoo';
3 
4 \_.repeat("foo", 3, "bar")
5 => 'foobarfoobarfoo'
\end{DoxyCode}


{\bfseries surround} \+\_\+.\+surround(string, wrap)

Surround a string with another string.


\begin{DoxyCode}
1 \_.surround("foo", "ab")
2 => 'abfooab';
\end{DoxyCode}


{\bfseries quote} \+\_\+.\+quote(string, quote\+Char) or \+\_\+.\+q(string, quote\+Char)

Quotes a string. {\ttfamily quote\+Char} defaults to {\ttfamily "}.


\begin{DoxyCode}
1 \_.quote('foo', quoteChar)
2 => '"foo"';
\end{DoxyCode}
 {\bfseries unquote} \+\_\+.\+unquote(string, quote\+Char)

Unquotes a string. {\ttfamily quote\+Char} defaults to {\ttfamily "}.


\begin{DoxyCode}
1 \_.unquote('"foo"')
2 => 'foo';
3 \_.unquote("'foo'", "'")
4 => 'foo';
\end{DoxyCode}


{\bfseries slugify} \+\_\+.\+slugify(string)

Transform text into a U\+R\+L slug. Replaces whitespaces, accentuated, and special characters with a dash.


\begin{DoxyCode}
1 \_.slugify("Un éléphant à l'orée du bois")
2 => 'un-elephant-a-loree-du-bois';
\end{DoxyCode}


$\ast$$\ast$$\ast$\+Caution\+: this function is charset dependent$\ast$$\ast$$\ast$

{\bfseries natural\+Cmp} array.\+sort(\+\_\+.\+natural\+Cmp)

Naturally sort strings like humans would do.


\begin{DoxyCode}
1 ['foo20', 'foo5'].sort(\_.naturalCmp)
2 => [ 'foo5', 'foo20' ]
\end{DoxyCode}


{\bfseries to\+Boolean} \+\_\+.\+to\+Boolean(string) or \+\_\+.\+to\+Bool(string)

Turn strings that can be commonly considered as booleas to real booleans. Such as \char`\"{}true\char`\"{}, \char`\"{}false\char`\"{}, \char`\"{}1\char`\"{} and \char`\"{}0\char`\"{}. This function is case insensitive.


\begin{DoxyCode}
1 \_.toBoolean("true")
2 => true
3 \_.toBoolean("FALSE")
4 => false
5 \_.toBoolean("random")
6 => undefined
\end{DoxyCode}


It can be customized by giving arrays of truth and falsy value matcher as parameters. Matchers can be also Reg\+Exp objects.


\begin{DoxyCode}
1 \_.toBoolean("truthy", ["truthy"], ["falsy"])
2 => true
3 \_.toBoolean("true only at start", [/^true/])
4 => true
\end{DoxyCode}


\subsection*{Roadmap}

Any suggestions or bug reports are welcome. Just email me or more preferably open an issue.

\paragraph*{Problems}

We lose two things for {\ttfamily include} and {\ttfamily reverse} methods from {\ttfamily \+\_\+.\+string}\+:


\begin{DoxyItemize}
\item Calls like `\+\_\+(\textquotesingle{}foobar\textquotesingle{}).include(\textquotesingle{}bar\textquotesingle{})` aren\textquotesingle{}t available;
\item Chaining isn\textquotesingle{}t available too.
\end{DoxyItemize}

But if you need this functionality you can create aliases for conflict functions which will be convenient for you\+:


\begin{DoxyCode}
1 \_.mixin(\{
2     includeString: \_.str.include,
3     reverseString: \_.str.reverse
4 \})
5 
6 // Now wrapper calls and chaining are available.
7 \_('foobar').chain().reverseString().includeString('rab').value()
\end{DoxyCode}


\paragraph*{Standalone Usage}

If you are using Underscore.\+string without Underscore. You also have {\ttfamily \+\_\+.\+string} namespace for it and {\ttfamily \+\_\+.\+str} alias But of course you can just reassign {\ttfamily \+\_\+} variable with {\ttfamily \+\_\+.\+string}


\begin{DoxyCode}
1 \_ = \_.string
\end{DoxyCode}


\subsection*{Changelog}

\subsubsection*{2.\+3.\+3}


\begin{DoxyItemize}
\item Add {\ttfamily to\+Boolean}
\item Add {\ttfamily unquote}
\item Add quote char option to {\ttfamily quote}
\item Support dash-\/separated words in {\ttfamily titleize}
\end{DoxyItemize}

\subsubsection*{2.\+3.\+2}


\begin{DoxyItemize}
\item Add {\ttfamily natural\+Cmp}
\item Bug fix to {\ttfamily camelize}
\item Add ă, ș, ț and ś to {\ttfamily slugify}
\item Doc updates
\item Add support for \href{http://component.io/}{\tt component}
\item \href{https://github.com/epeli/underscore.string/compare/v2.3.1...v2.3.2}{\tt Full changelog}
\end{DoxyItemize}

\subsubsection*{2.\+3.\+1}


\begin{DoxyItemize}
\item Bug fixes to {\ttfamily escape\+H\+T\+M\+L}, {\ttfamily classify}, {\ttfamily substr}
\item Faster {\ttfamily count}
\item Documentation fixes
\item \href{https://github.com/epeli/underscore.string/compare/v2.3.0...v2.3.1}{\tt Full changelog}
\end{DoxyItemize}

\subsubsection*{2.\+3.\+0}


\begin{DoxyItemize}
\item Added {\ttfamily numberformat} method
\item Added {\ttfamily levenshtein} method (Levenshtein distance calculation)
\item Added {\ttfamily swap\+Case} method
\item Changed default behavior of {\ttfamily words} method
\item Added {\ttfamily to\+Sentence\+Serial} method
\item Added {\ttfamily surround} and {\ttfamily quote} methods
\end{DoxyItemize}

\subsubsection*{2.\+2.\+1}


\begin{DoxyItemize}
\item Same as 2.\+2.\+0 (2.\+2.\+0rc on npm) to fix some npm drama
\end{DoxyItemize}

\subsubsection*{2.\+2.\+0}


\begin{DoxyItemize}
\item Capitalize method behavior changed
\item Various perfomance tweaks
\end{DoxyItemize}

\subsubsection*{2.\+1.\+1}


\begin{DoxyItemize}
\item Fixed words method bug
\item Added classify method
\end{DoxyItemize}

\subsubsection*{2.\+1.\+0}


\begin{DoxyItemize}
\item A\+M\+D support
\item Added to\+Sentence method
\item Added slugify method
\item Lots of speed optimizations
\end{DoxyItemize}

\subsubsection*{2.\+0.\+0}


\begin{DoxyItemize}
\item Added prune, humanize functions
\item Added \+\_\+.\+string (\+\_\+.\+str) namespace for Underscore.\+string library
\item Removed includes function
\end{DoxyItemize}

For upgrading to this version you need to mix in Underscore.\+string library to Underscore object\+:


\begin{DoxyCode}
1 \_.mixin(\_.string.exports());
\end{DoxyCode}


and all non-\/conflict Underscore.\+string functions will be available through Underscore object. Also function {\ttfamily includes} has been removed, you should replace this function by {\ttfamily \+\_\+.\+str.\+include} or create alias {\ttfamily \+\_\+.\+includes = \+\_\+.\+str.\+include} and all your code will work fine.

\subsubsection*{1.\+1.\+6}


\begin{DoxyItemize}
\item Fixed reverse and truncate
\item Added is\+Blank, strip\+Tags, inlude(alias for includes)
\item Added uglifier compression
\end{DoxyItemize}

\subsubsection*{1.\+1.\+5}


\begin{DoxyItemize}
\item Added str\+Right, str\+Right\+Back, str\+Left, str\+Left\+Back
\end{DoxyItemize}

\subsubsection*{1.\+1.\+4}


\begin{DoxyItemize}
\item Added pad, lpad, rpad, lrpad methods and aliases center, ljust, rjust
\item Integration with Underscore 1.\+1.\+6
\end{DoxyItemize}

\subsubsection*{1.\+1.\+3}


\begin{DoxyItemize}
\item Added methods\+: underscored, camelize, dasherize
\item Support newer version of npm
\end{DoxyItemize}

\subsubsection*{1.\+1.\+2}


\begin{DoxyItemize}
\item Created functions\+: lines, chars, words functions
\end{DoxyItemize}

\subsubsection*{1.\+0.\+2}


\begin{DoxyItemize}
\item Created integration test suite with underscore.\+js 1.\+1.\+4 (now it\textquotesingle{}s absolutely compatible)
\item Removed \textquotesingle{}reverse\textquotesingle{} function, because this function override underscore.\+js \textquotesingle{}reverse\textquotesingle{}
\end{DoxyItemize}

\subsection*{Contribute}


\begin{DoxyItemize}
\item Fork \& pull request. Don\textquotesingle{}t forget about tests.
\item If you planning add some feature please create issue before.
\end{DoxyItemize}

Otherwise changes will be rejected.

\subsection*{Contributors list}

\href{https://github.com/epeli/underscore.string/graphs/contributors}{\tt Can be found here}.

\subsection*{Licence}

The M\+I\+T License

Copyright (c) 2011 Esa-\/\+Matti Suuronen \href{mailto:esa-matti@suuronen.org}{\tt esa-\/matti@suuronen.\+org}

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+H\+E S\+O\+F\+T\+W\+A\+R\+E I\+S P\+R\+O\+V\+I\+D\+E\+D \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+U\+T W\+A\+R\+R\+A\+N\+T\+Y O\+F A\+N\+Y K\+I\+N\+D, E\+X\+P\+R\+E\+S\+S O\+R I\+M\+P\+L\+I\+E\+D, I\+N\+C\+L\+U\+D\+I\+N\+G B\+U\+T N\+O\+T L\+I\+M\+I\+T\+E\+D T\+O T\+H\+E W\+A\+R\+R\+A\+N\+T\+I\+E\+S O\+F M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+T\+Y, F\+I\+T\+N\+E\+S\+S F\+O\+R A P\+A\+R\+T\+I\+C\+U\+L\+A\+R P\+U\+R\+P\+O\+S\+E A\+N\+D N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+N\+T. I\+N N\+O E\+V\+E\+N\+T S\+H\+A\+L\+L T\+H\+E A\+U\+T\+H\+O\+R\+S O\+R C\+O\+P\+Y\+R\+I\+G\+H\+T H\+O\+L\+D\+E\+R\+S B\+E L\+I\+A\+B\+L\+E F\+O\+R A\+N\+Y C\+L\+A\+I\+M, D\+A\+M\+A\+G\+E\+S O\+R O\+T\+H\+E\+R L\+I\+A\+B\+I\+L\+I\+T\+Y, W\+H\+E\+T\+H\+E\+R I\+N A\+N A\+C\+T\+I\+O\+N O\+F C\+O\+N\+T\+R\+A\+C\+T, T\+O\+R\+T O\+R O\+T\+H\+E\+R\+W\+I\+S\+E, A\+R\+I\+S\+I\+N\+G F\+R\+O\+M, O\+U\+T O\+F O\+R I\+N C\+O\+N\+N\+E\+C\+T\+I\+O\+N W\+I\+T\+H T\+H\+E S\+O\+F\+T\+W\+A\+R\+E O\+R T\+H\+E U\+S\+E O\+R O\+T\+H\+E\+R D\+E\+A\+L\+I\+N\+G\+S I\+N T\+H\+E S\+O\+F\+T\+W\+A\+R\+E. 