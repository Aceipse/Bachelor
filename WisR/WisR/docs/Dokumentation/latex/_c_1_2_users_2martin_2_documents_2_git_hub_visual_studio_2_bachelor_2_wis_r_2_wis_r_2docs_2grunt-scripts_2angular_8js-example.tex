\hypertarget{_c_1_2_users_2martin_2_documents_2_git_hub_visual_studio_2_bachelor_2_wis_r_2_wis_r_2docs_2grunt-scripts_2angular_8js-example}{}\section{C\+:/\+Users/martin/\+Documents/\+Git\+Hub\+Visual\+Studio/\+Bachelor/\+Wis\+R/\+Wis\+R/docs/grunt-\/scripts/angular.\+js}
$<$file name=\char`\"{}index.\+html\char`\"{}$>$  $<$form novalidate=\char`\"{}\char`\"{} class=\char`\"{}simple-\/form\char`\"{}$>$ Name\+: $<$input type=\char`\"{}text\char`\"{} ng-\/model=\char`\"{}user.\+name\char`\"{}$>$~\newline
 E-\/mail\+: $<$input type=\char`\"{}email\char`\"{} ng-\/model=\char`\"{}user.\+email\char`\"{}$>$~\newline
 Gender\+: $<$input type=\char`\"{}radio\char`\"{} ng-\/model=\char`\"{}user.\+gender\char`\"{} value=\char`\"{}male\char`\"{}$>$male $<$input type=\char`\"{}radio\char`\"{} ng-\/model=\char`\"{}user.\+gender\char`\"{} value=\char`\"{}female\char`\"{}$>$female~\newline
 $<$button ng-\/click=\char`\"{}reset()\char`\"{}$>$R\+E\+S\+E\+T$<$/button$>$ $<$button ng-\/click=\char`\"{}update(user)\char`\"{}$>$S\+A\+V\+E$<$/button$>$ $<$/form$>$ 
\begin{DoxyPre}form = \{\{user | json\}\}\end{DoxyPre}
 
\begin{DoxyPre}master = \{\{master | json\}\}\end{DoxyPre}
 

$<$script$>$ angular.\+module(\textquotesingle{}copy\+Example\textquotesingle{}, \mbox{[}\mbox{]}) .controller(\textquotesingle{}Example\+Controller\textquotesingle{}, \mbox{[}\textquotesingle{}\$scope\textquotesingle{}, function(\$scope) \{ \$scope.\+master= \{\};

\$scope.\+update = function(user) \{ // Example with 1 argument \$scope.\+master= angular.\+copy(user); \};

\$scope.\+reset = function() \{ // Example with 2 arguments angular.\+copy(\$scope.\+master, \$scope.\+user); \};

\$scope.\+reset(); \}\mbox{]}); $<$/script$>$ $<$/file$>$ 

$\ast$/ function copy(source, destination, stack\+Source, stack\+Dest) \{ if (is\+Window(source) $\vert$$\vert$ is\+Scope(source)) \{ throw ng\+Min\+Err(\textquotesingle{}cpws\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Making copies of Window or Scope instances is not supported.\char`\"{}); \} if (is\+Typed\+Array(destination)) \{ throw ng\+Min\+Err(\textquotesingle{}cpta\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Typed\+Array destination cannot be mutated.\char`\"{}); \}

if (!destination) \{ destination = source; if (is\+Object(source)) \{ var index; if (stack\+Source \&\& (index = stack\+Source.\+index\+Of(source)) !== -\/1) \{ return stack\+Dest\mbox{[}index\mbox{]}; \}

// Typed\+Array, Date and Reg\+Exp have specific copy functionality and must be // pushed onto the stack before returning. // Array and other objects create the base object and recurse to copy child // objects. The array/object will be pushed onto the stack when recursed. if (is\+Array(source)) \{ return copy(source, \mbox{[}$\,$\mbox{]}, stack\+Source, stack\+Dest); \} else if (is\+Typed\+Array(source)) \{ destination = new source.\+constructor(source); \} else if (is\+Date(source)) \{ destination = new Date(source.\+get\+Time()); \} else if (is\+Reg\+Exp(source)) \{ destination = new Reg\+Exp(source.\+source, source.\+to\+String().match(/\mbox{[}$^\wedge$\textbackslash{}/\mbox{]}$\ast$\$/)\mbox{[}0\mbox{]}); destination.\+last\+Index = source.\+last\+Index; \} else \{ var empty\+Object = Object.\+create(get\+Prototype\+Of(source)); return copy(source, empty\+Object, stack\+Source, stack\+Dest); \}

if (stack\+Dest) \{ stack\+Source.\+push(source); stack\+Dest.\+push(destination); \} \} \} else \{ if (source === destination) throw ng\+Min\+Err(\textquotesingle{}cpi\textquotesingle{}, \char`\"{}\+Can\textquotesingle{}t copy! Source and destination are identical.\char`\"{});

stack\+Source = stack\+Source $\vert$$\vert$ \mbox{[}\mbox{]}; stack\+Dest = stack\+Dest $\vert$$\vert$ \mbox{[}\mbox{]};

if (is\+Object(source)) \{ stack\+Source.\+push(source); stack\+Dest.\+push(destination); \}

var result, key; if (is\+Array(source)) \{ destination.\+length = 0; for (var i = 0; i $<$ source.\+length; i++) \{ destination.\+push(copy(source\mbox{[}i\mbox{]}, null, stack\+Source, stack\+Dest)); \} \} else \{ var h = destination.\$\$hash\+Key; if (is\+Array(destination)) \{ destination.\+length = 0; \} else \{ for\+Each(destination, function(value, key) \{ delete destination\mbox{[}key\mbox{]}; \}); \} if (is\+Blank\+Object(source)) \{ // create\+Map() fast path --- Safe to avoid has\+Own\+Property check because prototype chain is empty for (key in source) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} else if (source \&\& typeof source.\+has\+Own\+Property === \textquotesingle{}function\textquotesingle{}) \{ // Slow path, which must rely on has\+Own\+Property for (key in source) \{ if (source.\+has\+Own\+Property(key)) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} \} else \{ // Slowest path --- has\+Own\+Property can\textquotesingle{}t be called as a method for (key in source) \{ if (has\+Own\+Property.\+call(source, key)) \{ destination\mbox{[}key\mbox{]} = copy(source\mbox{[}key\mbox{]}, null, stack\+Source, stack\+Dest); \} \} \} set\+Hash\+Key(destination,h); \} \} return destination; \}

/$\ast$$\ast$ Creates a shallow copy of an object, an array or a primitive.

Assumes that there are no proto properties for objects. $\ast$/ function shallow\+Copy(src, dst) \{ if (is\+Array(src)) \{ dst = dst $\vert$$\vert$ \mbox{[}\mbox{]};

for (var i = 0, ii = src.\+length; i $<$ ii; i++) \{ dst\mbox{[}i\mbox{]} = src\mbox{[}i\mbox{]}; \} \} else if (is\+Object(src)) \{ dst = dst $\vert$$\vert$ \{\};

for (var key in src) \{ if (!(key.\+char\+At(0) === \textquotesingle{}\$\textquotesingle{} \&\& key.\+char\+At(1) === \textquotesingle{}\$\textquotesingle{})) \{ dst\mbox{[}key\mbox{]} = src\mbox{[}key\mbox{]}; \} \} \}

return dst $\vert$$\vert$ src; \}

/$\ast$$\ast$  function


\begin{DoxyCodeInclude}

(\textcolor{keyword}{function}(window, document, undefined) \{\textcolor{stringliteral}{'use strict'};

\textcolor{keyword}{function} minErr(module, ErrorConstructor) \{
  ErrorConstructor = ErrorConstructor || Error;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    var SKIP\_INDEXES = 2;

    var templateArgs = arguments,
      code = templateArgs[0],
      message = \textcolor{charliteral}{'['} + (module ? module + \textcolor{charliteral}{':'} : \textcolor{stringliteral}{''}) + code + \textcolor{stringliteral}{'] '},
      \textcolor{keyword}{template} = templateArgs[1],
      paramPrefix, i;

    message += \textcolor{keyword}{template}.replace(/\(\backslash\)\{\(\backslash\)d+\(\backslash\)\}/g, \textcolor{keyword}{function}(match) \{
      var index = +match.slice(1, -1),
        shiftedIndex = index + SKIP\_INDEXES;

      \textcolor{keywordflow}{if} (shiftedIndex < templateArgs.length) \{
        \textcolor{keywordflow}{return} toDebugString(templateArgs[shiftedIndex]);
      \}

      \textcolor{keywordflow}{return} match;
    \});

    message += \textcolor{stringliteral}{'\(\backslash\)nhttp://errors.angularjs.org/1.4.4/'} +
      (module ? module + \textcolor{charliteral}{'/'} : \textcolor{stringliteral}{''}) + code;

    \textcolor{keywordflow}{for} (i = SKIP\_INDEXES, paramPrefix = \textcolor{charliteral}{'?'}; i < templateArgs.length; i++, paramPrefix = \textcolor{charliteral}{'&'}) \{
      message += paramPrefix + \textcolor{charliteral}{'p'} + (i - SKIP\_INDEXES) + \textcolor{charliteral}{'='} +
        encodeURIComponent(toDebugString(templateArgs[i]));
    \}

    \textcolor{keywordflow}{return} \textcolor{keyword}{new} ErrorConstructor(message);
  \};
\}

\textcolor{comment}{/* We need to tell jshint what variables are being exported */}
\textcolor{comment}{/* global angular: true,}
\textcolor{comment}{  msie: true,}
\textcolor{comment}{  jqLite: true,}
\textcolor{comment}{  jQuery: true,}
\textcolor{comment}{  slice: true,}
\textcolor{comment}{  splice: true,}
\textcolor{comment}{  push: true,}
\textcolor{comment}{  toString: true,}
\textcolor{comment}{  ngMinErr: true,}
\textcolor{comment}{  angularModule: true,}
\textcolor{comment}{  uid: true,}
\textcolor{comment}{  REGEX\_STRING\_REGEXP: true,}
\textcolor{comment}{  VALIDITY\_STATE\_PROPERTY: true,}
\textcolor{comment}{}
\textcolor{comment}{  lowercase: true,}
\textcolor{comment}{  uppercase: true,}
\textcolor{comment}{  manualLowercase: true,}
\textcolor{comment}{  manualUppercase: true,}
\textcolor{comment}{  nodeName\_: true,}
\textcolor{comment}{  isArrayLike: true,}
\textcolor{comment}{  forEach: true,}
\textcolor{comment}{  forEachSorted: true,}
\textcolor{comment}{  reverseParams: true,}
\textcolor{comment}{  nextUid: true,}
\textcolor{comment}{  setHashKey: true,}
\textcolor{comment}{  extend: true,}
\textcolor{comment}{  toInt: true,}
\textcolor{comment}{  inherit: true,}
\textcolor{comment}{  merge: true,}
\textcolor{comment}{  noop: true,}
\textcolor{comment}{  identity: true,}
\textcolor{comment}{  valueFn: true,}
\textcolor{comment}{  isUndefined: true,}
\textcolor{comment}{  isDefined: true,}
\textcolor{comment}{  isObject: true,}
\textcolor{comment}{  isBlankObject: true,}
\textcolor{comment}{  isString: true,}
\textcolor{comment}{  isNumber: true,}
\textcolor{comment}{  isDate: true,}
\textcolor{comment}{  isArray: true,}
\textcolor{comment}{  isFunction: true,}
\textcolor{comment}{  isRegExp: true,}
\textcolor{comment}{  isWindow: true,}
\textcolor{comment}{  isScope: true,}
\textcolor{comment}{  isFile: true,}
\textcolor{comment}{  isFormData: true,}
\textcolor{comment}{  isBlob: true,}
\textcolor{comment}{  isBoolean: true,}
\textcolor{comment}{  isPromiseLike: true,}
\textcolor{comment}{  trim: true,}
\textcolor{comment}{  escapeForRegexp: true,}
\textcolor{comment}{  isElement: true,}
\textcolor{comment}{  makeMap: true,}
\textcolor{comment}{  includes: true,}
\textcolor{comment}{  arrayRemove: true,}
\textcolor{comment}{  copy: true,}
\textcolor{comment}{  shallowCopy: true,}
\textcolor{comment}{  equals: true,}
\textcolor{comment}{  csp: true,}
\textcolor{comment}{  jq: true,}
\textcolor{comment}{  concat: true,}
\textcolor{comment}{  sliceArgs: true,}
\textcolor{comment}{  bind: true,}
\textcolor{comment}{  toJsonReplacer: true,}
\textcolor{comment}{  toJson: true,}
\textcolor{comment}{  fromJson: true,}
\textcolor{comment}{  convertTimezoneToLocal: true,}
\textcolor{comment}{  timezoneToOffset: true,}
\textcolor{comment}{  startingTag: true,}
\textcolor{comment}{  tryDecodeURIComponent: true,}
\textcolor{comment}{  parseKeyValue: true,}
\textcolor{comment}{  toKeyValue: true,}
\textcolor{comment}{  encodeUriSegment: true,}
\textcolor{comment}{  encodeUriQuery: true,}
\textcolor{comment}{  angularInit: true,}
\textcolor{comment}{  bootstrap: true,}
\textcolor{comment}{  getTestability: true,}
\textcolor{comment}{  snake\_case: true,}
\textcolor{comment}{  bindJQuery: true,}
\textcolor{comment}{  assertArg: true,}
\textcolor{comment}{  assertArgFn: true,}
\textcolor{comment}{  assertNotHasOwnProperty: true,}
\textcolor{comment}{  getter: true,}
\textcolor{comment}{  getBlockNodes: true,}
\textcolor{comment}{  hasOwnProperty: true,}
\textcolor{comment}{  createMap: true,}
\textcolor{comment}{}
\textcolor{comment}{  NODE\_TYPE\_ELEMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_ATTRIBUTE: true,}
\textcolor{comment}{  NODE\_TYPE\_TEXT: true,}
\textcolor{comment}{  NODE\_TYPE\_COMMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_DOCUMENT: true,}
\textcolor{comment}{  NODE\_TYPE\_DOCUMENT\_FRAGMENT: true,}
\textcolor{comment}{*/}


var REGEX\_STRING\_REGEXP = /^\(\backslash\)/(.+)\(\backslash\)/([a-z]*)$/;

\textcolor{comment}{// The name of a form control's ValidityState property.}
\textcolor{comment}{// This is used so that it's possible for internal tests to create mock ValidityStates.}
var VALIDITY\_STATE\_PROPERTY = \textcolor{stringliteral}{'validity'};

var lowercase = \textcolor{keyword}{function}(string) \{\textcolor{keywordflow}{return} isString(\textcolor{keywordtype}{string}) ? \textcolor{keywordtype}{string}.toLowerCase() : string;\};
var hasOwnProperty = Object.prototype.hasOwnProperty;

var uppercase = \textcolor{keyword}{function}(string) \{\textcolor{keywordflow}{return} isString(\textcolor{keywordtype}{string}) ? \textcolor{keywordtype}{string}.toUpperCase() : string;\};


var manualLowercase = \textcolor{keyword}{function}(s) \{
  \textcolor{comment}{/* jshint bitwise: false */}
  \textcolor{keywordflow}{return} isString(s)
      ? s.replace(/[A-Z]/g, \textcolor{keyword}{function}(ch) \{\textcolor{keywordflow}{return} String.fromCharCode(ch.charCodeAt(0) | 32);\})
      : s;
\};
var manualUppercase = \textcolor{keyword}{function}(s) \{
  \textcolor{comment}{/* jshint bitwise: false */}
  \textcolor{keywordflow}{return} isString(s)
      ? s.replace(/[a-z]/g, \textcolor{keyword}{function}(ch) \{\textcolor{keywordflow}{return} String.fromCharCode(ch.charCodeAt(0) & ~32);\})
      : s;
\};


\textcolor{comment}{// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish}
\textcolor{comment}{// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods}
\textcolor{comment}{// with correct but slower alternatives.}
\textcolor{keywordflow}{if} (\textcolor{charliteral}{'i'} !== \textcolor{charliteral}{'I'}.toLowerCase()) \{
  lowercase = manualLowercase;
  uppercase = manualUppercase;
\}


var
    msie,             \textcolor{comment}{// holds major version number for IE, or NaN if UA is not IE.}
    jqLite,           \textcolor{comment}{// delay binding since jQuery could be loaded after us.}
    jQuery,           \textcolor{comment}{// delay binding}
    slice             = [].slice,
    splice            = [].splice,
    push              = [].push,
    toString          = Object.prototype.toString,
    getPrototypeOf    = Object.getPrototypeOf,
    ngMinErr          = minErr(\textcolor{stringliteral}{'ng'}),

    angular           = window.angular || (window.angular = \{\}),
    angularModule,
    uid               = 0;

msie = document.documentMode;


\textcolor{keyword}{function} isArrayLike(obj) \{
  \textcolor{keywordflow}{if} (obj == null || isWindow(obj)) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \}

  \textcolor{comment}{// Support: iOS 8.2 (not reproducible in simulator)}
  \textcolor{comment}{// "length" in obj used to prevent JIT error (gh-11508)}
  var length = \textcolor{stringliteral}{"length"} in Object(obj) && obj.length;

  \textcolor{keywordflow}{if} (obj.nodeType === NODE\_TYPE\_ELEMENT && length) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}

  \textcolor{keywordflow}{return} isString(obj) || isArray(obj) || length === 0 ||
         typeof length === \textcolor{stringliteral}{'number'} && length > 0 && (length - 1) in obj;
\}

\textcolor{keyword}{function} forEach(obj, iterator, context) \{
  var key, length;
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (isFunction(obj)) \{
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{comment}{// Need to check if hasOwnProperty exists,}
        \textcolor{comment}{// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function}
        \textcolor{keywordflow}{if} (key != \textcolor{stringliteral}{'prototype'} && key != \textcolor{stringliteral}{'length'} && key != \textcolor{stringliteral}{'name'} && (!obj.hasOwnProperty || obj.
      hasOwnProperty(key))) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(obj) || isArrayLike(obj)) \{
      var isPrimitive = typeof obj !== \textcolor{stringliteral}{'object'};
      \textcolor{keywordflow}{for} (key = 0, length = obj.length; key < length; key++) \{
        \textcolor{keywordflow}{if} (isPrimitive || key in obj) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj.forEach && obj.forEach !== forEach) \{
        obj.forEach(iterator, context, obj);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isBlankObject(obj)) \{
      \textcolor{comment}{// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty}
      \textcolor{keywordflow}{for} (key in obj) \{
        iterator.call(context, obj[key], key, obj);
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj.hasOwnProperty === \textcolor{stringliteral}{'function'}) \{
      \textcolor{comment}{// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed}
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{keywordflow}{if} (obj.hasOwnProperty(key)) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// Slow path for objects which do not have a method `hasOwnProperty`}
      \textcolor{keywordflow}{for} (key in obj) \{
        \textcolor{keywordflow}{if} (hasOwnProperty.call(obj, key)) \{
          iterator.call(context, obj[key], key, obj);
        \}
      \}
    \}
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} forEachSorted(obj, iterator, context) \{
  var keys = Object.keys(obj).sort();
  \textcolor{keywordflow}{for} (var i = 0; i < keys.length; i++) \{
    iterator.call(context, obj[keys[i]], keys[i]);
  \}
  \textcolor{keywordflow}{return} keys;
\}


\textcolor{keyword}{function} reverseParams(iteratorFn) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value, key) \{ iteratorFn(key, value); \};
\}

\textcolor{keyword}{function} nextUid() \{
  \textcolor{keywordflow}{return} ++uid;
\}


\textcolor{keyword}{function} setHashKey(obj, h) \{
  \textcolor{keywordflow}{if} (h) \{
    obj.$$hashKey = h;
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keyword}{delete} obj.$$hashKey;
  \}
\}


\textcolor{keyword}{function} baseExtend(dst, objs, deep) \{
  var h = dst.$$hashKey;

  \textcolor{keywordflow}{for} (var i = 0, ii = objs.length; i < ii; ++i) \{
    var obj = objs[i];
    \textcolor{keywordflow}{if} (!isObject(obj) && !isFunction(obj)) \textcolor{keywordflow}{continue};
    var keys = Object.keys(obj);
    \textcolor{keywordflow}{for} (var j = 0, jj = keys.length; j < jj; j++) \{
      var key = keys[j];
      var src = obj[key];

      \textcolor{keywordflow}{if} (deep && isObject(src)) \{
        \textcolor{keywordflow}{if} (isDate(src)) \{
          dst[key] = \textcolor{keyword}{new} Date(src.valueOf());
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(src)) \{
          dst[key] = \textcolor{keyword}{new} RegExp(src);
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (!isObject(dst[key])) dst[key] = isArray(src) ? [] : \{\};
          baseExtend(dst[key], [src], \textcolor{keyword}{true});
        \}
      \} \textcolor{keywordflow}{else} \{
        dst[key] = src;
      \}
    \}
  \}

  setHashKey(dst, h);
  \textcolor{keywordflow}{return} dst;
\}

\textcolor{keyword}{function} extend(dst) \{
  \textcolor{keywordflow}{return} baseExtend(dst, slice.call(arguments, 1), \textcolor{keyword}{false});
\}


\textcolor{keyword}{function} merge(dst) \{
  \textcolor{keywordflow}{return} baseExtend(dst, slice.call(arguments, 1), \textcolor{keyword}{true});
\}



\textcolor{keyword}{function} toInt(str) \{
  \textcolor{keywordflow}{return} parseInt(str, 10);
\}


\textcolor{keyword}{function} inherit(parent, extra) \{
  \textcolor{keywordflow}{return} extend(Object.create(parent), extra);
\}

\textcolor{keyword}{function} noop() \{\}
noop.$inject = [];


\textcolor{keyword}{function} identity($) \{\textcolor{keywordflow}{return} $;\}
identity.$inject = [];


\textcolor{keyword}{function} valueFn(value) \{\textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{\textcolor{keywordflow}{return} value;\};\}

\textcolor{keyword}{function} hasCustomToString(obj) \{
  \textcolor{keywordflow}{return} isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
\}


\textcolor{keyword}{function} isUndefined(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'undefined'};\}


\textcolor{keyword}{function} isDefined(value) \{\textcolor{keywordflow}{return} typeof value !== \textcolor{stringliteral}{'undefined'};\}


\textcolor{keyword}{function} isObject(value) \{
  \textcolor{comment}{// http://jsperf.com/isobject4}
  \textcolor{keywordflow}{return} value !== null && typeof value === \textcolor{stringliteral}{'object'};
\}


\textcolor{keyword}{function} isBlankObject(value) \{
  \textcolor{keywordflow}{return} value !== null && typeof value === \textcolor{stringliteral}{'object'} && !getPrototypeOf(value);
\}


\textcolor{keyword}{function} isString(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'string'};\}


\textcolor{keyword}{function} isNumber(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'number'};\}


\textcolor{keyword}{function} isDate(value) \{
  \textcolor{keywordflow}{return} toString.call(value) === \textcolor{stringliteral}{'[object Date]'};
\}


var isArray = Array.isArray;

\textcolor{keyword}{function} isFunction(value) \{\textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'function'};\}


\textcolor{keyword}{function} isRegExp(value) \{
  \textcolor{keywordflow}{return} toString.call(value) === \textcolor{stringliteral}{'[object RegExp]'};
\}


\textcolor{keyword}{function} isWindow(obj) \{
  \textcolor{keywordflow}{return} obj && obj.window === obj;
\}


\textcolor{keyword}{function} isScope(obj) \{
  \textcolor{keywordflow}{return} obj && obj.$evalAsync && obj.$watch;
\}


\textcolor{keyword}{function} isFile(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object File]'};
\}


\textcolor{keyword}{function} isFormData(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object FormData]'};
\}


\textcolor{keyword}{function} isBlob(obj) \{
  \textcolor{keywordflow}{return} toString.call(obj) === \textcolor{stringliteral}{'[object Blob]'};
\}


\textcolor{keyword}{function} isBoolean(value) \{
  \textcolor{keywordflow}{return} typeof value === \textcolor{stringliteral}{'boolean'};
\}


\textcolor{keyword}{function} isPromiseLike(obj) \{
  \textcolor{keywordflow}{return} obj && isFunction(obj.then);
\}


var TYPED\_ARRAY\_REGEXP = /^\(\backslash\)[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(
      64))Array\(\backslash\)]$/;
\textcolor{keyword}{function} isTypedArray(value) \{
  \textcolor{keywordflow}{return} TYPED\_ARRAY\_REGEXP.test(toString.call(value));
\}


var trim = \textcolor{keyword}{function}(value) \{
  \textcolor{keywordflow}{return} isString(value) ? value.trim() : value;
\};

\textcolor{comment}{// Copied from:}
\textcolor{comment}{// http://docs.closure-library.googlecode.com/git/local\_closure\_goog\_string\_string.js.source.html#line1021}
\textcolor{comment}{// Prereq: s is a string.}
var escapeForRegexp = \textcolor{keyword}{function}(s) \{
  \textcolor{keywordflow}{return} s.replace(/([-()\(\backslash\)[\(\backslash\)]\{\}+?*.$\(\backslash\)^|,:#<!\(\backslash\)\(\backslash\)])/g, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)$1'}).
           replace(/\(\backslash\)x08/g, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)x08'});
\};


\textcolor{keyword}{function} isElement(node) \{
  \textcolor{keywordflow}{return} !!(node &&
    (node.nodeName  \textcolor{comment}{// we are a direct element}
    || (node.prop && node.attr && node.find)));  \textcolor{comment}{// we have an on and find method part of jQuery API}
\}

\textcolor{keyword}{function} makeMap(str) \{
  var obj = \{\}, items = str.split(\textcolor{stringliteral}{","}), i;
  \textcolor{keywordflow}{for} (i = 0; i < items.length; i++) \{
    obj[items[i]] = \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{return} obj;
\}


\textcolor{keyword}{function} nodeName\_(element) \{
  \textcolor{keywordflow}{return} lowercase(element.nodeName || (element[0] && element[0].nodeName));
\}

\textcolor{keyword}{function} includes(array, obj) \{
  \textcolor{keywordflow}{return} Array.prototype.indexOf.call(array, obj) != -1;
\}

\textcolor{keyword}{function} arrayRemove(array, value) \{
  var index = array.indexOf(value);
  \textcolor{keywordflow}{if} (index >= 0) \{
    array.splice(index, 1);
  \}
  \textcolor{keywordflow}{return} index;
\}

\textcolor{keyword}{function} copy(source, destination, stackSource, stackDest) \{
  \textcolor{keywordflow}{if} (isWindow(source) || isScope(source)) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpws'},
      \textcolor{stringliteral}{"Can't copy! Making copies of Window or Scope instances is not supported."});
  \}
  \textcolor{keywordflow}{if} (isTypedArray(destination)) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpta'},
      \textcolor{stringliteral}{"Can't copy! TypedArray destination cannot be mutated."});
  \}

  \textcolor{keywordflow}{if} (!destination) \{
    destination = source;
    \textcolor{keywordflow}{if} (isObject(source)) \{
      var index;
      \textcolor{keywordflow}{if} (stackSource && (index = stackSource.indexOf(source)) !== -1) \{
        \textcolor{keywordflow}{return} stackDest[index];
      \}

      \textcolor{comment}{// TypedArray, Date and RegExp have specific copy functionality and must be}
      \textcolor{comment}{// pushed onto the stack before returning.}
      \textcolor{comment}{// Array and other objects create the base object and recurse to copy child}
      \textcolor{comment}{// objects. The array/object will be pushed onto the stack when recursed.}
      \textcolor{keywordflow}{if} (isArray(source)) \{
        \textcolor{keywordflow}{return} copy(source, [], stackSource, stackDest);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isTypedArray(source)) \{
        destination = \textcolor{keyword}{new} source.constructor(source);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDate(source)) \{
        destination = \textcolor{keyword}{new} Date(source.getTime());
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(source)) \{
        destination = \textcolor{keyword}{new} RegExp(source.source, source.toString().match(/[^\(\backslash\)/]*$/)[0]);
        destination.lastIndex = source.lastIndex;
      \} \textcolor{keywordflow}{else} \{
        var emptyObject = Object.create(getPrototypeOf(source));
        \textcolor{keywordflow}{return} copy(source, emptyObject, stackSource, stackDest);
      \}

      \textcolor{keywordflow}{if} (stackDest) \{
        stackSource.push(source);
        stackDest.push(destination);
      \}
    \}
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{if} (source === destination) \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'cpi'},
      \textcolor{stringliteral}{"Can't copy! Source and destination are identical."});

    stackSource = stackSource || [];
    stackDest = stackDest || [];

    \textcolor{keywordflow}{if} (isObject(source)) \{
      stackSource.push(source);
      stackDest.push(destination);
    \}

    var result, key;
    \textcolor{keywordflow}{if} (isArray(source)) \{
      destination.length = 0;
      \textcolor{keywordflow}{for} (var i = 0; i < source.length; i++) \{
        destination.push(copy(source[i], null, stackSource, stackDest));
      \}
    \} \textcolor{keywordflow}{else} \{
      var h = destination.$$hashKey;
      \textcolor{keywordflow}{if} (isArray(destination)) \{
        destination.length = 0;
      \} \textcolor{keywordflow}{else} \{
        forEach(destination, \textcolor{keyword}{function}(value, key) \{
          \textcolor{keyword}{delete} destination[key];
        \});
      \}
      \textcolor{keywordflow}{if} (isBlankObject(source)) \{
        \textcolor{comment}{// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty}
        \textcolor{keywordflow}{for} (key in source) \{
          destination[key] = copy(source[key], null, stackSource, stackDest);
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (source && typeof source.hasOwnProperty === \textcolor{stringliteral}{'function'}) \{
        \textcolor{comment}{// Slow path, which must rely on hasOwnProperty}
        \textcolor{keywordflow}{for} (key in source) \{
          \textcolor{keywordflow}{if} (source.hasOwnProperty(key)) \{
            destination[key] = copy(source[key], null, stackSource, stackDest);
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// Slowest path --- hasOwnProperty can't be called as a method}
        \textcolor{keywordflow}{for} (key in source) \{
          \textcolor{keywordflow}{if} (hasOwnProperty.call(source, key)) \{
            destination[key] = copy(source[key], null, stackSource, stackDest);
          \}
        \}
      \}
      setHashKey(destination,h);
    \}
  \}
  \textcolor{keywordflow}{return} destination;
\}

\textcolor{keyword}{function} shallowCopy(src, dst) \{
  \textcolor{keywordflow}{if} (isArray(src)) \{
    dst = dst || [];

    \textcolor{keywordflow}{for} (var i = 0, ii = src.length; i < ii; i++) \{
      dst[i] = src[i];
    \}
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(src)) \{
    dst = dst || \{\};

    \textcolor{keywordflow}{for} (var key in src) \{
      \textcolor{keywordflow}{if} (!(key.charAt(0) === \textcolor{charliteral}{'$'} && key.charAt(1) === \textcolor{charliteral}{'$'})) \{
        dst[key] = src[key];
      \}
    \}
  \}

  \textcolor{keywordflow}{return} dst || src;
\}


\textcolor{keyword}{function} equals(o1, o2) \{
  \textcolor{keywordflow}{if} (o1 === o2) \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \textcolor{keywordflow}{if} (o1 === null || o2 === null) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \textcolor{keywordflow}{if} (o1 !== o1 && o2 !== o2) \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{// NaN === NaN}
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  \textcolor{keywordflow}{if} (t1 == t2) \{
    \textcolor{keywordflow}{if} (t1 == \textcolor{stringliteral}{'object'}) \{
      \textcolor{keywordflow}{if} (isArray(o1)) \{
        \textcolor{keywordflow}{if} (!isArray(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \textcolor{keywordflow}{if} ((length = o1.length) == o2.length) \{
          \textcolor{keywordflow}{for} (key = 0; key < length; key++) \{
            \textcolor{keywordflow}{if} (!equals(o1[key], o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          \}
          \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDate(o1)) \{
        \textcolor{keywordflow}{if} (!isDate(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \textcolor{keywordflow}{return} equals(o1.getTime(), o2.getTime());
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(o1)) \{
        \textcolor{keywordflow}{return} isRegExp(o2) ? o1.toString() == o2.toString() : \textcolor{keyword}{false};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
          isArray(o2) || isDate(o2) || isRegExp(o2)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        keySet = createMap();
        \textcolor{keywordflow}{for} (key in o1) \{
          \textcolor{keywordflow}{if} (key.charAt(0) === \textcolor{charliteral}{'$'} || isFunction(o1[key])) \textcolor{keywordflow}{continue};
          \textcolor{keywordflow}{if} (!equals(o1[key], o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          keySet[key] = \textcolor{keyword}{true};
        \}
        \textcolor{keywordflow}{for} (key in o2) \{
          \textcolor{keywordflow}{if} (!(key in keySet) &&
              key.charAt(0) !== \textcolor{charliteral}{'$'} &&
              o2[key] !== undefined &&
              !isFunction(o2[key])) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \}
    \}
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

var csp = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{if} (!isDefined(csp.rules)) \{


    var ngCspElement = (document.querySelector(\textcolor{stringliteral}{'[ng-csp]'}) ||
                    document.querySelector(\textcolor{stringliteral}{'[data-ng-csp]'}));

    \textcolor{keywordflow}{if} (ngCspElement) \{
      var ngCspAttribute = ngCspElement.getAttribute(\textcolor{stringliteral}{'ng-csp'}) ||
                    ngCspElement.getAttribute(\textcolor{stringliteral}{'data-ng-csp'});
      csp.rules = \{
        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf(\textcolor{stringliteral}{'no-unsafe-eval'}) !== -1),
        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf(\textcolor{stringliteral}{'no-inline-style'}) !== -1)
      \};
    \} \textcolor{keywordflow}{else} \{
      csp.rules = \{
        noUnsafeEval: noUnsafeEval(),
        noInlineStyle: \textcolor{keyword}{false}
      \};
    \}
  \}

  \textcolor{keywordflow}{return} csp.rules;

  \textcolor{keyword}{function} noUnsafeEval() \{
    \textcolor{keywordflow}{try} \{
      \textcolor{comment}{/* jshint -W031, -W054 */}
      \textcolor{keyword}{new} Function(\textcolor{stringliteral}{''});
      \textcolor{comment}{/* jshint +W031, +W054 */}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
  \}
\};

var jq = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{if} (isDefined(jq.name\_)) \textcolor{keywordflow}{return} jq.name\_;
  var el;
  var i, ii = ngAttrPrefixes.length, prefix, name;
  for (i = 0; i < ii; ++i) \{
    prefix = ngAttrPrefixes[i];
    \textcolor{keywordflow}{if} (el = document.querySelector(\textcolor{charliteral}{'['} + prefix.replace(\textcolor{charliteral}{':'}, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\):'}) + \textcolor{stringliteral}{'jq]'})) \{
      name = el.getAttribute(prefix + \textcolor{stringliteral}{'jq'});
      \textcolor{keywordflow}{break};
    \}
  \}

  \textcolor{keywordflow}{return} (jq.name\_ = name);
\};

\textcolor{keyword}{function} concat(array1, array2, index) \{
  \textcolor{keywordflow}{return} array1.concat(slice.call(array2, index));
\}

\textcolor{keyword}{function} sliceArgs(args, startIndex) \{
  \textcolor{keywordflow}{return} slice.call(args, startIndex || 0);
\}


\textcolor{comment}{/* jshint -W101 */}
\textcolor{comment}{/* jshint +W101 */}
\textcolor{keyword}{function} bind(\textcolor{keyword}{self}, fn) \{
  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  \textcolor{keywordflow}{if} (isFunction(fn) && !(fn instanceof RegExp)) \{
    \textcolor{keywordflow}{return} curryArgs.length
      ? \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} arguments.length
            ? fn.apply(\textcolor{keyword}{self}, concat(curryArgs, arguments, 0))
            : fn.apply(\textcolor{keyword}{self}, curryArgs);
        \}
      : \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} arguments.length
            ? fn.apply(\textcolor{keyword}{self}, arguments)
            : fn.call(\textcolor{keyword}{self});
        \};
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// in IE, native methods are not functions so they cannot be bound (note: they don't need to be)}
    \textcolor{keywordflow}{return} fn;
  \}
\}


\textcolor{keyword}{function} toJsonReplacer(key, value) \{
  var val = value;

  \textcolor{keywordflow}{if} (typeof key === \textcolor{stringliteral}{'string'} && key.charAt(0) === \textcolor{charliteral}{'$'} && key.charAt(1) === \textcolor{charliteral}{'$'}) \{
    val = undefined;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isWindow(value)) \{
    val = \textcolor{stringliteral}{'$WINDOW'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value &&  document === value) \{
    val = \textcolor{stringliteral}{'$DOCUMENT'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isScope(value)) \{
    val = \textcolor{stringliteral}{'$SCOPE'};
  \}

  \textcolor{keywordflow}{return} val;
\}


\textcolor{keyword}{function} toJson(obj, pretty) \{
  \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} undefined;
  \textcolor{keywordflow}{if} (!isNumber(pretty)) \{
    pretty = pretty ? 2 : null;
  \}
  \textcolor{keywordflow}{return} JSON.stringify(obj, toJsonReplacer, pretty);
\}


\textcolor{keyword}{function} fromJson(json) \{
  \textcolor{keywordflow}{return} isString(json)
      ? JSON.parse(json)
      : json;
\}


\textcolor{keyword}{function} timezoneToOffset(timezone, fallback) \{
  var requestedTimezoneOffset = Date.parse(\textcolor{stringliteral}{'Jan 01, 1970 00:00:00 '} + timezone) / 60000;
  \textcolor{keywordflow}{return} isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
\}


\textcolor{keyword}{function} addDateMinutes(date, minutes) \{
  date = \textcolor{keyword}{new} Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  \textcolor{keywordflow}{return} date;
\}


\textcolor{keyword}{function} convertTimezoneToLocal(date, timezone, reverse) \{
  reverse = reverse ? -1 : 1;
  var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
  \textcolor{keywordflow}{return} addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
\}


\textcolor{keyword}{function} startingTag(element) \{
  element = jqLite(element).clone();
  \textcolor{keywordflow}{try} \{
    \textcolor{comment}{// turns out IE does not let you set .html() on elements which}
    \textcolor{comment}{// are not allowed to have children. So we just ignore it.}
    element.empty();
  \} \textcolor{keywordflow}{catch} (e) \{\}
  var elemHtml = jqLite(\textcolor{stringliteral}{'<div>'}).append(element).html();
  \textcolor{keywordflow}{try} \{
    \textcolor{keywordflow}{return} element[0].nodeType === NODE\_TYPE\_TEXT ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\(\backslash\)w\(\backslash\)-]+)/, \textcolor{keyword}{function}(match, nodeName) \{ \textcolor{keywordflow}{return} \textcolor{charliteral}{'<'} + lowercase(nodeName); \});
  \} \textcolor{keywordflow}{catch} (e) \{
    \textcolor{keywordflow}{return} lowercase(elemHtml);
  \}

\}



\textcolor{keyword}{function} tryDecodeURIComponent(value) \{
  \textcolor{keywordflow}{try} \{
    \textcolor{keywordflow}{return} decodeURIComponent(value);
  \} \textcolor{keywordflow}{catch} (e) \{
    \textcolor{comment}{// Ignore any invalid uri component}
  \}
\}


\textcolor{keyword}{function} parseKeyValue(keyValue) \{
  var obj = \{\};
  forEach((keyValue || \textcolor{stringliteral}{""}).split(\textcolor{charliteral}{'&'}), \textcolor{keyword}{function}(keyValue) \{
    var splitPoint, key, val;
    \textcolor{keywordflow}{if} (keyValue) \{
      key = keyValue = keyValue.replace(/\(\backslash\)+/g,\textcolor{stringliteral}{'%20'});
      splitPoint = keyValue.indexOf(\textcolor{charliteral}{'='});
      \textcolor{keywordflow}{if} (splitPoint !== -1) \{
        key = keyValue.substring(0, splitPoint);
        val = keyValue.substring(splitPoint + 1);
      \}
      key = tryDecodeURIComponent(key);
      \textcolor{keywordflow}{if} (isDefined(key)) \{
        val = isDefined(val) ? tryDecodeURIComponent(val) : \textcolor{keyword}{true};
        \textcolor{keywordflow}{if} (!hasOwnProperty.call(obj, key)) \{
          obj[key] = val;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(obj[key])) \{
          obj[key].push(val);
        \} \textcolor{keywordflow}{else} \{
          obj[key] = [obj[key],val];
        \}
      \}
    \}
  \});
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} toKeyValue(obj) \{
  var parts = [];
  forEach(obj, \textcolor{keyword}{function}(value, key) \{
    \textcolor{keywordflow}{if} (isArray(value)) \{
      forEach(value, \textcolor{keyword}{function}(arrayValue) \{
        parts.push(encodeUriQuery(key, \textcolor{keyword}{true}) +
                   (arrayValue === \textcolor{keyword}{true} ? \textcolor{stringliteral}{''} : \textcolor{charliteral}{'='} + encodeUriQuery(arrayValue, \textcolor{keyword}{true})));
      \});
    \} \textcolor{keywordflow}{else} \{
    parts.push(encodeUriQuery(key, \textcolor{keyword}{true}) +
               (value === \textcolor{keyword}{true} ? \textcolor{stringliteral}{''} : \textcolor{charliteral}{'='} + encodeUriQuery(value, \textcolor{keyword}{true})));
    \}
  \});
  \textcolor{keywordflow}{return} parts.length ? parts.join(\textcolor{charliteral}{'&'}) : \textcolor{stringliteral}{''};
\}


\textcolor{keyword}{function} encodeUriSegment(val) \{
  \textcolor{keywordflow}{return} encodeUriQuery(val, \textcolor{keyword}{true}).
             replace(/%26/gi, \textcolor{charliteral}{'&'}).
             replace(/%3D/gi, \textcolor{charliteral}{'='}).
             replace(/%2B/gi, \textcolor{charliteral}{'+'});
\}


\textcolor{keyword}{function} encodeUriQuery(val, pctEncodeSpaces) \{
  \textcolor{keywordflow}{return} encodeURIComponent(val).
             replace(/%40/gi, \textcolor{charliteral}{'@'}).
             replace(/%3A/gi, \textcolor{charliteral}{':'}).
             replace(/%24/g, \textcolor{charliteral}{'$'}).
             replace(/%2C/gi, \textcolor{charliteral}{','}).
             replace(/%3B/gi, \textcolor{charliteral}{';'}).
             replace(/%20/g, (pctEncodeSpaces ? \textcolor{stringliteral}{'%20'} : \textcolor{charliteral}{'+'}));
\}

var ngAttrPrefixes = [\textcolor{stringliteral}{'ng-'}, \textcolor{stringliteral}{'data-ng-'}, \textcolor{stringliteral}{'ng:'}, \textcolor{stringliteral}{'x-ng-'}];

\textcolor{keyword}{function} getNgAttribute(element, ngAttr) \{
  var attr, i, ii = ngAttrPrefixes.length;
  \textcolor{keywordflow}{for} (i = 0; i < ii; ++i) \{
    attr = ngAttrPrefixes[i] + ngAttr;
    \textcolor{keywordflow}{if} (isString(attr = element.getAttribute(attr))) \{
      \textcolor{keywordflow}{return} attr;
    \}
  \}
  \textcolor{keywordflow}{return} null;
\}

\textcolor{keyword}{function} angularInit(element, bootstrap) \{
  var appElement,
      module,
      config = \{\};

  \textcolor{comment}{// The element `element` has priority over any other element}
  forEach(ngAttrPrefixes, \textcolor{keyword}{function}(prefix) \{
    var name = prefix + \textcolor{stringliteral}{'app'};

    \textcolor{keywordflow}{if} (!appElement && element.hasAttribute && element.hasAttribute(name)) \{
      appElement = element;
      module = element.getAttribute(name);
    \}
  \});
  forEach(ngAttrPrefixes, \textcolor{keyword}{function}(prefix) \{
    var name = prefix + \textcolor{stringliteral}{'app'};
    var candidate;

    \textcolor{keywordflow}{if} (!appElement && (candidate = element.querySelector(\textcolor{charliteral}{'['} + name.replace(\textcolor{charliteral}{':'}, \textcolor{stringliteral}{'\(\backslash\)\(\backslash\):'}) + \textcolor{charliteral}{']'}))) \{
      appElement = candidate;
      module = candidate.getAttribute(name);
    \}
  \});
  \textcolor{keywordflow}{if} (appElement) \{
    config.strictDi = getNgAttribute(appElement, \textcolor{stringliteral}{"strict-di"}) !== null;
    bootstrap(appElement, module ? [module] : [], config);
  \}
\}

\textcolor{keyword}{function} bootstrap(element, modules, config) \{
  \textcolor{keywordflow}{if} (!isObject(config)) config = \{\};
  var defaultConfig = \{
    strictDi: \textcolor{keyword}{false}
  \};
  config = extend(defaultConfig, config);
  var doBootstrap = \textcolor{keyword}{function}() \{
    element = jqLite(element);

    \textcolor{keywordflow}{if} (element.injector()) \{
      var tag = (element[0] === document) ? \textcolor{stringliteral}{'document'} : startingTag(element);
      \textcolor{comment}{//Encode angle brackets to prevent input from being sanitized to empty string #8683}
      \textcolor{keywordflow}{throw} ngMinErr(
          \textcolor{stringliteral}{'btstrpd'},
          \textcolor{stringliteral}{"App Already Bootstrapped with this Element '\{0\}'"},
          tag.replace(/</,\textcolor{stringliteral}{'&lt;'}).replace(/>/,\textcolor{stringliteral}{'&gt;'}));
    \}

    modules = modules || [];
    modules.unshift([\textcolor{stringliteral}{'$provide'}, \textcolor{keyword}{function}($provide) \{
      $provide.value(\textcolor{stringliteral}{'$rootElement'}, element);
    \}]);

    \textcolor{keywordflow}{if} (config.debugInfoEnabled) \{
      \textcolor{comment}{// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.}
      modules.push([\textcolor{stringliteral}{'$compileProvider'}, \textcolor{keyword}{function}($compileProvider) \{
        $compileProvider.debugInfoEnabled(\textcolor{keyword}{true});
      \}]);
    \}

    modules.unshift(\textcolor{stringliteral}{'ng'});
    var injector = createInjector(modules, config.strictDi);
    injector.invoke([\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$rootElement'}, \textcolor{stringliteral}{'$compile'}, \textcolor{stringliteral}{'$injector'},
       \textcolor{keyword}{function} bootstrapApply(scope, element, compile, injector) \{
        scope.$apply(\textcolor{keyword}{function}() \{
          element.data(\textcolor{stringliteral}{'$injector'}, injector);
          compile(element)(scope);
        \});
      \}]
    );
    \textcolor{keywordflow}{return} injector;
  \};

  var NG\_ENABLE\_DEBUG\_INFO = /^NG\_ENABLE\_DEBUG\_INFO!/;
  var NG\_DEFER\_BOOTSTRAP = /^NG\_DEFER\_BOOTSTRAP!/;

  \textcolor{keywordflow}{if} (window && NG\_ENABLE\_DEBUG\_INFO.test(window.name)) \{
    config.debugInfoEnabled = \textcolor{keyword}{true};
    window.name = window.name.replace(NG\_ENABLE\_DEBUG\_INFO, \textcolor{stringliteral}{''});
  \}

  \textcolor{keywordflow}{if} (window && !NG\_DEFER\_BOOTSTRAP.test(window.name)) \{
    \textcolor{keywordflow}{return} doBootstrap();
  \}

  window.name = window.name.replace(NG\_DEFER\_BOOTSTRAP, \textcolor{stringliteral}{''});
  angular.resumeBootstrap = \textcolor{keyword}{function}(extraModules) \{
    forEach(extraModules, \textcolor{keyword}{function}(module) \{
      modules.push(module);
    \});
    \textcolor{keywordflow}{return} doBootstrap();
  \};

  \textcolor{keywordflow}{if} (isFunction(angular.resumeDeferredBootstrap)) \{
    angular.resumeDeferredBootstrap();
  \}
\}

\textcolor{keyword}{function} reloadWithDebugInfo() \{
  window.name = \textcolor{stringliteral}{'NG\_ENABLE\_DEBUG\_INFO!'} + window.name;
  window.location.reload();
\}

\textcolor{keyword}{function} getTestability(rootElement) \{
  var injector = angular.element(rootElement).injector();
  \textcolor{keywordflow}{if} (!injector) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'test'},
      \textcolor{stringliteral}{'no injector found for element argument to getTestability'});
  \}
  \textcolor{keywordflow}{return} injector.get(\textcolor{stringliteral}{'$$testability'});
\}

var SNAKE\_CASE\_REGEXP = /[A-Z]/g;
\textcolor{keyword}{function} snake\_case(name, separator) \{
  separator = separator || \textcolor{charliteral}{'\_'};
  \textcolor{keywordflow}{return} name.replace(SNAKE\_CASE\_REGEXP, \textcolor{keyword}{function}(letter, pos) \{
    \textcolor{keywordflow}{return} (pos ? separator : \textcolor{stringliteral}{''}) + letter.toLowerCase();
  \});
\}

var bindJQueryFired = \textcolor{keyword}{false};
var skipDestroyOnNextJQueryCleanData;
\textcolor{keyword}{function} bindJQuery() \{
  var originalCleanData;

  \textcolor{keywordflow}{if} (bindJQueryFired) \{
    \textcolor{keywordflow}{return};
  \}

  \textcolor{comment}{// bind to jQuery if present;}
  var jqName = jq();
  jQuery = window.jQuery; \textcolor{comment}{// use default jQuery.}
  \textcolor{keywordflow}{if} (isDefined(jqName)) \{ \textcolor{comment}{// `ngJq` present}
    jQuery = jqName === null ? undefined : window[jqName]; \textcolor{comment}{// if empty; use jqLite. if not empty, use
       jQuery specified by `ngJq`.}
  \}

  \textcolor{comment}{// Use jQuery if it exists with proper functionality, otherwise default to us.}
  \textcolor{comment}{// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.}
  \textcolor{comment}{// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older}
  \textcolor{comment}{// versions. It will not work for sure with jQuery <1.7, though.}
  \textcolor{keywordflow}{if} (jQuery && jQuery.fn.on) \{
    jqLite = jQuery;
    extend(jQuery.fn, \{
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    \});

    \textcolor{comment}{// All nodes removed from the DOM via various jQuery APIs like .remove()}
    \textcolor{comment}{// are passed through jQuery.cleanData. Monkey-patch this method to fire}
    \textcolor{comment}{// the $destroy event on all removed nodes.}
    originalCleanData = jQuery.cleanData;
    jQuery.cleanData = \textcolor{keyword}{function}(elems) \{
      var events;
      \textcolor{keywordflow}{if} (!skipDestroyOnNextJQueryCleanData) \{
        \textcolor{keywordflow}{for} (var i = 0, elem; (elem = elems[i]) != null; i++) \{
          events = jQuery.\_data(elem, \textcolor{stringliteral}{"events"});
          \textcolor{keywordflow}{if} (events && events.$destroy) \{
            jQuery(elem).triggerHandler(\textcolor{stringliteral}{'$destroy'});
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        skipDestroyOnNextJQueryCleanData = \textcolor{keyword}{false};
      \}
      originalCleanData(elems);
    \};
  \} \textcolor{keywordflow}{else} \{
    jqLite = JQLite;
  \}

  angular.element = jqLite;

  \textcolor{comment}{// Prevent double-proxying.}
  bindJQueryFired = \textcolor{keyword}{true};
\}

\textcolor{keyword}{function} assertArg(arg, name, reason) \{
  \textcolor{keywordflow}{if} (!arg) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'areq'}, \textcolor{stringliteral}{"Argument '\{0\}' is \{1\}"}, (name || \textcolor{charliteral}{'?'}), (reason || \textcolor{stringliteral}{"required"}));
  \}
  \textcolor{keywordflow}{return} arg;
\}

\textcolor{keyword}{function} assertArgFn(arg, name, acceptArrayAnnotation) \{
  \textcolor{keywordflow}{if} (acceptArrayAnnotation && isArray(arg)) \{
      arg = arg[arg.length - 1];
  \}

  assertArg(isFunction(arg), name, \textcolor{stringliteral}{'not a function, got '} +
      (arg && typeof arg === \textcolor{stringliteral}{'object'} ? arg.constructor.name || \textcolor{stringliteral}{'Object'} : typeof arg));
  \textcolor{keywordflow}{return} arg;
\}

\textcolor{keyword}{function} assertNotHasOwnProperty(name, context) \{
  \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'hasOwnProperty'}) \{
    \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'badname'}, \textcolor{stringliteral}{"hasOwnProperty is not a valid \{0\} name"}, context);
  \}
\}

\textcolor{comment}{//TODO(misko): this function needs to be removed}
\textcolor{keyword}{function} getter(obj, path, bindFnToScope) \{
  \textcolor{keywordflow}{if} (!path) \textcolor{keywordflow}{return} obj;
  var keys = path.split(\textcolor{charliteral}{'.'});
  var key;
  var lastInstance = obj;
  var len = keys.length;

  \textcolor{keywordflow}{for} (var i = 0; i < len; i++) \{
    key = keys[i];
    \textcolor{keywordflow}{if} (obj) \{
      obj = (lastInstance = obj)[key];
    \}
  \}
  \textcolor{keywordflow}{if} (!bindFnToScope && isFunction(obj)) \{
    \textcolor{keywordflow}{return} bind(lastInstance, obj);
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{keyword}{function} getBlockNodes(nodes) \{
  \textcolor{comment}{// TODO(perf): just check if all items in `nodes` are siblings and if they are return the original}
  \textcolor{comment}{//             collection, otherwise update the original collection.}
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  \textcolor{keywordflow}{do} \{
    node = node.nextSibling;
    \textcolor{keywordflow}{if} (!node) \textcolor{keywordflow}{break};
    blockNodes.push(node);
  \} \textcolor{keywordflow}{while} (node !== endNode);

  \textcolor{keywordflow}{return} jqLite(blockNodes);
\}


\textcolor{keyword}{function} createMap() \{
  \textcolor{keywordflow}{return} Object.create(null);
\}

var NODE\_TYPE\_ELEMENT = 1;
var NODE\_TYPE\_ATTRIBUTE = 2;
var NODE\_TYPE\_TEXT = 3;
var NODE\_TYPE\_COMMENT = 8;
var NODE\_TYPE\_DOCUMENT = 9;
var NODE\_TYPE\_DOCUMENT\_FRAGMENT = 11;

\textcolor{keyword}{function} setupModuleLoader(window) \{

  var $injectorMinErr = minErr(\textcolor{stringliteral}{'$injector'});
  var ngMinErr = minErr(\textcolor{stringliteral}{'ng'});

  \textcolor{keyword}{function} ensure(obj, name, factory) \{
    \textcolor{keywordflow}{return} obj[name] || (obj[name] = factory());
  \}

  var angular = ensure(window, \textcolor{stringliteral}{'angular'}, Object);

  \textcolor{comment}{// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during
       bootstrap}
  angular.$$minErr = angular.$$minErr || minErr;

  \textcolor{keywordflow}{return} ensure(angular, \textcolor{stringliteral}{'module'}, \textcolor{keyword}{function}() \{
    var modules = \{\};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function} module(name, requires, configFn) \{
      var assertNotHasOwnProperty = \textcolor{keyword}{function}(name, context) \{
        \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'hasOwnProperty'}) \{
          \textcolor{keywordflow}{throw} ngMinErr(\textcolor{stringliteral}{'badname'}, \textcolor{stringliteral}{'hasOwnProperty is not a valid \{0\} name'}, context);
        \}
      \};

      assertNotHasOwnProperty(name, \textcolor{stringliteral}{'module'});
      \textcolor{keywordflow}{if} (requires && modules.hasOwnProperty(name)) \{
        modules[name] = null;
      \}
      \textcolor{keywordflow}{return} ensure(modules, name, \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!requires) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'nomod'}, \textcolor{stringliteral}{"Module '\{0\}' is not available! You either misspelled "} +
             \textcolor{stringliteral}{"the module name or forgot to load it. If registering a module ensure that you "} +
             \textcolor{stringliteral}{"specify the dependencies as the second argument."}, name);
        \}

        var invokeQueue = [];

        var configBlocks = [];

        var runBlocks = [];

        var config = invokeLater(\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'invoke'}, \textcolor{stringliteral}{'push'}, configBlocks);

        var moduleInstance = \{
          \textcolor{comment}{// Private state}
          \_invokeQueue: invokeQueue,
          \_configBlocks: configBlocks,
          \_runBlocks: runBlocks,

          requires: requires,

          name: name,


          provider: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'provider'}),

          factory: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'factory'}),

          service: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'service'}),

          value: invokeLater(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'value'}),

          constant: invokeLater(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'constant'}, \textcolor{stringliteral}{'unshift'}),

          decorator: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'decorator'}),

          animation: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$animateProvider'}, \textcolor{stringliteral}{'register'}),

          filter: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$filterProvider'}, \textcolor{stringliteral}{'register'}),

          controller: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$controllerProvider'}, \textcolor{stringliteral}{'register'}),

          directive: invokeLaterAndSetModuleName(\textcolor{stringliteral}{'$compileProvider'}, \textcolor{stringliteral}{'directive'}),

          config: config,

          run: \textcolor{keyword}{function}(block) \{
            runBlocks.push(block);
            \textcolor{keywordflow}{return} \textcolor{keyword}{this};
          \}
        \};

        \textcolor{keywordflow}{if} (configFn) \{
          config(configFn);
        \}

        \textcolor{keywordflow}{return} moduleInstance;

        \textcolor{keyword}{function} invokeLater(provider, method, insertMethod, queue) \{
          \textcolor{keywordflow}{if} (!queue) queue = invokeQueue;
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            queue[insertMethod || \textcolor{stringliteral}{'push'}]([provider, method, arguments]);
            \textcolor{keywordflow}{return} moduleInstance;
          \};
        \}

        \textcolor{keyword}{function} invokeLaterAndSetModuleName(provider, method) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}(recipeName, factoryFunction) \{
            \textcolor{keywordflow}{if} (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
            invokeQueue.push([provider, method, arguments]);
            \textcolor{keywordflow}{return} moduleInstance;
          \};
        \}
      \});
    \};
  \});

\}

\textcolor{comment}{/* global: toDebugString: true */}

\textcolor{keyword}{function} serializeObject(obj) \{
  var seen = [];

  \textcolor{keywordflow}{return} JSON.stringify(obj, \textcolor{keyword}{function}(key, val) \{
    val = toJsonReplacer(key, val);
    \textcolor{keywordflow}{if} (isObject(val)) \{

      \textcolor{keywordflow}{if} (seen.indexOf(val) >= 0) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'<<already seen>>'};

      seen.push(val);
    \}
    \textcolor{keywordflow}{return} val;
  \});
\}

\textcolor{keyword}{function} toDebugString(obj) \{
  \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'function'}) \{
    \textcolor{keywordflow}{return} obj.toString().replace(/ \(\backslash\)\{[\(\backslash\)s\(\backslash\)S]*$/, \textcolor{stringliteral}{''});
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj === \textcolor{stringliteral}{'undefined'}) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'undefined'};
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (typeof obj !== \textcolor{stringliteral}{'string'}) \{
    \textcolor{keywordflow}{return} serializeObject(obj);
  \}
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{comment}{/* global angularModule: true,}
\textcolor{comment}{  version: true,}
\textcolor{comment}{}
\textcolor{comment}{  $CompileProvider,}
\textcolor{comment}{}
\textcolor{comment}{  htmlAnchorDirective,}
\textcolor{comment}{  inputDirective,}
\textcolor{comment}{  inputDirective,}
\textcolor{comment}{  formDirective,}
\textcolor{comment}{  scriptDirective,}
\textcolor{comment}{  selectDirective,}
\textcolor{comment}{  styleDirective,}
\textcolor{comment}{  optionDirective,}
\textcolor{comment}{  ngBindDirective,}
\textcolor{comment}{  ngBindHtmlDirective,}
\textcolor{comment}{  ngBindTemplateDirective,}
\textcolor{comment}{  ngClassDirective,}
\textcolor{comment}{  ngClassEvenDirective,}
\textcolor{comment}{  ngClassOddDirective,}
\textcolor{comment}{  ngCloakDirective,}
\textcolor{comment}{  ngControllerDirective,}
\textcolor{comment}{  ngFormDirective,}
\textcolor{comment}{  ngHideDirective,}
\textcolor{comment}{  ngIfDirective,}
\textcolor{comment}{  ngIncludeDirective,}
\textcolor{comment}{  ngIncludeFillContentDirective,}
\textcolor{comment}{  ngInitDirective,}
\textcolor{comment}{  ngNonBindableDirective,}
\textcolor{comment}{  ngPluralizeDirective,}
\textcolor{comment}{  ngRepeatDirective,}
\textcolor{comment}{  ngShowDirective,}
\textcolor{comment}{  ngStyleDirective,}
\textcolor{comment}{  ngSwitchDirective,}
\textcolor{comment}{  ngSwitchWhenDirective,}
\textcolor{comment}{  ngSwitchDefaultDirective,}
\textcolor{comment}{  ngOptionsDirective,}
\textcolor{comment}{  ngTranscludeDirective,}
\textcolor{comment}{  ngModelDirective,}
\textcolor{comment}{  ngListDirective,}
\textcolor{comment}{  ngChangeDirective,}
\textcolor{comment}{  patternDirective,}
\textcolor{comment}{  patternDirective,}
\textcolor{comment}{  requiredDirective,}
\textcolor{comment}{  requiredDirective,}
\textcolor{comment}{  minlengthDirective,}
\textcolor{comment}{  minlengthDirective,}
\textcolor{comment}{  maxlengthDirective,}
\textcolor{comment}{  maxlengthDirective,}
\textcolor{comment}{  ngValueDirective,}
\textcolor{comment}{  ngModelOptionsDirective,}
\textcolor{comment}{  ngAttributeAliasDirectives,}
\textcolor{comment}{  ngEventDirectives,}
\textcolor{comment}{}
\textcolor{comment}{  $AnchorScrollProvider,}
\textcolor{comment}{  $AnimateProvider,}
\textcolor{comment}{  $CoreAnimateCssProvider,}
\textcolor{comment}{  $$CoreAnimateQueueProvider,}
\textcolor{comment}{  $$CoreAnimateRunnerProvider,}
\textcolor{comment}{  $BrowserProvider,}
\textcolor{comment}{  $CacheFactoryProvider,}
\textcolor{comment}{  $ControllerProvider,}
\textcolor{comment}{  $DocumentProvider,}
\textcolor{comment}{  $ExceptionHandlerProvider,}
\textcolor{comment}{  $FilterProvider,}
\textcolor{comment}{  $$ForceReflowProvider,}
\textcolor{comment}{  $InterpolateProvider,}
\textcolor{comment}{  $IntervalProvider,}
\textcolor{comment}{  $$HashMapProvider,}
\textcolor{comment}{  $HttpProvider,}
\textcolor{comment}{  $HttpParamSerializerProvider,}
\textcolor{comment}{  $HttpParamSerializerJQLikeProvider,}
\textcolor{comment}{  $HttpBackendProvider,}
\textcolor{comment}{  $LocationProvider,}
\textcolor{comment}{  $LogProvider,}
\textcolor{comment}{  $ParseProvider,}
\textcolor{comment}{  $RootScopeProvider,}
\textcolor{comment}{  $QProvider,}
\textcolor{comment}{  $$QProvider,}
\textcolor{comment}{  $$SanitizeUriProvider,}
\textcolor{comment}{  $SceProvider,}
\textcolor{comment}{  $SceDelegateProvider,}
\textcolor{comment}{  $SnifferProvider,}
\textcolor{comment}{  $TemplateCacheProvider,}
\textcolor{comment}{  $TemplateRequestProvider,}
\textcolor{comment}{  $$TestabilityProvider,}
\textcolor{comment}{  $TimeoutProvider,}
\textcolor{comment}{  $$RAFProvider,}
\textcolor{comment}{  $WindowProvider,}
\textcolor{comment}{  $$jqLiteProvider,}
\textcolor{comment}{  $$CookieReaderProvider}
\textcolor{comment}{*/}


var version = \{
  full: \textcolor{stringliteral}{'1.4.4'},    \textcolor{comment}{// all of these placeholder strings will be replaced by grunt's}
  major: 1,    \textcolor{comment}{// package task}
  minor: 4,
  dot: 4,
  codeName: \textcolor{stringliteral}{'pylon-requirement'}
\};


\textcolor{keyword}{function} publishExternalAPI(angular) \{
  extend(angular, \{
    \textcolor{stringliteral}{'bootstrap'}: bootstrap,
    \textcolor{stringliteral}{'copy'}: copy,
    \textcolor{stringliteral}{'extend'}: extend,
    \textcolor{stringliteral}{'merge'}: merge,
    \textcolor{stringliteral}{'equals'}: equals,
    \textcolor{stringliteral}{'element'}: jqLite,
    \textcolor{stringliteral}{'forEach'}: forEach,
    \textcolor{stringliteral}{'injector'}: createInjector,
    \textcolor{stringliteral}{'noop'}: noop,
    \textcolor{stringliteral}{'bind'}: bind,
    \textcolor{stringliteral}{'toJson'}: toJson,
    \textcolor{stringliteral}{'fromJson'}: fromJson,
    \textcolor{stringliteral}{'identity'}: identity,
    \textcolor{stringliteral}{'isUndefined'}: isUndefined,
    \textcolor{stringliteral}{'isDefined'}: isDefined,
    \textcolor{stringliteral}{'isString'}: isString,
    \textcolor{stringliteral}{'isFunction'}: isFunction,
    \textcolor{stringliteral}{'isObject'}: isObject,
    \textcolor{stringliteral}{'isNumber'}: isNumber,
    \textcolor{stringliteral}{'isElement'}: isElement,
    \textcolor{stringliteral}{'isArray'}: isArray,
    \textcolor{stringliteral}{'version'}: version,
    \textcolor{stringliteral}{'isDate'}: isDate,
    \textcolor{stringliteral}{'lowercase'}: lowercase,
    \textcolor{stringliteral}{'uppercase'}: uppercase,
    \textcolor{stringliteral}{'callbacks'}: \{counter: 0\},
    \textcolor{stringliteral}{'getTestability'}: getTestability,
    \textcolor{stringliteral}{'$$minErr'}: minErr,
    \textcolor{stringliteral}{'$$csp'}: csp,
    \textcolor{stringliteral}{'reloadWithDebugInfo'}: reloadWithDebugInfo
  \});

  angularModule = setupModuleLoader(window);

  angularModule(\textcolor{stringliteral}{'ng'}, [\textcolor{stringliteral}{'ngLocale'}], [\textcolor{stringliteral}{'$provide'},
    \textcolor{keyword}{function} ngModule($provide) \{
      \textcolor{comment}{// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.}
      $provide.provider(\{
        $$sanitizeUri: $$SanitizeUriProvider
      \});
      $provide.provider(\textcolor{stringliteral}{'$compile'}, $CompileProvider).
        directive(\{
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
        \}).
        directive(\{
          ngInclude: ngIncludeFillContentDirective
        \}).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider(\{
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $animateCss: $CoreAnimateCssProvider,
        $$animateQueue: $$CoreAnimateQueueProvider,
        $$AnimateRunner: $$CoreAnimateRunnerProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $$forceReflow: $$ForceReflowProvider,
        $interpolate: $InterpolateProvider,
        $interval: $IntervalProvider,
        $http: $HttpProvider,
        $httpParamSerializer: $HttpParamSerializerProvider,
        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $$q: $$QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $templateRequest: $TemplateRequestProvider,
        $$testability: $$TestabilityProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider,
        $$rAF: $$RAFProvider,
        $$jqLite: $$jqLiteProvider,
        $$HashMap: $$HashMapProvider,
        $$cookieReader: $$CookieReaderProvider
      \});
    \}
  ]);
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

\textcolor{comment}{/* global JQLitePrototype: true,}
\textcolor{comment}{  addEventListenerFn: true,}
\textcolor{comment}{  removeEventListenerFn: true,}
\textcolor{comment}{  BOOLEAN\_ATTR: true,}
\textcolor{comment}{  ALIASED\_ATTR: true,}
\textcolor{comment}{*/}

\textcolor{comment}{//JQLite}
\textcolor{comment}{}
JQLite.expando = \textcolor{stringliteral}{'ng339'};

var jqCache = JQLite.cache = \{\},
    jqId = 1,
    addEventListenerFn = \textcolor{keyword}{function}(element, type, fn) \{
      element.addEventListener(type, fn, \textcolor{keyword}{false});
    \},
    removeEventListenerFn = \textcolor{keyword}{function}(element, type, fn) \{
      element.removeEventListener(type, fn, \textcolor{keyword}{false});
    \};

\textcolor{comment}{/*}
\textcolor{comment}{ * !!! This is an undocumented "private" function !!!}
\textcolor{comment}{ */}
JQLite.\_data = \textcolor{keyword}{function}(node) \{
  \textcolor{comment}{//jQuery always returns an object on cache miss}
  \textcolor{keywordflow}{return} this.cache[node[this.expando]] || \{\};
\};

\textcolor{keyword}{function} jqNextId() \{ \textcolor{keywordflow}{return} ++jqId; \}


var SPECIAL\_CHARS\_REGEXP = /([\(\backslash\):\(\backslash\)-\(\backslash\)\_]+(.))/g;
var MOZ\_HACK\_REGEXP = /^moz([A-Z])/;
var MOUSE\_EVENT\_MAP= \{ mouseleave: \textcolor{stringliteral}{"mouseout"}, mouseenter: \textcolor{stringliteral}{"mouseover"}\};
var jqLiteMinErr = minErr(\textcolor{stringliteral}{'jqLite'});

\textcolor{keyword}{function} camelCase(name) \{
  \textcolor{keywordflow}{return} name.
    replace(SPECIAL\_CHARS\_REGEXP, \textcolor{keyword}{function}(\_, separator, letter, offset) \{
      \textcolor{keywordflow}{return} offset ? letter.toUpperCase() : letter;
    \}).
    replace(MOZ\_HACK\_REGEXP, \textcolor{stringliteral}{'Moz$1'});
\}

var SINGLE\_TAG\_REGEXP = /^<(\(\backslash\)w+)\(\backslash\)s*\(\backslash\)/?>(?:<\(\backslash\)/\(\backslash\)1>|)$/;
var HTML\_REGEXP = /<|&#?\(\backslash\)w+;/;
var TAG\_NAME\_REGEXP = /<([\(\backslash\)w:]+)/;
var XHTML\_TAG\_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\(\backslash\)w:]+)[^>]*)\(\backslash\)/>/gi;

var wrapMap = \{
  \textcolor{stringliteral}{'option'}: [1, \textcolor{stringliteral}{'<select multiple="multiple">'}, \textcolor{stringliteral}{'</select>'}],

  \textcolor{stringliteral}{'thead'}: [1, \textcolor{stringliteral}{'<table>'}, \textcolor{stringliteral}{'</table>'}],
  \textcolor{stringliteral}{'col'}: [2, \textcolor{stringliteral}{'<table><colgroup>'}, \textcolor{stringliteral}{'</colgroup></table>'}],
  \textcolor{stringliteral}{'tr'}: [2, \textcolor{stringliteral}{'<table><tbody>'}, \textcolor{stringliteral}{'</tbody></table>'}],
  \textcolor{stringliteral}{'td'}: [3, \textcolor{stringliteral}{'<table><tbody><tr>'}, \textcolor{stringliteral}{'</tr></tbody></table>'}],
  \textcolor{stringliteral}{'\_default'}: [0, \textcolor{stringliteral}{""}, \textcolor{stringliteral}{""}]
\};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


\textcolor{keyword}{function} jqLiteIsTextNode(html) \{
  \textcolor{keywordflow}{return} !HTML\_REGEXP.test(html);
\}

\textcolor{keyword}{function} jqLiteAcceptsData(node) \{
  \textcolor{comment}{// The window object can accept data but has no nodeType}
  \textcolor{comment}{// Otherwise we are only interested in elements (1) and documents (9)}
  var nodeType = node.nodeType;
  \textcolor{keywordflow}{return} nodeType === NODE\_TYPE\_ELEMENT || !nodeType || nodeType === NODE\_TYPE\_DOCUMENT;
\}

\textcolor{keyword}{function} jqLiteHasData(node) \{
  \textcolor{keywordflow}{for} (var key in jqCache[node.ng339]) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{false};
\}

\textcolor{keyword}{function} jqLiteBuildFragment(html, context) \{
  var tmp, tag, wrap,
      fragment = context.createDocumentFragment(),
      nodes = [], i;

  \textcolor{keywordflow}{if} (jqLiteIsTextNode(html)) \{
    \textcolor{comment}{// Convert non-html into a text node}
    nodes.push(context.createTextNode(html));
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// Convert html into DOM nodes}
    tmp = tmp || fragment.appendChild(context.createElement(\textcolor{stringliteral}{"div"}));
    tag = (TAG\_NAME\_REGEXP.exec(html) || [\textcolor{stringliteral}{""}, \textcolor{stringliteral}{""}])[1].toLowerCase();
    wrap = wrapMap[tag] || wrapMap.\_default;
    tmp.innerHTML = wrap[1] + html.replace(XHTML\_TAG\_REGEXP, \textcolor{stringliteral}{"<$1></$2>"}) + wrap[2];

    \textcolor{comment}{// Descend through wrappers to the right content}
    i = wrap[0];
    \textcolor{keywordflow}{while} (i--) \{
      tmp = tmp.lastChild;
    \}

    nodes = concat(nodes, tmp.childNodes);

    tmp = fragment.firstChild;
    tmp.textContent = \textcolor{stringliteral}{""};
  \}

  \textcolor{comment}{// Remove wrapper from fragment}
  fragment.textContent = \textcolor{stringliteral}{""};
  fragment.innerHTML = \textcolor{stringliteral}{""}; \textcolor{comment}{// Clear inner HTML}
  forEach(nodes, \textcolor{keyword}{function}(node) \{
    fragment.appendChild(node);
  \});

  \textcolor{keywordflow}{return} fragment;
\}

\textcolor{keyword}{function} jqLiteParseHTML(html, context) \{
  context = context || document;
  var parsed;

  \textcolor{keywordflow}{if} ((parsed = SINGLE\_TAG\_REGEXP.exec(html))) \{
    \textcolor{keywordflow}{return} [context.createElement(parsed[1])];
  \}

  \textcolor{keywordflow}{if} ((parsed = jqLiteBuildFragment(html, context))) \{
    \textcolor{keywordflow}{return} parsed.childNodes;
  \}

  \textcolor{keywordflow}{return} [];
\}

\textcolor{keyword}{function} JQLite(element) \{
  \textcolor{keywordflow}{if} (element instanceof JQLite) \{
    \textcolor{keywordflow}{return} element;
  \}

  var argIsString;

  \textcolor{keywordflow}{if} (isString(element)) \{
    element = trim(element);
    argIsString = \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{if} (!(\textcolor{keyword}{this} instanceof JQLite)) \{
    \textcolor{keywordflow}{if} (argIsString && element.charAt(0) != \textcolor{charliteral}{'<'}) \{
      \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'nosel'}, \textcolor{stringliteral}{'Looking up elements via selectors is not supported by jqLite! See:
       http://docs.angularjs.org/api/angular.element'});
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} JQLite(element);
  \}

  \textcolor{keywordflow}{if} (argIsString) \{
    jqLiteAddNodes(\textcolor{keyword}{this}, jqLiteParseHTML(element));
  \} \textcolor{keywordflow}{else} \{
    jqLiteAddNodes(\textcolor{keyword}{this}, element);
  \}
\}

\textcolor{keyword}{function} jqLiteClone(element) \{
  \textcolor{keywordflow}{return} element.cloneNode(\textcolor{keyword}{true});
\}

\textcolor{keyword}{function} jqLiteDealoc(element, onlyDescendants) \{
  \textcolor{keywordflow}{if} (!onlyDescendants) jqLiteRemoveData(element);

  \textcolor{keywordflow}{if} (element.querySelectorAll) \{
    var descendants = element.querySelectorAll(\textcolor{charliteral}{'*'});
    \textcolor{keywordflow}{for} (var i = 0, l = descendants.length; i < l; i++) \{
      jqLiteRemoveData(descendants[i]);
    \}
  \}
\}

\textcolor{keyword}{function} jqLiteOff(element, type, fn, unsupported) \{
  \textcolor{keywordflow}{if} (isDefined(unsupported)) \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'offargs'}, \textcolor{stringliteral}{'jqLite#off() does not support the `selector`
       argument'});

  var expandoStore = jqLiteExpandoStore(element);
  var events = expandoStore && expandoStore.events;
  var handle = expandoStore && expandoStore.handle;

  \textcolor{keywordflow}{if} (!handle) \textcolor{keywordflow}{return}; \textcolor{comment}{//no listeners registered}

  \textcolor{keywordflow}{if} (!type) \{
    \textcolor{keywordflow}{for} (type in events) \{
      \textcolor{keywordflow}{if} (type !== \textcolor{stringliteral}{'$destroy'}) \{
        removeEventListenerFn(element, type, handle);
      \}
      \textcolor{keyword}{delete} events[type];
    \}
  \} \textcolor{keywordflow}{else} \{
    forEach(type.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(type) \{
      \textcolor{keywordflow}{if} (isDefined(fn)) \{
        var listenerFns = events[type];
        arrayRemove(listenerFns || [], fn);
        \textcolor{keywordflow}{if} (listenerFns && listenerFns.length > 0) \{
          \textcolor{keywordflow}{return};
        \}
      \}

      removeEventListenerFn(element, type, handle);
      \textcolor{keyword}{delete} events[type];
    \});
  \}
\}

\textcolor{keyword}{function} jqLiteRemoveData(element, name) \{
  var expandoId = element.ng339;
  var expandoStore = expandoId && jqCache[expandoId];

  \textcolor{keywordflow}{if} (expandoStore) \{
    \textcolor{keywordflow}{if} (name) \{
      \textcolor{keyword}{delete} expandoStore.data[name];
      \textcolor{keywordflow}{return};
    \}

    \textcolor{keywordflow}{if} (expandoStore.handle) \{
      \textcolor{keywordflow}{if} (expandoStore.events.$destroy) \{
        expandoStore.handle(\{\}, \textcolor{stringliteral}{'$destroy'});
      \}
      jqLiteOff(element);
    \}
    \textcolor{keyword}{delete} jqCache[expandoId];
    element.ng339 = undefined; \textcolor{comment}{// don't delete DOM expandos. IE and Chrome don't like it}
  \}
\}


\textcolor{keyword}{function} jqLiteExpandoStore(element, createIfNecessary) \{
  var expandoId = element.ng339,
      expandoStore = expandoId && jqCache[expandoId];

  \textcolor{keywordflow}{if} (createIfNecessary && !expandoStore) \{
    element.ng339 = expandoId = jqNextId();
    expandoStore = jqCache[expandoId] = \{events: \{\}, data: \{\}, handle: undefined\};
  \}

  \textcolor{keywordflow}{return} expandoStore;
\}


\textcolor{keyword}{function} jqLiteData(element, key, value) \{
  \textcolor{keywordflow}{if} (jqLiteAcceptsData(element)) \{

    var isSimpleSetter = isDefined(value);
    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
    var massGetter = !key;
    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
    var data = expandoStore && expandoStore.data;

    \textcolor{keywordflow}{if} (isSimpleSetter) \{ \textcolor{comment}{// data('key', value)}
      data[key] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (massGetter) \{  \textcolor{comment}{// data()}
        \textcolor{keywordflow}{return} data;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (isSimpleGetter) \{ \textcolor{comment}{// data('key')}
          \textcolor{comment}{// don't force creation of expandoStore if it doesn't exist yet}
          \textcolor{keywordflow}{return} data && data[key];
        \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// mass-setter: data(\{key1: val1, key2: val2\})}
          extend(data, key);
        \}
      \}
    \}
  \}
\}

\textcolor{keyword}{function} jqLiteHasClass(element, selector) \{
  \textcolor{keywordflow}{if} (!element.getAttribute) \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \textcolor{keywordflow}{return} ((\textcolor{stringliteral}{" "} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{stringliteral}{" "}).replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "}).
      indexOf(\textcolor{stringliteral}{" "} + selector + \textcolor{stringliteral}{" "}) > -1);
\}

\textcolor{keyword}{function} jqLiteRemoveClass(element, cssClasses) \{
  \textcolor{keywordflow}{if} (cssClasses && element.setAttribute) \{
    forEach(cssClasses.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(cssClass) \{
      element.setAttribute(\textcolor{stringliteral}{'class'}, trim(
          (\textcolor{stringliteral}{" "} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{stringliteral}{" "})
          .replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "})
          .replace(\textcolor{stringliteral}{" "} + trim(cssClass) + \textcolor{stringliteral}{" "}, \textcolor{stringliteral}{" "}))
      );
    \});
  \}
\}

\textcolor{keyword}{function} jqLiteAddClass(element, cssClasses) \{
  \textcolor{keywordflow}{if} (cssClasses && element.setAttribute) \{
    var existingClasses = (\textcolor{charliteral}{' '} + (element.getAttribute(\textcolor{stringliteral}{'class'}) || \textcolor{stringliteral}{''}) + \textcolor{charliteral}{' '})
                            .replace(/[\(\backslash\)n\(\backslash\)t]/g, \textcolor{stringliteral}{" "});

    forEach(cssClasses.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(cssClass) \{
      cssClass = trim(cssClass);
      \textcolor{keywordflow}{if} (existingClasses.indexOf(\textcolor{charliteral}{' '} + cssClass + \textcolor{charliteral}{' '}) === -1) \{
        existingClasses += cssClass + \textcolor{charliteral}{' '};
      \}
    \});

    element.setAttribute(\textcolor{stringliteral}{'class'}, trim(existingClasses));
  \}
\}


\textcolor{keyword}{function} jqLiteAddNodes(root, elements) \{
  \textcolor{comment}{// THIS CODE IS VERY HOT. Don't make changes without benchmarking.}

  \textcolor{keywordflow}{if} (elements) \{

    \textcolor{comment}{// if a Node (the most common case)}
    \textcolor{keywordflow}{if} (elements.nodeType) \{
      root[root.length++] = elements;
    \} \textcolor{keywordflow}{else} \{
      var length = elements.length;

      \textcolor{comment}{// if an Array or NodeList and not a Window}
      \textcolor{keywordflow}{if} (typeof length === \textcolor{stringliteral}{'number'} && elements.window !== elements) \{
        \textcolor{keywordflow}{if} (length) \{
          \textcolor{keywordflow}{for} (var i = 0; i < length; i++) \{
            root[root.length++] = elements[i];
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        root[root.length++] = elements;
      \}
    \}
  \}
\}


\textcolor{keyword}{function} jqLiteController(element, name) \{
  \textcolor{keywordflow}{return} jqLiteInheritedData(element, \textcolor{charliteral}{'$'} + (name || \textcolor{stringliteral}{'ngController'}) + \textcolor{stringliteral}{'Controller'});
\}

\textcolor{keyword}{function} jqLiteInheritedData(element, name, value) \{
  \textcolor{comment}{// if element is the document object work with the html element instead}
  \textcolor{comment}{// this makes $(document).scope() possible}
  \textcolor{keywordflow}{if} (element.nodeType == NODE\_TYPE\_DOCUMENT) \{
    element = element.documentElement;
  \}
  var names = isArray(name) ? name : [name];

  \textcolor{keywordflow}{while} (element) \{
    \textcolor{keywordflow}{for} (var i = 0, ii = names.length; i < ii; i++) \{
      \textcolor{keywordflow}{if} ((value = jqLite.data(element, names[i])) !== undefined) \textcolor{keywordflow}{return} value;
    \}

    \textcolor{comment}{// If dealing with a document fragment node with a host element, and no parent, use the host}
    \textcolor{comment}{// element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM}
    \textcolor{comment}{// to lookup parent controllers.}
    element = element.parentNode || (element.nodeType === NODE\_TYPE\_DOCUMENT\_FRAGMENT && element.host);
  \}
\}

\textcolor{keyword}{function} jqLiteEmpty(element) \{
  jqLiteDealoc(element, \textcolor{keyword}{true});
  \textcolor{keywordflow}{while} (element.firstChild) \{
    element.removeChild(element.firstChild);
  \}
\}

\textcolor{keyword}{function} jqLiteRemove(element, keepData) \{
  \textcolor{keywordflow}{if} (!keepData) jqLiteDealoc(element);
  var parent = element.parentNode;
  \textcolor{keywordflow}{if} (parent) parent.removeChild(element);
\}


\textcolor{keyword}{function} jqLiteDocumentLoaded(action, win) \{
  win = win || window;
  \textcolor{keywordflow}{if} (win.document.readyState === \textcolor{stringliteral}{'complete'}) \{
    \textcolor{comment}{// Force the action to be run async for consistent behaviour}
    \textcolor{comment}{// from the action's point of view}
    \textcolor{comment}{// i.e. it will definitely not be in a $apply}
    win.setTimeout(action);
  \} \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// No need to unbind this handler as load is only ever called once}
    jqLite(win).on(\textcolor{stringliteral}{'load'}, action);
  \}
\}

\textcolor{comment}{// Functions which are declared directly.}
\textcolor{comment}{}var JQLitePrototype = JQLite.prototype = \{
  ready: \textcolor{keyword}{function}(fn) \{
    var fired = \textcolor{keyword}{false};

    \textcolor{keyword}{function} trigger() \{
      \textcolor{keywordflow}{if} (fired) \textcolor{keywordflow}{return};
      fired = \textcolor{keyword}{true};
      fn();
    \}

    \textcolor{comment}{// check if document is already loaded}
    \textcolor{keywordflow}{if} (document.readyState === \textcolor{stringliteral}{'complete'}) \{
      setTimeout(trigger);
    \} \textcolor{keywordflow}{else} \{
      this.on(\textcolor{stringliteral}{'DOMContentLoaded'}, trigger); \textcolor{comment}{// works for modern browsers and IE9}
      \textcolor{comment}{// we can not use jqLite since we are not done loading and jQuery could be loaded later.}
      \textcolor{comment}{// jshint -W064}
      JQLite(window).on(\textcolor{stringliteral}{'load'}, trigger); \textcolor{comment}{// fallback to window.onload for others}
      \textcolor{comment}{// jshint +W064}
    \}
  \},
  toString: \textcolor{keyword}{function}() \{
    var value = [];
    forEach(\textcolor{keyword}{this}, \textcolor{keyword}{function}(e) \{ value.push(\textcolor{stringliteral}{''} + e);\});
    \textcolor{keywordflow}{return} \textcolor{charliteral}{'['} + value.join(\textcolor{stringliteral}{', '}) + \textcolor{charliteral}{']'};
  \},

  eq: \textcolor{keyword}{function}(index) \{
      \textcolor{keywordflow}{return} (index >= 0) ? jqLite(\textcolor{keyword}{this}[index]) : jqLite(\textcolor{keyword}{this}[this.length + index]);
  \},

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
\};

\textcolor{comment}{// Functions iterating getter/setters.}
\textcolor{comment}{// these functions return self on setter and}
\textcolor{comment}{// value on get.}
\textcolor{comment}{}var BOOLEAN\_ATTR = \{\};
forEach(\textcolor{stringliteral}{'multiple,selected,checked,disabled,readOnly,required,open'}.split(\textcolor{charliteral}{','}), \textcolor{keyword}{function}(value) \{
  BOOLEAN\_ATTR[lowercase(value)] = value;
\});
var BOOLEAN\_ELEMENTS = \{\};
forEach(\textcolor{stringliteral}{'input,select,option,textarea,button,form,details'}.split(\textcolor{charliteral}{','}), \textcolor{keyword}{function}(value) \{
  BOOLEAN\_ELEMENTS[value] = \textcolor{keyword}{true};
\});
var ALIASED\_ATTR = \{
  \textcolor{stringliteral}{'ngMinlength'}: \textcolor{stringliteral}{'minlength'},
  \textcolor{stringliteral}{'ngMaxlength'}: \textcolor{stringliteral}{'maxlength'},
  \textcolor{stringliteral}{'ngMin'}: \textcolor{stringliteral}{'min'},
  \textcolor{stringliteral}{'ngMax'}: \textcolor{stringliteral}{'max'},
  \textcolor{stringliteral}{'ngPattern'}: \textcolor{stringliteral}{'pattern'}
\};

\textcolor{keyword}{function} getBooleanAttrName(element, name) \{
  \textcolor{comment}{// check dom last since we will most likely fail on name}
  var booleanAttr = BOOLEAN\_ATTR[name.toLowerCase()];

  \textcolor{comment}{// booleanAttr is here twice to minimize DOM access}
  \textcolor{keywordflow}{return} booleanAttr && BOOLEAN\_ELEMENTS[nodeName\_(element)] && booleanAttr;
\}

\textcolor{keyword}{function} getAliasedAttrName(element, name) \{
  var nodeName = element.nodeName;
  \textcolor{keywordflow}{return} (nodeName === \textcolor{stringliteral}{'INPUT'} || nodeName === \textcolor{stringliteral}{'TEXTAREA'}) && ALIASED\_ATTR[name];
\}

forEach(\{
  data: jqLiteData,
  removeData: jqLiteRemoveData,
  hasData: jqLiteHasData
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite[name] = fn;
\});

forEach(\{
  data: jqLiteData,
  inheritedData: jqLiteInheritedData,

  scope: \textcolor{keyword}{function}(element) \{
    \textcolor{comment}{// Can't use jqLiteData here directly so we stay compatible with jQuery!}
    \textcolor{keywordflow}{return} jqLite.data(element, \textcolor{stringliteral}{'$scope'}) || jqLiteInheritedData(element.parentNode || element, [\textcolor{stringliteral}{'
      $isolateScope'}, \textcolor{stringliteral}{'$scope'}]);
  \},

  isolateScope: \textcolor{keyword}{function}(element) \{
    \textcolor{comment}{// Can't use jqLiteData here directly so we stay compatible with jQuery!}
    \textcolor{keywordflow}{return} jqLite.data(element, \textcolor{stringliteral}{'$isolateScope'}) || jqLite.data(element, \textcolor{stringliteral}{'$isolateScopeNoTemplate'});
  \},

  controller: jqLiteController,

  injector: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} jqLiteInheritedData(element, \textcolor{stringliteral}{'$injector'});
  \},

  removeAttr: \textcolor{keyword}{function}(element, name) \{
    element.removeAttribute(name);
  \},

  hasClass: jqLiteHasClass,

  css: \textcolor{keyword}{function}(element, name, value) \{
    name = camelCase(name);

    \textcolor{keywordflow}{if} (isDefined(value)) \{
      element.style[name] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} element.style[name];
    \}
  \},

  attr: \textcolor{keyword}{function}(element, name, value) \{
    var nodeType = element.nodeType;
    \textcolor{keywordflow}{if} (nodeType === NODE\_TYPE\_TEXT || nodeType === NODE\_TYPE\_ATTRIBUTE || nodeType === NODE\_TYPE\_COMMENT) 
      \{
      \textcolor{keywordflow}{return};
    \}
    var lowercasedName = lowercase(name);
    \textcolor{keywordflow}{if} (BOOLEAN\_ATTR[lowercasedName]) \{
      \textcolor{keywordflow}{if} (isDefined(value)) \{
        \textcolor{keywordflow}{if} (!!value) \{
          element[name] = \textcolor{keyword}{true};
          element.setAttribute(name, lowercasedName);
        \} \textcolor{keywordflow}{else} \{
          element[name] = \textcolor{keyword}{false};
          element.removeAttribute(lowercasedName);
        \}
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} (element[name] ||
                 (element.attributes.getNamedItem(name) || noop).specified)
               ? lowercasedName
               : undefined;
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isDefined(value)) \{
      element.setAttribute(name, value);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (element.getAttribute) \{
      \textcolor{comment}{// the extra argument "2" is to get the right thing for a.href in IE, see jQuery code}
      \textcolor{comment}{// some elements (e.g. Document) don't have get attribute, so return undefined}
      var ret = element.getAttribute(name, 2);
      \textcolor{comment}{// normalize non-existing attributes to undefined (as jQuery)}
      \textcolor{keywordflow}{return} ret === null ? undefined : ret;
    \}
  \},

  prop: \textcolor{keyword}{function}(element, name, value) \{
    \textcolor{keywordflow}{if} (isDefined(value)) \{
      element[name] = value;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} element[name];
    \}
  \},

  text: (\textcolor{keyword}{function}() \{
    getText.$dv = \textcolor{stringliteral}{''};
    \textcolor{keywordflow}{return} getText;

    \textcolor{keyword}{function} getText(element, value) \{
      \textcolor{keywordflow}{if} (isUndefined(value)) \{
        var nodeType = element.nodeType;
        \textcolor{keywordflow}{return} (nodeType === NODE\_TYPE\_ELEMENT || nodeType === NODE\_TYPE\_TEXT) ? element.textContent : \textcolor{stringliteral}{''};
      \}
      element.textContent = value;
    \}
  \})(),

  val: \textcolor{keyword}{function}(element, value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{if} (element.multiple && nodeName\_(element) === \textcolor{stringliteral}{'select'}) \{
        var result = [];
        forEach(element.options, \textcolor{keyword}{function}(option) \{
          if (option.selected) \{
            result.push(option.value || option.text);
          \}
        \});
        \textcolor{keywordflow}{return} result.length === 0 ? null : result;
      \}
      \textcolor{keywordflow}{return} element.value;
    \}
    element.value = value;
  \},

  html: \textcolor{keyword}{function}(element, value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{return} element.innerHTML;
    \}
    jqLiteDealoc(element, \textcolor{keyword}{true});
    element.innerHTML = value;
  \},

  empty: jqLiteEmpty
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite.prototype[name] = \textcolor{keyword}{function}(arg1, arg2) \{
    var i, key;
    var nodeCount = this.length;

    \textcolor{comment}{// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it}
    \textcolor{comment}{// in a way that survives minification.}
    \textcolor{comment}{// jqLiteEmpty takes no arguments but is a setter.}
    \textcolor{keywordflow}{if} (fn !== jqLiteEmpty &&
        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === 
      undefined)) \{
      \textcolor{keywordflow}{if} (isObject(arg1)) \{

        \textcolor{comment}{// we are a write, but the object properties are the key/values}
        \textcolor{keywordflow}{for} (i = 0; i < nodeCount; i++) \{
          \textcolor{keywordflow}{if} (fn === jqLiteData) \{
            \textcolor{comment}{// data() takes the whole object in jQuery}
            fn(\textcolor{keyword}{this}[i], arg1);
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{for} (key in arg1) \{
              fn(\textcolor{keyword}{this}[i], key, arg1[key]);
            \}
          \}
        \}
        \textcolor{comment}{// return self for chaining}
        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// we are a read, so read the first child.}
        \textcolor{comment}{// TODO: do we still need this?}
        var value = fn.$dv;
        \textcolor{comment}{// Only if we have $dv do we iterate over all, otherwise it is just the first element.}
        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
        \textcolor{keywordflow}{for} (var j = 0; j < jj; j++) \{
          var nodeValue = fn(\textcolor{keyword}{this}[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        \}
        \textcolor{keywordflow}{return} value;
      \}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// we are a write, so apply to all children}
      \textcolor{keywordflow}{for} (i = 0; i < nodeCount; i++) \{
        fn(\textcolor{keyword}{this}[i], arg1, arg2);
      \}
      \textcolor{comment}{// return self for chaining}
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
  \};
\});

\textcolor{keyword}{function} createEventHandler(element, events) \{
  var eventHandler = \textcolor{keyword}{function}(event, type) \{
    \textcolor{comment}{// jQuery specific api}
    \textcolor{keyword}{event}.isDefaultPrevented = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{event}.defaultPrevented;
    \};

    var eventFns = events[type || \textcolor{keyword}{event}.type];
    var eventFnsLength = eventFns ? eventFns.length : 0;

    \textcolor{keywordflow}{if} (!eventFnsLength) \textcolor{keywordflow}{return};

    \textcolor{keywordflow}{if} (isUndefined(event.immediatePropagationStopped)) \{
      var originalStopImmediatePropagation = \textcolor{keyword}{event}.stopImmediatePropagation;
      \textcolor{keyword}{event}.stopImmediatePropagation = \textcolor{keyword}{function}() \{
        \textcolor{keyword}{event}.immediatePropagationStopped = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (event.stopPropagation) \{
          \textcolor{keyword}{event}.stopPropagation();
        \}

        \textcolor{keywordflow}{if} (originalStopImmediatePropagation) \{
          originalStopImmediatePropagation.call(event);
        \}
      \};
    \}

    \textcolor{keyword}{event}.isImmediatePropagationStopped = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{event}.immediatePropagationStopped === \textcolor{keyword}{true};
    \};

    \textcolor{comment}{// Copy event handlers in case event handlers array is modified during execution.}
    \textcolor{keywordflow}{if} ((eventFnsLength > 1)) \{
      eventFns = shallowCopy(eventFns);
    \}

    \textcolor{keywordflow}{for} (var i = 0; i < eventFnsLength; i++) \{
      \textcolor{keywordflow}{if} (!event.isImmediatePropagationStopped()) \{
        eventFns[i].call(element, event);
      \}
    \}
  \};

  \textcolor{comment}{// TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all}
  \textcolor{comment}{//       events on `element`}
  eventHandler.elem = element;
  \textcolor{keywordflow}{return} eventHandler;
\}

\textcolor{comment}{// Functions iterating traversal.}
\textcolor{comment}{// These functions chain results into a single}
\textcolor{comment}{// selector.}
\textcolor{comment}{}forEach(\{
  removeData: jqLiteRemoveData,

  on: \textcolor{keyword}{function} jqLiteOn(element, type, fn, unsupported) \{
    \textcolor{keywordflow}{if} (isDefined(unsupported)) \textcolor{keywordflow}{throw} jqLiteMinErr(\textcolor{stringliteral}{'onargs'}, \textcolor{stringliteral}{'jqLite#on() does not support the `selector`
       or `eventData` parameters'});

    \textcolor{comment}{// Do not add event handlers to non-elements because they will not be cleaned up.}
    \textcolor{keywordflow}{if} (!jqLiteAcceptsData(element)) \{
      \textcolor{keywordflow}{return};
    \}

    var expandoStore = jqLiteExpandoStore(element, \textcolor{keyword}{true});
    var events = expandoStore.events;
    var handle = expandoStore.handle;

    \textcolor{keywordflow}{if} (!handle) \{
      handle = expandoStore.handle = createEventHandler(element, events);
    \}

    \textcolor{comment}{// http://jsperf.com/string-indexof-vs-split}
    var types = type.indexOf(\textcolor{charliteral}{' '}) >= 0 ? type.split(\textcolor{charliteral}{' '}) : [type];
    var i = types.length;

    \textcolor{keywordflow}{while} (i--) \{
      type = types[i];
      var eventFns = events[type];

      \textcolor{keywordflow}{if} (!eventFns) \{
        events[type] = [];

        \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'mouseenter'} || type === \textcolor{stringliteral}{'mouseleave'}) \{
          \textcolor{comment}{// Refer to jQuery's implementation of mouseenter & mouseleave}
          \textcolor{comment}{// Read about mouseenter and mouseleave:}
          \textcolor{comment}{// http://www.quirksmode.org/js/events\_mouse.html#link8}

          jqLiteOn(element, MOUSE\_EVENT\_MAP[type], \textcolor{keyword}{function}(event) \{
            var target = \textcolor{keyword}{this}, related = \textcolor{keyword}{event}.relatedTarget;
            \textcolor{comment}{// For mousenter/leave call the handler if related is outside the target.}
            \textcolor{comment}{// NB: No relatedTarget if the mouse left/entered the browser window}
            \textcolor{keywordflow}{if} (!related || (related !== target && !target.contains(related))) \{
              handle(event, type);
            \}
          \});

        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (type !== \textcolor{stringliteral}{'$destroy'}) \{
            addEventListenerFn(element, type, handle);
          \}
        \}
        eventFns = events[type];
      \}
      eventFns.push(fn);
    \}
  \},

  off: jqLiteOff,

  one: \textcolor{keyword}{function}(element, type, fn) \{
    element = jqLite(element);

    \textcolor{comment}{//add the listener twice so that when it is called}
    \textcolor{comment}{//you can remove the original function and still be}
    \textcolor{comment}{//able to call element.off(ev, fn) normally}
    element.on(type, \textcolor{keyword}{function} onFn() \{
      element.off(type, fn);
      element.off(type, onFn);
    \});
    element.on(type, fn);
  \},

  replaceWith: \textcolor{keyword}{function}(element, replaceNode) \{
    var index, parent = element.parentNode;
    jqLiteDealoc(element);
    forEach(\textcolor{keyword}{new} JQLite(replaceNode), \textcolor{keyword}{function}(node) \{
      \textcolor{keywordflow}{if} (index) \{
        parent.insertBefore(node, index.nextSibling);
      \} \textcolor{keywordflow}{else} \{
        parent.replaceChild(node, element);
      \}
      index = node;
    \});
  \},

  children: \textcolor{keyword}{function}(element) \{
    var children = [];
    forEach(element.childNodes, \textcolor{keyword}{function}(element) \{
      if (element.nodeType === NODE\_TYPE\_ELEMENT) \{
        children.push(element);
      \}
    \});
    \textcolor{keywordflow}{return} children;
  \},

  contents: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} element.contentDocument || element.childNodes || [];
  \},

  append: \textcolor{keyword}{function}(element, node) \{
    var nodeType = element.nodeType;
    \textcolor{keywordflow}{if} (nodeType !== NODE\_TYPE\_ELEMENT && nodeType !== NODE\_TYPE\_DOCUMENT\_FRAGMENT) \textcolor{keywordflow}{return};

    node = \textcolor{keyword}{new} JQLite(node);

    \textcolor{keywordflow}{for} (var i = 0, ii = node.length; i < ii; i++) \{
      var child = node[i];
      element.appendChild(child);
    \}
  \},

  prepend: \textcolor{keyword}{function}(element, node) \{
    \textcolor{keywordflow}{if} (element.nodeType === NODE\_TYPE\_ELEMENT) \{
      var index = element.firstChild;
      forEach(\textcolor{keyword}{new} JQLite(node), \textcolor{keyword}{function}(child) \{
        element.insertBefore(child, index);
      \});
    \}
  \},

  wrap: \textcolor{keyword}{function}(element, wrapNode) \{
    wrapNode = jqLite(wrapNode).eq(0).clone()[0];
    var parent = element.parentNode;
    \textcolor{keywordflow}{if} (parent) \{
      parent.replaceChild(wrapNode, element);
    \}
    wrapNode.appendChild(element);
  \},

  \textcolor{keyword}{remove}: jqLiteRemove,

  detach: \textcolor{keyword}{function}(element) \{
    jqLiteRemove(element, \textcolor{keyword}{true});
  \},

  after: \textcolor{keyword}{function}(element, newElement) \{
    var index = element, parent = element.parentNode;
    newElement = \textcolor{keyword}{new} JQLite(newElement);

    \textcolor{keywordflow}{for} (var i = 0, ii = newElement.length; i < ii; i++) \{
      var node = newElement[i];
      parent.insertBefore(node, index.nextSibling);
      index = node;
    \}
  \},

  addClass: jqLiteAddClass,
  removeClass: jqLiteRemoveClass,

  toggleClass: \textcolor{keyword}{function}(element, selector, condition) \{
    \textcolor{keywordflow}{if} (selector) \{
      forEach(selector.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(className) \{
        var classCondition = condition;
        \textcolor{keywordflow}{if} (isUndefined(classCondition)) \{
          classCondition = !jqLiteHasClass(element, className);
        \}
        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
      \});
    \}
  \},

  parent: \textcolor{keyword}{function}(element) \{
    var parent = element.parentNode;
    \textcolor{keywordflow}{return} parent && parent.nodeType !== NODE\_TYPE\_DOCUMENT\_FRAGMENT ? parent : null;
  \},

  next: \textcolor{keyword}{function}(element) \{
    \textcolor{keywordflow}{return} element.nextElementSibling;
  \},

  find: \textcolor{keyword}{function}(element, selector) \{
    \textcolor{keywordflow}{if} (element.getElementsByTagName) \{
      \textcolor{keywordflow}{return} element.getElementsByTagName(selector);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} [];
    \}
  \},

  clone: jqLiteClone,

  triggerHandler: \textcolor{keyword}{function}(element, event, extraParameters) \{

    var dummyEvent, eventFnsCopy, handlerArgs;
    var eventName = \textcolor{keyword}{event}.type || event;
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var eventFns = events && events[eventName];

    \textcolor{keywordflow}{if} (eventFns) \{
      \textcolor{comment}{// Create a dummy event to pass to the handlers}
      dummyEvent = \{
        preventDefault: \textcolor{keyword}{function}() \{ this.defaultPrevented = \textcolor{keyword}{true}; \},
        isDefaultPrevented: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} this.defaultPrevented === \textcolor{keyword}{true}; \},
        stopImmediatePropagation: \textcolor{keyword}{function}() \{ this.immediatePropagationStopped = \textcolor{keyword}{true}; \},
        isImmediatePropagationStopped: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} this.immediatePropagationStopped === \textcolor{keyword}{true}; \},
        stopPropagation: noop,
        type: eventName,
        target: element
      \};

      \textcolor{comment}{// If a custom event was provided then extend our dummy event with it}
      \textcolor{keywordflow}{if} (event.type) \{
        dummyEvent = extend(dummyEvent, event);
      \}

      \textcolor{comment}{// Copy event handlers in case event handlers array is modified during execution.}
      eventFnsCopy = shallowCopy(eventFns);
      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];

      forEach(eventFnsCopy, \textcolor{keyword}{function}(fn) \{
        \textcolor{keywordflow}{if} (!dummyEvent.isImmediatePropagationStopped()) \{
          fn.apply(element, handlerArgs);
        \}
      \});
    \}
  \}
\}, \textcolor{keyword}{function}(fn, name) \{
  JQLite.prototype[name] = \textcolor{keyword}{function}(arg1, arg2, arg3) \{
    var value;

    \textcolor{keywordflow}{for} (var i = 0, ii = this.length; i < ii; i++) \{
      \textcolor{keywordflow}{if} (isUndefined(value)) \{
        value = fn(\textcolor{keyword}{this}[i], arg1, arg2, arg3);
        \textcolor{keywordflow}{if} (isDefined(value)) \{
          \textcolor{comment}{// any function which returns a value needs to be wrapped}
          value = jqLite(value);
        \}
      \} \textcolor{keywordflow}{else} \{
        jqLiteAddNodes(value, fn(\textcolor{keyword}{this}[i], arg1, arg2, arg3));
      \}
    \}
    \textcolor{keywordflow}{return} isDefined(value) ? value : \textcolor{keyword}{this};
  \};

  \textcolor{comment}{// bind legacy bind/unbind to on/off}
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
\});


\textcolor{comment}{// Provider for private $$jqLite service}
\textcolor{keyword}{function} $$jqLiteProvider() \{
  this.$get = \textcolor{keyword}{function} $$jqLite() \{
    \textcolor{keywordflow}{return} extend(JQLite, \{
      hasClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteHasClass(node, classes);
      \},
      addClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteAddClass(node, classes);
      \},
      removeClass: \textcolor{keyword}{function}(node, classes) \{
        \textcolor{keywordflow}{if} (node.attr) node = node[0];
        \textcolor{keywordflow}{return} jqLiteRemoveClass(node, classes);
      \}
    \});
  \};
\}

\textcolor{keyword}{function} hashKey(obj, nextUidFn) \{
  var key = obj && obj.$$hashKey;

  \textcolor{keywordflow}{if} (key) \{
    \textcolor{keywordflow}{if} (typeof key === \textcolor{stringliteral}{'function'}) \{
      key = obj.$$hashKey();
    \}
    \textcolor{keywordflow}{return} key;
  \}

  var objType = typeof obj;
  \textcolor{keywordflow}{if} (objType == \textcolor{stringliteral}{'function'} || (objType == \textcolor{stringliteral}{'object'} && obj !== null)) \{
    key = obj.$$hashKey = objType + \textcolor{charliteral}{':'} + (nextUidFn || nextUid)();
  \} \textcolor{keywordflow}{else} \{
    key = objType + \textcolor{charliteral}{':'} + obj;
  \}

  \textcolor{keywordflow}{return} key;
\}

\textcolor{keyword}{function} HashMap(array, isolatedUid) \{
  \textcolor{keywordflow}{if} (isolatedUid) \{
    var uid = 0;
    this.nextUid = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} ++uid;
    \};
  \}
  forEach(array, this.put, \textcolor{keyword}{this});
\}
HashMap.prototype = \{
  put: \textcolor{keyword}{function}(key, value) \{
    \textcolor{keyword}{this}[hashKey(key, this.nextUid)] = value;
  \},

  \textcolor{keyword}{get}: \textcolor{keyword}{function}(key) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{this}[hashKey(key, this.nextUid)];
  \},

  \textcolor{keyword}{remove}: \textcolor{keyword}{function}(key) \{
    var value = \textcolor{keyword}{this}[key = hashKey(key, this.nextUid)];
    \textcolor{keyword}{delete} \textcolor{keyword}{this}[key];
    \textcolor{keywordflow}{return} value;
  \}
\};

var $$HashMapProvider = [\textcolor{keyword}{function}() \{
  this.$get = [\textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} HashMap;
  \}];
\}];

var FN\_ARGS = /^[^\(\backslash\)(]*\(\backslash\)(\(\backslash\)s*([^\(\backslash\))]*)\(\backslash\))/m;
var FN\_ARG\_SPLIT = /,/;
var FN\_ARG = /^\(\backslash\)s*(\_?)(\(\backslash\)S+?)\(\backslash\)1\(\backslash\)s*$/;
var STRIP\_COMMENTS = /((\(\backslash\)/\(\backslash\)/.*$)|(\(\backslash\)/\(\backslash\)*[\(\backslash\)s\(\backslash\)S]*?\(\backslash\)*\(\backslash\)/))/mg;
var $injectorMinErr = minErr(\textcolor{stringliteral}{'$injector'});

\textcolor{keyword}{function} anonFn(fn) \{
  \textcolor{comment}{// For anonymous functions, showing at the very least the function signature can help in}
  \textcolor{comment}{// debugging.}
  var fnText = fn.toString().replace(STRIP\_COMMENTS, \textcolor{stringliteral}{''}),
      args = fnText.match(FN\_ARGS);
  \textcolor{keywordflow}{if} (args) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'function('} + (args[1] || \textcolor{stringliteral}{''}).replace(/[\(\backslash\)s\(\backslash\)r\(\backslash\)n]+/, \textcolor{charliteral}{' '}) + \textcolor{charliteral}{')'};
  \}
  \textcolor{keywordflow}{return} \textcolor{stringliteral}{'fn'};
\}

\textcolor{keyword}{function} annotate(fn, strictDi, name) \{
  var $inject,
      fnText,
      argDecl,
      last;

  \textcolor{keywordflow}{if} (typeof fn === \textcolor{stringliteral}{'function'}) \{
    \textcolor{keywordflow}{if} (!($inject = fn.$inject)) \{
      $inject = [];
      \textcolor{keywordflow}{if} (fn.length) \{
        \textcolor{keywordflow}{if} (strictDi) \{
          \textcolor{keywordflow}{if} (!isString(name) || !name) \{
            name = fn.name || anonFn(fn);
          \}
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'strictdi'},
            \textcolor{stringliteral}{'\{0\} is not using explicit annotation and cannot be invoked in strict mode'}, name);
        \}
        fnText = fn.toString().replace(STRIP\_COMMENTS, \textcolor{stringliteral}{''});
        argDecl = fnText.match(FN\_ARGS);
        forEach(argDecl[1].split(FN\_ARG\_SPLIT), \textcolor{keyword}{function}(arg) \{
          arg.replace(FN\_ARG, \textcolor{keyword}{function}(all, underscore, name) \{
            $inject.push(name);
          \});
        \});
      \}
      fn.$inject = $inject;
    \}
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(fn)) \{
    last = fn.length - 1;
    assertArgFn(fn[last], \textcolor{stringliteral}{'fn'});
    $inject = fn.slice(0, last);
  \} \textcolor{keywordflow}{else} \{
    assertArgFn(fn, \textcolor{stringliteral}{'fn'}, \textcolor{keyword}{true});
  \}
  \textcolor{keywordflow}{return} $inject;
\}


\textcolor{keyword}{function} createInjector(modulesToLoad, strictDi) \{
  strictDi = (strictDi === \textcolor{keyword}{true});
  var INSTANTIATING = \{\},
      providerSuffix = \textcolor{stringliteral}{'Provider'},
      path = [],
      loadedModules = \textcolor{keyword}{new} HashMap([], \textcolor{keyword}{true}),
      providerCache = \{
        $provide: \{
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          \}
      \},
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, \textcolor{keyword}{function}(serviceName, caller) \{
            \textcolor{keywordflow}{if} (angular.isString(caller)) \{
              path.push(caller);
            \}
            \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'unpr'}, \textcolor{stringliteral}{"Unknown provider: \{0\}"}, path.join(\textcolor{stringliteral}{' <- '}));
          \})),
      instanceCache = \{\},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, \textcolor{keyword}{function}(serviceName, caller) \{
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            \textcolor{keywordflow}{return} instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
          \}));


  forEach(loadModules(modulesToLoad), \textcolor{keyword}{function}(fn) \{ \textcolor{keywordflow}{if} (fn) instanceInjector.invoke(fn); \});

  \textcolor{keywordflow}{return} instanceInjector;

  \textcolor{comment}{// $provider}
\textcolor{comment}{}
  \textcolor{keyword}{function} supportObject(delegate) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(key, value) \{
      \textcolor{keywordflow}{if} (isObject(key)) \{
        forEach(key, reverseParams(delegate));
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} delegate(key, value);
      \}
    \};
  \}

  \textcolor{keyword}{function} provider(name, provider\_) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'service'});
    \textcolor{keywordflow}{if} (isFunction(provider\_) || isArray(provider\_)) \{
      provider\_ = providerInjector.instantiate(provider\_);
    \}
    \textcolor{keywordflow}{if} (!provider\_.$get) \{
      \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'pget'}, \textcolor{stringliteral}{"Provider '\{0\}' must define $get factory method."}, name);
    \}
    \textcolor{keywordflow}{return} providerCache[name + providerSuffix] = provider\_;
  \}

  \textcolor{keyword}{function} enforceReturnValue(name, factory) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function} enforcedReturnValue() \{
      var result = instanceInjector.invoke(factory, \textcolor{keyword}{this});
      \textcolor{keywordflow}{if} (isUndefined(result)) \{
        \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'undef'}, \textcolor{stringliteral}{"Provider '\{0\}' must return a value from $get factory method."}, name
      );
      \}
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} factory(name, factoryFn, enforce) \{
    \textcolor{keywordflow}{return} provider(name, \{
      $get: enforce !== \textcolor{keyword}{false} ? enforceReturnValue(name, factoryFn) : factoryFn
    \});
  \}

  \textcolor{keyword}{function} service(name, constructor) \{
    \textcolor{keywordflow}{return} factory(name, [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{
      \textcolor{keywordflow}{return} $injector.instantiate(constructor);
    \}]);
  \}

  \textcolor{keyword}{function} value(name, val) \{ \textcolor{keywordflow}{return} factory(name, valueFn(val), \textcolor{keyword}{false}); \}

  \textcolor{keyword}{function} constant(name, value) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'constant'});
    providerCache[name] = value;
    instanceCache[name] = value;
  \}

  \textcolor{keyword}{function} decorator(serviceName, decorFn) \{
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = \textcolor{keyword}{function}() \{
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      \textcolor{keywordflow}{return} instanceInjector.invoke(decorFn, null, \{$delegate: origInstance\});
    \};
  \}

  \textcolor{comment}{// Module Loading}
\textcolor{comment}{}  \textcolor{keyword}{function} loadModules(modulesToLoad) \{
    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), \textcolor{stringliteral}{'modulesToLoad'}, \textcolor{stringliteral}{'not an array'});
    var runBlocks = [], moduleFn;
    forEach(modulesToLoad, \textcolor{keyword}{function}(module) \{
      \textcolor{keywordflow}{if} (loadedModules.get(module)) \textcolor{keywordflow}{return};
      loadedModules.put(module, \textcolor{keyword}{true});

      \textcolor{keyword}{function} runInvokeQueue(queue) \{
        var i, ii;
        \textcolor{keywordflow}{for} (i = 0, ii = queue.length; i < ii; i++) \{
          var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);

          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
        \}
      \}

      \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{if} (isString(module)) \{
          moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn.\_runBlocks);
          runInvokeQueue(moduleFn.\_invokeQueue);
          runInvokeQueue(moduleFn.\_configBlocks);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isFunction(module)) \{
            runBlocks.push(providerInjector.invoke(module));
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(module)) \{
            runBlocks.push(providerInjector.invoke(module));
        \} \textcolor{keywordflow}{else} \{
          assertArgFn(module, \textcolor{stringliteral}{'module'});
        \}
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{keywordflow}{if} (isArray(module)) \{
          module = module[module.length - 1];
        \}
        \textcolor{keywordflow}{if} (e.message && e.stack && e.stack.indexOf(e.message) == -1) \{
          \textcolor{comment}{// Safari & FF's stack traces don't contain error.message content}
          \textcolor{comment}{// unlike those of Chrome and IE}
          \textcolor{comment}{// So if stack doesn't contain message, we create a new string that contains both.}
          \textcolor{comment}{// Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.}
          \textcolor{comment}{/* jshint -W022 */}
          e = e.message + \textcolor{charliteral}{'\(\backslash\)n'} + e.stack;
        \}
        \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'modulerr'}, \textcolor{stringliteral}{"Failed to instantiate module \{0\} due to:\(\backslash\)n\{1\}"},
                  module, e.stack || e.message || e);
      \}
    \});
    \textcolor{keywordflow}{return} runBlocks;
  \}

  \textcolor{comment}{// internal Injector}
\textcolor{comment}{}
  \textcolor{keyword}{function} createInternalInjector(cache, factory) \{

    \textcolor{keyword}{function} getService(serviceName, caller) \{
      \textcolor{keywordflow}{if} (cache.hasOwnProperty(serviceName)) \{
        \textcolor{keywordflow}{if} (cache[serviceName] === INSTANTIATING) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'cdep'}, \textcolor{stringliteral}{'Circular dependency found: \{0\}'},
                    serviceName + \textcolor{stringliteral}{' <- '} + path.join(\textcolor{stringliteral}{' <- '}));
        \}
        \textcolor{keywordflow}{return} cache[serviceName];
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{try} \{
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          \textcolor{keywordflow}{return} cache[serviceName] = factory(serviceName, caller);
        \} \textcolor{keywordflow}{catch} (err) \{
          \textcolor{keywordflow}{if} (cache[serviceName] === INSTANTIATING) \{
            \textcolor{keyword}{delete} cache[serviceName];
          \}
          \textcolor{keywordflow}{throw} err;
        \} \textcolor{keywordflow}{finally} \{
          path.shift();
        \}
      \}
    \}

    \textcolor{keyword}{function} invoke(fn, \textcolor{keyword}{self}, locals, serviceName) \{
      \textcolor{keywordflow}{if} (typeof locals === \textcolor{stringliteral}{'string'}) \{
        serviceName = locals;
        locals = null;
      \}

      var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName),
          length, i,
          key;

      \textcolor{keywordflow}{for} (i = 0, length = $inject.length; i < length; i++) \{
        key = $inject[i];
        \textcolor{keywordflow}{if} (typeof key !== \textcolor{stringliteral}{'string'}) \{
          \textcolor{keywordflow}{throw} $injectorMinErr(\textcolor{stringliteral}{'itkn'},
                  \textcolor{stringliteral}{'Incorrect injection token! Expected service name as string, got \{0\}'}, key);
        \}
        args.push(
          locals && locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key, serviceName)
        );
      \}
      \textcolor{keywordflow}{if} (isArray(fn)) \{
        fn = fn[length];
      \}

      \textcolor{comment}{// http://jsperf.com/angularjs-invoke-apply-vs-switch}
      \textcolor{comment}{// #5388}
      \textcolor{keywordflow}{return} fn.apply(\textcolor{keyword}{self}, args);
    \}

    \textcolor{keyword}{function} instantiate(Type, locals, serviceName) \{
      \textcolor{comment}{// Check if Type is annotated and use just the given function at n-1 as parameter}
      \textcolor{comment}{// e.g. someModule.factory('greeter', ['$window', function(renamed$window) \{\}]);}
      \textcolor{comment}{// Object creation: http://jsperf.com/create-constructor/2}
      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
      var returnedValue = invoke(Type, instance, locals, serviceName);

      \textcolor{keywordflow}{return} isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
    \}

    \textcolor{keywordflow}{return} \{
      invoke: invoke,
      instantiate: instantiate,
      \textcolor{keyword}{get}: getService,
      annotate: createInjector.$$annotate,
      has: \textcolor{keyword}{function}(name) \{
        \textcolor{keywordflow}{return} providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      \}
    \};
  \}
\}

createInjector.$$annotate = annotate;

\textcolor{keyword}{function} $AnchorScrollProvider() \{

  var autoScrollingEnabled = \textcolor{keyword}{true};

  this.disableAutoScrolling = \textcolor{keyword}{function}() \{
    autoScrollingEnabled = \textcolor{keyword}{false};
  \};

  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$location'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($window, $location, $rootScope) \{
    var document = $window.document;

    \textcolor{comment}{// Helper function to get first anchor from a NodeList}
    \textcolor{comment}{// (using `Array#some()` instead of `angular#forEach()` since it's more performant}
    \textcolor{comment}{//  and working in all supported browsers.)}
    \textcolor{keyword}{function} getFirstAnchor(list) \{
      var result = null;
      Array.prototype.some.call(list, \textcolor{keyword}{function}(element) \{
        \textcolor{keywordflow}{if} (nodeName\_(element) === \textcolor{charliteral}{'a'}) \{
          result = element;
          \textcolor{keywordflow}{return} \textcolor{keyword}{true};
        \}
      \});
      \textcolor{keywordflow}{return} result;
    \}

    \textcolor{keyword}{function} getYOffset() \{

      var offset = scroll.yOffset;

      \textcolor{keywordflow}{if} (isFunction(offset)) \{
        offset = offset();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isElement(offset)) \{
        var elem = offset[0];
        var style = $window.getComputedStyle(elem);
        \textcolor{keywordflow}{if} (style.position !== \textcolor{stringliteral}{'fixed'}) \{
          offset = 0;
        \} \textcolor{keywordflow}{else} \{
          offset = elem.getBoundingClientRect().bottom;
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isNumber(offset)) \{
        offset = 0;
      \}

      \textcolor{keywordflow}{return} offset;
    \}

    \textcolor{keyword}{function} scrollTo(elem) \{
      \textcolor{keywordflow}{if} (elem) \{
        elem.scrollIntoView();

        var offset = getYOffset();

        \textcolor{keywordflow}{if} (offset) \{
          \textcolor{comment}{// `offset` is the number of pixels we should scroll UP in order to align `elem` properly.}
          \textcolor{comment}{// This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the}
          \textcolor{comment}{// top of the viewport.}
          \textcolor{comment}{//}
          \textcolor{comment}{// IF the number of pixels from the top of `elem` to the end of the page's content is less}
          \textcolor{comment}{// than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some}
          \textcolor{comment}{// way down the page.}
          \textcolor{comment}{//}
          \textcolor{comment}{// This is often the case for elements near the bottom of the page.}
          \textcolor{comment}{//}
          \textcolor{comment}{// In such cases we do not need to scroll the whole `offset` up, just the difference between}
          \textcolor{comment}{// the top of the element and the offset, which is enough to align the top of `elem` at the}
          \textcolor{comment}{// desired position.}
          var elemTop = elem.getBoundingClientRect().top;
          $window.scrollBy(0, elemTop - offset);
        \}
      \} \textcolor{keywordflow}{else} \{
        $window.scrollTo(0, 0);
      \}
    \}

    \textcolor{keyword}{function} scroll(hash) \{
      hash = isString(hash) ? hash : $location.hash();
      var elm;

      \textcolor{comment}{// empty hash, scroll to the top of the page}
      \textcolor{keywordflow}{if} (!hash) scrollTo(null);

      \textcolor{comment}{// element with given id}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((elm = document.getElementById(hash))) scrollTo(elm);

      \textcolor{comment}{// first anchor with given name :-D}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);

      \textcolor{comment}{// no element and hash == 'top', scroll to the top of the page}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hash === \textcolor{stringliteral}{'top'}) scrollTo(null);
    \}

    \textcolor{comment}{// does not scroll when user clicks on anchor link that is currently on}
    \textcolor{comment}{// (no url change, no $location.hash() change), browser native does scroll}
    \textcolor{keywordflow}{if} (autoScrollingEnabled) \{
      $rootScope.$watch(\textcolor{keyword}{function} autoScrollWatch() \{\textcolor{keywordflow}{return} $location.hash();\},
        \textcolor{keyword}{function} autoScrollWatchAction(newVal, oldVal) \{
          \textcolor{comment}{// skip the initial scroll if $location.hash is empty}
          \textcolor{keywordflow}{if} (newVal === oldVal && newVal === \textcolor{stringliteral}{''}) \textcolor{keywordflow}{return};

          jqLiteDocumentLoaded(\textcolor{keyword}{function}() \{
            $rootScope.$evalAsync(scroll);
          \});
        \});
    \}

    \textcolor{keywordflow}{return} scroll;
  \}];
\}

var $animateMinErr = minErr(\textcolor{stringliteral}{'$animate'});
var ELEMENT\_NODE = 1;
var NG\_ANIMATE\_CLASSNAME = \textcolor{stringliteral}{'ng-animate'};

\textcolor{keyword}{function} mergeClasses(a,b) \{
  \textcolor{keywordflow}{if} (!a && !b) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
  \textcolor{keywordflow}{if} (!a) \textcolor{keywordflow}{return} b;
  \textcolor{keywordflow}{if} (!b) \textcolor{keywordflow}{return} a;
  \textcolor{keywordflow}{if} (isArray(a)) a = a.join(\textcolor{charliteral}{' '});
  \textcolor{keywordflow}{if} (isArray(b)) b = b.join(\textcolor{charliteral}{' '});
  \textcolor{keywordflow}{return} a + \textcolor{charliteral}{' '} + b;
\}

\textcolor{keyword}{function} extractElementNode(element) \{
  \textcolor{keywordflow}{for} (var i = 0; i < element.length; i++) \{
    var elm = element[i];
    \textcolor{keywordflow}{if} (elm.nodeType === ELEMENT\_NODE) \{
      \textcolor{keywordflow}{return} elm;
    \}
  \}
\}

\textcolor{keyword}{function} splitClasses(classes) \{
  \textcolor{keywordflow}{if} (isString(classes)) \{
    classes = classes.split(\textcolor{charliteral}{' '});
  \}

  \textcolor{comment}{// Use createMap() to prevent class assumptions involving property names in}
  \textcolor{comment}{// Object.prototype}
  var obj = createMap();
  forEach(classes, \textcolor{keyword}{function}(klass) \{
    \textcolor{comment}{// sometimes the split leaves empty string values}
    \textcolor{comment}{// incase extra spaces were applied to the options}
    \textcolor{keywordflow}{if} (klass.length) \{
      obj[klass] = true;
    \}
  \});
  \textcolor{keywordflow}{return} obj;
\}

\textcolor{comment}{// if any other type of options value besides an Object value is}
\textcolor{comment}{// passed into the $animate.method() animation then this helper code}
\textcolor{comment}{// will be run which will ignore it. While this patch is not the}
\textcolor{comment}{// greatest solution to this, a lot of existing plugins depend on}
\textcolor{comment}{// $animate to either call the callback (< 1.2) or return a promise}
\textcolor{comment}{// that can be changed. This helper function ensures that the options}
\textcolor{comment}{// are wiped clean incase a callback function is provided.}
\textcolor{keyword}{function} prepareAnimateOptions(options) \{
  \textcolor{keywordflow}{return} isObject(options)
      ? options
      : \{\};
\}

var $$CoreAnimateRunnerProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$$rAF'}, \textcolor{keyword}{function}($q, $$rAF) \{
    \textcolor{keyword}{function} AnimateRunner() \{\}
    AnimateRunner.all = noop;
    AnimateRunner.chain = noop;
    AnimateRunner.prototype = \{
      end: noop,
      cancel: noop,
      resume: noop,
      pause: noop,
      complete: noop,
      then: \textcolor{keyword}{function}(pass, fail) \{
        \textcolor{keywordflow}{return} $q(\textcolor{keyword}{function}(resolve) \{
          $$rAF(\textcolor{keyword}{function}() \{
            resolve();
          \});
        \}).then(pass, fail);
      \}
    \};
    \textcolor{keywordflow}{return} AnimateRunner;
  \}];
\};

\textcolor{comment}{// this is prefixed with Core since it conflicts with}
\textcolor{comment}{// the animateQueueProvider defined in ngAnimate/animateQueue.js}
var $$CoreAnimateQueueProvider = \textcolor{keyword}{function}() \{
  var postDigestQueue = \textcolor{keyword}{new} HashMap();
  var postDigestElements = [];

  this.$get = [\textcolor{stringliteral}{'$$AnimateRunner'}, \textcolor{stringliteral}{'$rootScope'},
       \textcolor{keyword}{function}($$AnimateRunner,   $rootScope) \{
    \textcolor{keywordflow}{return} \{
      enabled: noop,
      on: noop,
      off: noop,
      pin: noop,

      push: \textcolor{keyword}{function}(element, event, options, domOperation) \{
        domOperation        && domOperation();

        options = options || \{\};
        options.from        && element.css(options.from);
        options.to          && element.css(options.to);

        \textcolor{keywordflow}{if} (options.addClass || options.removeClass) \{
          addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{new} $$AnimateRunner(); \textcolor{comment}{// jshint ignore:line}
      \}
    \};

    \textcolor{keyword}{function} addRemoveClassesPostDigest(element, add, \textcolor{keyword}{remove}) \{
      var classVal, data = postDigestQueue.get(element);

      \textcolor{keywordflow}{if} (!data) \{
        postDigestQueue.put(element, data = \{\});
        postDigestElements.push(element);
      \}

      var updateData = \textcolor{keyword}{function}(classes, value) \{
        var changed = \textcolor{keyword}{false};
        \textcolor{keywordflow}{if} (classes) \{
          classes = isString(classes) ? classes.split(\textcolor{charliteral}{' '}) :
                    isArray(classes) ? classes : [];
          forEach(classes, \textcolor{keyword}{function}(className) \{
            \textcolor{keywordflow}{if} (className) \{
              changed = \textcolor{keyword}{true};
              data[className] = value;
            \}
          \});
        \}
        \textcolor{keywordflow}{return} changed;
      \};

      var classesAdded = updateData(add, \textcolor{keyword}{true});
      var classesRemoved = updateData(\textcolor{keyword}{remove}, \textcolor{keyword}{false});
      \textcolor{keywordflow}{if} ((!classesAdded && !classesRemoved) || postDigestElements.length > 1) \textcolor{keywordflow}{return};

      $rootScope.$$postDigest(\textcolor{keyword}{function}() \{
        forEach(postDigestElements, \textcolor{keyword}{function}(element) \{
          var data = postDigestQueue.get(element);
          \textcolor{keywordflow}{if} (data) \{
            var existing = splitClasses(element.attr(\textcolor{stringliteral}{'class'}));
            var toAdd = \textcolor{stringliteral}{''};
            var toRemove = \textcolor{stringliteral}{''};
            forEach(data, \textcolor{keyword}{function}(status, className) \{
              var hasClass = !!existing[className];
              \textcolor{keywordflow}{if} (status !== hasClass) \{
                \textcolor{keywordflow}{if} (status) \{
                  toAdd += (toAdd.length ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + className;
                \} \textcolor{keywordflow}{else} \{
                  toRemove += (toRemove.length ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + className;
                \}
              \}
            \});

            forEach(element, \textcolor{keyword}{function}(elm) \{
              toAdd    && jqLiteAddClass(elm, toAdd);
              toRemove && jqLiteRemoveClass(elm, toRemove);
            \});
            postDigestQueue.remove(element);
          \}
        \});

        postDigestElements.length = 0;
      \});
    \}
  \}];
\};

var $AnimateProvider = [\textcolor{stringliteral}{'$provide'}, \textcolor{keyword}{function}($provide) \{
  var provider = \textcolor{keyword}{this};

  this.$$registeredAnimations = Object.create(null);

  this.\textcolor{keyword}{register} = \textcolor{keyword}{function}(name, factory) \{
    \textcolor{keywordflow}{if} (name && name.charAt(0) !== \textcolor{charliteral}{'.'}) \{
      \textcolor{keywordflow}{throw} $animateMinErr(\textcolor{stringliteral}{'notcsel'}, \textcolor{stringliteral}{"Expecting class selector starting with '.' got '\{0\}'."}, name);
    \}

    var key = name + \textcolor{stringliteral}{'-animation'};
    provider.$$registeredAnimations[name.substr(1)] = key;
    $provide.factory(key, factory);
  \};

  this.classNameFilter = \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{if} (arguments.length === 1) \{
      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
      \textcolor{keywordflow}{if} (this.$$classNameFilter) \{
        var reservedRegex = \textcolor{keyword}{new} RegExp(\textcolor{stringliteral}{"(\(\backslash\)\(\backslash\)s+|\(\backslash\)\(\backslash\)/)"} + NG\_ANIMATE\_CLASSNAME + \textcolor{stringliteral}{"(\(\backslash\)\(\backslash\)s+|\(\backslash\)\(\backslash\)/)"});
        \textcolor{keywordflow}{if} (reservedRegex.test(\textcolor{keyword}{this}.$$classNameFilter.toString())) \{
          \textcolor{keywordflow}{throw} $animateMinErr(\textcolor{stringliteral}{'nongcls'},\textcolor{stringliteral}{'$animateProvider.classNameFilter(regex) prohibits accepting a
       regex value which matches/contains the "\{0\}" CSS class.'}, NG\_ANIMATE\_CLASSNAME);

        \}
      \}
    \}
    \textcolor{keywordflow}{return} this.$$classNameFilter;
  \};

  this.$get = [\textcolor{stringliteral}{'$$animateQueue'}, \textcolor{keyword}{function}($$animateQueue) \{
    \textcolor{keyword}{function} domInsert(element, parentElement, afterElement) \{
      \textcolor{comment}{// if for some reason the previous element was removed}
      \textcolor{comment}{// from the dom sometime before this code runs then let's}
      \textcolor{comment}{// just stick to using the parent element as the anchor}
      \textcolor{keywordflow}{if} (afterElement) \{
        var afterNode = extractElementNode(afterElement);
        \textcolor{keywordflow}{if} (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) \{
          afterElement = null;
        \}
      \}
      afterElement ? afterElement.after(element) : parentElement.prepend(element);
    \}

    \textcolor{keywordflow}{return} \{
      \textcolor{comment}{// we don't call it directly since non-existant arguments may}
      \textcolor{comment}{// be interpreted as null within the sub enabled function}

      on: $$animateQueue.on,

      off: $$animateQueue.off,

      pin: $$animateQueue.pin,

      enabled: $$animateQueue.enabled,

      cancel: \textcolor{keyword}{function}(runner) \{
        runner.end && runner.end();
      \},

      enter: \textcolor{keyword}{function}(element, parent, after, options) \{
        parent = parent && jqLite(parent);
        after = after && jqLite(after);
        parent = parent || after.parent();
        domInsert(element, parent, after);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'enter'}, prepareAnimateOptions(options));
      \},

      move: \textcolor{keyword}{function}(element, parent, after, options) \{
        parent = parent && jqLite(parent);
        after = after && jqLite(after);
        parent = parent || after.parent();
        domInsert(element, parent, after);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'move'}, prepareAnimateOptions(options));
      \},

      leave: \textcolor{keyword}{function}(element, options) \{
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'leave'}, prepareAnimateOptions(options), \textcolor{keyword}{function}() \{
          element.remove();
        \});
      \},

      addClass: \textcolor{keyword}{function}(element, className, options) \{
        options = prepareAnimateOptions(options);
        options.addClass = mergeClasses(options.addclass, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'addClass'}, options);
      \},

      removeClass: \textcolor{keyword}{function}(element, className, options) \{
        options = prepareAnimateOptions(options);
        options.removeClass = mergeClasses(options.removeClass, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'removeClass'}, options);
      \},

      setClass: \textcolor{keyword}{function}(element, add, \textcolor{keyword}{remove}, options) \{
        options = prepareAnimateOptions(options);
        options.addClass = mergeClasses(options.addClass, add);
        options.removeClass = mergeClasses(options.removeClass, \textcolor{keyword}{remove});
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'setClass'}, options);
      \},

      animate: \textcolor{keyword}{function}(element, from, to, className, options) \{
        options = prepareAnimateOptions(options);
        options.from = options.from ? extend(options.from, from) : from;
        options.to   = options.to   ? extend(options.to, to)     : to;

        className = className || \textcolor{stringliteral}{'ng-inline-animate'};
        options.tempClasses = mergeClasses(options.tempClasses, className);
        \textcolor{keywordflow}{return} $$animateQueue.push(element, \textcolor{stringliteral}{'animate'}, options);
      \}
    \};
  \}];
\}];

var $CoreAnimateCssProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$$rAF'}, \textcolor{stringliteral}{'$q'}, \textcolor{keyword}{function}($$rAF, $q) \{

    var RAFPromise = \textcolor{keyword}{function}() \{\};
    RAFPromise.prototype = \{
      done: \textcolor{keyword}{function}(cancel) \{
        this.defer && this.defer[cancel === \textcolor{keyword}{true} ? \textcolor{stringliteral}{'reject'} : \textcolor{stringliteral}{'resolve'}]();
      \},
      end: \textcolor{keyword}{function}() \{
        this.done();
      \},
      cancel: \textcolor{keyword}{function}() \{
        this.done(\textcolor{keyword}{true});
      \},
      getPromise: \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!this.defer) \{
          this.defer = $q.defer();
        \}
        \textcolor{keywordflow}{return} this.defer.promise;
      \},
      then: \textcolor{keyword}{function}(f1,f2) \{
        \textcolor{keywordflow}{return} this.getPromise().then(f1,f2);
      \},
      \textcolor{stringliteral}{'catch'}: \textcolor{keyword}{function}(f1) \{
        \textcolor{keywordflow}{return} this.getPromise().catch(f1);
      \},
      \textcolor{stringliteral}{'finally'}: \textcolor{keyword}{function}(f1) \{
        \textcolor{keywordflow}{return} this.getPromise().finally(f1);
      \}
    \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(element, options) \{
      \textcolor{keywordflow}{if} (options.from) \{
        element.css(options.from);
        options.from = null;
      \}

      var closed, runner = \textcolor{keyword}{new} RAFPromise();
      \textcolor{keywordflow}{return} \{
        start: run,
        end: run
      \};

      \textcolor{keyword}{function} run() \{
        $$rAF(\textcolor{keyword}{function}() \{
          close();
          \textcolor{keywordflow}{if} (!closed) \{
            runner.done();
          \}
          closed = \textcolor{keyword}{true};
        \});
        \textcolor{keywordflow}{return} runner;
      \}

      \textcolor{keyword}{function} close() \{
        \textcolor{keywordflow}{if} (options.addClass) \{
          element.addClass(options.addClass);
          options.addClass = null;
        \}
        \textcolor{keywordflow}{if} (options.removeClass) \{
          element.removeClass(options.removeClass);
          options.removeClass = null;
        \}
        \textcolor{keywordflow}{if} (options.to) \{
          element.css(options.to);
          options.to = null;
        \}
      \}
    \};
  \}];
\};

\textcolor{comment}{/* global stripHash: true */}

\textcolor{keyword}{function} Browser(window, document, $log, $sniffer) \{
  var \textcolor{keyword}{self} = \textcolor{keyword}{this},
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = \{\};

  \textcolor{keyword}{self}.isMock = \textcolor{keyword}{false};

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  \textcolor{comment}{// TODO(vojta): remove this temporary api}
  \textcolor{keyword}{self}.$$completeOutstandingRequest = completeOutstandingRequest;
  \textcolor{keyword}{self}.$$incOutstandingRequestCount = \textcolor{keyword}{function}() \{ outstandingRequestCount++; \};

  \textcolor{keyword}{function} completeOutstandingRequest(fn) \{
    \textcolor{keywordflow}{try} \{
      fn.apply(null, sliceArgs(arguments, 1));
    \} \textcolor{keywordflow}{finally} \{
      outstandingRequestCount--;
      \textcolor{keywordflow}{if} (outstandingRequestCount === 0) \{
        \textcolor{keywordflow}{while} (outstandingRequestCallbacks.length) \{
          \textcolor{keywordflow}{try} \{
            outstandingRequestCallbacks.pop()();
          \} \textcolor{keywordflow}{catch} (e) \{
            $log.error(e);
          \}
        \}
      \}
    \}
  \}

  \textcolor{keyword}{function} getHash(url) \{
    var index = url.indexOf(\textcolor{charliteral}{'#'});
    \textcolor{keywordflow}{return} index === -1 ? \textcolor{stringliteral}{''} : url.substr(index);
  \}

  \textcolor{keyword}{self}.notifyWhenNoOutstandingRequests = \textcolor{keyword}{function}(callback) \{
    \textcolor{keywordflow}{if} (outstandingRequestCount === 0) \{
      callback();
    \} \textcolor{keywordflow}{else} \{
      outstandingRequestCallbacks.push(callback);
    \}
  \};

  \textcolor{comment}{// URL API}
\textcolor{comment}{}
  var cachedState, lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find(\textcolor{stringliteral}{'base'}),
      reloadLocation = null;

  cacheState();
  lastHistoryState = cachedState;

  \textcolor{keyword}{self}.url = \textcolor{keyword}{function}(url, replace, state) \{
    \textcolor{comment}{// In modern browsers `history.state` is `null` by default; treating it separately}
    \textcolor{comment}{// from `undefined` would cause `$browser.url('/foo')` to change `history.state`}
    \textcolor{comment}{// to undefined via `pushState`. Instead, let's change `undefined` to `null` here.}
    \textcolor{keywordflow}{if} (isUndefined(state)) \{
      state = null;
    \}

    \textcolor{comment}{// Android Browser BFCache causes location, history reference to become stale.}
    \textcolor{keywordflow}{if} (location !== window.location) location = window.location;
    \textcolor{keywordflow}{if} (history !== window.history) history = window.history;

    \textcolor{comment}{// setter}
    \textcolor{keywordflow}{if} (url) \{
      var sameState = lastHistoryState === state;

      \textcolor{comment}{// Don't change anything if previous and current URLs and states match. This also prevents}
      \textcolor{comment}{// IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.}
      \textcolor{comment}{// See https://github.com/angular/angular.js/commit/ffb2701}
      \textcolor{keywordflow}{if} (lastBrowserUrl === url && (!$sniffer.history || sameState)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{self};
      \}
      var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
      lastBrowserUrl = url;
      lastHistoryState = state;
      \textcolor{comment}{// Don't use history API if only the hash changed}
      \textcolor{comment}{// due to a bug in IE10/IE11 which leads}
      \textcolor{comment}{// to not firing a `hashchange` nor `popstate` event}
      \textcolor{comment}{// in some cases (see #9143).}
      \textcolor{keywordflow}{if} ($sniffer.history && (!sameBase || !sameState)) \{
        history[replace ? \textcolor{stringliteral}{'replaceState'} : \textcolor{stringliteral}{'pushState'}](state, \textcolor{stringliteral}{''}, url);
        cacheState();
        \textcolor{comment}{// Do the assignment again so that those two variables are referentially identical.}
        lastHistoryState = cachedState;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (!sameBase || reloadLocation) \{
          reloadLocation = url;
        \}
        \textcolor{keywordflow}{if} (replace) \{
          location.replace(url);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!sameBase) \{
          location.href = url;
        \} \textcolor{keywordflow}{else} \{
          location.hash = getHash(url);
        \}
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{self};
    \textcolor{comment}{// getter}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// - reloadLocation is needed as browsers don't allow to read out}
      \textcolor{comment}{//   the new location.href if a reload happened.}
      \textcolor{comment}{// - the replacement is a workaround for https://bugzilla.mozilla.org/show\_bug.cgi?id=407172}
      \textcolor{keywordflow}{return} reloadLocation || location.href.replace(/%27/g,\textcolor{stringliteral}{"'"});
    \}
  \};

  \textcolor{keyword}{self}.state = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} cachedState;
  \};

  var urlChangeListeners = [],
      urlChangeInit = \textcolor{keyword}{false};

  \textcolor{keyword}{function} cacheStateAndFireUrlChange() \{
    cacheState();
    fireUrlChange();
  \}

  \textcolor{keyword}{function} getCurrentState() \{
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{return} history.state;
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{comment}{// MSIE can reportedly throw when there is no state (UNCONFIRMED).}
    \}
  \}

  \textcolor{comment}{// This variable should be used *only* inside the cacheState function.}
  var lastCachedState = null;
  \textcolor{keyword}{function} cacheState() \{
    \textcolor{comment}{// This should be the only place in $browser where `history.state` is read.}
    cachedState = getCurrentState();
    cachedState = isUndefined(cachedState) ? null : cachedState;

    \textcolor{comment}{// Prevent callbacks fo fire twice if both hashchange & popstate were fired.}
    \textcolor{keywordflow}{if} (equals(cachedState, lastCachedState)) \{
      cachedState = lastCachedState;
    \}
    lastCachedState = cachedState;
  \}

  \textcolor{keyword}{function} fireUrlChange() \{
    \textcolor{keywordflow}{if} (lastBrowserUrl === \textcolor{keyword}{self}.url() && lastHistoryState === cachedState) \{
      \textcolor{keywordflow}{return};
    \}

    lastBrowserUrl = \textcolor{keyword}{self}.url();
    lastHistoryState = cachedState;
    forEach(urlChangeListeners, \textcolor{keyword}{function}(listener) \{
      listener(\textcolor{keyword}{self}.url(), cachedState);
    \});
  \}

  \textcolor{keyword}{self}.onUrlChange = \textcolor{keyword}{function}(callback) \{
    \textcolor{comment}{// TODO(vojta): refactor to use node's syntax for events}
    \textcolor{keywordflow}{if} (!urlChangeInit) \{
      \textcolor{comment}{// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)}
      \textcolor{comment}{// don't fire popstate when user change the address bar and don't fire hashchange when url}
      \textcolor{comment}{// changed by push/replaceState}

      \textcolor{comment}{// html5 history api - popstate event}
      \textcolor{keywordflow}{if} ($sniffer.history) jqLite(window).on(\textcolor{stringliteral}{'popstate'}, cacheStateAndFireUrlChange);
      \textcolor{comment}{// hashchange event}
      jqLite(window).on(\textcolor{stringliteral}{'hashchange'}, cacheStateAndFireUrlChange);

      urlChangeInit = \textcolor{keyword}{true};
    \}

    urlChangeListeners.push(callback);
    \textcolor{keywordflow}{return} callback;
  \};

  \textcolor{keyword}{self}.$$applicationDestroyed = \textcolor{keyword}{function}() \{
    jqLite(window).off(\textcolor{stringliteral}{'hashchange popstate'}, cacheStateAndFireUrlChange);
  \};

  \textcolor{keyword}{self}.$$checkUrlChange = fireUrlChange;

  \textcolor{comment}{// Misc API}
\textcolor{comment}{}
  \textcolor{keyword}{self}.baseHref = \textcolor{keyword}{function}() \{
    var href = baseElement.attr(\textcolor{stringliteral}{'href'});
    \textcolor{keywordflow}{return} href ? href.replace(/^(https?\(\backslash\):)?\(\backslash\)/\(\backslash\)/[^\(\backslash\)/]*/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''};
  \};

  \textcolor{keyword}{self}.defer = \textcolor{keyword}{function}(fn, delay) \{
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(\textcolor{keyword}{function}() \{
      \textcolor{keyword}{delete} pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    \}, delay || 0);
    pendingDeferIds[timeoutId] = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} timeoutId;
  \};


  \textcolor{keyword}{self}.defer.cancel = \textcolor{keyword}{function}(deferId) \{
    \textcolor{keywordflow}{if} (pendingDeferIds[deferId]) \{
      \textcolor{keyword}{delete} pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \};

\}

\textcolor{keyword}{function} $BrowserProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$log'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$document'},
      \textcolor{keyword}{function}($window, $log, $sniffer, $document) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Browser($window, $document, $log, $sniffer);
      \}];
\}

\textcolor{keyword}{function} $CacheFactoryProvider() \{

  this.$get = \textcolor{keyword}{function}() \{
    var caches = \{\};

    \textcolor{keyword}{function} cacheFactory(cacheId, options) \{
      \textcolor{keywordflow}{if} (cacheId in caches) \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'$cacheFactory'})(\textcolor{stringliteral}{'iid'}, \textcolor{stringliteral}{"CacheId '\{0\}' is already taken!"}, cacheId);
      \}

      var size = 0,
          stats = extend(\{\}, options, \{\textcolor{keywordtype}{id}: cacheId\}),
          data = \{\},
          capacity = (options && options.capacity) || Number.MAX\_VALUE,
          lruHash = \{\},
          freshEnd = null,
          staleEnd = null;

      \textcolor{keywordflow}{return} caches[cacheId] = \{

        put: \textcolor{keyword}{function}(key, value) \{
          \textcolor{keywordflow}{if} (isUndefined(value)) \textcolor{keywordflow}{return};
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key] || (lruHash[key] = \{key: key\});

            refresh(lruEntry);
          \}

          \textcolor{keywordflow}{if} (!(key in data)) size++;
          data[key] = value;

          \textcolor{keywordflow}{if} (size > capacity) \{
            this.\textcolor{keyword}{remove}(staleEnd.key);
          \}

          \textcolor{keywordflow}{return} value;
        \},

        \textcolor{keyword}{get}: \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key];

            \textcolor{keywordflow}{if} (!lruEntry) \textcolor{keywordflow}{return};

            refresh(lruEntry);
          \}

          \textcolor{keywordflow}{return} data[key];
        \},


        \textcolor{keyword}{remove}: \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{if} (capacity < Number.MAX\_VALUE) \{
            var lruEntry = lruHash[key];

            \textcolor{keywordflow}{if} (!lruEntry) \textcolor{keywordflow}{return};

            \textcolor{keywordflow}{if} (lruEntry == freshEnd) freshEnd = lruEntry.p;
            \textcolor{keywordflow}{if} (lruEntry == staleEnd) staleEnd = lruEntry.n;
            link(lruEntry.n,lruEntry.p);

            \textcolor{keyword}{delete} lruHash[key];
          \}

          \textcolor{keyword}{delete} data[key];
          size--;
        \},


        removeAll: \textcolor{keyword}{function}() \{
          data = \{\};
          size = 0;
          lruHash = \{\};
          freshEnd = staleEnd = null;
        \},


        destroy: \textcolor{keyword}{function}() \{
          data = null;
          stats = null;
          lruHash = null;
          \textcolor{keyword}{delete} caches[cacheId];
        \},


        info: \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} extend(\{\}, stats, \{size: size\});
        \}
      \};


      \textcolor{keyword}{function} refresh(entry) \{
        \textcolor{keywordflow}{if} (entry != freshEnd) \{
          \textcolor{keywordflow}{if} (!staleEnd) \{
            staleEnd = entry;
          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (staleEnd == entry) \{
            staleEnd = entry.n;
          \}

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        \}
      \}


      \textcolor{keyword}{function} link(nextEntry, prevEntry) \{
        \textcolor{keywordflow}{if} (nextEntry != prevEntry) \{
          \textcolor{keywordflow}{if} (nextEntry) nextEntry.p = prevEntry; \textcolor{comment}{//p stands for previous, 'prev' didn't minify}
          \textcolor{keywordflow}{if} (prevEntry) prevEntry.n = nextEntry; \textcolor{comment}{//n stands for next, 'next' didn't minify}
        \}
      \}
    \}


    cacheFactory.info = \textcolor{keyword}{function}() \{
      var info = \{\};
      forEach(caches, \textcolor{keyword}{function}(cache, cacheId) \{
        info[cacheId] = cache.info();
      \});
      \textcolor{keywordflow}{return} info;
    \};


    cacheFactory.get = \textcolor{keyword}{function}(cacheId) \{
      \textcolor{keywordflow}{return} caches[cacheId];
    \};


    \textcolor{keywordflow}{return} cacheFactory;
  \};
\}

\textcolor{keyword}{function} $TemplateCacheProvider() \{
  this.$get = [\textcolor{stringliteral}{'$cacheFactory'}, \textcolor{keyword}{function}($cacheFactory) \{
    \textcolor{keywordflow}{return} $cacheFactory(\textcolor{stringliteral}{'templates'});
  \}];
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

\textcolor{comment}{/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!}
\textcolor{comment}{ *}
\textcolor{comment}{ * DOM-related variables:}
\textcolor{comment}{ *}
\textcolor{comment}{ * - "node" - DOM Node}
\textcolor{comment}{ * - "element" - DOM Element or Node}
\textcolor{comment}{ * - "$node" or "$element" - jqLite-wrapped node or element}
\textcolor{comment}{ *}
\textcolor{comment}{ *}
\textcolor{comment}{ * Compiler related stuff:}
\textcolor{comment}{ *}
\textcolor{comment}{ * - "linkFn" - linking fn of a single directive}
\textcolor{comment}{ * - "nodeLinkFn" - function that aggregates all linking fns for a particular node}
\textcolor{comment}{ * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node}
\textcolor{comment}{ * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)}
\textcolor{comment}{ */}


var $compileMinErr = minErr(\textcolor{stringliteral}{'$compile'});

$CompileProvider.$inject = [\textcolor{stringliteral}{'$provide'}, \textcolor{stringliteral}{'$$sanitizeUriProvider'}];
\textcolor{keyword}{function} $CompileProvider($provide, $$sanitizeUriProvider) \{
  var hasDirectives = \{\},
      Suffix = \textcolor{stringliteral}{'Directive'},
      COMMENT\_DIRECTIVE\_REGEXP = /^\(\backslash\)s*directive\(\backslash\):\(\backslash\)s*([\(\backslash\)w\(\backslash\)-]+)\(\backslash\)s+(.*)$/,
      CLASS\_DIRECTIVE\_REGEXP = /(([\(\backslash\)w\(\backslash\)-]+)(?:\(\backslash\):([^;]+))?;?)/,
      ALL\_OR\_NOTHING\_ATTRS = makeMap(\textcolor{stringliteral}{'ngSrc,ngSrcset,src,srcset'}),
      REQUIRE\_PREFIX\_REGEXP = /^(?:(\(\backslash\)^\(\backslash\)^?)?(\(\backslash\)?)?(\(\backslash\)^\(\backslash\)^?)?)?/;

  \textcolor{comment}{// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes}
  \textcolor{comment}{// The assumption is that future DOM event attribute names will begin with}
  \textcolor{comment}{// 'on' and be composed of only English letters.}
  var EVENT\_HANDLER\_ATTR\_REGEXP = /^(on[a-z]+|formaction)$/;

  \textcolor{keyword}{function} parseIsolateBindings(scope, directiveName, isController) \{
    var LOCAL\_REGEXP = /^\(\backslash\)s*([@&]|=(\(\backslash\)*?))(\(\backslash\)??)\(\backslash\)s*(\(\backslash\)w*)\(\backslash\)s*$/;

    var bindings = \{\};

    forEach(scope, \textcolor{keyword}{function}(definition, scopeName) \{
      var match = definition.match(LOCAL\_REGEXP);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'iscp'},
            \textcolor{stringliteral}{"Invalid \{3\} for directive '\{0\}'."} +
            \textcolor{stringliteral}{" Definition: \{... \{1\}: '\{2\}' ...\}"},
            directiveName, scopeName, definition,
            (isController ? \textcolor{stringliteral}{"controller bindings definition"} :
            \textcolor{stringliteral}{"isolate scope definition"}));
      \}

      bindings[scopeName] = \{
        mode: match[1][0],
        collection: match[2] === \textcolor{charliteral}{'*'},
        optional: match[3] === \textcolor{charliteral}{'?'},
        attrName: match[4] || scopeName
      \};
    \});

    \textcolor{keywordflow}{return} bindings;
  \}

  \textcolor{keyword}{function} parseDirectiveBindings(directive, directiveName) \{
    var bindings = \{
      isolateScope: null,
      bindToController: null
    \};
    \textcolor{keywordflow}{if} (isObject(directive.scope)) \{
      \textcolor{keywordflow}{if} (directive.bindToController === \textcolor{keyword}{true}) \{
        bindings.bindToController = parseIsolateBindings(directive.scope,
                                                         directiveName, \textcolor{keyword}{true});
        bindings.isolateScope = \{\};
      \} \textcolor{keywordflow}{else} \{
        bindings.isolateScope = parseIsolateBindings(directive.scope,
                                                     directiveName, \textcolor{keyword}{false});
      \}
    \}
    \textcolor{keywordflow}{if} (isObject(directive.bindToController)) \{
      bindings.bindToController =
          parseIsolateBindings(directive.bindToController, directiveName, \textcolor{keyword}{true});
    \}
    \textcolor{keywordflow}{if} (isObject(bindings.bindToController)) \{
      var controller = directive.controller;
      var controllerAs = directive.controllerAs;
      \textcolor{keywordflow}{if} (!controller) \{
        \textcolor{comment}{// There is no controller, there may or may not be a controllerAs property}
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'noctrl'},
              \textcolor{stringliteral}{"Cannot bind to controller without directive '\{0\}'s controller."},
              directiveName);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!identifierForController(controller, controllerAs)) \{
        \textcolor{comment}{// There is a controller, but no identifier or controllerAs property}
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'noident'},
              \textcolor{stringliteral}{"Cannot bind to controller without identifier for directive '\{0\}'."},
              directiveName);
      \}
    \}
    \textcolor{keywordflow}{return} bindings;
  \}

  \textcolor{keyword}{function} assertValidDirectiveName(name) \{
    var letter = name.charAt(0);
    \textcolor{keywordflow}{if} (!letter || letter !== lowercase(letter)) \{
      \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'baddir'}, \textcolor{stringliteral}{"Directive name '\{0\}' is invalid. The first character must be a
       lowercase letter"}, name);
    \}
    \textcolor{keywordflow}{if} (name !== name.trim()) \{
      \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'baddir'},
            \textcolor{stringliteral}{"Directive name '\{0\}' is invalid. The name should not contain leading or trailing whitespaces"},
            name);
    \}
  \}

   this.directive = \textcolor{keyword}{function} registerDirective(name, directiveFactory) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'directive'});
    \textcolor{keywordflow}{if} (isString(name)) \{
      assertValidDirectiveName(name);
      assertArg(directiveFactory, \textcolor{stringliteral}{'directiveFactory'});
      \textcolor{keywordflow}{if} (!hasDirectives.hasOwnProperty(name)) \{
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$exceptionHandler'},
          \textcolor{keyword}{function}($injector, $exceptionHandler) \{
            var directives = [];
            forEach(hasDirectives[name], \textcolor{keyword}{function}(directiveFactory, index) \{
              \textcolor{keywordflow}{try} \{
                var directive = $injector.invoke(directiveFactory);
                \textcolor{keywordflow}{if} (isFunction(directive)) \{
                  directive = \{ compile: valueFn(directive) \};
                \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!directive.compile && directive.link) \{
                  directive.compile = valueFn(directive.link);
                \}
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || \textcolor{stringliteral}{'EA'};
                var bindings = directive.$$bindings =
                    parseDirectiveBindings(directive, directive.name);
                \textcolor{keywordflow}{if} (isObject(bindings.isolateScope)) \{
                  directive.$$isolateBindings = bindings.isolateScope;
                \}
                directive.$$moduleName = directiveFactory.$$moduleName;
                directives.push(directive);
              \} \textcolor{keywordflow}{catch} (e) \{
                $exceptionHandler(e);
              \}
            \});
            \textcolor{keywordflow}{return} directives;
          \}]);
      \}
      hasDirectives[name].push(directiveFactory);
    \} \textcolor{keywordflow}{else} \{
      forEach(name, reverseParams(registerDirective));
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};


  this.aHrefSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    \}
  \};


  this.imgSrcSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    \}
  \};

  var debugInfoEnabled = \textcolor{keyword}{true};
  this.debugInfoEnabled = \textcolor{keyword}{function}(enabled) \{
    \textcolor{keywordflow}{if} (isDefined(enabled)) \{
      debugInfoEnabled = enabled;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} debugInfoEnabled;
  \};

  this.$get = [
            \textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$templateRequest'}, \textcolor{stringliteral}{'$parse'},
            \textcolor{stringliteral}{'$controller'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$document'}, \textcolor{stringliteral}{'$sce'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'$$sanitizeUri'},
    \textcolor{keyword}{function}($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) \{

    var Attributes = \textcolor{keyword}{function}(element, attributesToCopy) \{
      \textcolor{keywordflow}{if} (attributesToCopy) \{
        var keys = Object.keys(attributesToCopy);
        var i, l, key;

        \textcolor{keywordflow}{for} (i = 0, l = keys.length; i < l; i++) \{
          key = keys[i];
          \textcolor{keyword}{this}[key] = attributesToCopy[key];
        \}
      \} \textcolor{keywordflow}{else} \{
        this.$attr = \{\};
      \}

      this.$$element = element;
    \};

    Attributes.prototype = \{
      $normalize: directiveNormalize,


      $addClass: \textcolor{keyword}{function}(classVal) \{
        \textcolor{keywordflow}{if} (classVal && classVal.length > 0) \{
          $animate.addClass(this.$$element, classVal);
        \}
      \},

      $removeClass: \textcolor{keyword}{function}(classVal) \{
        \textcolor{keywordflow}{if} (classVal && classVal.length > 0) \{
          $animate.removeClass(this.$$element, classVal);
        \}
      \},

      $updateClass: \textcolor{keyword}{function}(newClasses, oldClasses) \{
        var toAdd = tokenDifference(newClasses, oldClasses);
        \textcolor{keywordflow}{if} (toAdd && toAdd.length) \{
          $animate.addClass(this.$$element, toAdd);
        \}

        var toRemove = tokenDifference(oldClasses, newClasses);
        \textcolor{keywordflow}{if} (toRemove && toRemove.length) \{
          $animate.removeClass(this.$$element, toRemove);
        \}
      \},

      $set: \textcolor{keyword}{function}(key, value, writeAttr, attrName) \{
        \textcolor{comment}{// TODO: decide whether or not to throw an error if "class"}
        \textcolor{comment}{//is set through this function since it may cause $updateClass to}
        \textcolor{comment}{//become unstable.}

        var node = this.$$element[0],
            booleanKey = getBooleanAttrName(node, key),
            aliasedKey = getAliasedAttrName(node, key),
            observer = key,
            nodeName;

        \textcolor{keywordflow}{if} (booleanKey) \{
          this.$$element.prop(key, value);
          attrName = booleanKey;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aliasedKey) \{
          \textcolor{keyword}{this}[aliasedKey] = value;
          observer = aliasedKey;
        \}

        \textcolor{keyword}{this}[key] = value;

        \textcolor{comment}{// translate normalized key to actual key}
        \textcolor{keywordflow}{if} (attrName) \{
          this.$attr[key] = attrName;
        \} \textcolor{keywordflow}{else} \{
          attrName = this.$attr[key];
          \textcolor{keywordflow}{if} (!attrName) \{
            this.$attr[key] = attrName = snake\_case(key, \textcolor{charliteral}{'-'});
          \}
        \}

        nodeName = nodeName\_(this.$$element);

        \textcolor{keywordflow}{if} ((nodeName === \textcolor{charliteral}{'a'} && key === \textcolor{stringliteral}{'href'}) ||
            (nodeName === \textcolor{stringliteral}{'img'} && key === \textcolor{stringliteral}{'src'})) \{
          \textcolor{comment}{// sanitize a[href] and img[src] values}
          \textcolor{keyword}{this}[key] = value = $$sanitizeUri(value, key === \textcolor{stringliteral}{'src'});
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nodeName === \textcolor{stringliteral}{'img'} && key === \textcolor{stringliteral}{'srcset'}) \{
          \textcolor{comment}{// sanitize img[srcset] values}
          var result = \textcolor{stringliteral}{""};

          \textcolor{comment}{// first check if there are spaces because it's not the same pattern}
          var trimmedSrcset = trim(value);
          \textcolor{comment}{//                (   999x   ,|   999w   ,|   ,|,   )}
          var srcPattern = /(\(\backslash\)s+\(\backslash\)d+x\(\backslash\)s*,|\(\backslash\)s+\(\backslash\)d+w\(\backslash\)s*,|\(\backslash\)s+,|,\(\backslash\)s+)/;
          var pattern = /\(\backslash\)s/.test(trimmedSrcset) ? srcPattern : /(,)/;

          \textcolor{comment}{// split srcset into tuple of uri and descriptor except for the last item}
          var rawUris = trimmedSrcset.split(pattern);

          \textcolor{comment}{// for each tuples}
          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
          \textcolor{keywordflow}{for} (var i = 0; i < nbrUrisWith2parts; i++) \{
            var innerIdx = i * 2;
            \textcolor{comment}{// sanitize the uri}
            result += $$sanitizeUri(trim(rawUris[innerIdx]), \textcolor{keyword}{true});
            \textcolor{comment}{// add the descriptor}
            result += (\textcolor{stringliteral}{" "} + trim(rawUris[innerIdx + 1]));
          \}

          \textcolor{comment}{// split the last item into uri and descriptor}
          var lastTuple = trim(rawUris[i * 2]).split(/\(\backslash\)s/);

          \textcolor{comment}{// sanitize the last uri}
          result += $$sanitizeUri(trim(lastTuple[0]), \textcolor{keyword}{true});

          \textcolor{comment}{// and add the last descriptor if any}
          \textcolor{keywordflow}{if} (lastTuple.length === 2) \{
            result += (\textcolor{stringliteral}{" "} + trim(lastTuple[1]));
          \}
          \textcolor{keyword}{this}[key] = value = result;
        \}

        \textcolor{keywordflow}{if} (writeAttr !== \textcolor{keyword}{false}) \{
          \textcolor{keywordflow}{if} (value === null || value === undefined) \{
            this.$$element.removeAttr(attrName);
          \} \textcolor{keywordflow}{else} \{
            this.$$element.attr(attrName, value);
          \}
        \}

        \textcolor{comment}{// fire observers}
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[observer], \textcolor{keyword}{function}(fn) \{
          \textcolor{keywordflow}{try} \{
            fn(value);
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
          \}
        \});
      \},


      $observe: \textcolor{keyword}{function}(key, fn) \{
        var attrs = \textcolor{keyword}{this},
            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) \{
            \textcolor{comment}{// no one registered attribute interpolation function, so lets call it manually}
            fn(attrs[key]);
          \}
        \});

        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          arrayRemove(listeners, fn);
        \};
      \}
    \};


    \textcolor{keyword}{function} safeAddClass($element, className) \{
      \textcolor{keywordflow}{try} \{
        $element.addClass(className);
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{comment}{// ignore, since it means that we are trying to set class on}
        \textcolor{comment}{// SVG element, where class name is read-only.}
      \}
    \}


    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == \textcolor{stringliteral}{'\{\{'} || endSymbol  == \textcolor{stringliteral}{'\}\}'})
            ? identity
            : \textcolor{keyword}{function} denormalizeTemplate(\textcolor{keyword}{template}) \{
              \textcolor{keywordflow}{return} \textcolor{keyword}{template}.replace(/\(\backslash\)\{\(\backslash\)\{/g, startSymbol).replace(/\}\}/g, endSymbol);
        \},
        NG\_ATTR\_BINDING = /^ngAttr[A-Z]/;

    compile.$$addBindingInfo = debugInfoEnabled ? \textcolor{keyword}{function} $$addBindingInfo($element, binding) \{
      var bindings = $element.data(\textcolor{stringliteral}{'$binding'}) || [];

      \textcolor{keywordflow}{if} (isArray(binding)) \{
        bindings = bindings.concat(binding);
      \} \textcolor{keywordflow}{else} \{
        bindings.push(binding);
      \}

      $element.data(\textcolor{stringliteral}{'$binding'}, bindings);
    \} : noop;

    compile.$$addBindingClass = debugInfoEnabled ? \textcolor{keyword}{function} $$addBindingClass($element) \{
      safeAddClass($element, \textcolor{stringliteral}{'ng-binding'});
    \} : noop;

    compile.$$addScopeInfo = debugInfoEnabled ? \textcolor{keyword}{function} $$addScopeInfo($element, scope, isolated, 
      noTemplate) \{
      var dataName = isolated ? (noTemplate ? \textcolor{stringliteral}{'$isolateScopeNoTemplate'} : \textcolor{stringliteral}{'$isolateScope'}) : \textcolor{stringliteral}{'$scope'};
      $element.data(dataName, scope);
    \} : noop;

    compile.$$addScopeClass = debugInfoEnabled ? \textcolor{keyword}{function} $$addScopeClass($element, isolated) \{
      safeAddClass($element, isolated ? \textcolor{stringliteral}{'ng-isolate-scope'} : \textcolor{stringliteral}{'ng-scope'});
    \} : noop;

    \textcolor{keywordflow}{return} compile;

    \textcolor{comment}{//================================}

    \textcolor{keyword}{function} compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) \{
      \textcolor{keywordflow}{if} (!($compileNodes instanceof jqLite)) \{
        \textcolor{comment}{// jquery always rewraps, whereas we need to preserve the original selector so that we can}
        \textcolor{comment}{// modify it.}
        $compileNodes = jqLite($compileNodes);
      \}
      \textcolor{comment}{// We can not compile top level text elements since text nodes can be merged and we will}
      \textcolor{comment}{// not be able to attach scope data to them, so we will wrap them in <span>}
      forEach($compileNodes, \textcolor{keyword}{function}(node, index) \{
        \textcolor{keywordflow}{if} (node.nodeType == NODE\_TYPE\_TEXT && node.nodeValue.match(/\(\backslash\)S+/) \textcolor{comment}{/* non-empty */} ) \{
          $compileNodes[index] = jqLite(node).wrap(\textcolor{stringliteral}{'<span></span>'}).parent()[0];
        \}
      \});
      var compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      compile.$$addScopeClass($compileNodes);
      var \textcolor{keyword}{namespace }= null;
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} publicLinkFn(scope, cloneConnectFn, options) \{
        assertArg(scope, \textcolor{stringliteral}{'scope'});

        options = options || \{\};
        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
          transcludeControllers = options.transcludeControllers,
          futureParentElement = options.futureParentElement;

        \textcolor{comment}{// When `parentBoundTranscludeFn` is passed, it is a}
        \textcolor{comment}{// `controllersBoundTransclude` function (it was previously passed}
        \textcolor{comment}{// as `transclude` to directive.link) so we must unwrap it to get}
        \textcolor{comment}{// its `boundTranscludeFn`}
        \textcolor{keywordflow}{if} (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) \{
          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
        \}

        \textcolor{keywordflow}{if} (!\textcolor{keyword}{namespace}) \{
          \textcolor{keyword}{namespace }= detectNamespaceForChildElements(futureParentElement);
        \}
        var $linkNode;
        \textcolor{keywordflow}{if} (\textcolor{keyword}{namespace} !== \textcolor{stringliteral}{'html'}) \{
          \textcolor{comment}{// When using a directive with replace:true and templateUrl the $compileNodes}
          \textcolor{comment}{// (or a child element inside of them)}
          \textcolor{comment}{// might change, so we need to recreate the namespace adapted compileNodes}
          \textcolor{comment}{// for call to the link function.}
          \textcolor{comment}{// Note: This will already clone the nodes...}
          $linkNode = jqLite(
            wrapTemplate(\textcolor{keyword}{namespace}, jqLite(\textcolor{stringliteral}{'<div>'}).append($compileNodes).html())
          );
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cloneConnectFn) \{
          \textcolor{comment}{// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart}
          \textcolor{comment}{// and sometimes changes the structure of the DOM.}
          $linkNode = JQLitePrototype.clone.call($compileNodes);
        \} \textcolor{keywordflow}{else} \{
          $linkNode = $compileNodes;
        \}

        \textcolor{keywordflow}{if} (transcludeControllers) \{
          \textcolor{keywordflow}{for} (var controllerName in transcludeControllers) \{
            $linkNode.data(\textcolor{charliteral}{'$'} + controllerName + \textcolor{stringliteral}{'Controller'}, transcludeControllers[controllerName].
      instance);
          \}
        \}

        compile.$$addScopeInfo($linkNode, scope);

        \textcolor{keywordflow}{if} (cloneConnectFn) cloneConnectFn($linkNode, scope);
        \textcolor{keywordflow}{if} (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
        \textcolor{keywordflow}{return} $linkNode;
      \};
    \}

    \textcolor{keyword}{function} detectNamespaceForChildElements(parentElement) \{
      \textcolor{comment}{// TODO: Make this detect MathML as well...}
      var node = parentElement && parentElement[0];
      \textcolor{keywordflow}{if} (!node) \{
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{'html'};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} nodeName\_(node) !== \textcolor{stringliteral}{'foreignobject'} && node.toString().match(/SVG/) ? \textcolor{stringliteral}{'svg'} : \textcolor{stringliteral}{'html'};
      \}
    \}

    \textcolor{keyword}{function} compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) \{
      var linkFns = [],
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;

      \textcolor{keywordflow}{for} (var i = 0; i < nodeList.length; i++) \{
        attrs = \textcolor{keyword}{new} Attributes();

        \textcolor{comment}{// we must always refer to nodeList[i] since the nodes can be replaced underneath us.}
        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                                      null, [], [], previousCompileContext)
            : null;

        \textcolor{keywordflow}{if} (nodeLinkFn && nodeLinkFn.scope) \{
          compile.$$addScopeClass(attrs.$$element);
        \}

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                      !(childNodes = nodeList[i].childNodes) ||
                      !childNodes.length)
            ? null
            : compileNodes(childNodes,
                 nodeLinkFn ? (
                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
                     && nodeLinkFn.transclude) : transcludeFn);

        \textcolor{keywordflow}{if} (nodeLinkFn || childLinkFn) \{
          linkFns.push(i, nodeLinkFn, childLinkFn);
          linkFnFound = \textcolor{keyword}{true};
          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
        \}

        \textcolor{comment}{//use the previous context only for the first element in the virtual group}
        previousCompileContext = null;
      \}

      \textcolor{comment}{// return a linking function if we have found anything, null otherwise}
      \textcolor{keywordflow}{return} linkFnFound ? compositeLinkFn : null;

      \textcolor{keyword}{function} compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) \{
        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
        var stableNodeList;


        \textcolor{keywordflow}{if} (nodeLinkFnFound) \{
          \textcolor{comment}{// copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our}
          \textcolor{comment}{// offsets don't get screwed up}
          var nodeListLength = nodeList.length;
          stableNodeList = \textcolor{keyword}{new} Array(nodeListLength);

          \textcolor{comment}{// create a sparse array by only copying the elements which have a linkFn}
          \textcolor{keywordflow}{for} (i = 0; i < linkFns.length; i+=3) \{
            idx = linkFns[i];
            stableNodeList[idx] = nodeList[idx];
          \}
        \} \textcolor{keywordflow}{else} \{
          stableNodeList = nodeList;
        \}

        \textcolor{keywordflow}{for} (i = 0, ii = linkFns.length; i < ii;) \{
          node = stableNodeList[linkFns[i++]];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          \textcolor{keywordflow}{if} (nodeLinkFn) \{
            \textcolor{keywordflow}{if} (nodeLinkFn.scope) \{
              childScope = scope.$new();
              compile.$$addScopeInfo(jqLite(node), childScope);
              var destroyBindings = nodeLinkFn.$$destroyBindings;
              \textcolor{keywordflow}{if} (destroyBindings) \{
                nodeLinkFn.$$destroyBindings = null;
                childScope.$on(\textcolor{stringliteral}{'$destroyed'}, destroyBindings);
              \}
            \} \textcolor{keywordflow}{else} \{
              childScope = scope;
            \}

            \textcolor{keywordflow}{if} (nodeLinkFn.transcludeOnThisElement) \{
              childBoundTranscludeFn = createBoundTranscludeFn(
                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) \{
              childBoundTranscludeFn = parentBoundTranscludeFn;

            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!parentBoundTranscludeFn && transcludeFn) \{
              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);

            \} \textcolor{keywordflow}{else} \{
              childBoundTranscludeFn = null;
            \}

            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn,
                       nodeLinkFn);

          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (childLinkFn) \{
            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
          \}
        \}
      \}
    \}

    \textcolor{keyword}{function} createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) \{

      var boundTranscludeFn = \textcolor{keyword}{function}(transcludedScope, cloneFn, controllers, futureParentElement, 
      containingScope) \{

        \textcolor{keywordflow}{if} (!transcludedScope) \{
          transcludedScope = scope.$new(\textcolor{keyword}{false}, containingScope);
          transcludedScope.$$transcluded = \textcolor{keyword}{true};
        \}

        \textcolor{keywordflow}{return} transcludeFn(transcludedScope, cloneFn, \{
          parentBoundTranscludeFn: previousBoundTranscludeFn,
          transcludeControllers: controllers,
          futureParentElement: futureParentElement
        \});
      \};

      \textcolor{keywordflow}{return} boundTranscludeFn;
    \}

    \textcolor{keyword}{function} collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) \{
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      \textcolor{keywordflow}{switch} (nodeType) \{
        \textcolor{keywordflow}{case} NODE\_TYPE\_ELEMENT: \textcolor{comment}{/* Element */}
          \textcolor{comment}{// use the node name: <directive>}
          addDirective(directives,
              directiveNormalize(nodeName\_(node)), \textcolor{charliteral}{'E'}, maxPriority, ignoreDirective);

          \textcolor{comment}{// iterate over the attributes}
          \textcolor{keywordflow}{for} (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) \{
            var attrStartName = \textcolor{keyword}{false};
            var attrEndName = \textcolor{keyword}{false};

            attr = nAttrs[j];
            name = attr.name;
            value = trim(attr.value);

            \textcolor{comment}{// support ngAttr attribute binding}
            ngAttrName = directiveNormalize(name);
            \textcolor{keywordflow}{if} (isNgAttr = NG\_ATTR\_BINDING.test(ngAttrName)) \{
              name = name.replace(PREFIX\_REGEXP, \textcolor{stringliteral}{''})
                .substr(8).replace(/\_(.)/g, \textcolor{keyword}{function}(match, letter) \{
                  \textcolor{keywordflow}{return} letter.toUpperCase();
                \});
            \}

            var directiveNName = ngAttrName.replace(/(Start|End)$/, \textcolor{stringliteral}{''});
            \textcolor{keywordflow}{if} (directiveIsMultiElement(directiveNName)) \{
              \textcolor{keywordflow}{if} (ngAttrName === directiveNName + \textcolor{stringliteral}{'Start'}) \{
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + \textcolor{stringliteral}{'end'};
                name = name.substr(0, name.length - 6);
              \}
            \}

            nName = directiveNormalize(name.toLowerCase());
            attrsMap[nName] = name;
            \textcolor{keywordflow}{if} (isNgAttr || !attrs.hasOwnProperty(nName)) \{
                attrs[nName] = value;
                \textcolor{keywordflow}{if} (getBooleanAttrName(node, nName)) \{
                  attrs[nName] = \textcolor{keyword}{true}; \textcolor{comment}{// presence means true}
                \}
            \}
            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
            addDirective(directives, nName, \textcolor{charliteral}{'A'}, maxPriority, ignoreDirective, attrStartName,
                          attrEndName);
          \}

          \textcolor{comment}{// use class as directive}
          className = node.className;
          \textcolor{keywordflow}{if} (isObject(className)) \{
              \textcolor{comment}{// Maybe SVGAnimatedString}
              className = className.animVal;
          \}
          \textcolor{keywordflow}{if} (isString(className) && className !== \textcolor{stringliteral}{''}) \{
            \textcolor{keywordflow}{while} (match = CLASS\_DIRECTIVE\_REGEXP.exec(className)) \{
              nName = directiveNormalize(match[2]);
              \textcolor{keywordflow}{if} (addDirective(directives, nName, \textcolor{charliteral}{'C'}, maxPriority, ignoreDirective)) \{
                attrs[nName] = trim(match[3]);
              \}
              className = className.substr(match.index + match[0].length);
            \}
          \}
          \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} NODE\_TYPE\_TEXT: \textcolor{comment}{/* Text Node */}
          \textcolor{keywordflow}{if} (msie === 11) \{
            \textcolor{comment}{// Workaround for #11781}
            \textcolor{keywordflow}{while} (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE\_TYPE\_TEXT) \{
              node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
              node.parentNode.removeChild(node.nextSibling);
            \}
          \}
          addTextInterpolateDirective(directives, node.nodeValue);
          \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} NODE\_TYPE\_COMMENT: \textcolor{comment}{/* Comment */}
          \textcolor{keywordflow}{try} \{
            match = COMMENT\_DIRECTIVE\_REGEXP.exec(node.nodeValue);
            \textcolor{keywordflow}{if} (match) \{
              nName = directiveNormalize(match[1]);
              \textcolor{keywordflow}{if} (addDirective(directives, nName, \textcolor{charliteral}{'M'}, maxPriority, ignoreDirective)) \{
                attrs[nName] = trim(match[2]);
              \}
            \}
          \} \textcolor{keywordflow}{catch} (e) \{
            \textcolor{comment}{// turns out that under some circumstances IE9 throws errors when one attempts to read}
            \textcolor{comment}{// comment's node value.}
            \textcolor{comment}{// Just ignore it and continue. (Can't seem to reproduce in test case.)}
          \}
          \textcolor{keywordflow}{break};
      \}

      directives.sort(byPriority);
      \textcolor{keywordflow}{return} directives;
    \}

    \textcolor{keyword}{function} groupScan(node, attrStart, attrEnd) \{
      var nodes = [];
      var depth = 0;
      \textcolor{keywordflow}{if} (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) \{
        \textcolor{keywordflow}{do} \{
          \textcolor{keywordflow}{if} (!node) \{
            \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'uterdir'},
                      \textcolor{stringliteral}{"Unterminated attribute, found '\{0\}' but no matching '\{1\}' found."},
                      attrStart, attrEnd);
          \}
          \textcolor{keywordflow}{if} (node.nodeType == NODE\_TYPE\_ELEMENT) \{
            \textcolor{keywordflow}{if} (node.hasAttribute(attrStart)) depth++;
            \textcolor{keywordflow}{if} (node.hasAttribute(attrEnd)) depth--;
          \}
          nodes.push(node);
          node = node.nextSibling;
        \} \textcolor{keywordflow}{while} (depth > 0);
      \} \textcolor{keywordflow}{else} \{
        nodes.push(node);
      \}

      \textcolor{keywordflow}{return} jqLite(nodes);
    \}

    \textcolor{keyword}{function} groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element, attrs, controllers, transcludeFn) \{
        element = groupScan(element[0], attrStart, attrEnd);
        \textcolor{keywordflow}{return} linkFn(scope, element, attrs, controllers, transcludeFn);
      \};
    \}

    \textcolor{keyword}{function} applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) \{
      previousCompileContext = previousCompileContext || \{\};

      var terminalPriority = -Number.MAX\_VALUE,
          newScopeDirective = previousCompileContext.newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = \textcolor{keyword}{false},
          hasTemplate = \textcolor{keyword}{false},
          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      \textcolor{comment}{// executes all directives on the current element}
      \textcolor{keywordflow}{for} (var i = 0, ii = directives.length; i < ii; i++) \{
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        \textcolor{comment}{// collect multiblock sections}
        \textcolor{keywordflow}{if} (attrStart) \{
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        \}
        $template = undefined;

        \textcolor{keywordflow}{if} (terminalPriority > directive.priority) \{
          \textcolor{keywordflow}{break}; \textcolor{comment}{// prevent further processing of directives}
        \}

        \textcolor{keywordflow}{if} (directiveValue = directive.scope) \{

          \textcolor{comment}{// skip the check for directives with async templates, we'll check the derived sync}
          \textcolor{comment}{// directive when the template arrives}
          \textcolor{keywordflow}{if} (!directive.templateUrl) \{
            \textcolor{keywordflow}{if} (isObject(directiveValue)) \{
              \textcolor{comment}{// This directive is trying to add an isolated scope.}
              \textcolor{comment}{// Check that there is no scope of any kind already}
              assertNoDuplicate(\textcolor{stringliteral}{'new/isolated scope'}, newIsolateScopeDirective || newScopeDirective,
                                directive, $compileNode);
              newIsolateScopeDirective = directive;
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// This directive is trying to add a child scope.}
              \textcolor{comment}{// Check that there is no isolated scope already}
              assertNoDuplicate(\textcolor{stringliteral}{'new/isolated scope'}, newIsolateScopeDirective, directive,
                                $compileNode);
            \}
          \}

          newScopeDirective = newScopeDirective || directive;
        \}

        directiveName = directive.name;

        \textcolor{keywordflow}{if} (!directive.templateUrl && directive.controller) \{
          directiveValue = directive.controller;
          controllerDirectives = controllerDirectives || createMap();
          assertNoDuplicate(\textcolor{stringliteral}{"'"} + directiveName + \textcolor{stringliteral}{"' controller"},
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        \}

        \textcolor{keywordflow}{if} (directiveValue = directive.transclude) \{
          hasTranscludeDirective = \textcolor{keyword}{true};

          \textcolor{comment}{// Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.}
          \textcolor{comment}{// This option should only be used by directives that know how to safely handle element
       transclusion,}
          \textcolor{comment}{// where the transcluded nodes are added or replaced after linking.}
          \textcolor{keywordflow}{if} (!directive.$$tlb) \{
            assertNoDuplicate(\textcolor{stringliteral}{'transclusion'}, nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          \}

          \textcolor{keywordflow}{if} (directiveValue == \textcolor{stringliteral}{'element'}) \{
            hasElementTranscludeDirective = \textcolor{keyword}{true};
            terminalPriority = directive.priority;
            $template = $compileNode;
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(\textcolor{charliteral}{' '} + directiveName + \textcolor{stringliteral}{': '} +
                                              templateAttrs[directiveName] + \textcolor{charliteral}{' '}));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, sliceArgs($template), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name, \{
                                          \textcolor{comment}{// Don't pass in:}
                                          \textcolor{comment}{// - controllerDirectives - otherwise we'll create duplicates
       controllers}
                                          \textcolor{comment}{// - newIsolateScopeDirective or templateDirective - combining
       templates with}
                                          \textcolor{comment}{//   element transclusion doesn't make sense.}
                                          \textcolor{comment}{//}
                                          \textcolor{comment}{// We need only nonTlbTranscludeDirective so that we prevent
       putting transclusion}
                                          \textcolor{comment}{// on the same element more than once.}
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        \});
          \} \textcolor{keywordflow}{else} \{
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.empty(); \textcolor{comment}{// clear contents}
            childTranscludeFn = compile($template, transcludeFn);
          \}
        \}

        \textcolor{keywordflow}{if} (directive.template) \{
          hasTemplate = \textcolor{keyword}{true};
          assertNoDuplicate(\textcolor{stringliteral}{'template'}, templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          \textcolor{keywordflow}{if} (directive.replace) \{
            replaceDirective = directive;
            \textcolor{keywordflow}{if} (jqLiteIsTextNode(directiveValue)) \{
              $template = [];
            \} \textcolor{keywordflow}{else} \{
              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
            \}
            compileNode = $template[0];

            \textcolor{keywordflow}{if} ($template.length != 1 || compileNode.nodeType !== NODE\_TYPE\_ELEMENT) \{
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tplrt'},
                  \textcolor{stringliteral}{"Template for directive '\{0\}' must have exactly one root element. \{1\}"},
                  directiveName, \textcolor{stringliteral}{''});
            \}

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = \{$attr: \{\}\};

            \textcolor{comment}{// combine directives from the original node and from the template:}
            \textcolor{comment}{// - take the array of directives for this element}
            \textcolor{comment}{// - split it into two parts, those that already applied (processed) and those that weren't
       (unprocessed)}
            \textcolor{comment}{// - collect directives from the template and sort them by priority}
            \textcolor{comment}{// - combine directives as: processed + template + unprocessed}
            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));

            \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
              markDirectivesAsIsolate(templateDirectives);
            \}
            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          \} \textcolor{keywordflow}{else} \{
            $compileNode.html(directiveValue);
          \}
        \}

        \textcolor{keywordflow}{if} (directive.templateUrl) \{
          hasTemplate = \textcolor{keyword}{true};
          assertNoDuplicate(\textcolor{stringliteral}{'template'}, templateDirective, directive, $compileNode);
          templateDirective = directive;

          \textcolor{keywordflow}{if} (directive.replace) \{
            replaceDirective = directive;
          \}

          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
              templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, 
      postLinkFns, \{
                controllerDirectives: controllerDirectives,
                newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              \});
          ii = directives.length;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (directive.compile) \{
          \textcolor{keywordflow}{try} \{
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            \textcolor{keywordflow}{if} (isFunction(linkFn)) \{
              addLinkFns(null, linkFn, attrStart, attrEnd);
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (linkFn) \{
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            \}
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e, startingTag($compileNode));
          \}
        \}

        \textcolor{keywordflow}{if} (directive.terminal) \{
          nodeLinkFn.terminal = \textcolor{keyword}{true};
          terminalPriority = Math.max(terminalPriority, directive.priority);
        \}

      \}

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === \textcolor{keyword}{true};
      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
      nodeLinkFn.templateOnThisElement = hasTemplate;
      nodeLinkFn.transclude = childTranscludeFn;

      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;

      \textcolor{comment}{// might be normal or delayed nodeLinkFn depending on if templateUrl is present}
      \textcolor{keywordflow}{return} nodeLinkFn;


      \textcolor{keyword}{function} addLinkFns(pre, post, attrStart, attrEnd) \{
        \textcolor{keywordflow}{if} (pre) \{
          \textcolor{keywordflow}{if} (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          pre.directiveName = directiveName;
          \textcolor{keywordflow}{if} (newIsolateScopeDirective === directive || directive.$$isolateScope) \{
            pre = cloneAndAnnotateFn(pre, \{isolateScope: \textcolor{keyword}{true}\});
          \}
          preLinkFns.push(pre);
        \}
        \textcolor{keywordflow}{if} (post) \{
          \textcolor{keywordflow}{if} (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          post.directiveName = directiveName;
          \textcolor{keywordflow}{if} (newIsolateScopeDirective === directive || directive.$$isolateScope) \{
            post = cloneAndAnnotateFn(post, \{isolateScope: \textcolor{keyword}{true}\});
          \}
          postLinkFns.push(post);
        \}
      \}


      \textcolor{keyword}{function} getControllers(directiveName, require, $element, elementControllers) \{
        var value;

        \textcolor{keywordflow}{if} (isString(require)) \{
          var match = require.match(REQUIRE\_PREFIX\_REGEXP);
          var name = require.substring(match[0].length);
          var inheritType = match[1] || match[3];
          var optional = match[2] === \textcolor{charliteral}{'?'};

          \textcolor{comment}{//If only parents then start at the parent element}
          \textcolor{keywordflow}{if} (inheritType === \textcolor{stringliteral}{'^^'}) \{
            $element = $element.parent();
          \textcolor{comment}{//Otherwise attempt getting the controller from elementControllers in case}
          \textcolor{comment}{//the element is transcluded (and has no data) and to avoid .data if possible}
          \} \textcolor{keywordflow}{else} \{
            value = elementControllers && elementControllers[name];
            value = value && value.instance;
          \}

          \textcolor{keywordflow}{if} (!value) \{
            var dataName = \textcolor{charliteral}{'$'} + name + \textcolor{stringliteral}{'Controller'};
            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
          \}

          \textcolor{keywordflow}{if} (!value && !optional) \{
            \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'ctreq'},
                \textcolor{stringliteral}{"Controller '\{0\}', required by directive '\{1\}', can't be found!"},
                name, directiveName);
          \}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(require)) \{
          value = [];
          \textcolor{keywordflow}{for} (var i = 0, ii = require.length; i < ii; i++) \{
            value[i] = getControllers(directiveName, require[i], $element, elementControllers);
          \}
        \}

        \textcolor{keywordflow}{return} value || null;
      \}

      \textcolor{keyword}{function} setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) \{
        var elementControllers = createMap();
        \textcolor{keywordflow}{for} (var controllerKey in controllerDirectives) \{
          var directive = controllerDirectives[controllerKey];
          var locals = \{
            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : 
      scope,
            $element: $element,
            $attrs: attrs,
            $transclude: transcludeFn
          \};

          var controller = directive.controller;
          \textcolor{keywordflow}{if} (controller == \textcolor{charliteral}{'@'}) \{
            controller = attrs[directive.name];
          \}

          var controllerInstance = $controller(controller, locals, \textcolor{keyword}{true}, directive.controllerAs);

          \textcolor{comment}{// For directives with element transclusion the element is a comment,}
          \textcolor{comment}{// but jQuery .data doesn't support attaching data to comment nodes as it's hard to}
          \textcolor{comment}{// clean up (http://bugs.jquery.com/ticket/8335).}
          \textcolor{comment}{// Instead, we save the controllers for the element in a local hash and attach to .data}
          \textcolor{comment}{// later, once we have the actual element.}
          elementControllers[directive.name] = controllerInstance;
          \textcolor{keywordflow}{if} (!hasElementTranscludeDirective) \{
            $element.data(\textcolor{charliteral}{'$'} + directive.name + \textcolor{stringliteral}{'Controller'}, controllerInstance.instance);
          \}
        \}
        \textcolor{keywordflow}{return} elementControllers;
      \}

      \textcolor{keyword}{function} nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn,
                          thisLinkFn) \{
        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,
            attrs;

        \textcolor{keywordflow}{if} (compileNode === linkNode) \{
          attrs = templateAttrs;
          $element = templateAttrs.$$element;
        \} \textcolor{keywordflow}{else} \{
          $element = jqLite(linkNode);
          attrs = \textcolor{keyword}{new} Attributes($element, templateAttrs);
        \}

        \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
          isolateScope = scope.$new(\textcolor{keyword}{true});
        \}

        \textcolor{keywordflow}{if} (boundTranscludeFn) \{
          \textcolor{comment}{// track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`}
          \textcolor{comment}{// is later passed as `parentBoundTranscludeFn` to `publicLinkFn`}
          transcludeFn = controllersBoundTransclude;
          transcludeFn.$$boundTransclude = boundTranscludeFn;
        \}

        \textcolor{keywordflow}{if} (controllerDirectives) \{
          elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, 
      isolateScope, scope);
        \}

        \textcolor{keywordflow}{if} (newIsolateScopeDirective) \{
          \textcolor{comment}{// Initialize isolate scope bindings for new isolate scope directive.}
          compile.$$addScopeInfo($element, isolateScope, \textcolor{keyword}{true}, !(templateDirective && (templateDirective ==
      = newIsolateScopeDirective ||
              templateDirective === newIsolateScopeDirective.$$originalDirective)));
          compile.$$addScopeClass($element, \textcolor{keyword}{true});
          isolateScope.$$isolateBindings =
              newIsolateScopeDirective.$$isolateBindings;
          initializeDirectiveBindings(scope, attrs, isolateScope,
                                      isolateScope.$$isolateBindings,
                                      newIsolateScopeDirective, isolateScope);
        \}
        \textcolor{keywordflow}{if} (elementControllers) \{
          \textcolor{comment}{// Initialize bindToController bindings for new/isolate scopes}
          var scopeDirective = newIsolateScopeDirective || newScopeDirective;
          var bindings;
          var controllerForBindings;
          \textcolor{keywordflow}{if} (scopeDirective && elementControllers[scopeDirective.name]) \{
            bindings = scopeDirective.$$bindings.bindToController;
            controller = elementControllers[scopeDirective.name];

            \textcolor{keywordflow}{if} (controller && controller.identifier && bindings) \{
              controllerForBindings = controller;
              thisLinkFn.$$destroyBindings =
                  initializeDirectiveBindings(scope, attrs, controller.instance,
                                              bindings, scopeDirective);
            \}
          \}
          \textcolor{keywordflow}{for} (i in elementControllers) \{
            controller = elementControllers[i];
            var controllerResult = controller();

            \textcolor{keywordflow}{if} (controllerResult !== controller.instance) \{
              \textcolor{comment}{// If the controller constructor has a return value, overwrite the instance}
              \textcolor{comment}{// from setupControllers and update the element data}
              controller.instance = controllerResult;
              $element.data(\textcolor{charliteral}{'$'} + i + \textcolor{stringliteral}{'Controller'}, controllerResult);
              \textcolor{keywordflow}{if} (controller === controllerForBindings) \{
                \textcolor{comment}{// Remove and re-install bindToController bindings}
                thisLinkFn.$$destroyBindings();
                thisLinkFn.$$destroyBindings =
                  initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
              \}
            \}
          \}
        \}

        \textcolor{comment}{// PRELINKING}
        \textcolor{keywordflow}{for} (i = 0, ii = preLinkFns.length; i < ii; i++) \{
          linkFn = preLinkFns[i];
          invokeLinkFn(linkFn,
              linkFn.isolateScope ? isolateScope : scope,
              $element,
              attrs,
              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, 
      elementControllers),
              transcludeFn
          );
        \}

        \textcolor{comment}{// RECURSION}
        \textcolor{comment}{// We only pass the isolate scope, if the isolate directive has a template,}
        \textcolor{comment}{// otherwise the child elements do not belong to the isolate directive.}
        var scopeToChild = scope;
        \textcolor{keywordflow}{if} (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.
      templateUrl === null)) \{
          scopeToChild = isolateScope;
        \}
        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);

        \textcolor{comment}{// POSTLINKING}
        \textcolor{keywordflow}{for} (i = postLinkFns.length - 1; i >= 0; i--) \{
          linkFn = postLinkFns[i];
          invokeLinkFn(linkFn,
              linkFn.isolateScope ? isolateScope : scope,
              $element,
              attrs,
              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, 
      elementControllers),
              transcludeFn
          );
        \}

        \textcolor{comment}{// This is the function that is injected as `$transclude`.}
        \textcolor{comment}{// Note: all arguments are optional!}
        \textcolor{keyword}{function} controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) \{
          var transcludeControllers;

          \textcolor{comment}{// No scope passed in:}
          \textcolor{keywordflow}{if} (!isScope(scope)) \{
            futureParentElement = cloneAttachFn;
            cloneAttachFn = scope;
            scope = undefined;
          \}

          \textcolor{keywordflow}{if} (hasElementTranscludeDirective) \{
            transcludeControllers = elementControllers;
          \}
          \textcolor{keywordflow}{if} (!futureParentElement) \{
            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
          \}
          \textcolor{keywordflow}{return} boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, 
      scopeToChild);
        \}
      \}
    \}

    \textcolor{keyword}{function} markDirectivesAsIsolate(directives) \{
      \textcolor{comment}{// mark all directives as needing isolate scope.}
      \textcolor{keywordflow}{for} (var j = 0, jj = directives.length; j < jj; j++) \{
        directives[j] = inherit(directives[j], \{$$isolateScope: \textcolor{keyword}{true}\});
      \}
    \}

    \textcolor{keyword}{function} addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
                          endAttrName) \{
      \textcolor{keywordflow}{if} (name === ignoreDirective) \textcolor{keywordflow}{return} null;
      var match = null;
      \textcolor{keywordflow}{if} (hasDirectives.hasOwnProperty(name)) \{
        \textcolor{keywordflow}{for} (var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i < ii; i++) \{
          \textcolor{keywordflow}{try} \{
            directive = directives[i];
            \textcolor{keywordflow}{if} ((maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) \{
              \textcolor{keywordflow}{if} (startAttrName) \{
                directive = inherit(directive, \{$$start: startAttrName, $$end: endAttrName\});
              \}
              tDirectives.push(directive);
              match = directive;
            \}
          \} \textcolor{keywordflow}{catch} (e) \{ $exceptionHandler(e); \}
        \}
      \}
      \textcolor{keywordflow}{return} match;
    \}


    \textcolor{keyword}{function} directiveIsMultiElement(name) \{
      \textcolor{keywordflow}{if} (hasDirectives.hasOwnProperty(name)) \{
        \textcolor{keywordflow}{for} (var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i < ii; i++) \{
          directive = directives[i];
          \textcolor{keywordflow}{if} (directive.multiElement) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}

    \textcolor{keyword}{function} mergeTemplateAttributes(dst, src) \{
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      \textcolor{comment}{// reapply the old attributes to the new element}
      forEach(dst, \textcolor{keyword}{function}(value, key) \{
        \textcolor{keywordflow}{if} (key.charAt(0) != \textcolor{charliteral}{'$'}) \{
          \textcolor{keywordflow}{if} (src[key] && src[key] !== value) \{
            value += (key === \textcolor{stringliteral}{'style'} ? \textcolor{charliteral}{';'} : \textcolor{charliteral}{' '}) + src[key];
          \}
          dst.$set(key, value, \textcolor{keyword}{true}, srcAttr[key]);
        \}
      \});

      \textcolor{comment}{// copy the new attributes on the old attrs object}
      forEach(src, \textcolor{keyword}{function}(value, key) \{
        \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{'class'}) \{
          safeAddClass($element, value);
          dst[\textcolor{stringliteral}{'class'}] = (dst[\textcolor{stringliteral}{'class'}] ? dst[\textcolor{stringliteral}{'class'}] + \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + value;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key == \textcolor{stringliteral}{'style'}) \{
          $element.attr(\textcolor{stringliteral}{'style'}, $element.attr(\textcolor{stringliteral}{'style'}) + \textcolor{charliteral}{';'} + value);
          dst[\textcolor{stringliteral}{'style'}] = (dst[\textcolor{stringliteral}{'style'}] ? dst[\textcolor{stringliteral}{'style'}] + \textcolor{charliteral}{';'} : \textcolor{stringliteral}{''}) + value;
          \textcolor{comment}{// `dst` will never contain hasOwnProperty as DOM parser won't let it.}
          \textcolor{comment}{// You will get an "InvalidCharacterError: DOM Exception 5" error if you}
          \textcolor{comment}{// have an attribute like "has-own-property" or "data-has-own-property", etc.}
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key.charAt(0) != \textcolor{charliteral}{'$'} && !dst.hasOwnProperty(key)) \{
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        \}
      \});
    \}


    \textcolor{keyword}{function} compileTemplateUrl(directives, $compileNode, tAttrs,
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) \{
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          derivedSyncDirective = inherit(origAsyncDirective, \{
            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
          \}),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl,
          templateNamespace = origAsyncDirective.templateNamespace;

      $compileNode.empty();

      $templateRequest(templateUrl)
        .then(\textcolor{keyword}{function}(content) \{
          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;

          content = denormalizeTemplate(content);

          \textcolor{keywordflow}{if} (origAsyncDirective.replace) \{
            \textcolor{keywordflow}{if} (jqLiteIsTextNode(content)) \{
              $template = [];
            \} \textcolor{keywordflow}{else} \{
              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
            \}
            compileNode = $template[0];

            \textcolor{keywordflow}{if} ($template.length != 1 || compileNode.nodeType !== NODE\_TYPE\_ELEMENT) \{
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tplrt'},
                  \textcolor{stringliteral}{"Template for directive '\{0\}' must have exactly one root element. \{1\}"},
                  origAsyncDirective.name, templateUrl);
            \}

            tempTemplateAttrs = \{$attr: \{\}\};
            replaceWith($rootElement, $compileNode, compileNode);
            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);

            \textcolor{keywordflow}{if} (isObject(origAsyncDirective.scope)) \{
              markDirectivesAsIsolate(templateDirectives);
            \}
            directives = templateDirectives.concat(directives);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          \} \textcolor{keywordflow}{else} \{
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          \}

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
              previousCompileContext);
          forEach($rootElement, \textcolor{keyword}{function}(node, i) \{
            \textcolor{keywordflow}{if} (node == compileNode) \{
              $rootElement[i] = $compileNode[0];
            \}
          \});
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);

          \textcolor{keywordflow}{while} (linkQueue.length) \{
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                boundTranscludeFn = linkQueue.shift(),
                linkNode = $compileNode[0];

            \textcolor{keywordflow}{if} (scope.$$destroyed) \textcolor{keywordflow}{continue};

            \textcolor{keywordflow}{if} (beforeTemplateLinkNode !== beforeTemplateCompileNode) \{
              var oldClasses = beforeTemplateLinkNode.className;

              \textcolor{keywordflow}{if} (!(previousCompileContext.hasElementTranscludeDirective &&
                  origAsyncDirective.replace)) \{
                \textcolor{comment}{// it was cloned therefore we have to clone as well.}
                linkNode = jqLiteClone(compileNode);
              \}
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);

              \textcolor{comment}{// Copy in CSS classes from original node}
              safeAddClass(jqLite(linkNode), oldClasses);
            \}
            \textcolor{keywordflow}{if} (afterTemplateNodeLinkFn.transcludeOnThisElement) \{
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, 
      boundTranscludeFn);
            \} \textcolor{keywordflow}{else} \{
              childBoundTranscludeFn = boundTranscludeFn;
            \}
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
              childBoundTranscludeFn, afterTemplateNodeLinkFn);
          \}
          linkQueue = null;
        \});

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) \{
        var childBoundTranscludeFn = boundTranscludeFn;
        \textcolor{keywordflow}{if} (scope.$$destroyed) \textcolor{keywordflow}{return};
        \textcolor{keywordflow}{if} (linkQueue) \{
          linkQueue.push(scope,
                         node,
                         rootElement,
                         childBoundTranscludeFn);
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{if} (afterTemplateNodeLinkFn.transcludeOnThisElement) \{
            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, 
      boundTranscludeFn);
          \}
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, 
      childBoundTranscludeFn,
                                  afterTemplateNodeLinkFn);
        \}
      \};
    \}


    \textcolor{keyword}{function} byPriority(a, b) \{
      var diff = b.priority - a.priority;
      \textcolor{keywordflow}{if} (diff !== 0) \textcolor{keywordflow}{return} diff;
      \textcolor{keywordflow}{if} (a.name !== b.name) \textcolor{keywordflow}{return} (a.name < b.name) ? -1 : 1;
      \textcolor{keywordflow}{return} a.index - b.index;
    \}

    \textcolor{keyword}{function} assertNoDuplicate(what, previousDirective, directive, element) \{

      \textcolor{keyword}{function} wrapModuleNameIfDefined(moduleName) \{
        \textcolor{keywordflow}{return} moduleName ?
          (\textcolor{stringliteral}{' (module: '} + moduleName + \textcolor{charliteral}{')'}) :
          \textcolor{stringliteral}{''};
      \}

      \textcolor{keywordflow}{if} (previousDirective) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'multidir'}, \textcolor{stringliteral}{'Multiple directives [\{0\}\{1\}, \{2\}\{3\}] asking for \{4\} on: \{5\}'},
            previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),
            directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
      \}
    \}


    \textcolor{keyword}{function} addTextInterpolateDirective(directives, text) \{
      var interpolateFn = $interpolate(text, \textcolor{keyword}{true});
      \textcolor{keywordflow}{if} (interpolateFn) \{
        directives.push(\{
          priority: 0,
          compile: \textcolor{keyword}{function} textInterpolateCompileFn(templateNode) \{
            var templateNodeParent = templateNode.parent(),
                hasCompileParent = !!templateNodeParent.length;

            \textcolor{comment}{// When transcluding a template that has bindings in the root}
            \textcolor{comment}{// we don't have a parent and thus need to add the class during linking fn.}
            \textcolor{keywordflow}{if} (hasCompileParent) compile.$$addBindingClass(templateNodeParent);

            \textcolor{keywordflow}{return} \textcolor{keyword}{function} textInterpolateLinkFn(scope, node) \{
              var parent = node.parent();
              \textcolor{keywordflow}{if} (!hasCompileParent) compile.$$addBindingClass(parent);
              compile.$$addBindingInfo(parent, interpolateFn.expressions);
              scope.$watch(interpolateFn, \textcolor{keyword}{function} interpolateFnWatchAction(value) \{
                node[0].nodeValue = value;
              \});
            \};
          \}
        \});
      \}
    \}


    \textcolor{keyword}{function} wrapTemplate(type, \textcolor{keyword}{template}) \{
      type = lowercase(type || \textcolor{stringliteral}{'html'});
      \textcolor{keywordflow}{switch} (type) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'svg'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'math'}:
        var wrapper = document.createElement(\textcolor{stringliteral}{'div'});
        wrapper.innerHTML = \textcolor{charliteral}{'<'} + type + \textcolor{charliteral}{'>'} + \textcolor{keyword}{template} + \textcolor{stringliteral}{'</'} + type + \textcolor{charliteral}{'>'};
        \textcolor{keywordflow}{return} wrapper.childNodes[0].childNodes;
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{template};
      \}
    \}


    \textcolor{keyword}{function} getTrustedContext(node, attrNormalizedName) \{
      \textcolor{keywordflow}{if} (attrNormalizedName == \textcolor{stringliteral}{"srcdoc"}) \{
        \textcolor{keywordflow}{return} $sce.HTML;
      \}
      var tag = nodeName\_(node);
      \textcolor{comment}{// maction[xlink:href] can source SVG.  It's not limited to <maction>.}
      \textcolor{keywordflow}{if} (attrNormalizedName == \textcolor{stringliteral}{"xlinkHref"} ||
          (tag == \textcolor{stringliteral}{"form"} && attrNormalizedName == \textcolor{stringliteral}{"action"}) ||
          (tag != \textcolor{stringliteral}{"img"} && (attrNormalizedName == \textcolor{stringliteral}{"src"} ||
                            attrNormalizedName == \textcolor{stringliteral}{"ngSrc"}))) \{
        \textcolor{keywordflow}{return} $sce.RESOURCE\_URL;
      \}
    \}


    \textcolor{keyword}{function} addAttrInterpolateDirective(node, directives, value, name, allOrNothing) \{
      var trustedContext = getTrustedContext(node, name);
      allOrNothing = ALL\_OR\_NOTHING\_ATTRS[name] || allOrNothing;

      var interpolateFn = $interpolate(value, \textcolor{keyword}{true}, trustedContext, allOrNothing);

      \textcolor{comment}{// no interpolation found -> ignore}
      \textcolor{keywordflow}{if} (!interpolateFn) \textcolor{keywordflow}{return};


      \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{"multiple"} && nodeName\_(node) === \textcolor{stringliteral}{"select"}) \{
        \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{"selmulti"},
            \textcolor{stringliteral}{"Binding to the 'multiple' attribute is not supported. Element: \{0\}"},
            startingTag(node));
      \}

      directives.push(\{
        priority: 100,
        compile: \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{return} \{
              pre: \textcolor{keyword}{function} attrInterpolatePreLinkFn(scope, element, attr) \{
                var $$observers = (attr.$$observers || (attr.$$observers = \{\}));

                \textcolor{keywordflow}{if} (EVENT\_HANDLER\_ATTR\_REGEXP.test(name)) \{
                  \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'nodomevents'},
                      \textcolor{stringliteral}{"Interpolations for HTML DOM event attributes are disallowed.  Please use the "} +
                          \textcolor{stringliteral}{"ng- versions (such as ng-click instead of onclick) instead."});
                \}

                \textcolor{comment}{// If the attribute has changed since last $interpolate()ed}
                var newValue = attr[name];
                \textcolor{keywordflow}{if} (newValue !== value) \{
                  \textcolor{comment}{// we need to interpolate again since the attribute value has been updated}
                  \textcolor{comment}{// (e.g. by another directive's compile function)}
                  \textcolor{comment}{// ensure unset/empty values make interpolateFn falsy}
                  interpolateFn = newValue && $interpolate(newValue, \textcolor{keyword}{true}, trustedContext, allOrNothing);
                  value = newValue;
                \}

                \textcolor{comment}{// if attribute was updated so that there is no interpolation going on we don't want to}
                \textcolor{comment}{// register any observers}
                \textcolor{keywordflow}{if} (!interpolateFn) \textcolor{keywordflow}{return};

                \textcolor{comment}{// initialize attr object so that it's ready in case we need the value for isolate}
                \textcolor{comment}{// scope initialization, otherwise the value would not be available from isolate}
                \textcolor{comment}{// directive's linking fn during linking phase}
                attr[name] = interpolateFn(scope);

                ($$observers[name] || ($$observers[name] = [])).$$inter = \textcolor{keyword}{true};
                (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, \textcolor{keyword}{function} interpolateFnWatchAction(newValue, oldValue) \{
                    \textcolor{comment}{//special case for class attribute addition + removal}
                    \textcolor{comment}{//so that class changes can tap into the animation}
                    \textcolor{comment}{//hooks provided by the $animate service. Be sure to}
                    \textcolor{comment}{//skip animations when the first digest occurs (when}
                    \textcolor{comment}{//both the new and the old values are the same) since}
                    \textcolor{comment}{//the CSS classes are the non-interpolated values}
                    \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{'class'} && newValue != oldValue) \{
                      attr.$updateClass(newValue, oldValue);
                    \} \textcolor{keywordflow}{else} \{
                      attr.$set(name, newValue);
                    \}
                  \});
              \}
            \};
          \}
      \});
    \}


    \textcolor{keyword}{function} replaceWith($rootElement, elementsToRemove, newNode) \{
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      \textcolor{keywordflow}{if} ($rootElement) \{
        \textcolor{keywordflow}{for} (i = 0, ii = $rootElement.length; i < ii; i++) \{
          \textcolor{keywordflow}{if} ($rootElement[i] == firstElementToRemove) \{
            $rootElement[i++] = newNode;
            \textcolor{keywordflow}{for} (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) \{
              \textcolor{keywordflow}{if} (j2 < jj) \{
                $rootElement[j] = $rootElement[j2];
              \} \textcolor{keywordflow}{else} \{
                \textcolor{keyword}{delete} $rootElement[j];
              \}
            \}
            $rootElement.length -= removeCount - 1;

            \textcolor{comment}{// If the replaced element is also the jQuery .context then replace it}
            \textcolor{comment}{// .context is a deprecated jQuery api, so we should set it only when jQuery set it}
            \textcolor{comment}{// http://api.jquery.com/context/}
            \textcolor{keywordflow}{if} ($rootElement.context === firstElementToRemove) \{
              $rootElement.context = newNode;
            \}
            \textcolor{keywordflow}{break};
          \}
        \}
      \}

      \textcolor{keywordflow}{if} (parent) \{
        parent.replaceChild(newNode, firstElementToRemove);
      \}

      \textcolor{comment}{// TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?}
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);

      \textcolor{keywordflow}{if} (jqLite.hasData(firstElementToRemove)) \{
        \textcolor{comment}{// Copy over user data (that includes Angular's $scope etc.). Don't copy private}
        \textcolor{comment}{// data here because there's no public interface in jQuery to do that and copying over}
        \textcolor{comment}{// event listeners (which is the main use of private data) wouldn't work anyway.}
        jqLite(newNode).data(jqLite(firstElementToRemove).data());

        \textcolor{comment}{// Remove data of the replaced element. We cannot just call .remove()}
        \textcolor{comment}{// on the element it since that would deallocate scope that is needed}
        \textcolor{comment}{// for the new node. Instead, remove the data "manually".}
        \textcolor{keywordflow}{if} (!jQuery) \{
          \textcolor{keyword}{delete} jqLite.cache[firstElementToRemove[jqLite.expando]];
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// jQuery 2.x doesn't expose the data storage. Use jQuery.cleanData to clean up after}
          \textcolor{comment}{// the replaced element. The cleanData version monkey-patched by Angular would cause}
          \textcolor{comment}{// the scope to be trashed and we do need the very same scope to work with the new}
          \textcolor{comment}{// element. However, we cannot just cache the non-patched version and use it here as}
          \textcolor{comment}{// that would break if another library patches the method after Angular does (one}
          \textcolor{comment}{// example is jQuery UI). Instead, set a flag indicating scope destroying should be}
          \textcolor{comment}{// skipped this one time.}
          skipDestroyOnNextJQueryCleanData = \textcolor{keyword}{true};
          jQuery.cleanData([firstElementToRemove]);
        \}
      \}

      \textcolor{keywordflow}{for} (var k = 1, kk = elementsToRemove.length; k < kk; k++) \{
        var element = elementsToRemove[k];
        jqLite(element).remove(); \textcolor{comment}{// must do this way to clean up expando}
        fragment.appendChild(element);
        \textcolor{keyword}{delete} elementsToRemove[k];
      \}

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1;
    \}


    \textcolor{keyword}{function} cloneAndAnnotateFn(fn, annotation) \{
      \textcolor{keywordflow}{return} extend(\textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} fn.apply(null, arguments); \}, fn, annotation);
    \}


    \textcolor{keyword}{function} invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) \{
      \textcolor{keywordflow}{try} \{
        linkFn(scope, $element, attrs, controllers, transcludeFn);
      \} \textcolor{keywordflow}{catch} (e) \{
        $exceptionHandler(e, startingTag($element));
      \}
    \}


    \textcolor{comment}{// Set up $watches for isolate scope and controller bindings. This process}
    \textcolor{comment}{// only occurs for isolate scopes and new scopes with controllerAs.}
    \textcolor{keyword}{function} initializeDirectiveBindings(scope, attrs, destination, bindings,
                                         directive, newScope) \{
      var onNewScopeDestroyed;
      forEach(bindings, \textcolor{keyword}{function}(definition, scopeName) \{
        var attrName = definition.attrName,
        optional = definition.optional,
        mode = definition.mode, \textcolor{comment}{// @, =, or &}
        lastValue,
        parentGet, parentSet, compare;

        \textcolor{keywordflow}{switch} (mode) \{

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'@'}:
            \textcolor{keywordflow}{if} (!optional && !hasOwnProperty.call(attrs, attrName)) \{
              destination[scopeName] = attrs[attrName] = \textcolor{keywordtype}{void} 0;
            \}
            attrs.$observe(attrName, \textcolor{keyword}{function}(value) \{
              \textcolor{keywordflow}{if} (isString(value)) \{
                destination[scopeName] = value;
              \}
            \});
            attrs.$$observers[attrName].$$scope = scope;
            \textcolor{keywordflow}{if} (isString(attrs[attrName])) \{
              \textcolor{comment}{// If the attribute has been provided then we trigger an interpolation to ensure}
              \textcolor{comment}{// the value is there for use in the link fn}
              destination[scopeName] = $interpolate(attrs[attrName])(scope);
            \}
            \textcolor{keywordflow}{break};

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'='}:
            \textcolor{keywordflow}{if} (!hasOwnProperty.call(attrs, attrName)) \{
              \textcolor{keywordflow}{if} (optional) \textcolor{keywordflow}{break};
              attrs[attrName] = \textcolor{keywordtype}{void} 0;
            \}
            \textcolor{keywordflow}{if} (optional && !attrs[attrName]) \textcolor{keywordflow}{break};

            parentGet = $parse(attrs[attrName]);
            \textcolor{keywordflow}{if} (parentGet.literal) \{
              compare = equals;
            \} \textcolor{keywordflow}{else} \{
              compare = \textcolor{keyword}{function}(a, b) \{ \textcolor{keywordflow}{return} a === b || (a !== a && b !== b); \};
            \}
            parentSet = parentGet.assign || \textcolor{keyword}{function}() \{
              \textcolor{comment}{// reset the change, or we will throw this exception on every $digest}
              lastValue = destination[scopeName] = parentGet(scope);
              \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'nonassign'},
                  \textcolor{stringliteral}{"Expression '\{0\}' used with directive '\{1\}' is non-assignable!"},
                  attrs[attrName], directive.name);
            \};
            lastValue = destination[scopeName] = parentGet(scope);
            var parentValueWatch = \textcolor{keyword}{function} parentValueWatch(parentValue) \{
              \textcolor{keywordflow}{if} (!compare(parentValue, destination[scopeName])) \{
                \textcolor{comment}{// we are out of sync and need to copy}
                \textcolor{keywordflow}{if} (!compare(parentValue, lastValue)) \{
                  \textcolor{comment}{// parent changed and it has precedence}
                  destination[scopeName] = parentValue;
                \} \textcolor{keywordflow}{else} \{
                  \textcolor{comment}{// if the parent can be assigned then do so}
                  parentSet(scope, parentValue = destination[scopeName]);
                \}
              \}
              \textcolor{keywordflow}{return} lastValue = parentValue;
            \};
            parentValueWatch.$stateful = \textcolor{keyword}{true};
            var unwatch;
            \textcolor{keywordflow}{if} (definition.collection) \{
              unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
            \} \textcolor{keywordflow}{else} \{
              unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
            \}
            onNewScopeDestroyed = (onNewScopeDestroyed || []);
            onNewScopeDestroyed.push(unwatch);
            \textcolor{keywordflow}{break};

          \textcolor{keywordflow}{case} \textcolor{charliteral}{'&'}:
            \textcolor{comment}{// Don't assign Object.prototype method to scope}
            parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;

            \textcolor{comment}{// Don't assign noop to destination if expression is not valid}
            \textcolor{keywordflow}{if} (parentGet === noop && optional) \textcolor{keywordflow}{break};

            destination[scopeName] = \textcolor{keyword}{function}(locals) \{
              \textcolor{keywordflow}{return} parentGet(scope, locals);
            \};
            \textcolor{keywordflow}{break};
        \}
      \});
      var destroyBindings = onNewScopeDestroyed ? \textcolor{keyword}{function} destroyBindings() \{
        \textcolor{keywordflow}{for} (var i = 0, ii = onNewScopeDestroyed.length; i < ii; ++i) \{
          onNewScopeDestroyed[i]();
        \}
      \} : noop;
      \textcolor{keywordflow}{if} (newScope && destroyBindings !== noop) \{
        newScope.$on(\textcolor{stringliteral}{'$destroy'}, destroyBindings);
        \textcolor{keywordflow}{return} noop;
      \}
      \textcolor{keywordflow}{return} destroyBindings;
    \}
  \}];
\}

var PREFIX\_REGEXP = /^((?:x|data)[\(\backslash\):\(\backslash\)-\_])/i;
\textcolor{keyword}{function} directiveNormalize(name) \{
  \textcolor{keywordflow}{return} camelCase(name.replace(PREFIX\_REGEXP, \textcolor{stringliteral}{''}));
\}

\textcolor{keyword}{function} nodesetLinkingFn(
  \textcolor{comment}{/* angular.Scope */} scope,
  \textcolor{comment}{/* NodeList */} nodeList,
  \textcolor{comment}{/* Element */} rootElement,
  \textcolor{comment}{/* function(Function) */} boundTranscludeFn
) \{\}

\textcolor{keyword}{function} directiveLinkingFn(
  \textcolor{comment}{/* nodesetLinkingFn */} nodesetLinkingFn,
  \textcolor{comment}{/* angular.Scope */} scope,
  \textcolor{comment}{/* Node */} node,
  \textcolor{comment}{/* Element */} rootElement,
  \textcolor{comment}{/* function(Function) */} boundTranscludeFn
) \{\}

\textcolor{keyword}{function} tokenDifference(str1, str2) \{
  var values = \textcolor{stringliteral}{''},
      tokens1 = str1.split(/\(\backslash\)s+/),
      tokens2 = str2.split(/\(\backslash\)s+/);

  outer:
  \textcolor{keywordflow}{for} (var i = 0; i < tokens1.length; i++) \{
    var token = tokens1[i];
    \textcolor{keywordflow}{for} (var j = 0; j < tokens2.length; j++) \{
      \textcolor{keywordflow}{if} (token == tokens2[j]) \textcolor{keywordflow}{continue} outer;
    \}
    values += (values.length > 0 ? \textcolor{charliteral}{' '} : \textcolor{stringliteral}{''}) + token;
  \}
  \textcolor{keywordflow}{return} values;
\}

\textcolor{keyword}{function} removeComments(jqNodes) \{
  jqNodes = jqLite(jqNodes);
  var i = jqNodes.length;

  \textcolor{keywordflow}{if} (i <= 1) \{
    \textcolor{keywordflow}{return} jqNodes;
  \}

  \textcolor{keywordflow}{while} (i--) \{
    var node = jqNodes[i];
    \textcolor{keywordflow}{if} (node.nodeType === NODE\_TYPE\_COMMENT) \{
      splice.call(jqNodes, i, 1);
    \}
  \}
  \textcolor{keywordflow}{return} jqNodes;
\}

var $controllerMinErr = minErr(\textcolor{stringliteral}{'$controller'});


var CNTRL\_REG = /^(\(\backslash\)S+)(\(\backslash\)s+as\(\backslash\)s+(\(\backslash\)w+))?$/;
\textcolor{keyword}{function} identifierForController(controller, ident) \{
  \textcolor{keywordflow}{if} (ident && isString(ident)) \textcolor{keywordflow}{return} ident;
  \textcolor{keywordflow}{if} (isString(controller)) \{
    var match = CNTRL\_REG.exec(controller);
    \textcolor{keywordflow}{if} (match) \textcolor{keywordflow}{return} match[3];
  \}
\}


\textcolor{keyword}{function} $ControllerProvider() \{
  var controllers = \{\},
      globals = \textcolor{keyword}{false};

  this.\textcolor{keyword}{register} = \textcolor{keyword}{function}(name, constructor) \{
    assertNotHasOwnProperty(name, \textcolor{stringliteral}{'controller'});
    \textcolor{keywordflow}{if} (isObject(name)) \{
      extend(controllers, name);
    \} \textcolor{keywordflow}{else} \{
      controllers[name] = constructor;
    \}
  \};

  this.allowGlobals = \textcolor{keyword}{function}() \{
    globals = \textcolor{keyword}{true};
  \};


  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}($injector, $window) \{

    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(expression, locals, later, ident) \{
      \textcolor{comment}{// PRIVATE API:}
      \textcolor{comment}{//   param `later` --- indicates that the controller's constructor is invoked at a later time.}
      \textcolor{comment}{//                     If true, $controller will allocate the object with the correct}
      \textcolor{comment}{//                     prototype chain, but will not invoke the controller until a returned}
      \textcolor{comment}{//                     callback is invoked.}
      \textcolor{comment}{//   param `ident` --- An optional label which overrides the label parsed from the controller}
      \textcolor{comment}{//                     expression, if any.}
      var instance, match, constructor, identifier;
      later = later === \textcolor{keyword}{true};
      \textcolor{keywordflow}{if} (ident && isString(ident)) \{
        identifier = ident;
      \}

      \textcolor{keywordflow}{if} (isString(expression)) \{
        match = expression.match(CNTRL\_REG);
        \textcolor{keywordflow}{if} (!match) \{
          \textcolor{keywordflow}{throw} $controllerMinErr(\textcolor{stringliteral}{'ctrlfmt'},
            \textcolor{stringliteral}{"Badly formed controller string '\{0\}'. "} +
            \textcolor{stringliteral}{"Must match `\_\_name\_\_ as \_\_id\_\_` or `\_\_name\_\_`."}, expression);
        \}
        constructor = match[1],
        identifier = identifier || match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, \textcolor{keyword}{true}) ||
                (globals ? getter($window, constructor, \textcolor{keyword}{true}) : undefined);

        assertArgFn(expression, constructor, \textcolor{keyword}{true});
      \}

      \textcolor{keywordflow}{if} (later) \{
        \textcolor{comment}{// Instantiate controller later:}
        \textcolor{comment}{// This machinery is used to create an instance of the object before calling the}
        \textcolor{comment}{// controller's constructor itself.}
        \textcolor{comment}{//}
        \textcolor{comment}{// This allows properties to be added to the controller before the constructor is}
        \textcolor{comment}{// invoked. Primarily, this is used for isolate scope bindings in $compile.}
        \textcolor{comment}{//}
        \textcolor{comment}{// This feature is not intended for use by applications, and is thus not documented}
        \textcolor{comment}{// publicly.}
        \textcolor{comment}{// Object creation: http://jsperf.com/create-constructor/2}
        var controllerPrototype = (isArray(expression) ?
          expression[expression.length - 1] : expression).prototype;
        instance = Object.create(controllerPrototype || null);

        \textcolor{keywordflow}{if} (identifier) \{
          addIdentifier(locals, identifier, instance, constructor || expression.name);
        \}

        var instantiate;
        \textcolor{keywordflow}{return} instantiate = extend(\textcolor{keyword}{function}() \{
          var result = $injector.invoke(expression, instance, locals, constructor);
          \textcolor{keywordflow}{if} (result !== instance && (isObject(result) || isFunction(result))) \{
            instance = result;
            \textcolor{keywordflow}{if} (identifier) \{
              \textcolor{comment}{// If result changed, re-assign controllerAs value to scope.}
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            \}
          \}
          \textcolor{keywordflow}{return} instance;
        \}, \{
          instance: instance,
          identifier: identifier
        \});
      \}

      instance = $injector.instantiate(expression, locals, constructor);

      \textcolor{keywordflow}{if} (identifier) \{
        addIdentifier(locals, identifier, instance, constructor || expression.name);
      \}

      \textcolor{keywordflow}{return} instance;
    \};

    \textcolor{keyword}{function} addIdentifier(locals, identifier, instance, name) \{
      \textcolor{keywordflow}{if} (!(locals && isObject(locals.$scope))) \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'$controller'})(\textcolor{stringliteral}{'noscp'},
          \textcolor{stringliteral}{"Cannot export controller '\{0\}' as '\{1\}'! No $scope object provided via `locals`."},
          name, identifier);
      \}

      locals.$scope[identifier] = instance;
    \}
  \}];
\}

\textcolor{keyword}{function} $DocumentProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}(window) \{
    \textcolor{keywordflow}{return} jqLite(window.document);
  \}];
\}

\textcolor{keyword}{function} $ExceptionHandlerProvider() \{
  this.$get = [\textcolor{stringliteral}{'$log'}, \textcolor{keyword}{function}($log) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(exception, cause) \{
      $log.error.apply($log, arguments);
    \};
  \}];
\}

var $$ForceReflowProvider = \textcolor{keyword}{function}() \{
  this.$get = [\textcolor{stringliteral}{'$document'}, \textcolor{keyword}{function}($document) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(domNode) \{
      \textcolor{comment}{//the line below will force the browser to perform a repaint so}
      \textcolor{comment}{//that all the animated elements within the animation frame will}
      \textcolor{comment}{//be properly updated and drawn on screen. This is required to}
      \textcolor{comment}{//ensure that the preparation animation is properly flushed so that}
      \textcolor{comment}{//the active state picks up from there. DO NOT REMOVE THIS LINE.}
      \textcolor{comment}{//DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH}
      \textcolor{comment}{//WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND}
      \textcolor{comment}{//WILL TAKE YEARS AWAY FROM YOUR LIFE.}
      \textcolor{keywordflow}{if} (domNode) \{
        \textcolor{keywordflow}{if} (!domNode.nodeType && domNode instanceof jqLite) \{
          domNode = domNode[0];
        \}
      \} \textcolor{keywordflow}{else} \{
        domNode = $document[0].body;
      \}
      \textcolor{keywordflow}{return} domNode.offsetWidth + 1;
    \};
  \}];
\};

var APPLICATION\_JSON = \textcolor{stringliteral}{'application/json'};
var CONTENT\_TYPE\_APPLICATION\_JSON = \{\textcolor{stringliteral}{'Content-Type'}: APPLICATION\_JSON + \textcolor{stringliteral}{';charset=utf-8'}\};
var JSON\_START = /^\(\backslash\)[|^\(\backslash\)\{(?!\(\backslash\)\{)/;
var JSON\_ENDS = \{
  \textcolor{charliteral}{'['}: /]$/,
  \textcolor{charliteral}{'\{'}: /\}$/
\};
var JSON\_PROTECTION\_PREFIX = /^\(\backslash\))\(\backslash\)]\(\backslash\)\}\textcolor{stringliteral}{',?\(\backslash\)n/;}
\textcolor{stringliteral}{var $httpMinErr = minErr('}$http\textcolor{stringliteral}{');}
\textcolor{stringliteral}{var $httpMinErrLegacyFn = function(method) \{}
\textcolor{stringliteral}{  return function() \{}
\textcolor{stringliteral}{    throw $httpMinErr('}legacy\textcolor{stringliteral}{', '}The method `\{0\}` on the promise returned from `$http` has been disabled.\textcolor{stringliteral}{',
       method);}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function serializeValue(v) \{}
\textcolor{stringliteral}{  if (isObject(v)) \{}
\textcolor{stringliteral}{    return isDate(v) ? v.toISOString() : toJson(v);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{  return v;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpParamSerializerProvider() \{}
\textcolor{stringliteral}{  this.$get = function() \{}
\textcolor{stringliteral}{    return function ngParamSerializer(params) \{}
\textcolor{stringliteral}{      if (!params) return '}\textcolor{stringliteral}{';}
\textcolor{stringliteral}{      var parts = [];}
\textcolor{stringliteral}{      forEachSorted(params, function(value, key) \{}
\textcolor{stringliteral}{        if (value === null || isUndefined(value)) return;}
\textcolor{stringliteral}{        if (isArray(value)) \{}
\textcolor{stringliteral}{          forEach(value, function(v, k) \{}
\textcolor{stringliteral}{            parts.push(encodeUriQuery(key)  + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(v)));}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else \{}
\textcolor{stringliteral}{          parts.push(encodeUriQuery(key) + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(value)));}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{      \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{      return parts.join('}&\textcolor{stringliteral}{');}
\textcolor{stringliteral}{    \};}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpParamSerializerJQLikeProvider() \{}
\textcolor{stringliteral}{  this.$get = function() \{}
\textcolor{stringliteral}{    return function jQueryLikeParamSerializer(params) \{}
\textcolor{stringliteral}{      if (!params) return '}\textcolor{stringliteral}{';}
\textcolor{stringliteral}{      var parts = [];}
\textcolor{stringliteral}{      serialize(params, '}\textcolor{stringliteral}{', true);}
\textcolor{stringliteral}{      return parts.join('}&\textcolor{stringliteral}{');}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{      function serialize(toSerialize, prefix, topLevel) \{}
\textcolor{stringliteral}{        if (toSerialize === null || isUndefined(toSerialize)) return;}
\textcolor{stringliteral}{        if (isArray(toSerialize)) \{}
\textcolor{stringliteral}{          forEach(toSerialize, function(value, index) \{}
\textcolor{stringliteral}{            serialize(value, prefix + '}[\textcolor{stringliteral}{' + (isObject(value) ? index : '}\textcolor{stringliteral}{') + '}]\textcolor{stringliteral}{');}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else if (isObject(toSerialize) && !isDate(toSerialize)) \{}
\textcolor{stringliteral}{          forEachSorted(toSerialize, function(value, key) \{}
\textcolor{stringliteral}{            serialize(value, prefix +}
\textcolor{stringliteral}{                (topLevel ? '}\textcolor{stringliteral}{' : '}[\textcolor{stringliteral}{') +}
\textcolor{stringliteral}{                key +}
\textcolor{stringliteral}{                (topLevel ? '}\textcolor{stringliteral}{' : '}]\textcolor{stringliteral}{'));}
\textcolor{stringliteral}{          \});}
\textcolor{stringliteral}{        \} else \{}
\textcolor{stringliteral}{          parts.push(encodeUriQuery(prefix) + '}=\textcolor{stringliteral}{' + encodeUriQuery(serializeValue(toSerialize)));}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \};}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function defaultHttpResponseTransform(data, headers) \{}
\textcolor{stringliteral}{  if (isString(data)) \{}
\textcolor{stringliteral}{    // Strip json vulnerability protection prefix and trim whitespace}
\textcolor{stringliteral}{    var tempData = data.replace(JSON\_PROTECTION\_PREFIX, '}\textcolor{stringliteral}{').trim();}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    if (tempData) \{}
\textcolor{stringliteral}{      var contentType = headers('}Content-Type\textcolor{stringliteral}{');}
\textcolor{stringliteral}{      if ((contentType && (contentType.indexOf(APPLICATION\_JSON) === 0)) || isJsonLike(tempData)) \{}
\textcolor{stringliteral}{        data = fromJson(tempData);}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return data;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function isJsonLike(str) \{}
\textcolor{stringliteral}{    var jsonStart = str.match(JSON\_START);}
\textcolor{stringliteral}{    return jsonStart && JSON\_ENDS[jsonStart[0]].test(str);}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function parseHeaders(headers) \{}
\textcolor{stringliteral}{  var parsed = createMap(), i;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function fillInParsed(key, val) \{}
\textcolor{stringliteral}{    if (key) \{}
\textcolor{stringliteral}{      parsed[key] = parsed[key] ? parsed[key] + '}, \textcolor{stringliteral}{' + val : val;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  if (isString(headers)) \{}
\textcolor{stringliteral}{    forEach(headers.split('}\(\backslash\)n\textcolor{stringliteral}{'), function(line) \{}
\textcolor{stringliteral}{      i = line.indexOf('}:\textcolor{stringliteral}{');}
\textcolor{stringliteral}{      fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \} else if (isObject(headers)) \{}
\textcolor{stringliteral}{    forEach(headers, function(headerVal, headerKey) \{}
\textcolor{stringliteral}{      fillInParsed(lowercase(headerKey), trim(headerVal));}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return parsed;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function headersGetter(headers) \{}
\textcolor{stringliteral}{  var headersObj;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return function(name) \{}
\textcolor{stringliteral}{    if (!headersObj) headersObj =  parseHeaders(headers);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    if (name) \{}
\textcolor{stringliteral}{      var value = headersObj[lowercase(name)];}
\textcolor{stringliteral}{      if (value === void 0) \{}
\textcolor{stringliteral}{        value = null;}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{      return value;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    return headersObj;}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function transformData(data, headers, status, fns) \{}
\textcolor{stringliteral}{  if (isFunction(fns)) \{}
\textcolor{stringliteral}{    return fns(data, headers, status);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  forEach(fns, function(fn) \{}
\textcolor{stringliteral}{    data = fn(data, headers, status);}
\textcolor{stringliteral}{  \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  return data;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function isSuccess(status) \{}
\textcolor{stringliteral}{  return 200 <= status && status < 300;}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function $HttpProvider() \{}
\textcolor{stringliteral}{  var defaults = this.defaults = \{}
\textcolor{stringliteral}{    // transform incoming response data}
\textcolor{stringliteral}{    transformResponse: [defaultHttpResponseTransform],}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // transform outgoing request data}
\textcolor{stringliteral}{    transformRequest: [function(d) \{}
\textcolor{stringliteral}{      return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;}
\textcolor{stringliteral}{    \}],}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // default headers}
\textcolor{stringliteral}{    headers: \{}
\textcolor{stringliteral}{      common: \{}
\textcolor{stringliteral}{        '}Accept\textcolor{stringliteral}{': '}application/json, text/plain, *\textcolor{comment}{/*'}
\textcolor{comment}{      \},}
\textcolor{comment}{      post:   shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON),}
\textcolor{comment}{      put:    shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON),}
\textcolor{comment}{      patch:  shallowCopy(CONTENT\_TYPE\_APPLICATION\_JSON)}
\textcolor{comment}{    \},}
\textcolor{comment}{}
\textcolor{comment}{    xsrfCookieName: 'XSRF-TOKEN',}
\textcolor{comment}{    xsrfHeaderName: 'X-XSRF-TOKEN',}
\textcolor{comment}{}
\textcolor{comment}{    paramSerializer: '$httpParamSerializer'}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var useApplyAsync = false;}
\textcolor{comment}{  this.useApplyAsync = function(value) \{}
\textcolor{comment}{    if (isDefined(value)) \{}
\textcolor{comment}{      useApplyAsync = !!value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \}}
\textcolor{comment}{    return useApplyAsync;}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var useLegacyPromise = true;}
\textcolor{comment}{  this.useLegacyPromiseExtensions = function(value) \{}
\textcolor{comment}{    if (isDefined(value)) \{}
\textcolor{comment}{      useLegacyPromise = !!value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \}}
\textcolor{comment}{    return useLegacyPromise;}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  var interceptorFactories = this.interceptors = [];}
\textcolor{comment}{}
\textcolor{comment}{  this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector',}
\textcolor{comment}{      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) \{}
\textcolor{comment}{}
\textcolor{comment}{    var defaultCache = $cacheFactory('$http');}
\textcolor{comment}{}
\textcolor{comment}{    defaults.paramSerializer = isString(defaults.paramSerializer) ?}
\textcolor{comment}{      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;}
\textcolor{comment}{}
\textcolor{comment}{    var reversedInterceptors = [];}
\textcolor{comment}{}
\textcolor{comment}{    forEach(interceptorFactories, function(interceptorFactory) \{}
\textcolor{comment}{      reversedInterceptors.unshift(isString(interceptorFactory)}
\textcolor{comment}{          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));}
\textcolor{comment}{    \});}
\textcolor{comment}{}
\textcolor{comment}{    function $http(requestConfig) \{}
\textcolor{comment}{}
\textcolor{comment}{      if (!angular.isObject(requestConfig)) \{}
\textcolor{comment}{        throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: \{0\}',
       requestConfig);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      var config = extend(\{}
\textcolor{comment}{        method: 'get',}
\textcolor{comment}{        transformRequest: defaults.transformRequest,}
\textcolor{comment}{        transformResponse: defaults.transformResponse,}
\textcolor{comment}{        paramSerializer: defaults.paramSerializer}
\textcolor{comment}{      \}, requestConfig);}
\textcolor{comment}{}
\textcolor{comment}{      config.headers = mergeHeaders(requestConfig);}
\textcolor{comment}{      config.method = uppercase(config.method);}
\textcolor{comment}{      config.paramSerializer = isString(config.paramSerializer) ?}
\textcolor{comment}{        $injector.get(config.paramSerializer) : config.paramSerializer;}
\textcolor{comment}{}
\textcolor{comment}{      var serverRequest = function(config) \{}
\textcolor{comment}{        var headers = config.headers;}
\textcolor{comment}{        var reqData = transformData(config.data, headersGetter(headers), undefined,
       config.transformRequest);}
\textcolor{comment}{}
\textcolor{comment}{        // strip content-type if data is undefined}
\textcolor{comment}{        if (isUndefined(reqData)) \{}
\textcolor{comment}{          forEach(headers, function(value, header) \{}
\textcolor{comment}{            if (lowercase(header) === 'content-type') \{}
\textcolor{comment}{                delete headers[header];}
\textcolor{comment}{            \}}
\textcolor{comment}{          \});}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) \{}
\textcolor{comment}{          config.withCredentials = defaults.withCredentials;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        // send request}
\textcolor{comment}{        return sendReq(config, reqData).then(transformResponse, transformResponse);}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var chain = [serverRequest, undefined];}
\textcolor{comment}{      var promise = $q.when(config);}
\textcolor{comment}{}
\textcolor{comment}{      // apply interceptors}
\textcolor{comment}{      forEach(reversedInterceptors, function(interceptor) \{}
\textcolor{comment}{        if (interceptor.request || interceptor.requestError) \{}
\textcolor{comment}{          chain.unshift(interceptor.request, interceptor.requestError);}
\textcolor{comment}{        \}}
\textcolor{comment}{        if (interceptor.response || interceptor.responseError) \{}
\textcolor{comment}{          chain.push(interceptor.response, interceptor.responseError);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      while (chain.length) \{}
\textcolor{comment}{        var thenFn = chain.shift();}
\textcolor{comment}{        var rejectFn = chain.shift();}
\textcolor{comment}{}
\textcolor{comment}{        promise = promise.then(thenFn, rejectFn);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (useLegacyPromise) \{}
\textcolor{comment}{        promise.success = function(fn) \{}
\textcolor{comment}{          assertArgFn(fn, 'fn');}
\textcolor{comment}{}
\textcolor{comment}{          promise.then(function(response) \{}
\textcolor{comment}{            fn(response.data, response.status, response.headers, config);}
\textcolor{comment}{          \});}
\textcolor{comment}{          return promise;}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        promise.error = function(fn) \{}
\textcolor{comment}{          assertArgFn(fn, 'fn');}
\textcolor{comment}{}
\textcolor{comment}{          promise.then(null, function(response) \{}
\textcolor{comment}{            fn(response.data, response.status, response.headers, config);}
\textcolor{comment}{          \});}
\textcolor{comment}{          return promise;}
\textcolor{comment}{        \};}
\textcolor{comment}{      \} else \{}
\textcolor{comment}{        promise.success = $httpMinErrLegacyFn('success');}
\textcolor{comment}{        promise.error = $httpMinErrLegacyFn('error');}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{}
\textcolor{comment}{      function transformResponse(response) \{}
\textcolor{comment}{        // make a copy since the response must be cacheable}
\textcolor{comment}{        var resp = extend(\{\}, response);}
\textcolor{comment}{        if (!response.data) \{}
\textcolor{comment}{          resp.data = response.data;}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          resp.data = transformData(response.data, response.headers, response.status,
       config.transformResponse);}
\textcolor{comment}{        \}}
\textcolor{comment}{        return (isSuccess(response.status))}
\textcolor{comment}{          ? resp}
\textcolor{comment}{          : $q.reject(resp);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function executeHeaderFns(headers, config) \{}
\textcolor{comment}{        var headerContent, processedHeaders = \{\};}
\textcolor{comment}{}
\textcolor{comment}{        forEach(headers, function(headerFn, header) \{}
\textcolor{comment}{          if (isFunction(headerFn)) \{}
\textcolor{comment}{            headerContent = headerFn(config);}
\textcolor{comment}{            if (headerContent != null) \{}
\textcolor{comment}{              processedHeaders[header] = headerContent;}
\textcolor{comment}{            \}}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            processedHeaders[header] = headerFn;}
\textcolor{comment}{          \}}
\textcolor{comment}{        \});}
\textcolor{comment}{}
\textcolor{comment}{        return processedHeaders;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function mergeHeaders(config) \{}
\textcolor{comment}{        var defHeaders = defaults.headers,}
\textcolor{comment}{            reqHeaders = extend(\{\}, config.headers),}
\textcolor{comment}{            defHeaderName, lowercaseDefHeaderName, reqHeaderName;}
\textcolor{comment}{}
\textcolor{comment}{        defHeaders = extend(\{\}, defHeaders.common, defHeaders[lowercase(config.method)]);}
\textcolor{comment}{}
\textcolor{comment}{        // using for-in instead of forEach to avoid unecessary iteration after header has been found}
\textcolor{comment}{        defaultHeadersIteration:}
\textcolor{comment}{        for (defHeaderName in defHeaders) \{}
\textcolor{comment}{          lowercaseDefHeaderName = lowercase(defHeaderName);}
\textcolor{comment}{}
\textcolor{comment}{          for (reqHeaderName in reqHeaders) \{}
\textcolor{comment}{            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) \{}
\textcolor{comment}{              continue defaultHeadersIteration;}
\textcolor{comment}{            \}}
\textcolor{comment}{          \}}
\textcolor{comment}{}
\textcolor{comment}{          reqHeaders[defHeaderName] = defHeaders[defHeaderName];}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        // execute if header value is a function for merged headers}
\textcolor{comment}{        return executeHeaderFns(reqHeaders, shallowCopy(config));}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    $http.pendingRequests = [];}
\textcolor{comment}{}
\textcolor{comment}{    createShortMethods('get', 'delete', 'head', 'jsonp');}
\textcolor{comment}{}
\textcolor{comment}{    createShortMethodsWithData('post', 'put', 'patch');}
\textcolor{comment}{}
\textcolor{comment}{    $http.defaults = defaults;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    return $http;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function createShortMethods(names) \{}
\textcolor{comment}{      forEach(arguments, function(name) \{}
\textcolor{comment}{        $http[name] = function(url, config) \{}
\textcolor{comment}{          return $http(extend(\{\}, config || \{\}, \{}
\textcolor{comment}{            method: name,}
\textcolor{comment}{            url: url}
\textcolor{comment}{          \}));}
\textcolor{comment}{        \};}
\textcolor{comment}{      \});}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function createShortMethodsWithData(name) \{}
\textcolor{comment}{      forEach(arguments, function(name) \{}
\textcolor{comment}{        $http[name] = function(url, data, config) \{}
\textcolor{comment}{          return $http(extend(\{\}, config || \{\}, \{}
\textcolor{comment}{            method: name,}
\textcolor{comment}{            url: url,}
\textcolor{comment}{            data: data}
\textcolor{comment}{          \}));}
\textcolor{comment}{        \};}
\textcolor{comment}{      \});}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function sendReq(config, reqData) \{}
\textcolor{comment}{      var deferred = $q.defer(),}
\textcolor{comment}{          promise = deferred.promise,}
\textcolor{comment}{          cache,}
\textcolor{comment}{          cachedResp,}
\textcolor{comment}{          reqHeaders = config.headers,}
\textcolor{comment}{          url = buildUrl(config.url, config.paramSerializer(config.params));}
\textcolor{comment}{}
\textcolor{comment}{      $http.pendingRequests.push(config);}
\textcolor{comment}{      promise.then(removePendingReq, removePendingReq);}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      if ((config.cache || defaults.cache) && config.cache !== false &&}
\textcolor{comment}{          (config.method === 'GET' || config.method === 'JSONP')) \{}
\textcolor{comment}{        cache = isObject(config.cache) ? config.cache}
\textcolor{comment}{              : isObject(defaults.cache) ? defaults.cache}
\textcolor{comment}{              : defaultCache;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (cache) \{}
\textcolor{comment}{        cachedResp = cache.get(url);}
\textcolor{comment}{        if (isDefined(cachedResp)) \{}
\textcolor{comment}{          if (isPromiseLike(cachedResp)) \{}
\textcolor{comment}{            // cached request has already been sent, but there is no response yet}
\textcolor{comment}{            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            // serving from cache}
\textcolor{comment}{            if (isArray(cachedResp)) \{}
\textcolor{comment}{              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);}
\textcolor{comment}{            \} else \{}
\textcolor{comment}{              resolvePromise(cachedResp, 200, \{\}, 'OK');}
\textcolor{comment}{            \}}
\textcolor{comment}{          \}}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          // put the promise for the non-transformed response into cache as a placeholder}
\textcolor{comment}{          cache.put(url, promise);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      // if we won't have the response in cache, set the xsrf headers and}
\textcolor{comment}{      // send the request to the backend}
\textcolor{comment}{      if (isUndefined(cachedResp)) \{}
\textcolor{comment}{        var xsrfValue = urlIsSameOrigin(config.url)}
\textcolor{comment}{            ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName]}
\textcolor{comment}{            : undefined;}
\textcolor{comment}{        if (xsrfValue) \{}
\textcolor{comment}{          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,}
\textcolor{comment}{            config.withCredentials, config.responseType);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      function done(status, response, headersString, statusText) \{}
\textcolor{comment}{        if (cache) \{}
\textcolor{comment}{          if (isSuccess(status)) \{}
\textcolor{comment}{            cache.put(url, [status, response, parseHeaders(headersString), statusText]);}
\textcolor{comment}{          \} else \{}
\textcolor{comment}{            // remove promise from the cache}
\textcolor{comment}{            cache.remove(url);}
\textcolor{comment}{          \}}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        function resolveHttpPromise() \{}
\textcolor{comment}{          resolvePromise(response, status, headersString, statusText);}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (useApplyAsync) \{}
\textcolor{comment}{          $rootScope.$applyAsync(resolveHttpPromise);}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          resolveHttpPromise();}
\textcolor{comment}{          if (!$rootScope.$$phase) $rootScope.$apply();}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{      function resolvePromise(response, status, headers, statusText) \{}
\textcolor{comment}{        // normalize internal statuses to 0}
\textcolor{comment}{        status = Math.max(status, 0);}
\textcolor{comment}{}
\textcolor{comment}{        (isSuccess(status) ? deferred.resolve : deferred.reject)(\{}
\textcolor{comment}{          data: response,}
\textcolor{comment}{          status: status,}
\textcolor{comment}{          headers: headersGetter(headers),}
\textcolor{comment}{          config: config,}
\textcolor{comment}{          statusText: statusText}
\textcolor{comment}{        \});}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function resolvePromiseWithResult(result) \{}
\textcolor{comment}{        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function removePendingReq() \{}
\textcolor{comment}{        var idx = $http.pendingRequests.indexOf(config);}
\textcolor{comment}{        if (idx !== -1) $http.pendingRequests.splice(idx, 1);}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function buildUrl(url, serializedParams) \{}
\textcolor{comment}{      if (serializedParams.length > 0) \{}
\textcolor{comment}{        url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;}
\textcolor{comment}{      \}}
\textcolor{comment}{      return url;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function createXhr() \{}
\textcolor{comment}{    return new window.XMLHttpRequest();}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function $HttpBackendProvider() \{}
\textcolor{comment}{  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) \{}
\textcolor{comment}{    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) \{}
\textcolor{comment}{  // TODO(vojta): fix the signature}
\textcolor{comment}{  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) \{}
\textcolor{comment}{    $browser.$$incOutstandingRequestCount();}
\textcolor{comment}{    url = url || $browser.url();}
\textcolor{comment}{}
\textcolor{comment}{    if (lowercase(method) == 'jsonp') \{}
\textcolor{comment}{      var callbackId = '\_' + (callbacks.counter++).toString(36);}
\textcolor{comment}{      callbacks[callbackId] = function(data) \{}
\textcolor{comment}{        callbacks[callbackId].data = data;}
\textcolor{comment}{        callbacks[callbackId].called = true;}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var jsonpDone = jsonpReq(url.replace('JSON\_CALLBACK', 'angular.callbacks.' + callbackId),}
\textcolor{comment}{          callbackId, function(status, text) \{}
\textcolor{comment}{        completeRequest(callback, status, callbacks[callbackId].data, "", text);}
\textcolor{comment}{        callbacks[callbackId] = noop;}
\textcolor{comment}{      \});}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{}
\textcolor{comment}{      var xhr = createXhr();}
\textcolor{comment}{}
\textcolor{comment}{      xhr.open(method, url, true);}
\textcolor{comment}{      forEach(headers, function(value, key) \{}
\textcolor{comment}{        if (isDefined(value)) \{}
\textcolor{comment}{            xhr.setRequestHeader(key, value);}
\textcolor{comment}{        \}}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      xhr.onload = function requestLoaded() \{}
\textcolor{comment}{        var statusText = xhr.statusText || '';}
\textcolor{comment}{}
\textcolor{comment}{        // responseText is the old-school way of retrieving response (supported by IE9)}
\textcolor{comment}{        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)}
\textcolor{comment}{        var response = ('response' in xhr) ? xhr.response : xhr.responseText;}
\textcolor{comment}{}
\textcolor{comment}{        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)}
\textcolor{comment}{        var status = xhr.status === 1223 ? 204 : xhr.status;}
\textcolor{comment}{}
\textcolor{comment}{        // fix status code when it is 0 (0 status is undocumented).}
\textcolor{comment}{        // Occurs when accessing file resources or on Android 4.1 stock browser}
\textcolor{comment}{        // while retrieving files from application cache.}
\textcolor{comment}{        if (status === 0) \{}
\textcolor{comment}{          status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        completeRequest(callback,}
\textcolor{comment}{            status,}
\textcolor{comment}{            response,}
\textcolor{comment}{            xhr.getAllResponseHeaders(),}
\textcolor{comment}{            statusText);}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      var requestError = function() \{}
\textcolor{comment}{        // The response is always empty}
\textcolor{comment}{        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/
      #concept-network-error}
\textcolor{comment}{        completeRequest(callback, -1, null, null, '');}
\textcolor{comment}{      \};}
\textcolor{comment}{}
\textcolor{comment}{      xhr.onerror = requestError;}
\textcolor{comment}{      xhr.onabort = requestError;}
\textcolor{comment}{}
\textcolor{comment}{      if (withCredentials) \{}
\textcolor{comment}{        xhr.withCredentials = true;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (responseType) \{}
\textcolor{comment}{        try \{}
\textcolor{comment}{          xhr.responseType = responseType;}
\textcolor{comment}{        \} catch (e) \{}
\textcolor{comment}{          // WebKit added support for the json responseType value on 09/03/2013}
\textcolor{comment}{          // https://bugs.webkit.org/show\_bug.cgi?id=73648. Versions of Safari prior to 7 are}
\textcolor{comment}{          // known to throw when setting the value "json" as the response type. Other older}
\textcolor{comment}{          // browsers implementing the responseType}
\textcolor{comment}{          //}
\textcolor{comment}{          // The json response type can be ignored if not supported, because JSON payloads are}
\textcolor{comment}{          // parsed on the client-side regardless.}
\textcolor{comment}{          if (responseType !== 'json') \{}
\textcolor{comment}{            throw e;}
\textcolor{comment}{          \}}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      xhr.send(post);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    if (timeout > 0) \{}
\textcolor{comment}{      var timeoutId = $browserDefer(timeoutRequest, timeout);}
\textcolor{comment}{    \} else if (isPromiseLike(timeout)) \{}
\textcolor{comment}{      timeout.then(timeoutRequest);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function timeoutRequest() \{}
\textcolor{comment}{      jsonpDone && jsonpDone();}
\textcolor{comment}{      xhr && xhr.abort();}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function completeRequest(callback, status, response, headersString, statusText) \{}
\textcolor{comment}{      // cancel timeout and subsequent timeout promise resolution}
\textcolor{comment}{      if (timeoutId !== undefined) \{}
\textcolor{comment}{        $browserDefer.cancel(timeoutId);}
\textcolor{comment}{      \}}
\textcolor{comment}{      jsonpDone = xhr = null;}
\textcolor{comment}{}
\textcolor{comment}{      callback(status, response, headersString, statusText);}
\textcolor{comment}{      $browser.$$completeOutstandingRequest(noop);}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  function jsonpReq(url, callbackId, done) \{}
\textcolor{comment}{    // we can't use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:}
\textcolor{comment}{    // - fetches local scripts via XHR and evals them}
\textcolor{comment}{    // - adds and immediately removes script elements from the document}
\textcolor{comment}{    var script = rawDocument.createElement('script'), callback = null;}
\textcolor{comment}{    script.type = "text/javascript";}
\textcolor{comment}{    script.src = url;}
\textcolor{comment}{    script.async = true;}
\textcolor{comment}{}
\textcolor{comment}{    callback = function(event) \{}
\textcolor{comment}{      removeEventListenerFn(script, "load", callback);}
\textcolor{comment}{      removeEventListenerFn(script, "error", callback);}
\textcolor{comment}{      rawDocument.body.removeChild(script);}
\textcolor{comment}{      script = null;}
\textcolor{comment}{      var status = -1;}
\textcolor{comment}{      var text = "unknown";}
\textcolor{comment}{}
\textcolor{comment}{      if (event) \{}
\textcolor{comment}{        if (event.type === "load" && !callbacks[callbackId].called) \{}
\textcolor{comment}{          event = \{ type: "error" \};}
\textcolor{comment}{        \}}
\textcolor{comment}{        text = event.type;}
\textcolor{comment}{        status = event.type === "error" ? 404 : 200;}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (done) \{}
\textcolor{comment}{        done(status, text);}
\textcolor{comment}{      \}}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    addEventListenerFn(script, "load", callback);}
\textcolor{comment}{    addEventListenerFn(script, "error", callback);}
\textcolor{comment}{    rawDocument.body.appendChild(script);}
\textcolor{comment}{    return callback;}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');}
\textcolor{comment}{$interpolateMinErr.throwNoconcat = function(text) \{}
\textcolor{comment}{  throw $interpolateMinErr('noconcat',}
\textcolor{comment}{      "Error while interpolating: \{0\}\(\backslash\)nStrict Contextual Escaping disallows " +}
\textcolor{comment}{      "interpolations that concatenate multiple expressions when a trusted value is " +}
\textcolor{comment}{      "required.  See http://docs.angularjs.org/api/ng.$sce", text);}
\textcolor{comment}{\};}
\textcolor{comment}{}
\textcolor{comment}{$interpolateMinErr.interr = function(text, err) \{}
\textcolor{comment}{  return $interpolateMinErr('interr', "Can't interpolate: \{0\}\(\backslash\)n\{1\}", text, err.toString());}
\textcolor{comment}{\};}
\textcolor{comment}{}
\textcolor{comment}{function $InterpolateProvider() \{}
\textcolor{comment}{  var startSymbol = '\{\{';}
\textcolor{comment}{  var endSymbol = '\}\}';}
\textcolor{comment}{}
\textcolor{comment}{  this.startSymbol = function(value) \{}
\textcolor{comment}{    if (value) \{}
\textcolor{comment}{      startSymbol = value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{      return startSymbol;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{  this.endSymbol = function(value) \{}
\textcolor{comment}{    if (value) \{}
\textcolor{comment}{      endSymbol = value;}
\textcolor{comment}{      return this;}
\textcolor{comment}{    \} else \{}
\textcolor{comment}{      return endSymbol;}
\textcolor{comment}{    \}}
\textcolor{comment}{  \};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) \{}
\textcolor{comment}{    var startSymbolLength = startSymbol.length,}
\textcolor{comment}{        endSymbolLength = endSymbol.length,}
\textcolor{comment}{        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),}
\textcolor{comment}{        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');}
\textcolor{comment}{}
\textcolor{comment}{    function escape(ch) \{}
\textcolor{comment}{      return '\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)' + ch;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function unescapeText(text) \{}
\textcolor{comment}{      return text.replace(escapedStartRegexp, startSymbol).}
\textcolor{comment}{        replace(escapedEndRegexp, endSymbol);}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function stringify(value) \{}
\textcolor{comment}{      if (value == null) \{ // null || undefined}
\textcolor{comment}{        return '';}
\textcolor{comment}{      \}}
\textcolor{comment}{      switch (typeof value) \{}
\textcolor{comment}{        case 'string':}
\textcolor{comment}{          break;}
\textcolor{comment}{        case 'number':}
\textcolor{comment}{          value = '' + value;}
\textcolor{comment}{          break;}
\textcolor{comment}{        default:}
\textcolor{comment}{          value = toJson(value);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      return value;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) \{}
\textcolor{comment}{      allOrNothing = !!allOrNothing;}
\textcolor{comment}{      var startIndex,}
\textcolor{comment}{          endIndex,}
\textcolor{comment}{          index = 0,}
\textcolor{comment}{          expressions = [],}
\textcolor{comment}{          parseFns = [],}
\textcolor{comment}{          textLength = text.length,}
\textcolor{comment}{          exp,}
\textcolor{comment}{          concat = [],}
\textcolor{comment}{          expressionPositions = [];}
\textcolor{comment}{}
\textcolor{comment}{      while (index < textLength) \{}
\textcolor{comment}{        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&}
\textcolor{comment}{             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) \{}
\textcolor{comment}{          if (index !== startIndex) \{}
\textcolor{comment}{            concat.push(unescapeText(text.substring(index, startIndex)));}
\textcolor{comment}{          \}}
\textcolor{comment}{          exp = text.substring(startIndex + startSymbolLength, endIndex);}
\textcolor{comment}{          expressions.push(exp);}
\textcolor{comment}{          parseFns.push($parse(exp, parseStringifyInterceptor));}
\textcolor{comment}{          index = endIndex + endSymbolLength;}
\textcolor{comment}{          expressionPositions.push(concat.length);}
\textcolor{comment}{          concat.push('');}
\textcolor{comment}{        \} else \{}
\textcolor{comment}{          // we did not find an interpolation, so we have to add the remainder to the separators array}
\textcolor{comment}{          if (index !== textLength) \{}
\textcolor{comment}{            concat.push(unescapeText(text.substring(index)));}
\textcolor{comment}{          \}}
\textcolor{comment}{          break;}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      // Concatenating expressions makes it hard to reason about whether some combination of}
\textcolor{comment}{      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a}
\textcolor{comment}{      // single expression be used for iframe[src], object[src], etc., we ensure that the value}
\textcolor{comment}{      // that's used is assigned or constructed by some JS code somewhere that is more testable or}
\textcolor{comment}{      // make it obvious that you bound the value to some user controlled value.  This helps reduce}
\textcolor{comment}{      // the load when auditing for XSS issues.}
\textcolor{comment}{      if (trustedContext && concat.length > 1) \{}
\textcolor{comment}{          $interpolateMinErr.throwNoconcat(text);}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      if (!mustHaveExpression || expressions.length) \{}
\textcolor{comment}{        var compute = function(values) \{}
\textcolor{comment}{          for (var i = 0, ii = expressions.length; i < ii; i++) \{}
\textcolor{comment}{            if (allOrNothing && isUndefined(values[i])) return;}
\textcolor{comment}{            concat[expressionPositions[i]] = values[i];}
\textcolor{comment}{          \}}
\textcolor{comment}{          return concat.join('');}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        var getValue = function(value) \{}
\textcolor{comment}{          return trustedContext ?}
\textcolor{comment}{            $sce.getTrusted(trustedContext, value) :}
\textcolor{comment}{            $sce.valueOf(value);}
\textcolor{comment}{        \};}
\textcolor{comment}{}
\textcolor{comment}{        return extend(function interpolationFn(context) \{}
\textcolor{comment}{            var i = 0;}
\textcolor{comment}{            var ii = expressions.length;}
\textcolor{comment}{            var values = new Array(ii);}
\textcolor{comment}{}
\textcolor{comment}{            try \{}
\textcolor{comment}{              for (; i < ii; i++) \{}
\textcolor{comment}{                values[i] = parseFns[i](context);}
\textcolor{comment}{              \}}
\textcolor{comment}{}
\textcolor{comment}{              return compute(values);}
\textcolor{comment}{            \} catch (err) \{}
\textcolor{comment}{              $exceptionHandler($interpolateMinErr.interr(text, err));}
\textcolor{comment}{            \}}
\textcolor{comment}{}
\textcolor{comment}{          \}, \{}
\textcolor{comment}{          // all of these properties are undocumented for now}
\textcolor{comment}{          exp: text, //just for compatibility with regular watchers created via $watch}
\textcolor{comment}{          expressions: expressions,}
\textcolor{comment}{          $$watchDelegate: function(scope, listener) \{}
\textcolor{comment}{            var lastValue;}
\textcolor{comment}{            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) \{}
\textcolor{comment}{              var currValue = compute(values);}
\textcolor{comment}{              if (isFunction(listener)) \{}
\textcolor{comment}{                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);}
\textcolor{comment}{              \}}
\textcolor{comment}{              lastValue = currValue;}
\textcolor{comment}{            \});}
\textcolor{comment}{          \}}
\textcolor{comment}{        \});}
\textcolor{comment}{      \}}
\textcolor{comment}{}
\textcolor{comment}{      function parseStringifyInterceptor(value) \{}
\textcolor{comment}{        try \{}
\textcolor{comment}{          value = getValue(value);}
\textcolor{comment}{          return allOrNothing && !isDefined(value) ? value : stringify(value);}
\textcolor{comment}{        \} catch (err) \{}
\textcolor{comment}{          $exceptionHandler($interpolateMinErr.interr(text, err));}
\textcolor{comment}{        \}}
\textcolor{comment}{      \}}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    $interpolate.startSymbol = function() \{}
\textcolor{comment}{      return startSymbol;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    $interpolate.endSymbol = function() \{}
\textcolor{comment}{      return endSymbol;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    return $interpolate;}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function $IntervalProvider() \{}
\textcolor{comment}{  this.$get = ['$rootScope', '$window', '$q', '$$q',}
\textcolor{comment}{       function($rootScope,   $window,   $q,   $$q) \{}
\textcolor{comment}{    var intervals = \{\};}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    function interval(fn, delay, count, invokeApply) \{}
\textcolor{comment}{      var hasParams = arguments.length > 4,}
\textcolor{comment}{          args = hasParams ? sliceArgs(arguments, 4) : [],}
\textcolor{comment}{          setInterval = $window.setInterval,}
\textcolor{comment}{          clearInterval = $window.clearInterval,}
\textcolor{comment}{          iteration = 0,}
\textcolor{comment}{          skipApply = (isDefined(invokeApply) && !invokeApply),}
\textcolor{comment}{          deferred = (skipApply ? $$q : $q).defer(),}
\textcolor{comment}{          promise = deferred.promise;}
\textcolor{comment}{}
\textcolor{comment}{      count = isDefined(count) ? count : 0;}
\textcolor{comment}{}
\textcolor{comment}{      promise.then(null, null, (!hasParams) ? fn : function() \{}
\textcolor{comment}{        fn.apply(null, args);}
\textcolor{comment}{      \});}
\textcolor{comment}{}
\textcolor{comment}{      promise.$$intervalId = setInterval(function tick() \{}
\textcolor{comment}{        deferred.notify(iteration++);}
\textcolor{comment}{}
\textcolor{comment}{        if (count > 0 && iteration >= count) \{}
\textcolor{comment}{          deferred.resolve(iteration);}
\textcolor{comment}{          clearInterval(promise.$$intervalId);}
\textcolor{comment}{          delete intervals[promise.$$intervalId];}
\textcolor{comment}{        \}}
\textcolor{comment}{}
\textcolor{comment}{        if (!skipApply) $rootScope.$apply();}
\textcolor{comment}{}
\textcolor{comment}{      \}, delay);}
\textcolor{comment}{}
\textcolor{comment}{      intervals[promise.$$intervalId] = deferred;}
\textcolor{comment}{}
\textcolor{comment}{      return promise;}
\textcolor{comment}{    \}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{    interval.cancel = function(promise) \{}
\textcolor{comment}{      if (promise && promise.$$intervalId in intervals) \{}
\textcolor{comment}{        intervals[promise.$$intervalId].reject('canceled');}
\textcolor{comment}{        $window.clearInterval(promise.$$intervalId);}
\textcolor{comment}{        delete intervals[promise.$$intervalId];}
\textcolor{comment}{        return true;}
\textcolor{comment}{      \}}
\textcolor{comment}{      return false;}
\textcolor{comment}{    \};}
\textcolor{comment}{}
\textcolor{comment}{    return interval;}
\textcolor{comment}{  \}];}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{var PATH\_MATCH = /^([^\(\backslash\)?#]*)(\(\backslash\)?([^#]*))?(#(.*))?$/,}
\textcolor{comment}{    DEFAULT\_PORTS = \{'http': 80, 'https': 443, 'ftp': 21\};}
\textcolor{comment}{var $locationMinErr = minErr('$location');}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function encodePath(path) \{}
\textcolor{comment}{  var segments = path.split('/'),}
\textcolor{comment}{      i = segments.length;}
\textcolor{comment}{}
\textcolor{comment}{  while (i--) \{}
\textcolor{comment}{    segments[i] = encodeUriSegment(segments[i]);}
\textcolor{comment}{  \}}
\textcolor{comment}{}
\textcolor{comment}{  return segments.join('/');}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function parseAbsoluteUrl(absoluteUrl, locationObj) \{}
\textcolor{comment}{  var parsedUrl = urlResolve(absoluteUrl);}
\textcolor{comment}{}
\textcolor{comment}{  locationObj.$$protocol = parsedUrl.protocol;}
\textcolor{comment}{  locationObj.$$host = parsedUrl.hostname;}
\textcolor{comment}{  locationObj.$$port = toInt(parsedUrl.port) || DEFAULT\_PORTS[parsedUrl.protocol] || null;}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function parseAppUrl(relativeUrl, locationObj) \{}
\textcolor{comment}{  var prefixed = (relativeUrl.charAt(0) !== '/');}
\textcolor{comment}{  if (prefixed) \{}
\textcolor{comment}{    relativeUrl = '/' + relativeUrl;}
\textcolor{comment}{  \}}
\textcolor{comment}{  var match = urlResolve(relativeUrl);}
\textcolor{comment}{  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?}
\textcolor{comment}{      match.pathname.substring(1) : match.pathname);}
\textcolor{comment}{  locationObj.$$search = parseKeyValue(match.search);}
\textcolor{comment}{  locationObj.$$hash = decodeURIComponent(match.hash);}
\textcolor{comment}{}
\textcolor{comment}{  // make sure path starts with '/';}
\textcolor{comment}{  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') \{}
\textcolor{comment}{    locationObj.$$path = '/' + locationObj.$$path;}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function beginsWith(begin, whole) \{}
\textcolor{comment}{  if (whole.indexOf(begin) === 0) \{}
\textcolor{comment}{    return whole.substr(begin.length);}
\textcolor{comment}{  \}}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function stripHash(url) \{}
\textcolor{comment}{  var index = url.indexOf('#');}
\textcolor{comment}{  return index == -1 ? url : url.substr(0, index);}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{function trimEmptyHash(url) \{}
\textcolor{comment}{  return url.replace(/(#.+)|#$/, '$1');}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{}
\textcolor{comment}{function stripFile(url) \{}
\textcolor{comment}{  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);}
\textcolor{comment}{\}}
\textcolor{comment}{}
\textcolor{comment}{/* return the server only (scheme://host:port) */}
\textcolor{keyword}{function} serverBase(url) \{
  \textcolor{keywordflow}{return} url.substring(0, url.indexOf(\textcolor{charliteral}{'/'}, url.indexOf(\textcolor{stringliteral}{'//'}) + 2));
\}


\textcolor{keyword}{function} LocationHtml5Url(appBase, appBaseNoFile, basePrefix) \{
  this.$$html5 = \textcolor{keyword}{true};
  basePrefix = basePrefix || \textcolor{stringliteral}{''};
  parseAbsoluteUrl(appBase, \textcolor{keyword}{this});


  this.$$parse = \textcolor{keyword}{function}(url) \{
    var pathUrl = beginsWith(appBaseNoFile, url);
    \textcolor{keywordflow}{if} (!isString(pathUrl)) \{
      \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'ipthprfx'}, \textcolor{stringliteral}{'Invalid url "\{0\}", missing path prefix "\{1\}".'}, url,
          appBaseNoFile);
    \}

    parseAppUrl(pathUrl, \textcolor{keyword}{this});

    \textcolor{keywordflow}{if} (!this.$$path) \{
      this.$$path = \textcolor{charliteral}{'/'};
    \}

    this.$$compose();
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); \textcolor{comment}{// first char is always '/'}
  \};

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (relHref && relHref[0] === \textcolor{charliteral}{'#'}) \{
      \textcolor{comment}{// special case for links to hash fragments:}
      \textcolor{comment}{// keep the old url and only replace the hash fragment}
      this.hash(relHref.slice(1));
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    var appUrl, prevAppUrl;
    var rewrittenUrl;

    \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBase, url)) !== undefined) \{
      prevAppUrl = appUrl;
      \textcolor{keywordflow}{if} ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) \{
        rewrittenUrl = appBaseNoFile + (beginsWith(\textcolor{charliteral}{'/'}, appUrl) || appUrl);
      \} \textcolor{keywordflow}{else} \{
        rewrittenUrl = appBase + prevAppUrl;
      \}
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) \{
      rewrittenUrl = appBaseNoFile + appUrl;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (appBaseNoFile == url + \textcolor{charliteral}{'/'}) \{
      rewrittenUrl = appBaseNoFile;
    \}
    \textcolor{keywordflow}{if} (rewrittenUrl) \{
      this.$$parse(rewrittenUrl);
    \}
    \textcolor{keywordflow}{return} !!rewrittenUrl;
  \};
\}


\textcolor{keyword}{function} LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) \{

  parseAbsoluteUrl(appBase, \textcolor{keyword}{this});


  this.$$parse = \textcolor{keyword}{function}(url) \{
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl;

    \textcolor{keywordflow}{if} (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === \textcolor{charliteral}{'#'}) \{

      \textcolor{comment}{// The rest of the url starts with a hash so we have}
      \textcolor{comment}{// got either a hashbang path or a plain hash fragment}
      withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
      \textcolor{keywordflow}{if} (isUndefined(withoutHashUrl)) \{
        \textcolor{comment}{// There was no hashbang prefix so we just have a hash fragment}
        withoutHashUrl = withoutBaseUrl;
      \}

    \} \textcolor{keywordflow}{else} \{
      \textcolor{comment}{// There was no hashbang path nor hash fragment:}
      \textcolor{comment}{// If we are in HTML5 mode we use what is left as the path;}
      \textcolor{comment}{// Otherwise we ignore what is left}
      \textcolor{keywordflow}{if} (this.$$html5) \{
        withoutHashUrl = withoutBaseUrl;
      \} \textcolor{keywordflow}{else} \{
        withoutHashUrl = \textcolor{stringliteral}{''};
        \textcolor{keywordflow}{if} (isUndefined(withoutBaseUrl)) \{
          appBase = url;
          this.replace();
        \}
      \}
    \}

    parseAppUrl(withoutHashUrl, \textcolor{keyword}{this});

    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);

    this.$$compose();

    \textcolor{comment}{/*}
\textcolor{comment}{     * In Windows, on an anchor node on documents loaded from}
\textcolor{comment}{     * the filesystem, the browser will return a pathname}
\textcolor{comment}{     * prefixed with the drive name ('/C:/path') when a}
\textcolor{comment}{     * pathname without a drive is set:}
\textcolor{comment}{     *  * a.setAttribute('href', '/foo')}
\textcolor{comment}{     *   * a.pathname === '/C:/foo' //true}
\textcolor{comment}{     *}
\textcolor{comment}{     * Inside of Angular, we're always using pathnames that}
\textcolor{comment}{     * do not include drive names for routing.}
\textcolor{comment}{     */}
    \textcolor{keyword}{function} removeWindowsDriveName(path, url, base) \{
      \textcolor{comment}{/*}
\textcolor{comment}{      Matches paths for file protocol on windows,}
\textcolor{comment}{      such as /C:/foo/bar, and captures only /foo/bar.}
\textcolor{comment}{      */}
      var windowsFilePathExp = /^\(\backslash\)/[A-Z]:(\(\backslash\)/.*)/;

      var firstPathSegmentMatch;

      \textcolor{comment}{//Get the relative path from the input URL.}
      \textcolor{keywordflow}{if} (url.indexOf(base) === 0) \{
        url = url.replace(base, \textcolor{stringliteral}{''});
      \}

      \textcolor{comment}{// The input URL intentionally contains a first path segment that ends with a colon.}
      \textcolor{keywordflow}{if} (windowsFilePathExp.exec(url)) \{
        \textcolor{keywordflow}{return} path;
      \}

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      \textcolor{keywordflow}{return} firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    \}
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : \textcolor{stringliteral}{''});
  \};

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (stripHash(appBase) == stripHash(url)) \{
      this.$$parse(url);
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \};
\}


\textcolor{keyword}{function} LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) \{
  this.$$html5 = \textcolor{keyword}{true};
  LocationHashbangUrl.apply(\textcolor{keyword}{this}, arguments);

  this.$$parseLinkUrl = \textcolor{keyword}{function}(url, relHref) \{
    \textcolor{keywordflow}{if} (relHref && relHref[0] === \textcolor{charliteral}{'#'}) \{
      \textcolor{comment}{// special case for links to hash fragments:}
      \textcolor{comment}{// keep the old url and only replace the hash fragment}
      this.hash(relHref.slice(1));
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    var rewrittenUrl;
    var appUrl;

    \textcolor{keywordflow}{if} (appBase == stripHash(url)) \{
      rewrittenUrl = url;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((appUrl = beginsWith(appBaseNoFile, url))) \{
      rewrittenUrl = appBase + hashPrefix + appUrl;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (appBaseNoFile === url + \textcolor{charliteral}{'/'}) \{
      rewrittenUrl = appBaseNoFile;
    \}
    \textcolor{keywordflow}{if} (rewrittenUrl) \{
      this.$$parse(rewrittenUrl);
    \}
    \textcolor{keywordflow}{return} !!rewrittenUrl;
  \};

  this.$$compose = \textcolor{keyword}{function}() \{
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? \textcolor{charliteral}{'#'} + encodeUriSegment(this.$$hash) : \textcolor{stringliteral}{''};

    this.$$url = encodePath(this.$$path) + (search ? \textcolor{charliteral}{'?'} + search : \textcolor{stringliteral}{''}) + hash;
    \textcolor{comment}{// include hashPrefix in $$absUrl when $$url is empty so IE9 does not reload page because of removal of
       '#'}
    this.$$absUrl = appBase + hashPrefix + this.$$url;
  \};

\}


var locationPrototype = \{

  $$html5: \textcolor{keyword}{false},

  $$replace: \textcolor{keyword}{false},

  absUrl: locationGetter(\textcolor{stringliteral}{'$$absUrl'}),

  url: \textcolor{keyword}{function}(url) \{
    \textcolor{keywordflow}{if} (isUndefined(url)) \{
      \textcolor{keywordflow}{return} this.$$url;
    \}

    var match = PATH\_MATCH.exec(url);
    \textcolor{keywordflow}{if} (match[1] || url === \textcolor{stringliteral}{''}) this.path(decodeURIComponent(match[1]));
    \textcolor{keywordflow}{if} (match[2] || match[1] || url === \textcolor{stringliteral}{''}) this.search(match[3] || \textcolor{stringliteral}{''});
    this.hash(match[5] || \textcolor{stringliteral}{''});

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \},

  protocol: locationGetter(\textcolor{stringliteral}{'$$protocol'}),

  host: locationGetter(\textcolor{stringliteral}{'$$host'}),

  port: locationGetter(\textcolor{stringliteral}{'$$port'}),

  path: locationGetterSetter(\textcolor{stringliteral}{'$$path'}, \textcolor{keyword}{function}(path) \{
    path = path !== null ? path.toString() : \textcolor{stringliteral}{''};
    \textcolor{keywordflow}{return} path.charAt(0) == \textcolor{charliteral}{'/'} ? path : \textcolor{charliteral}{'/'} + path;
  \}),

  search: \textcolor{keyword}{function}(search, paramValue) \{
    \textcolor{keywordflow}{switch} (arguments.length) \{
      \textcolor{keywordflow}{case} 0:
        \textcolor{keywordflow}{return} this.$$search;
      \textcolor{keywordflow}{case} 1:
        \textcolor{keywordflow}{if} (isString(search) || isNumber(search)) \{
          search = search.toString();
          this.$$search = parseKeyValue(search);
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(search)) \{
          search = copy(search, \{\});
          \textcolor{comment}{// remove object undefined or null properties}
          forEach(search, \textcolor{keyword}{function}(value, key) \{
            \textcolor{keywordflow}{if} (value == null) \textcolor{keyword}{delete} search[key];
          \});

          this.$$search = search;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'isrcharg'},
              \textcolor{stringliteral}{'The first argument of the `$location#search()` call must be a string or an object.'});
        \}
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{if} (isUndefined(paramValue) || paramValue === null) \{
          \textcolor{keyword}{delete} this.$$search[search];
        \} \textcolor{keywordflow}{else} \{
          this.$$search[search] = paramValue;
        \}
    \}

    this.$$compose();
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \},

  hash: locationGetterSetter(\textcolor{stringliteral}{'$$hash'}, \textcolor{keyword}{function}(hash) \{
    \textcolor{keywordflow}{return} hash !== null ? hash.toString() : \textcolor{stringliteral}{''};
  \}),

  replace: \textcolor{keyword}{function}() \{
    this.$$replace = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \}
\};

forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], \textcolor{keyword}{function}(Location) \{
  Location.prototype = Object.create(locationPrototype);

  Location.prototype.state = \textcolor{keyword}{function}(state) \{
    \textcolor{keywordflow}{if} (!arguments.length) \{
      \textcolor{keywordflow}{return} this.$$state;
    \}

    \textcolor{keywordflow}{if} (Location !== LocationHtml5Url || !this.$$html5) \{
      \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'nostate'}, \textcolor{stringliteral}{'History API state support is available only '} +
        \textcolor{stringliteral}{'in HTML5 mode and only in browsers supporting HTML5 History API'});
    \}
    \textcolor{comment}{// The user might modify `stateObject` after invoking `$location.state(stateObject)`}
    \textcolor{comment}{// but we're changing the $$state reference to $browser.state() during the $digest}
    \textcolor{comment}{// so the modification window is narrow.}
    this.$$state = isUndefined(state) ? null : state;

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};
\});


\textcolor{keyword}{function} locationGetter(property) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{this}[property];
  \};
\}


\textcolor{keyword}{function} locationGetterSetter(property, preprocess) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (isUndefined(value)) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[property];
    \}

    \textcolor{keyword}{this}[property] = preprocess(value);
    this.$$compose();

    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \};
\}


\textcolor{keyword}{function} $LocationProvider() \{
  var hashPrefix = \textcolor{stringliteral}{''},
      html5Mode = \{
        enabled: \textcolor{keyword}{false},
        requireBase: \textcolor{keyword}{true},
        rewriteLinks: \textcolor{keyword}{true}
      \};

  this.hashPrefix = \textcolor{keyword}{function}(prefix) \{
    \textcolor{keywordflow}{if} (isDefined(prefix)) \{
      hashPrefix = prefix;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} hashPrefix;
    \}
  \};

  this.html5Mode = \textcolor{keyword}{function}(mode) \{
    \textcolor{keywordflow}{if} (isBoolean(mode)) \{
      html5Mode.enabled = mode;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(mode)) \{

      \textcolor{keywordflow}{if} (isBoolean(mode.enabled)) \{
        html5Mode.enabled = mode.enabled;
      \}

      \textcolor{keywordflow}{if} (isBoolean(mode.requireBase)) \{
        html5Mode.requireBase = mode.requireBase;
      \}

      \textcolor{keywordflow}{if} (isBoolean(mode.rewriteLinks)) \{
        html5Mode.rewriteLinks = mode.rewriteLinks;
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} html5Mode;
    \}
  \};

  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$rootElement'}, \textcolor{stringliteral}{'$window'},
      \textcolor{keyword}{function}($rootScope, $browser, $sniffer, $rootElement, $window) \{
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), \textcolor{comment}{// if base[href] is undefined, it defaults to ''}
        initialUrl = $browser.url(),
        appBase;

    \textcolor{keywordflow}{if} (html5Mode.enabled) \{
      \textcolor{keywordflow}{if} (!baseHref && html5Mode.requireBase) \{
        \textcolor{keywordflow}{throw} $locationMinErr(\textcolor{stringliteral}{'nobase'},
          \textcolor{stringliteral}{"$location in HTML5 mode requires a <base> tag to be present!"});
      \}
      appBase = serverBase(initialUrl) + (baseHref || \textcolor{charliteral}{'/'});
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    \} \textcolor{keywordflow}{else} \{
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    \}
    var appBaseNoFile = stripFile(appBase);

    $location = \textcolor{keyword}{new} LocationMode(appBase, appBaseNoFile, \textcolor{charliteral}{'#'} + hashPrefix);
    $location.$$parseLinkUrl(initialUrl, initialUrl);

    $location.$$state = $browser.state();

    var IGNORE\_URI\_REGEXP = /^\(\backslash\)s*(javascript|mailto):/i;

    \textcolor{keyword}{function} setBrowserUrlWithFallback(url, replace, state) \{
      var oldUrl = $location.url();
      var oldState = $location.$$state;
      \textcolor{keywordflow}{try} \{
        $browser.url(url, replace, state);

        \textcolor{comment}{// Make sure $location.state() returns referentially identical (not just deeply equal)}
        \textcolor{comment}{// state object; this makes possible quick checking if the state changed in the digest}
        \textcolor{comment}{// loop. Checking deep equality would be too expensive.}
        $location.$$state = $browser.state();
      \} \textcolor{keywordflow}{catch} (e) \{
        \textcolor{comment}{// Restore old values if pushState fails}
        $location.url(oldUrl);
        $location.$$state = oldState;

        \textcolor{keywordflow}{throw} e;
      \}
    \}

    $rootElement.on(\textcolor{stringliteral}{'click'}, \textcolor{keyword}{function}(event) \{
      \textcolor{comment}{// TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)}
      \textcolor{comment}{// currently we open nice url link and redirect then}

      \textcolor{keywordflow}{if} (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 
      || event.button == 2) \textcolor{keywordflow}{return};

      var elm = jqLite(event.target);

      \textcolor{comment}{// traverse the DOM up to find first A tag}
      while (nodeName\_(elm[0]) !== \textcolor{charliteral}{'a'}) \{
        \textcolor{comment}{// ignore rewriting if no A tag (reached root element, or no parent - removed from document)}
        \textcolor{keywordflow}{if} (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) \textcolor{keywordflow}{return};
      \}

      var absHref = elm.prop(\textcolor{stringliteral}{'href'});
      \textcolor{comment}{// get the actual href attribute - see}
      \textcolor{comment}{// http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx}
      var relHref = elm.attr(\textcolor{stringliteral}{'href'}) || elm.attr(\textcolor{stringliteral}{'xlink:href'});

      \textcolor{keywordflow}{if} (isObject(absHref) && absHref.toString() === \textcolor{stringliteral}{'[object SVGAnimatedString]'}) \{
        \textcolor{comment}{// SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during}
        \textcolor{comment}{// an animation.}
        absHref = urlResolve(absHref.animVal).href;
      \}

      \textcolor{comment}{// Ignore when url is started with javascript: or mailto:}
      \textcolor{keywordflow}{if} (IGNORE\_URI\_REGEXP.test(absHref)) \textcolor{keywordflow}{return};

      \textcolor{keywordflow}{if} (absHref && !elm.attr(\textcolor{stringliteral}{'target'}) && !event.isDefaultPrevented()) \{
        \textcolor{keywordflow}{if} ($location.$$parseLinkUrl(absHref, relHref)) \{
          \textcolor{comment}{// We do a preventDefault for all urls that are part of the angular application,}
          \textcolor{comment}{// in html5mode and also without, so that we are able to abort navigation without}
          \textcolor{comment}{// getting double entries in the location history.}
          event.preventDefault();
          \textcolor{comment}{// update location manually}
          \textcolor{keywordflow}{if} ($location.absUrl() != $browser.url()) \{
            $rootScope.$apply();
            \textcolor{comment}{// hack to work around FF6 bug 684208 when scenario runner clicks on links}
            $window.angular[\textcolor{stringliteral}{'ff-684208-preventDefault'}] = \textcolor{keyword}{true};
          \}
        \}
      \}
    \});


    \textcolor{comment}{// rewrite hashbang url <> html5 url}
    \textcolor{keywordflow}{if} (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) \{
      $browser.url($location.absUrl(), \textcolor{keyword}{true});
    \}

    var initializing = \textcolor{keyword}{true};

    \textcolor{comment}{// update $location when $browser url changes}
    $browser.onUrlChange(\textcolor{keyword}{function}(newUrl, newState) \{

      \textcolor{keywordflow}{if} (isUndefined(beginsWith(appBaseNoFile, newUrl))) \{
        \textcolor{comment}{// If we are navigating outside of the app then force a reload}
        $window.location.href = newUrl;
        \textcolor{keywordflow}{return};
      \}

      $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
        var oldUrl = $location.absUrl();
        var oldState = $location.$$state;
        var defaultPrevented;

        $location.$$parse(newUrl);
        $location.$$state = newState;

        defaultPrevented = $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeStart'}, newUrl, oldUrl,
            newState, oldState).defaultPrevented;

        \textcolor{comment}{// if the location was changed by a `$locationChangeStart` handler then stop}
        \textcolor{comment}{// processing this location change}
        \textcolor{keywordflow}{if} ($location.absUrl() !== newUrl) \textcolor{keywordflow}{return};

        \textcolor{keywordflow}{if} (defaultPrevented) \{
          $location.$$parse(oldUrl);
          $location.$$state = oldState;
          setBrowserUrlWithFallback(oldUrl, \textcolor{keyword}{false}, oldState);
        \} \textcolor{keywordflow}{else} \{
          initializing = \textcolor{keyword}{false};
          afterLocationChange(oldUrl, oldState);
        \}
      \});
      \textcolor{keywordflow}{if} (!$rootScope.$$phase) $rootScope.$digest();
    \});

    \textcolor{comment}{// update browser}
    $rootScope.$watch(\textcolor{keyword}{function} $locationWatch() \{
      var oldUrl = trimEmptyHash($browser.url());
      var newUrl = trimEmptyHash($location.absUrl());
      var oldState = $browser.state();
      var currentReplace = $location.$$replace;
      var urlOrStateChanged = oldUrl !== newUrl ||
        ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);

      \textcolor{keywordflow}{if} (initializing || urlOrStateChanged) \{
        initializing = \textcolor{keyword}{false};

        $rootScope.$evalAsync(\textcolor{keyword}{function}() \{
          var newUrl = $location.absUrl();
          var defaultPrevented = $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeStart'}, newUrl, oldUrl,
              $location.$$state, oldState).defaultPrevented;

          \textcolor{comment}{// if the location was changed by a `$locationChangeStart` handler then stop}
          \textcolor{comment}{// processing this location change}
          \textcolor{keywordflow}{if} ($location.absUrl() !== newUrl) \textcolor{keywordflow}{return};

          \textcolor{keywordflow}{if} (defaultPrevented) \{
            $location.$$parse(oldUrl);
            $location.$$state = oldState;
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (urlOrStateChanged) \{
              setBrowserUrlWithFallback(newUrl, currentReplace,
                                        oldState === $location.$$state ? null : $location.$$state);
            \}
            afterLocationChange(oldUrl, oldState);
          \}
        \});
      \}

      $location.$$replace = \textcolor{keyword}{false};

      \textcolor{comment}{// we don't need to return anything because $evalAsync will make the digest loop dirty when}
      \textcolor{comment}{// there is a change}
    \});

    \textcolor{keywordflow}{return} $location;

    \textcolor{keyword}{function} afterLocationChange(oldUrl, oldState) \{
      $rootScope.$broadcast(\textcolor{stringliteral}{'$locationChangeSuccess'}, $location.absUrl(), oldUrl,
        $location.$$state, oldState);
    \}
\}];
\}

\textcolor{keyword}{function} $LogProvider() \{
  var debug = \textcolor{keyword}{true},
      \textcolor{keyword}{self} = \textcolor{keyword}{this};

  this.debugEnabled = \textcolor{keyword}{function}(flag) \{
    \textcolor{keywordflow}{if} (isDefined(flag)) \{
      debug = flag;
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} debug;
    \}
  \};

  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{keyword}{function}($window) \{
    \textcolor{keywordflow}{return} \{
      log: consoleLog(\textcolor{stringliteral}{'log'}),

      info: consoleLog(\textcolor{stringliteral}{'info'}),

      warn: consoleLog(\textcolor{stringliteral}{'warn'}),

      error: consoleLog(\textcolor{stringliteral}{'error'}),

      debug: (\textcolor{keyword}{function}() \{
        var fn = consoleLog(\textcolor{stringliteral}{'debug'});

        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (debug) \{
            fn.apply(\textcolor{keyword}{self}, arguments);
          \}
        \};
      \}())
    \};

    \textcolor{keyword}{function} formatError(arg) \{
      \textcolor{keywordflow}{if} (arg instanceof Error) \{
        \textcolor{keywordflow}{if} (arg.stack) \{
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? \textcolor{stringliteral}{'Error: '} + arg.message + \textcolor{charliteral}{'\(\backslash\)n'} + arg.stack
              : arg.stack;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (arg.sourceURL) \{
          arg = arg.message + \textcolor{charliteral}{'\(\backslash\)n'} + arg.sourceURL + \textcolor{charliteral}{':'} + arg.line;
        \}
      \}
      \textcolor{keywordflow}{return} arg;
    \}

    \textcolor{keyword}{function} consoleLog(type) \{
      var console = $window.console || \{\},
          logFn = console[type] || console.log || noop,
          hasApply = \textcolor{keyword}{false};

      \textcolor{comment}{// Note: reading logFn.apply throws an error in IE11 in IE8 document mode.}
      \textcolor{comment}{// The reason behind this is that console.log has type "object" in IE8...}
      \textcolor{keywordflow}{try} \{
        hasApply = !!logFn.apply;
      \} \textcolor{keywordflow}{catch} (e) \{\}

      \textcolor{keywordflow}{if} (hasApply) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          var args = [];
          forEach(arguments, \textcolor{keyword}{function}(arg) \{
            args.push(formatError(arg));
          \});
          \textcolor{keywordflow}{return} logFn.apply(console, args);
        \};
      \}

      \textcolor{comment}{// we are IE which either doesn't have window.console => this is noop and we do nothing,}
      \textcolor{comment}{// or we are IE where console.log doesn't have apply so we log at least first 2 args}
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(arg1, arg2) \{
        logFn(arg1, arg2 == null ? \textcolor{stringliteral}{''} : arg2);
      \};
    \}
  \}];
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

var $parseMinErr = minErr(\textcolor{stringliteral}{'$parse'});

\textcolor{comment}{// Sandboxing Angular Expressions}
\textcolor{comment}{// ------------------------------}
\textcolor{comment}{// Angular expressions are generally considered safe because these expressions only have direct}
\textcolor{comment}{// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by}
\textcolor{comment}{// obtaining a reference to native JS functions such as the Function constructor.}
\textcolor{comment}{//}
\textcolor{comment}{// As an example, consider the following Angular expression:}
\textcolor{comment}{//}
\textcolor{comment}{//   \{\}.toString.constructor('alert("evil JS code")')}
\textcolor{comment}{//}
\textcolor{comment}{// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits}
\textcolor{comment}{// against the expression language, but not to prevent exploits that were enabled by exposing}
\textcolor{comment}{// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good}
\textcolor{comment}{// practice and therefore we are not even trying to protect against interaction with an object}
\textcolor{comment}{// explicitly exposed in this way.}
\textcolor{comment}{//}
\textcolor{comment}{// In general, it is not possible to access a Window object from an angular expression unless a}
\textcolor{comment}{// window or some DOM object that has a reference to window is published onto a Scope.}
\textcolor{comment}{// Similarly we prevent invocations of function known to be dangerous, as well as assignments to}
\textcolor{comment}{// native objects.}
\textcolor{comment}{//}
\textcolor{comment}{// See https://docs.angularjs.org/guide/security}


\textcolor{keyword}{function} ensureSafeMemberName(name, fullExpression) \{
  \textcolor{keywordflow}{if} (name === \textcolor{stringliteral}{"\_\_defineGetter\_\_"} || name === \textcolor{stringliteral}{"\_\_defineSetter\_\_"}
      || name === \textcolor{stringliteral}{"\_\_lookupGetter\_\_"} || name === \textcolor{stringliteral}{"\_\_lookupSetter\_\_"}
      || name === \textcolor{stringliteral}{"\_\_proto\_\_"}) \{
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfld'},
        \textcolor{stringliteral}{'Attempting to access a disallowed field in Angular expressions! '}
        + \textcolor{stringliteral}{'Expression: \{0\}'}, fullExpression);
  \}
  \textcolor{keywordflow}{return} name;
\}

\textcolor{keyword}{function} ensureSafeObject(obj, fullExpression) \{
  \textcolor{comment}{// nifty check if obj is Function that is fast and works across iframes and other contexts}
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (obj.constructor === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfn'},
          \textcolor{stringliteral}{'Referencing Function in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// isWindow(obj)}
        obj.window === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecwindow'},
          \textcolor{stringliteral}{'Referencing the Window in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// isElement(obj)}
        obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecdom'},
          \textcolor{stringliteral}{'Referencing DOM nodes in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{comment}{// block Object so that we can't get hold of dangerous Object.* methods}
        obj === Object) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecobj'},
          \textcolor{stringliteral}{'Referencing Object in Angular expressions is disallowed! Expression: \{0\}'},
          fullExpression);
    \}
  \}
  \textcolor{keywordflow}{return} obj;
\}

var CALL = Function.prototype.call;
var APPLY = Function.prototype.apply;
var BIND = Function.prototype.bind;

\textcolor{keyword}{function} ensureSafeFunction(obj, fullExpression) \{
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{if} (obj.constructor === obj) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecfn'},
        \textcolor{stringliteral}{'Referencing Function in Angular expressions is disallowed! Expression: \{0\}'},
        fullExpression);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj === CALL || obj === APPLY || obj === BIND) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'isecff'},
        \textcolor{stringliteral}{'Referencing call, apply or bind in Angular expressions is disallowed! Expression: \{0\}'},
        fullExpression);
    \}
  \}
\}

var OPERATORS = createMap();
forEach(\textcolor{stringliteral}{'+ - * / % === !== == != < > <= >= && || ! = |'}.split(\textcolor{charliteral}{' '}), \textcolor{keyword}{function}(\textcolor{keyword}{operator}) \{ OPERATORS[\textcolor{keyword}{operator}
      ] = \textcolor{keyword}{true}; \});
var ESCAPE = \{\textcolor{stringliteral}{"n"}:\textcolor{stringliteral}{"\(\backslash\)n"}, \textcolor{stringliteral}{"f"}:\textcolor{stringliteral}{"\(\backslash\)f"}, \textcolor{stringliteral}{"r"}:\textcolor{stringliteral}{"\(\backslash\)r"}, \textcolor{stringliteral}{"t"}:\textcolor{stringliteral}{"\(\backslash\)t"}, \textcolor{stringliteral}{"v"}:\textcolor{stringliteral}{"\(\backslash\)v"}, \textcolor{stringliteral}{"'"}:\textcolor{stringliteral}{"'"}, \textcolor{charliteral}{'"'}:\textcolor{charliteral}{'"'}\};




var Lexer = \textcolor{keyword}{function}(options) \{
  this.options = options;
\};

Lexer.prototype = \{
  constructor: Lexer,

  lex: \textcolor{keyword}{function}(text) \{
    this.text = text;
    this.index = 0;
    this.tokens = [];

    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'"'} || ch === \textcolor{stringliteral}{"'"}) \{
        this.readString(ch);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isNumber(ch) || ch === \textcolor{charliteral}{'.'} && this.isNumber(this.peek())) \{
        this.readNumber();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isIdent(ch)) \{
        this.readIdent();
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.is(ch, \textcolor{stringliteral}{'()\{\}[].,;:?'})) \{
        this.tokens.push(\{index: this.index, text: ch\});
        this.index++;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isWhitespace(ch)) \{
        this.index++;
      \} \textcolor{keywordflow}{else} \{
        var ch2 = ch + this.peek();
        var ch3 = ch2 + this.peek(2);
        var op1 = OPERATORS[ch];
        var op2 = OPERATORS[ch2];
        var op3 = OPERATORS[ch3];
        \textcolor{keywordflow}{if} (op1 || op2 || op3) \{
          var token = op3 ? ch3 : (op2 ? ch2 : ch);
          this.tokens.push(\{index: this.index, text: token, \textcolor{keyword}{operator}: \textcolor{keyword}{true}\});
          this.index += token.length;
        \} \textcolor{keywordflow}{else} \{
          this.throwError(\textcolor{stringliteral}{'Unexpected next character '}, this.index, this.index + 1);
        \}
      \}
    \}
    \textcolor{keywordflow}{return} this.tokens;
  \},

  is: \textcolor{keyword}{function}(ch, chars) \{
    \textcolor{keywordflow}{return} chars.indexOf(ch) !== -1;
  \},

  peek: \textcolor{keyword}{function}(i) \{
    var num = i || 1;
    \textcolor{keywordflow}{return} (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : \textcolor{keyword}{false};
  \},

  isNumber: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (\textcolor{charliteral}{'0'} <= ch && ch <= \textcolor{charliteral}{'9'}) && typeof ch === \textcolor{stringliteral}{"string"};
  \},

  isWhitespace: \textcolor{keyword}{function}(ch) \{
    \textcolor{comment}{// IE treats non-breaking space as \(\backslash\)u00A0}
    \textcolor{keywordflow}{return} (ch === \textcolor{charliteral}{' '} || ch === \textcolor{charliteral}{'\(\backslash\)r'} || ch === \textcolor{charliteral}{'\(\backslash\)t'} ||
            ch === \textcolor{charliteral}{'\(\backslash\)n'} || ch === \textcolor{charliteral}{'\(\backslash\)v'} || ch === \textcolor{stringliteral}{'\(\backslash\)u00A0'});
  \},

  isIdent: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (\textcolor{charliteral}{'a'} <= ch && ch <= \textcolor{charliteral}{'z'} ||
            \textcolor{charliteral}{'A'} <= ch && ch <= \textcolor{charliteral}{'Z'} ||
            \textcolor{charliteral}{'\_'} === ch || ch === \textcolor{charliteral}{'$'});
  \},

  isExpOperator: \textcolor{keyword}{function}(ch) \{
    \textcolor{keywordflow}{return} (ch === \textcolor{charliteral}{'-'} || ch === \textcolor{charliteral}{'+'} || this.isNumber(ch));
  \},

  throwError: \textcolor{keyword}{function}(error, start, end) \{
    end = end || this.index;
    var colStr = (isDefined(start)
            ? \textcolor{stringliteral}{'s '} + start +  \textcolor{charliteral}{'-'} + this.index + \textcolor{stringliteral}{' ['} + this.text.substring(start, end) + \textcolor{charliteral}{']'}
            : \textcolor{charliteral}{' '} + end);
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'lexerr'}, \textcolor{stringliteral}{'Lexer Error: \{0\} at column\{1\} in expression [\{2\}].'},
        error, colStr, this.text);
  \},

  readNumber: \textcolor{keyword}{function}() \{
    var number = \textcolor{stringliteral}{''};
    var start = this.index;
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = lowercase(this.text.charAt(\textcolor{keyword}{this}.index));
      \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'.'} || this.isNumber(ch)) \{
        number += ch;
      \} \textcolor{keywordflow}{else} \{
        var peekCh = this.peek();
        \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'e'} && this.isExpOperator(peekCh)) \{
          number += ch;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isExpOperator(ch) &&
            peekCh && this.isNumber(peekCh) &&
            number.charAt(number.length - 1) == \textcolor{charliteral}{'e'}) \{
          number += ch;
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) == \textcolor{charliteral}{'e'}) \{
          this.throwError(\textcolor{stringliteral}{'Invalid exponent'});
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{break};
        \}
      \}
      this.index++;
    \}
    this.tokens.push(\{
      index: start,
      text: number,
      constant: \textcolor{keyword}{true},
      value: Number(number)
    \});
  \},

  readIdent: \textcolor{keyword}{function}() \{
    var start = this.index;
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      \textcolor{keywordflow}{if} (!(this.isIdent(ch) || this.isNumber(ch))) \{
        \textcolor{keywordflow}{break};
      \}
      this.index++;
    \}
    this.tokens.push(\{
      index: start,
      text: this.text.slice(start, this.index),
      identifier: \textcolor{keyword}{true}
    \});
  \},

  readString: \textcolor{keyword}{function}(quote) \{
    var start = this.index;
    this.index++;
    var \textcolor{keywordtype}{string} = \textcolor{stringliteral}{''};
    var rawString = quote;
    var escape = \textcolor{keyword}{false};
    \textcolor{keywordflow}{while} (this.index < this.text.length) \{
      var ch = this.text.charAt(this.index);
      rawString += ch;
      \textcolor{keywordflow}{if} (escape) \{
        \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'u'}) \{
          var hex = this.text.substring(this.index + 1, this.index + 5);
          \textcolor{keywordflow}{if} (!hex.match(/[\(\backslash\)da-f]\{4\}/i)) \{
            this.throwError(\textcolor{stringliteral}{'Invalid unicode escape [\(\backslash\)\(\backslash\)u'} + hex + \textcolor{charliteral}{']'});
          \}
          this.index += 4;
          \textcolor{keywordtype}{string} += String.fromCharCode(parseInt(hex, 16));
        \} \textcolor{keywordflow}{else} \{
          var rep = ESCAPE[ch];
          \textcolor{keywordtype}{string} = \textcolor{keywordtype}{string} + (rep || ch);
        \}
        escape = \textcolor{keyword}{false};
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch === \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
        escape = \textcolor{keyword}{true};
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch === quote) \{
        this.index++;
        this.tokens.push(\{
          index: start,
          text: rawString,
          constant: \textcolor{keyword}{true},
          value: \textcolor{keywordtype}{string}
        \});
        \textcolor{keywordflow}{return};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordtype}{string} += ch;
      \}
      this.index++;
    \}
    this.throwError(\textcolor{stringliteral}{'Unterminated quote'}, start);
  \}
\};

var AST = \textcolor{keyword}{function}(lexer, options) \{
  this.lexer = lexer;
  this.options = options;
\};

AST.Program = \textcolor{stringliteral}{'Program'};
AST.ExpressionStatement = \textcolor{stringliteral}{'ExpressionStatement'};
AST.AssignmentExpression = \textcolor{stringliteral}{'AssignmentExpression'};
AST.ConditionalExpression = \textcolor{stringliteral}{'ConditionalExpression'};
AST.LogicalExpression = \textcolor{stringliteral}{'LogicalExpression'};
AST.BinaryExpression = \textcolor{stringliteral}{'BinaryExpression'};
AST.UnaryExpression = \textcolor{stringliteral}{'UnaryExpression'};
AST.CallExpression = \textcolor{stringliteral}{'CallExpression'};
AST.MemberExpression = \textcolor{stringliteral}{'MemberExpression'};
AST.Identifier = \textcolor{stringliteral}{'Identifier'};
AST.Literal = \textcolor{stringliteral}{'Literal'};
AST.ArrayExpression = \textcolor{stringliteral}{'ArrayExpression'};
AST.Property = \textcolor{stringliteral}{'Property'};
AST.ObjectExpression = \textcolor{stringliteral}{'ObjectExpression'};
AST.ThisExpression = \textcolor{stringliteral}{'ThisExpression'};

\textcolor{comment}{// Internal use only}
AST.NGValueParameter = \textcolor{stringliteral}{'NGValueParameter'};

AST.prototype = \{
  ast: \textcolor{keyword}{function}(text) \{
    this.text = text;
    this.tokens = this.lexer.lex(text);

    var value = this.program();

    \textcolor{keywordflow}{if} (this.tokens.length !== 0) \{
      this.throwError(\textcolor{stringliteral}{'is an unexpected token'}, this.tokens[0]);
    \}

    \textcolor{keywordflow}{return} value;
  \},

  program: \textcolor{keyword}{function}() \{
    var body = [];
    \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{
      \textcolor{keywordflow}{if} (this.tokens.length > 0 && !\textcolor{keyword}{this}.peek(\textcolor{charliteral}{'\}'}, \textcolor{charliteral}{')'}, \textcolor{charliteral}{';'}, \textcolor{charliteral}{']'}))
        body.push(\textcolor{keyword}{this}.expressionStatement());
      \textcolor{keywordflow}{if} (!this.expect(\textcolor{charliteral}{';'})) \{
        \textcolor{keywordflow}{return} \{ type: AST.Program, body: body\};
      \}
    \}
  \},

  expressionStatement: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{ type: AST.ExpressionStatement, expression: this.filterChain() \};
  \},

  filterChain: \textcolor{keyword}{function}() \{
    var left = this.expression();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'|'}))) \{
      left = this.filter(left);
    \}
    \textcolor{keywordflow}{return} left;
  \},

  expression: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.assignment();
  \},

  assignment: \textcolor{keyword}{function}() \{
    var result = this.ternary();
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'='})) \{
      result = \{ type: AST.AssignmentExpression, left: result, right: this.assignment(), \textcolor{keyword}{operator}: \textcolor{charliteral}{'='}\};
    \}
    \textcolor{keywordflow}{return} result;
  \},

  ternary: \textcolor{keyword}{function}() \{
    var test = this.logicalOR();
    var alternate;
    var consequent;
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'?'})) \{
      alternate = this.expression();
      \textcolor{keywordflow}{if} (this.consume(\textcolor{charliteral}{':'})) \{
        consequent = this.expression();
        \textcolor{keywordflow}{return} \{ type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent\}
      ;
      \}
    \}
    \textcolor{keywordflow}{return} test;
  \},

  logicalOR: \textcolor{keyword}{function}() \{
    var left = this.logicalAND();
    \textcolor{keywordflow}{while} (this.expect(\textcolor{stringliteral}{'||'})) \{
      left = \{ type: AST.LogicalExpression, \textcolor{keyword}{operator}: \textcolor{stringliteral}{'||'}, left: left, right: this.logicalAND() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  logicalAND: \textcolor{keyword}{function}() \{
    var left = this.equality();
    \textcolor{keywordflow}{while} (this.expect(\textcolor{stringliteral}{'&&'})) \{
      left = \{ type: AST.LogicalExpression, \textcolor{keyword}{operator}: \textcolor{stringliteral}{'&&'}, left: left, right: this.equality()\};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  equality: \textcolor{keyword}{function}() \{
    var left = this.relational();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{stringliteral}{'=='},\textcolor{stringliteral}{'!='},\textcolor{stringliteral}{'==='},\textcolor{stringliteral}{'!=='}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.relational() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  relational: \textcolor{keyword}{function}() \{
    var left = this.additive();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'<'}, \textcolor{charliteral}{'>'}, \textcolor{stringliteral}{'<='}, \textcolor{stringliteral}{'>='}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.additive() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  additive: \textcolor{keyword}{function}() \{
    var left = this.multiplicative();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'+'},\textcolor{charliteral}{'-'}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.multiplicative() \}
      ;
    \}
    \textcolor{keywordflow}{return} left;
  \},

  multiplicative: \textcolor{keyword}{function}() \{
    var left = this.unary();
    var token;
    \textcolor{keywordflow}{while} ((token = this.expect(\textcolor{charliteral}{'*'},\textcolor{charliteral}{'/'},\textcolor{charliteral}{'%'}))) \{
      left = \{ type: AST.BinaryExpression, \textcolor{keyword}{operator}: token.text, left: left, right: this.unary() \};
    \}
    \textcolor{keywordflow}{return} left;
  \},

  unary: \textcolor{keyword}{function}() \{
    var token;
    \textcolor{keywordflow}{if} ((token = this.expect(\textcolor{charliteral}{'+'}, \textcolor{charliteral}{'-'}, \textcolor{charliteral}{'!'}))) \{
      \textcolor{keywordflow}{return} \{ type: AST.UnaryExpression, \textcolor{keyword}{operator}: token.text, prefix: \textcolor{keyword}{true}, argument: this.unary() \};
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} this.primary();
    \}
  \},

  primary: \textcolor{keyword}{function}() \{
    var primary;
    \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'('})) \{
      primary = this.filterChain();
      this.consume(\textcolor{charliteral}{')'});
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'['})) \{
      primary = this.arrayDeclaration();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.expect(\textcolor{charliteral}{'\{'})) \{
      primary = this.object();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.constants.hasOwnProperty(\textcolor{keyword}{this}.peek().text)) \{
      primary = copy(this.constants[this.consume().text]);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().identifier) \{
      primary = this.identifier();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().constant) \{
      primary = this.constant();
    \} \textcolor{keywordflow}{else} \{
      this.throwError(\textcolor{stringliteral}{'not a primary expression'}, this.peek());
    \}

    var next;
    \textcolor{keywordflow}{while} ((next = this.expect(\textcolor{charliteral}{'('}, \textcolor{charliteral}{'['}, \textcolor{charliteral}{'.'}))) \{
      \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'('}) \{
        primary = \{type: AST.CallExpression, callee: primary, arguments: this.parseArguments() \};
        this.consume(\textcolor{charliteral}{')'});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'['}) \{
        primary = \{ type: AST.MemberExpression, \textcolor{keywordtype}{object}: primary, property: this.expression(), computed: \textcolor{keyword}{
      true} \};
        this.consume(\textcolor{charliteral}{']'});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.text === \textcolor{charliteral}{'.'}) \{
        primary = \{ type: AST.MemberExpression, \textcolor{keywordtype}{object}: primary, property: this.identifier(), computed: \textcolor{keyword}{
      false} \};
      \} \textcolor{keywordflow}{else} \{
        this.throwError(\textcolor{stringliteral}{'IMPOSSIBLE'});
      \}
    \}
    \textcolor{keywordflow}{return} primary;
  \},

  filter: \textcolor{keyword}{function}(baseExpression) \{
    var args = [baseExpression];
    var result = \{type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: \textcolor{keyword}{true}\};

    \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{':'})) \{
      args.push(this.expression());
    \}

    \textcolor{keywordflow}{return} result;
  \},

  parseArguments: \textcolor{keyword}{function}() \{
    var args = [];
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{')'}) \{
      \textcolor{keywordflow}{do} \{
        args.push(this.expression());
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    \textcolor{keywordflow}{return} args;
  \},

  identifier: \textcolor{keyword}{function}() \{
    var token = this.consume();
    \textcolor{keywordflow}{if} (!token.identifier) \{
      this.throwError(\textcolor{stringliteral}{'is not a valid identifier'}, token);
    \}
    \textcolor{keywordflow}{return} \{ type: AST.Identifier, name: token.text \};
  \},

  constant: \textcolor{keyword}{function}() \{
    \textcolor{comment}{// TODO check that it is a constant}
    \textcolor{keywordflow}{return} \{ type: AST.Literal, value: this.consume().value \};
  \},

  arrayDeclaration: \textcolor{keyword}{function}() \{
    var elements = [];
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{']'}) \{
      \textcolor{keywordflow}{do} \{
        \textcolor{keywordflow}{if} (this.peek(\textcolor{charliteral}{']'})) \{
          \textcolor{comment}{// Support trailing commas per ES5.1.}
          \textcolor{keywordflow}{break};
        \}
        elements.push(this.expression());
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    this.consume(\textcolor{charliteral}{']'});

    \textcolor{keywordflow}{return} \{ type: AST.ArrayExpression, elements: elements \};
  \},

  \textcolor{keywordtype}{object}: \textcolor{keyword}{function}() \{
    var properties = [], property;
    \textcolor{keywordflow}{if} (this.peekToken().text !== \textcolor{charliteral}{'\}'}) \{
      \textcolor{keywordflow}{do} \{
        \textcolor{keywordflow}{if} (this.peek(\textcolor{charliteral}{'\}'})) \{
          \textcolor{comment}{// Support trailing commas per ES5.1.}
          \textcolor{keywordflow}{break};
        \}
        property = \{type: AST.Property, kind: \textcolor{stringliteral}{'init'}\};
        \textcolor{keywordflow}{if} (this.peek().constant) \{
          property.key = this.constant();
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.peek().identifier) \{
          property.key = this.identifier();
        \} \textcolor{keywordflow}{else} \{
          this.throwError(\textcolor{stringliteral}{"invalid key"}, this.peek());
        \}
        this.consume(\textcolor{charliteral}{':'});
        property.value = this.expression();
        properties.push(property);
      \} \textcolor{keywordflow}{while} (this.expect(\textcolor{charliteral}{','}));
    \}
    this.consume(\textcolor{charliteral}{'\}'});

    \textcolor{keywordflow}{return} \{type: AST.ObjectExpression, properties: properties \};
  \},

  throwError: \textcolor{keyword}{function}(msg, token) \{
    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'syntax'},
        \textcolor{stringliteral}{'Syntax Error: Token \(\backslash\)'\{0\}\(\backslash\)' \{1\} at column \{2\} of the expression [\{3\}] starting at [\{4\}].'},
          token.text, msg, (token.index + 1), \textcolor{keyword}{this}.text, \textcolor{keyword}{this}.text.substring(token.index));
  \},

  consume: \textcolor{keyword}{function}(e1) \{
    \textcolor{keywordflow}{if} (this.tokens.length === 0) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'ueoe'}, \textcolor{stringliteral}{'Unexpected end of expression: \{0\}'}, this.text);
    \}

    var token = this.expect(e1);
    \textcolor{keywordflow}{if} (!token) \{
      this.throwError(\textcolor{stringliteral}{'is unexpected, expecting ['} + e1 + \textcolor{charliteral}{']'}, this.peek());
    \}
    \textcolor{keywordflow}{return} token;
  \},

  peekToken: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} (this.tokens.length === 0) \{
      \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'ueoe'}, \textcolor{stringliteral}{'Unexpected end of expression: \{0\}'}, this.text);
    \}
    \textcolor{keywordflow}{return} this.tokens[0];
  \},

  peek: \textcolor{keyword}{function}(e1, e2, e3, e4) \{
    \textcolor{keywordflow}{return} this.peekAhead(0, e1, e2, e3, e4);
  \},

  peekAhead: \textcolor{keyword}{function}(i, e1, e2, e3, e4) \{
    \textcolor{keywordflow}{if} (this.tokens.length > i) \{
      var token = this.tokens[i];
      var t = token.text;
      \textcolor{keywordflow}{if} (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 && !e2 && !e3 && !e4)) \{
        \textcolor{keywordflow}{return} token;
      \}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \},

  expect: \textcolor{keyword}{function}(e1, e2, e3, e4) \{
    var token = this.peek(e1, e2, e3, e4);
    \textcolor{keywordflow}{if} (token) \{
      this.tokens.shift();
      \textcolor{keywordflow}{return} token;
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \},


  \textcolor{comment}{/* `undefined` is not a constant, it is an identifier,}
\textcolor{comment}{   * but using it as an identifier is not supported}
\textcolor{comment}{   */}
  constants: \{
    \textcolor{stringliteral}{'true'}: \{ type: AST.Literal, value: \textcolor{keyword}{true} \},
    \textcolor{stringliteral}{'false'}: \{ type: AST.Literal, value: \textcolor{keyword}{false} \},
    \textcolor{stringliteral}{'null'}: \{ type: AST.Literal, value: null \},
    \textcolor{stringliteral}{'undefined'}: \{type: AST.Literal, value: undefined \},
    \textcolor{stringliteral}{'this'}: \{type: AST.ThisExpression \}
  \}
\};

\textcolor{keyword}{function} ifDefined(v, d) \{
  \textcolor{keywordflow}{return} typeof v !== \textcolor{stringliteral}{'undefined'} ? v : d;
\}

\textcolor{keyword}{function} plusFn(l, r) \{
  \textcolor{keywordflow}{if} (typeof l === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} r;
  \textcolor{keywordflow}{if} (typeof r === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} l;
  \textcolor{keywordflow}{return} l + r;
\}

\textcolor{keyword}{function} isStateless($filter, filterName) \{
  var fn = $filter(filterName);
  \textcolor{keywordflow}{return} !fn.$stateful;
\}

\textcolor{keyword}{function} findConstantAndWatchExpressions(ast, $filter) \{
  var allConstants;
  var argsToWatch;
  \textcolor{keywordflow}{switch} (ast.type) \{
  \textcolor{keywordflow}{case} AST.Program:
    allConstants = \textcolor{keyword}{true};
    forEach(ast.body, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr.expression, $filter);
      allConstants = allConstants && expr.expression.constant;
    \});
    ast.constant = allConstants;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.Literal:
    ast.constant = \textcolor{keyword}{true};
    ast.toWatch = [];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.UnaryExpression:
    findConstantAndWatchExpressions(ast.argument, $filter);
    ast.constant = ast.argument.constant;
    ast.toWatch = ast.argument.toWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.BinaryExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.LogicalExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ConditionalExpression:
    findConstantAndWatchExpressions(ast.test, $filter);
    findConstantAndWatchExpressions(ast.alternate, $filter);
    findConstantAndWatchExpressions(ast.consequent, $filter);
    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.Identifier:
    ast.constant = \textcolor{keyword}{false};
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.MemberExpression:
    findConstantAndWatchExpressions(ast.object, $filter);
    \textcolor{keywordflow}{if} (ast.computed) \{
      findConstantAndWatchExpressions(ast.property, $filter);
    \}
    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.CallExpression:
    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
    argsToWatch = [];
    forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr, $filter);
      allConstants = allConstants && expr.constant;
      if (!expr.constant) \{
        argsToWatch.push.apply(argsToWatch, expr.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.AssignmentExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = [ast];
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ArrayExpression:
    allConstants = \textcolor{keyword}{true};
    argsToWatch = [];
    forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
      findConstantAndWatchExpressions(expr, $filter);
      allConstants = allConstants && expr.constant;
      if (!expr.constant) \{
        argsToWatch.push.apply(argsToWatch, expr.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ObjectExpression:
    allConstants = \textcolor{keyword}{true};
    argsToWatch = [];
    forEach(ast.properties, \textcolor{keyword}{function}(property) \{
      findConstantAndWatchExpressions(property.value, $filter);
      allConstants = allConstants && property.value.constant;
      if (!property.value.constant) \{
        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
      \}
    \});
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    \textcolor{keywordflow}{break};
  \textcolor{keywordflow}{case} AST.ThisExpression:
    ast.constant = \textcolor{keyword}{false};
    ast.toWatch = [];
    \textcolor{keywordflow}{break};
  \}
\}

\textcolor{keyword}{function} getInputs(body) \{
  \textcolor{keywordflow}{if} (body.length != 1) \textcolor{keywordflow}{return};
  var lastExpression = body[0].expression;
  var candidate = lastExpression.toWatch;
  \textcolor{keywordflow}{if} (candidate.length !== 1) \textcolor{keywordflow}{return} candidate;
  \textcolor{keywordflow}{return} candidate[0] !== lastExpression ? candidate : undefined;
\}

\textcolor{keyword}{function} isAssignable(ast) \{
  \textcolor{keywordflow}{return} ast.type === AST.Identifier || ast.type === AST.MemberExpression;
\}

\textcolor{keyword}{function} assignableAST(ast) \{
  \textcolor{keywordflow}{if} (ast.body.length === 1 && isAssignable(ast.body[0].expression)) \{
    \textcolor{keywordflow}{return} \{type: AST.AssignmentExpression, left: ast.body[0].expression, right: \{type: AST.
      NGValueParameter\}, \textcolor{keyword}{operator}: \textcolor{charliteral}{'='}\};
  \}
\}

\textcolor{keyword}{function} isLiteral(ast) \{
  \textcolor{keywordflow}{return} ast.body.length === 0 ||
      ast.body.length === 1 && (
      ast.body[0].expression.type === AST.Literal ||
      ast.body[0].expression.type === AST.ArrayExpression ||
      ast.body[0].expression.type === AST.ObjectExpression);
\}

\textcolor{keyword}{function} isConstant(ast) \{
  \textcolor{keywordflow}{return} ast.constant;
\}

\textcolor{keyword}{function} ASTCompiler(astBuilder, $filter) \{
  this.astBuilder = astBuilder;
  this.$filter = $filter;
\}

ASTCompiler.prototype = \{
  compile: \textcolor{keyword}{function}(expression, expensiveChecks) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    var ast = this.astBuilder.ast(expression);
    this.state = \{
      nextId: 0,
      filters: \{\},
      expensiveChecks: expensiveChecks,
      fn: \{vars: [], body: [], own: \{\}\},
      assign: \{vars: [], body: [], own: \{\}\},
      inputs: []
    \};
    findConstantAndWatchExpressions(ast, \textcolor{keyword}{self}.$filter);
    var extra = \textcolor{stringliteral}{''};
    var assignable;
    this.stage = \textcolor{stringliteral}{'assign'};
    \textcolor{keywordflow}{if} ((assignable = assignableAST(ast))) \{
      this.state.computing = \textcolor{stringliteral}{'assign'};
      var result = this.nextId();
      this.recurse(assignable, result);
      extra = \textcolor{stringliteral}{'fn.assign='} + this.generateFunction(\textcolor{stringliteral}{'assign'}, \textcolor{stringliteral}{'s,v,l'});
    \}
    var toWatch = getInputs(ast.body);
    \textcolor{keyword}{self}.stage = \textcolor{stringliteral}{'inputs'};
    forEach(toWatch, \textcolor{keyword}{function}(watch, key) \{
      var fnKey = \textcolor{stringliteral}{'fn'} + key;
      \textcolor{keyword}{self}.state[fnKey] = \{vars: [], body: [], own: \{\}\};
      \textcolor{keyword}{self}.state.computing = fnKey;
      var intoId = \textcolor{keyword}{self}.nextId();
      \textcolor{keyword}{self}.recurse(watch, intoId);
      \textcolor{keyword}{self}.return\_(intoId);
      \textcolor{keyword}{self}.state.inputs.push(fnKey);
      watch.watchId = key;
    \});
    this.state.computing = \textcolor{stringliteral}{'fn'};
    this.stage = \textcolor{stringliteral}{'main'};
    this.recurse(ast);
    var fnString =
      \textcolor{comment}{// The build and minification steps remove the string "use strict" from the code, but this is done
       using a regex.}
      \textcolor{comment}{// This is a workaround for this until we do a better job at only removing the prefix only when we
       should.}
      \textcolor{charliteral}{'"'} + this.USE + \textcolor{charliteral}{' '} + this.STRICT + \textcolor{stringliteral}{'";\(\backslash\)n'} +
      this.filterPrefix() +
      \textcolor{stringliteral}{'var fn='} + this.generateFunction(\textcolor{stringliteral}{'fn'}, \textcolor{stringliteral}{'s,l,a,i'}) +
      extra +
      this.watchFns() +
      \textcolor{stringliteral}{'return fn;'};

    \textcolor{comment}{/* jshint -W054 */}
    var fn = (\textcolor{keyword}{new} Function(\textcolor{stringliteral}{'$filter'},
        \textcolor{stringliteral}{'ensureSafeMemberName'},
        \textcolor{stringliteral}{'ensureSafeObject'},
        \textcolor{stringliteral}{'ensureSafeFunction'},
        \textcolor{stringliteral}{'ifDefined'},
        \textcolor{stringliteral}{'plus'},
        \textcolor{stringliteral}{'text'},
        fnString))(
          this.$filter,
          ensureSafeMemberName,
          ensureSafeObject,
          ensureSafeFunction,
          ifDefined,
          plusFn,
          expression);
    \textcolor{comment}{/* jshint +W054 */}
    this.state = this.stage = undefined;
    fn.literal = isLiteral(ast);
    fn.constant = isConstant(ast);
    \textcolor{keywordflow}{return} fn;
  \},

  USE: \textcolor{stringliteral}{'use'},

  STRICT: \textcolor{stringliteral}{'strict'},

  watchFns: \textcolor{keyword}{function}() \{
    var result = [];
    var fns = this.state.inputs;
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    forEach(fns, \textcolor{keyword}{function}(name) \{
      result.push(\textcolor{stringliteral}{'var '} + name + \textcolor{charliteral}{'='} + \textcolor{keyword}{self}.generateFunction(name, \textcolor{charliteral}{'s'}));
    \});
    \textcolor{keywordflow}{if} (fns.length) \{
      result.push(\textcolor{stringliteral}{'fn.inputs=['} + fns.join(\textcolor{charliteral}{','}) + \textcolor{stringliteral}{'];'});
    \}
    \textcolor{keywordflow}{return} result.join(\textcolor{stringliteral}{''});
  \},

  generateFunction: \textcolor{keyword}{function}(name, params) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'function('} + params + \textcolor{stringliteral}{')\{'} +
        this.varsPrefix(name) +
        this.body(name) +
        \textcolor{stringliteral}{'\};'};
  \},

  filterPrefix: \textcolor{keyword}{function}() \{
    var parts = [];
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    forEach(this.state.filters, \textcolor{keyword}{function}(\textcolor{keywordtype}{id}, filter) \{
      parts.push(id + \textcolor{stringliteral}{'=$filter('} + self.escape(filter) + \textcolor{stringliteral}{')'});
    \});
    \textcolor{keywordflow}{if} (parts.length) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'var '} + parts.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{';'};
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
  \},

  varsPrefix: \textcolor{keyword}{function}(section) \{
    \textcolor{keywordflow}{return} this.state[section].vars.length ? \textcolor{stringliteral}{'var '} + this.state[section].vars.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{';'} : \textcolor{stringliteral}{''};
  \},

  body: \textcolor{keyword}{function}(section) \{
    \textcolor{keywordflow}{return} this.state[section].body.join(\textcolor{stringliteral}{''});
  \},

  recurse: \textcolor{keyword}{function}(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) \{
    var left, right, \textcolor{keyword}{self} = \textcolor{keyword}{this}, args, expression;
    recursionFn = recursionFn || noop;
    \textcolor{keywordflow}{if} (!skipWatchIdCheck && isDefined(ast.watchId)) \{
      intoId = intoId || this.nextId();
      this.if\_(\textcolor{charliteral}{'i'},
        this.lazyAssign(intoId, this.computedMember(\textcolor{charliteral}{'i'}, ast.watchId)),
        \textcolor{keyword}{this}.lazyRecurse(ast, intoId, nameId, recursionFn, create, \textcolor{keyword}{true})
      );
      \textcolor{keywordflow}{return};
    \}
    \textcolor{keywordflow}{switch} (ast.type) \{
    \textcolor{keywordflow}{case} AST.Program:
      forEach(ast.body, \textcolor{keyword}{function}(expression, pos) \{
        self.recurse(expression.expression, undefined, undefined, function(expr) \{ right = expr; \});
        \textcolor{keywordflow}{if} (pos !== ast.body.length - 1) \{
          \textcolor{keyword}{self}.current().body.push(right, \textcolor{charliteral}{';'});
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keyword}{self}.return\_(right);
        \}
      \});
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.Literal:
      expression = this.escape(ast.value);
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.UnaryExpression:
      this.recurse(ast.argument, undefined, undefined, \textcolor{keyword}{function}(expr) \{ right = expr; \});
      expression = ast.operator + \textcolor{charliteral}{'('} + this.ifDefined(right, 0) + \textcolor{charliteral}{')'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.BinaryExpression:
      this.recurse(ast.left, undefined, undefined, \textcolor{keyword}{function}(expr) \{ left = expr; \});
      this.recurse(ast.right, undefined, undefined, \textcolor{keyword}{function}(expr) \{ right = expr; \});
      \textcolor{keywordflow}{if} (ast.operator === \textcolor{charliteral}{'+'}) \{
        expression = this.plus(left, right);
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ast.operator === \textcolor{charliteral}{'-'}) \{
        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
      \} \textcolor{keywordflow}{else} \{
        expression = \textcolor{charliteral}{'('} + left + \textcolor{charliteral}{')'} + ast.operator + \textcolor{charliteral}{'('} + right + \textcolor{charliteral}{')'};
      \}
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.LogicalExpression:
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.left, intoId);
      \textcolor{keyword}{self}.if\_(ast.operator === \textcolor{stringliteral}{'&&'} ? intoId : \textcolor{keyword}{self}.not(intoId), \textcolor{keyword}{self}.lazyRecurse(ast.right, intoId));
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ConditionalExpression:
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.test, intoId);
      \textcolor{keyword}{self}.if\_(intoId, \textcolor{keyword}{self}.lazyRecurse(ast.alternate, intoId), \textcolor{keyword}{self}.lazyRecurse(ast.consequent, intoId));
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.Identifier:
      intoId = intoId || this.nextId();
      \textcolor{keywordflow}{if} (nameId) \{
        nameId.context = \textcolor{keyword}{self}.stage === \textcolor{stringliteral}{'inputs'} ? \textcolor{charliteral}{'s'} : this.assign(this.nextId(), this.getHasOwnProperty(\textcolor{charliteral}{
      'l'}, ast.name) + \textcolor{stringliteral}{'?l:s'});
        nameId.computed = \textcolor{keyword}{false};
        nameId.name = ast.name;
      \}
      ensureSafeMemberName(ast.name);
      \textcolor{keyword}{self}.if\_(\textcolor{keyword}{self}.stage === \textcolor{stringliteral}{'inputs'} || \textcolor{keyword}{self}.not(\textcolor{keyword}{self}.getHasOwnProperty(\textcolor{charliteral}{'l'}, ast.name)),
        \textcolor{keyword}{function}() \{
          self.if\_(self.stage === \textcolor{stringliteral}{'inputs'} || \textcolor{stringliteral}{'s'}, function() \{
            if (create && create !== 1) \{
              self.if\_(
                self.not(self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name)),
                self.lazyAssign(self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name), \textcolor{stringliteral}{'\{\}'}));
            \}
            self.assign(intoId, self.nonComputedMember(\textcolor{stringliteral}{'s'}, ast.name));
          \});
        \}, intoId && \textcolor{keyword}{self}.lazyAssign(intoId, \textcolor{keyword}{self}.nonComputedMember(\textcolor{charliteral}{'l'}, ast.name))
        );
      \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) \{
        \textcolor{keyword}{self}.addEnsureSafeObject(intoId);
      \}
      recursionFn(intoId);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.MemberExpression:
      left = nameId && (nameId.context = this.nextId()) || this.nextId();
      intoId = intoId || this.nextId();
      \textcolor{keyword}{self}.recurse(ast.object, left, undefined, \textcolor{keyword}{function}() \{
        self.if\_(self.notNull(left), function() \{
          if (ast.computed) \{
            right = self.nextId();
            self.recurse(ast.property, right);
            self.addEnsureSafeMemberName(right);
            if (create && create !== 1) \{
              self.if\_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left
      , right), \textcolor{stringliteral}{'\{\}'}));
            \}
            expression = self.ensureSafeObject(self.computedMember(left, right));
            self.assign(intoId, expression);
            if (nameId) \{
              nameId.computed = true;
              nameId.name = right;
            \}
          \} else \{
            ensureSafeMemberName(ast.property.name);
            if (create && create !== 1) \{
              self.if\_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonC
      omputedMember(left, ast.property.name), \textcolor{stringliteral}{'\{\}'}));
            \}
            expression = self.nonComputedMember(left, ast.property.name);
            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) \{
              expression = self.ensureSafeObject(expression);
            \}
            self.assign(intoId, expression);
            if (nameId) \{
              nameId.computed = false;
              nameId.name = ast.property.name;
            \}
          \}
        \}, \textcolor{keyword}{function}() \{
          self.assign(intoId, \textcolor{stringliteral}{'undefined'});
        \});
        recursionFn(intoId);
      \}, !!create);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.CallExpression:
      intoId = intoId || this.nextId();
      \textcolor{keywordflow}{if} (ast.filter) \{
        right = \textcolor{keyword}{self}.filter(ast.callee.name);
        args = [];
        forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
          var argument = self.nextId();
          self.recurse(expr, argument);
          args.push(argument);
        \});
        expression = right + \textcolor{charliteral}{'('} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{')'};
        \textcolor{keyword}{self}.assign(intoId, expression);
        recursionFn(intoId);
      \} \textcolor{keywordflow}{else} \{
        right = \textcolor{keyword}{self}.nextId();
        left = \{\};
        args = [];
        \textcolor{keyword}{self}.recurse(ast.callee, right, left, \textcolor{keyword}{function}() \{
          self.if\_(self.notNull(right), function() \{
            self.addEnsureSafeFunction(right);
            forEach(ast.arguments, function(expr) \{
              self.recurse(expr, self.nextId(), undefined, function(argument) \{
                args.push(self.ensureSafeObject(argument));
              \});
            \});
            if (left.name) \{
              if (!self.state.expensiveChecks) \{
                self.addEnsureSafeObject(left.context);
              \}
              expression = self.member(left.context, left.name, left.computed) + \textcolor{stringliteral}{'('} + args.join(\textcolor{stringliteral}{','}) + \textcolor{stringliteral}{')'}
      ;
            \} else \{
              expression = right + \textcolor{stringliteral}{'('} + args.join(\textcolor{stringliteral}{','}) + \textcolor{stringliteral}{')'};
            \}
            expression = self.ensureSafeObject(expression);
            self.assign(intoId, expression);
          \}, \textcolor{keyword}{function}() \{
            self.assign(intoId, \textcolor{stringliteral}{'undefined'});
          \});
          recursionFn(intoId);
        \});
      \}
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.AssignmentExpression:
      right = this.nextId();
      left = \{\};
      \textcolor{keywordflow}{if} (!isAssignable(ast.left)) \{
        \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'lval'}, \textcolor{stringliteral}{'Trying to assing a value to a non l-value'});
      \}
      this.recurse(ast.left, undefined, left, \textcolor{keyword}{function}() \{
        self.if\_(self.notNull(left.context), function() \{
          self.recurse(ast.right, right);
          self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
          self.assign(intoId, expression);
          recursionFn(intoId || expression);
        \});
      \}, 1);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ArrayExpression:
      args = [];
      forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
        self.recurse(expr, self.nextId(), undefined, function(argument) \{
          args.push(argument);
        \});
      \});
      expression = \textcolor{charliteral}{'['} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{']'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ObjectExpression:
      args = [];
      forEach(ast.properties, \textcolor{keyword}{function}(property) \{
        self.recurse(property.value, self.nextId(), undefined, function(expr) \{
          args.push(self.escape(
              property.key.type === AST.Identifier ? property.key.name :
                (\textcolor{stringliteral}{''} + property.key.value)) +
              \textcolor{stringliteral}{':'} + expr);
        \});
      \});
      expression = \textcolor{charliteral}{'\{'} + args.join(\textcolor{charliteral}{','}) + \textcolor{charliteral}{'\}'};
      this.assign(intoId, expression);
      recursionFn(expression);
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.ThisExpression:
      this.assign(intoId, \textcolor{charliteral}{'s'});
      recursionFn(\textcolor{charliteral}{'s'});
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} AST.NGValueParameter:
      this.assign(intoId, \textcolor{charliteral}{'v'});
      recursionFn(\textcolor{charliteral}{'v'});
      \textcolor{keywordflow}{break};
    \}
  \},

  getHasOwnProperty: \textcolor{keyword}{function}(element, property) \{
    var key = element + \textcolor{charliteral}{'.'} + property;
    var own = this.current().own;
    \textcolor{keywordflow}{if} (!own.hasOwnProperty(key)) \{
      own[key] = this.nextId(\textcolor{keyword}{false}, element + \textcolor{stringliteral}{'&&('} + this.escape(property) + \textcolor{stringliteral}{' in '} + element + \textcolor{charliteral}{')'});
    \}
    \textcolor{keywordflow}{return} own[key];
  \},

  assign: \textcolor{keyword}{function}(id, value) \{
    \textcolor{keywordflow}{if} (!\textcolor{keywordtype}{id}) \textcolor{keywordflow}{return};
    this.current().body.push(\textcolor{keywordtype}{id}, \textcolor{charliteral}{'='}, value, \textcolor{charliteral}{';'});
    \textcolor{keywordflow}{return} id;
  \},

  filter: \textcolor{keyword}{function}(filterName) \{
    \textcolor{keywordflow}{if} (!this.state.filters.hasOwnProperty(filterName)) \{
      this.state.filters[filterName] = this.nextId(\textcolor{keyword}{true});
    \}
    \textcolor{keywordflow}{return} this.state.filters[filterName];
  \},

  ifDefined: \textcolor{keyword}{function}(id, defaultValue) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ifDefined('} + \textcolor{keywordtype}{id} + \textcolor{charliteral}{','} + this.escape(defaultValue) + \textcolor{charliteral}{')'};
  \},

  plus: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'plus('} + left + \textcolor{charliteral}{','} + right + \textcolor{charliteral}{')'};
  \},

  return\_: \textcolor{keyword}{function}(id) \{
    this.current().body.push(\textcolor{stringliteral}{'return '}, \textcolor{keywordtype}{id}, \textcolor{charliteral}{';'});
  \},

  if\_: \textcolor{keyword}{function}(test, alternate, consequent) \{
    \textcolor{keywordflow}{if} (test === \textcolor{keyword}{true}) \{
      alternate();
    \} \textcolor{keywordflow}{else} \{
      var body = this.current().body;
      body.push(\textcolor{stringliteral}{'if('}, test, \textcolor{stringliteral}{')\{'});
      alternate();
      body.push(\textcolor{charliteral}{'\}'});
      \textcolor{keywordflow}{if} (consequent) \{
        body.push(\textcolor{stringliteral}{'else\{'});
        consequent();
        body.push(\textcolor{charliteral}{'\}'});
      \}
    \}
  \},

  not: \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'!('} + expression + \textcolor{charliteral}{')'};
  \},

  notNull: \textcolor{keyword}{function}(expression) \{
    \textcolor{keywordflow}{return} expression + \textcolor{stringliteral}{'!=null'};
  \},

  nonComputedMember: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} left + \textcolor{charliteral}{'.'} + right;
  \},

  computedMember: \textcolor{keyword}{function}(left, right) \{
    \textcolor{keywordflow}{return} left + \textcolor{charliteral}{'['} + right + \textcolor{charliteral}{']'};
  \},

  member: \textcolor{keyword}{function}(left, right, computed) \{
    \textcolor{keywordflow}{if} (computed) \textcolor{keywordflow}{return} this.computedMember(left, right);
    \textcolor{keywordflow}{return} this.nonComputedMember(left, right);
  \},

  addEnsureSafeObject: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeObject(item), \textcolor{charliteral}{';'});
  \},

  addEnsureSafeMemberName: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeMemberName(item), \textcolor{charliteral}{';'});
  \},

  addEnsureSafeFunction: \textcolor{keyword}{function}(item) \{
    this.current().body.push(this.ensureSafeFunction(item), \textcolor{charliteral}{';'});
  \},

  ensureSafeObject: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeObject('} + item + \textcolor{stringliteral}{',text)'};
  \},

  ensureSafeMemberName: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeMemberName('} + item + \textcolor{stringliteral}{',text)'};
  \},

  ensureSafeFunction: \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'ensureSafeFunction('} + item + \textcolor{stringliteral}{',text)'};
  \},

  lazyRecurse: \textcolor{keyword}{function}(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keyword}{self}.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
    \};
  \},

  lazyAssign: \textcolor{keyword}{function}(id, value) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keyword}{self}.assign(\textcolor{keywordtype}{id}, value);
    \};
  \},

  stringEscapeRegex: /[^ a-zA-Z0-9]/g,

  stringEscapeFn: \textcolor{keyword}{function}(c) \{
    \textcolor{keywordflow}{return} \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)u'} + (\textcolor{stringliteral}{'0000'} + c.charCodeAt(0).toString(16)).slice(-4);
  \},

  escape: \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (isString(value)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'"} + value.replace(\textcolor{keyword}{this}.stringEscapeRegex, \textcolor{keyword}{this}.stringEscapeFn) + \textcolor{stringliteral}{"'"};
    \textcolor{keywordflow}{if} (isNumber(value)) \textcolor{keywordflow}{return} value.toString();
    \textcolor{keywordflow}{if} (value === \textcolor{keyword}{true}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'true'};
    \textcolor{keywordflow}{if} (value === \textcolor{keyword}{false}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'false'};
    \textcolor{keywordflow}{if} (value === null) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'null'};
    \textcolor{keywordflow}{if} (typeof value === \textcolor{stringliteral}{'undefined'}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{'undefined'};

    \textcolor{keywordflow}{throw} $parseMinErr(\textcolor{stringliteral}{'esc'}, \textcolor{stringliteral}{'IMPOSSIBLE'});
  \},

  nextId: \textcolor{keyword}{function}(skip, init) \{
    var \textcolor{keywordtype}{id} = \textcolor{charliteral}{'v'} + (this.state.nextId++);
    \textcolor{keywordflow}{if} (!skip) \{
      this.current().vars.push(\textcolor{keywordtype}{id} + (init ? \textcolor{charliteral}{'='} + init : \textcolor{stringliteral}{''}));
    \}
    \textcolor{keywordflow}{return} id;
  \},

  current: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} this.state[this.state.computing];
  \}
\};


\textcolor{keyword}{function} ASTInterpreter(astBuilder, $filter) \{
  this.astBuilder = astBuilder;
  this.$filter = $filter;
\}

ASTInterpreter.prototype = \{
  compile: \textcolor{keyword}{function}(expression, expensiveChecks) \{
    var \textcolor{keyword}{self} = \textcolor{keyword}{this};
    var ast = this.astBuilder.ast(expression);
    this.expression = expression;
    this.expensiveChecks = expensiveChecks;
    findConstantAndWatchExpressions(ast, \textcolor{keyword}{self}.$filter);
    var assignable;
    var assign;
    \textcolor{keywordflow}{if} ((assignable = assignableAST(ast))) \{
      assign = this.recurse(assignable);
    \}
    var toWatch = getInputs(ast.body);
    var inputs;
    \textcolor{keywordflow}{if} (toWatch) \{
      inputs = [];
      forEach(toWatch, \textcolor{keyword}{function}(watch, key) \{
        var input = \textcolor{keyword}{self}.recurse(watch);
        watch.input = input;
        inputs.push(input);
        watch.watchId = key;
      \});
    \}
    var expressions = [];
    forEach(ast.body, \textcolor{keyword}{function}(expression) \{
      expressions.push(self.recurse(expression.expression));
    \});
    var fn = ast.body.length === 0 ? \textcolor{keyword}{function}() \{\} :
             ast.body.length === 1 ? expressions[0] :
             \textcolor{keyword}{function}(scope, locals) \{
               var lastValue;
               forEach(expressions, \textcolor{keyword}{function}(exp) \{
                 lastValue = exp(scope, locals);
               \});
               \textcolor{keywordflow}{return} lastValue;
             \};
    \textcolor{keywordflow}{if} (assign) \{
      fn.assign = \textcolor{keyword}{function}(scope, value, locals) \{
        \textcolor{keywordflow}{return} assign(scope, locals, value);
      \};
    \}
    \textcolor{keywordflow}{if} (inputs) \{
      fn.inputs = inputs;
    \}
    fn.literal = isLiteral(ast);
    fn.constant = isConstant(ast);
    \textcolor{keywordflow}{return} fn;
  \},

  recurse: \textcolor{keyword}{function}(ast, context, create) \{
    var left, right, \textcolor{keyword}{self} = \textcolor{keyword}{this}, args, expression;
    \textcolor{keywordflow}{if} (ast.input) \{
      \textcolor{keywordflow}{return} this.inputs(ast.input, ast.watchId);
    \}
    \textcolor{keywordflow}{switch} (ast.type) \{
    \textcolor{keywordflow}{case} AST.Literal:
      \textcolor{keywordflow}{return} this.value(ast.value, context);
    \textcolor{keywordflow}{case} AST.UnaryExpression:
      right = this.recurse(ast.argument);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'unary'} + ast.operator](right, context);
    \textcolor{keywordflow}{case} AST.BinaryExpression:
      left = this.recurse(ast.left);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'binary'} + ast.operator](left, right, context);
    \textcolor{keywordflow}{case} AST.LogicalExpression:
      left = this.recurse(ast.left);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'binary'} + ast.operator](left, right, context);
    \textcolor{keywordflow}{case} AST.ConditionalExpression:
      \textcolor{keywordflow}{return} \textcolor{keyword}{this}[\textcolor{stringliteral}{'ternary?:'}](
        this.recurse(ast.test),
        this.recurse(ast.alternate),
        this.recurse(ast.consequent),
        context
      );
    \textcolor{keywordflow}{case} AST.Identifier:
      ensureSafeMemberName(ast.name, \textcolor{keyword}{self}.expression);
      \textcolor{keywordflow}{return} \textcolor{keyword}{self}.identifier(ast.name,
                             \textcolor{keyword}{self}.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
                             context, create, \textcolor{keyword}{self}.expression);
    \textcolor{keywordflow}{case} AST.MemberExpression:
      left = this.recurse(ast.object, \textcolor{keyword}{false}, !!create);
      \textcolor{keywordflow}{if} (!ast.computed) \{
        ensureSafeMemberName(ast.property.name, \textcolor{keyword}{self}.expression);
        right = ast.property.name;
      \}
      \textcolor{keywordflow}{if} (ast.computed) right = this.recurse(ast.property);
      \textcolor{keywordflow}{return} ast.computed ?
        this.computedMember(left, right, context, create, \textcolor{keyword}{self}.expression) :
        this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
    \textcolor{keywordflow}{case} AST.CallExpression:
      args = [];
      forEach(ast.arguments, \textcolor{keyword}{function}(expr) \{
        args.push(self.recurse(expr));
      \});
      \textcolor{keywordflow}{if} (ast.filter) right = this.$filter(ast.callee.name);
      \textcolor{keywordflow}{if} (!ast.filter) right = this.recurse(ast.callee, \textcolor{keyword}{true});
      \textcolor{keywordflow}{return} ast.filter ?
        \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
          var values = [];
          \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
            values.push(args[i](scope, locals, assign, inputs));
          \}
          var value = right.apply(undefined, values, inputs);
          \textcolor{keywordflow}{return} context ? \{context: undefined, name: undefined, value: value\} : value;
        \} :
        \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
          var rhs = right(scope, locals, assign, inputs);
          var value;
          \textcolor{keywordflow}{if} (rhs.value != null) \{
            ensureSafeObject(rhs.context, \textcolor{keyword}{self}.expression);
            ensureSafeFunction(rhs.value, \textcolor{keyword}{self}.expression);
            var values = [];
            \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
              values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), \textcolor{keyword}{self}.expression));
            \}
            value = ensureSafeObject(rhs.value.apply(rhs.context, values), \textcolor{keyword}{self}.expression);
          \}
          \textcolor{keywordflow}{return} context ? \{value: value\} : value;
        \};
    \textcolor{keywordflow}{case} AST.AssignmentExpression:
      left = this.recurse(ast.left, \textcolor{keyword}{true}, 1);
      right = this.recurse(ast.right);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        ensureSafeObject(lhs.value, \textcolor{keyword}{self}.expression);
        lhs.context[lhs.name] = rhs;
        \textcolor{keywordflow}{return} context ? \{value: rhs\} : rhs;
      \};
    \textcolor{keywordflow}{case} AST.ArrayExpression:
      args = [];
      forEach(ast.elements, \textcolor{keyword}{function}(expr) \{
        args.push(self.recurse(expr));
      \});
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var value = [];
        \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
          value.push(args[i](scope, locals, assign, inputs));
        \}
        \textcolor{keywordflow}{return} context ? \{value: value\} : value;
      \};
    \textcolor{keywordflow}{case} AST.ObjectExpression:
      args = [];
      forEach(ast.properties, \textcolor{keyword}{function}(property) \{
        args.push(\{key: property.key.type === AST.Identifier ?
                        property.key.name :
                        (\textcolor{stringliteral}{''} + property.key.value),
                   value: self.recurse(property.value)
        \});
      \});
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        var value = \{\};
        \textcolor{keywordflow}{for} (var i = 0; i < args.length; ++i) \{
          value[args[i].key] = args[i].value(scope, locals, assign, inputs);
        \}
        \textcolor{keywordflow}{return} context ? \{value: value\} : value;
      \};
    \textcolor{keywordflow}{case} AST.ThisExpression:
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope) \{
        \textcolor{keywordflow}{return} context ? \{value: scope\} : scope;
      \};
    \textcolor{keywordflow}{case} AST.NGValueParameter:
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
        \textcolor{keywordflow}{return} context ? \{value: assign\} : assign;
      \};
    \}
  \},

  \textcolor{stringliteral}{'unary+'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (isDefined(arg)) \{
        arg = +arg;
      \} \textcolor{keywordflow}{else} \{
        arg = 0;
      \}
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'unary-'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (isDefined(arg)) \{
        arg = -arg;
      \} \textcolor{keywordflow}{else} \{
        arg = 0;
      \}
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'unary!'}: \textcolor{keyword}{function}(argument, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = !argument(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary+'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs = right(scope, locals, assign, inputs);
      var arg = plusFn(lhs, rhs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary-'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs = right(scope, locals, assign, inputs);
      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary*'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary/'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary%'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary==='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary!=='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary=='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary!='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary<'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary>'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary<='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary>='}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary&&'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'binary||'}: \textcolor{keyword}{function}(left, right, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  \textcolor{stringliteral}{'ternary?:'}: \textcolor{keyword}{function}(test, alternate, consequent, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent
      (scope, locals, assign, inputs);
      \textcolor{keywordflow}{return} context ? \{value: arg\} : arg;
    \};
  \},
  value: \textcolor{keyword}{function}(value, context) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} context ? \{context: undefined, name: undefined, value: value\} : value; \};
  \},
  identifier: \textcolor{keyword}{function}(name, expensiveChecks, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var base = locals && (name in locals) ? locals : scope;
      \textcolor{keywordflow}{if} (create && create !== 1 && base && !(base[name])) \{
        base[name] = \{\};
      \}
      var value = base ? base[name] : undefined;
      \textcolor{keywordflow}{if} (expensiveChecks) \{
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: base, name: name, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  computedMember: \textcolor{keyword}{function}(left, right, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      var rhs;
      var value;
      \textcolor{keywordflow}{if} (lhs != null) \{
        rhs = right(scope, locals, assign, inputs);
        ensureSafeMemberName(rhs, expression);
        \textcolor{keywordflow}{if} (create && create !== 1 && lhs && !(lhs[rhs])) \{
          lhs[rhs] = \{\};
        \}
        value = lhs[rhs];
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: lhs, name: rhs, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  nonComputedMember: \textcolor{keyword}{function}(left, right, expensiveChecks, context, create, expression) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, locals, assign, inputs) \{
      var lhs = left(scope, locals, assign, inputs);
      \textcolor{keywordflow}{if} (create && create !== 1 && lhs && !(lhs[right])) \{
        lhs[right] = \{\};
      \}
      var value = lhs != null ? lhs[right] : undefined;
      \textcolor{keywordflow}{if} (expensiveChecks || isPossiblyDangerousMemberName(right)) \{
        ensureSafeObject(value, expression);
      \}
      \textcolor{keywordflow}{if} (context) \{
        \textcolor{keywordflow}{return} \{context: lhs, name: right, value: value\};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} value;
      \}
    \};
  \},
  inputs: \textcolor{keyword}{function}(input, watchId) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, value, locals, inputs) \{
      \textcolor{keywordflow}{if} (inputs) \textcolor{keywordflow}{return} inputs[watchId];
      \textcolor{keywordflow}{return} input(scope, value, locals);
    \};
  \}
\};

var Parser = \textcolor{keyword}{function}(lexer, $filter, options) \{
  this.lexer = lexer;
  this.$filter = $filter;
  this.options = options;
  this.ast = \textcolor{keyword}{new} AST(this.lexer);
  this.astCompiler = options.csp ? \textcolor{keyword}{new} ASTInterpreter(this.ast, $filter) :
                                   new ASTCompiler(this.ast, $filter);
\};

Parser.prototype = \{
  constructor: Parser,

  parse: \textcolor{keyword}{function}(text) \{
    \textcolor{keywordflow}{return} this.astCompiler.compile(text, this.options.expensiveChecks);
  \}
\};

var getterFnCacheDefault = createMap();
var getterFnCacheExpensive = createMap();

\textcolor{keyword}{function} isPossiblyDangerousMemberName(name) \{
  \textcolor{keywordflow}{return} name == \textcolor{stringliteral}{'constructor'};
\}

var objectValueOf = Object.prototype.valueOf;

\textcolor{keyword}{function} getValueOf(value) \{
  \textcolor{keywordflow}{return} isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
\}


\textcolor{keyword}{function} $ParseProvider() \{
  var cacheDefault = createMap();
  var cacheExpensive = createMap();

  this.$get = [\textcolor{stringliteral}{'$filter'}, \textcolor{keyword}{function}($filter) \{
    var noUnsafeEval = csp().noUnsafeEval;
    var $parseOptions = \{
          csp: noUnsafeEval,
          expensiveChecks: \textcolor{keyword}{false}
        \},
        $parseOptionsExpensive = \{
          csp: noUnsafeEval,
          expensiveChecks: \textcolor{keyword}{true}
        \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function} $parse(exp, interceptorFn, expensiveChecks) \{
      var parsedExpression, oneTime, cacheKey;

      \textcolor{keywordflow}{switch} (typeof exp) \{
        \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
          exp = exp.trim();
          cacheKey = exp;

          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
          parsedExpression = cache[cacheKey];

          \textcolor{keywordflow}{if} (!parsedExpression) \{
            \textcolor{keywordflow}{if} (exp.charAt(0) === \textcolor{charliteral}{':'} && exp.charAt(1) === \textcolor{charliteral}{':'}) \{
              oneTime = \textcolor{keyword}{true};
              exp = exp.substring(2);
            \}
            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
            var lexer = \textcolor{keyword}{new} Lexer(parseOptions);
            var parser = \textcolor{keyword}{new} Parser(lexer, $filter, parseOptions);
            parsedExpression = parser.parse(exp);
            \textcolor{keywordflow}{if} (parsedExpression.constant) \{
              parsedExpression.$$watchDelegate = constantWatchDelegate;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (oneTime) \{
              parsedExpression.$$watchDelegate = parsedExpression.literal ?
                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parsedExpression.inputs) \{
              parsedExpression.$$watchDelegate = inputsWatchDelegate;
            \}
            cache[cacheKey] = parsedExpression;
          \}
          \textcolor{keywordflow}{return} addInterceptor(parsedExpression, interceptorFn);

        \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
          \textcolor{keywordflow}{return} addInterceptor(exp, interceptorFn);

        \textcolor{keywordflow}{default}:
          \textcolor{keywordflow}{return} noop;
      \}
    \};

    \textcolor{keyword}{function} expressionInputDirtyCheck(newValue, oldValueOfValue) \{

      \textcolor{keywordflow}{if} (newValue == null || oldValueOfValue == null) \{ \textcolor{comment}{// null/undefined}
        \textcolor{keywordflow}{return} newValue === oldValueOfValue;
      \}

      \textcolor{keywordflow}{if} (typeof newValue === \textcolor{stringliteral}{'object'}) \{

        \textcolor{comment}{// attempt to convert the value to a primitive type}
        \textcolor{comment}{// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can}
        \textcolor{comment}{//             be cheaply dirty-checked}
        newValue = getValueOf(newValue);

        \textcolor{keywordflow}{if} (typeof newValue === \textcolor{stringliteral}{'object'}) \{
          \textcolor{comment}{// objects/arrays are not supported - deep-watching them would be too expensive}
          \textcolor{keywordflow}{return} \textcolor{keyword}{false};
        \}

        \textcolor{comment}{// fall-through to the primitive equality check}
      \}

      \textcolor{comment}{//Primitive or NaN}
      \textcolor{keywordflow}{return} newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue)
      ;
    \}

    \textcolor{keyword}{function} inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) 
      \{
      var inputExpressions = parsedExpression.inputs;
      var lastResult;

      \textcolor{keywordflow}{if} (inputExpressions.length === 1) \{
        var oldInputValueOf = expressionInputDirtyCheck; \textcolor{comment}{// init to something unique so that equals check
       fails}
        inputExpressions = inputExpressions[0];
        \textcolor{keywordflow}{return} scope.$watch(\textcolor{keyword}{function} expressionInputWatch(scope) \{
          var newInputValue = inputExpressions(scope);
          \textcolor{keywordflow}{if} (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) \{
            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
            oldInputValueOf = newInputValue && getValueOf(newInputValue);
          \}
          \textcolor{keywordflow}{return} lastResult;
        \}, listener, objectEquality, prettyPrintExpression);
      \}

      var oldInputValueOfValues = [];
      var oldInputValues = [];
      \textcolor{keywordflow}{for} (var i = 0, ii = inputExpressions.length; i < ii; i++) \{
        oldInputValueOfValues[i] = expressionInputDirtyCheck; \textcolor{comment}{// init to something unique so that equals
       check fails}
        oldInputValues[i] = null;
      \}

      \textcolor{keywordflow}{return} scope.$watch(\textcolor{keyword}{function} expressionInputsWatch(scope) \{
        var changed = \textcolor{keyword}{false};

        \textcolor{keywordflow}{for} (var i = 0, ii = inputExpressions.length; i < ii; i++) \{
          var newInputValue = inputExpressions[i](scope);
          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) \{
            oldInputValues[i] = newInputValue;
            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
          \}
        \}

        \textcolor{keywordflow}{if} (changed) \{
          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
        \}

        \textcolor{keywordflow}{return} lastResult;
      \}, listener, objectEquality, prettyPrintExpression);
    \}

    \textcolor{keyword}{function} oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch, lastValue;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} oneTimeWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} oneTimeListener(value, old, scope) \{
        lastValue = value;
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.apply(\textcolor{keyword}{this}, arguments);
        \}
        \textcolor{keywordflow}{if} (isDefined(value)) \{
          scope.$$postDigest(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isDefined(lastValue)) \{
              unwatch();
            \}
          \});
        \}
      \}, objectEquality);
    \}

    \textcolor{keyword}{function} oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch, lastValue;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} oneTimeWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} oneTimeListener(value, old, scope) \{
        lastValue = value;
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.call(\textcolor{keyword}{this}, value, old, scope);
        \}
        \textcolor{keywordflow}{if} (isAllDefined(value)) \{
          scope.$$postDigest(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isAllDefined(lastValue)) unwatch();
          \});
        \}
      \}, objectEquality);

      \textcolor{keyword}{function} isAllDefined(value) \{
        var allDefined = \textcolor{keyword}{true};
        forEach(value, \textcolor{keyword}{function}(val) \{
          \textcolor{keywordflow}{if} (!isDefined(val)) allDefined = \textcolor{keyword}{false};
        \});
        \textcolor{keywordflow}{return} allDefined;
      \}
    \}

    \textcolor{keyword}{function} constantWatchDelegate(scope, listener, objectEquality, parsedExpression) \{
      var unwatch;
      \textcolor{keywordflow}{return} unwatch = scope.$watch(\textcolor{keyword}{function} constantWatch(scope) \{
        \textcolor{keywordflow}{return} parsedExpression(scope);
      \}, \textcolor{keyword}{function} constantListener(value, old, scope) \{
        \textcolor{keywordflow}{if} (isFunction(listener)) \{
          listener.apply(\textcolor{keyword}{this}, arguments);
        \}
        unwatch();
      \}, objectEquality);
    \}

    \textcolor{keyword}{function} addInterceptor(parsedExpression, interceptorFn) \{
      \textcolor{keywordflow}{if} (!interceptorFn) \textcolor{keywordflow}{return} parsedExpression;
      var watchDelegate = parsedExpression.$$watchDelegate;

      var regularWatch =
          watchDelegate !== oneTimeLiteralWatchDelegate &&
          watchDelegate !== oneTimeWatchDelegate;

      var fn = regularWatch ? \textcolor{keyword}{function} regularInterceptedExpression(scope, locals, assign, inputs) \{
        var value = parsedExpression(scope, locals, assign, inputs);
        \textcolor{keywordflow}{return} interceptorFn(value, scope, locals);
      \} : \textcolor{keyword}{function} oneTimeInterceptedExpression(scope, locals, assign, inputs) \{
        var value = parsedExpression(scope, locals, assign, inputs);
        var result = interceptorFn(value, scope, locals);
        \textcolor{comment}{// we only return the interceptor's result if the}
        \textcolor{comment}{// initial value is defined (for bind-once)}
        \textcolor{keywordflow}{return} isDefined(value) ? result : value;
      \};

      \textcolor{comment}{// Propagate $$watchDelegates other then inputsWatchDelegate}
      \textcolor{keywordflow}{if} (parsedExpression.$$watchDelegate &&
          parsedExpression.$$watchDelegate !== inputsWatchDelegate) \{
        fn.$$watchDelegate = parsedExpression.$$watchDelegate;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!interceptorFn.$stateful) \{
        \textcolor{comment}{// If there is an interceptor, but no watchDelegate then treat the interceptor like}
        \textcolor{comment}{// we treat filters - it is assumed to be a pure function unless flagged with $stateful}
        fn.$$watchDelegate = inputsWatchDelegate;
        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
      \}

      \textcolor{keywordflow}{return} fn;
    \}
  \}];
\}

\textcolor{keyword}{function} $QProvider() \{

  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{keyword}{function}($rootScope, $exceptionHandler) \{
    \textcolor{keywordflow}{return} qFactory(\textcolor{keyword}{function}(callback) \{
      $rootScope.$evalAsync(callback);
    \}, $exceptionHandler);
  \}];
\}

\textcolor{keyword}{function} $$QProvider() \{
  this.$get = [\textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{keyword}{function}($browser, $exceptionHandler) \{
    \textcolor{keywordflow}{return} qFactory(\textcolor{keyword}{function}(callback) \{
      $browser.defer(callback);
    \}, $exceptionHandler);
  \}];
\}

\textcolor{keyword}{function} qFactory(nextTick, exceptionHandler) \{
  var $qMinErr = minErr(\textcolor{stringliteral}{'$q'}, TypeError);
  \textcolor{keyword}{function} callOnce(\textcolor{keyword}{self}, resolveFn, rejectFn) \{
    var called = \textcolor{keyword}{false};
    \textcolor{keyword}{function} wrap(fn) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (called) \textcolor{keywordflow}{return};
        called = \textcolor{keyword}{true};
        fn.call(\textcolor{keyword}{self}, value);
      \};
    \}

    \textcolor{keywordflow}{return} [wrap(resolveFn), wrap(rejectFn)];
  \}

  var defer = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Deferred();
  \};

  \textcolor{keyword}{function} Promise() \{
    this.$$state = \{ status: 0 \};
  \}

  extend(Promise.prototype, \{
    then: function(onFulfilled, onRejected, progressBack) \{
      if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) \{
        return this;
      \}
      var result = new Deferred();

      this.$$state.pending = this.$$state.pending || [];
      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
      if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);

      return result.promise;
    \},

    \textcolor{stringliteral}{"catch"}: \textcolor{keyword}{function}(callback) \{
      return this.then(null, callback);
    \},

    \textcolor{stringliteral}{"finally"}: \textcolor{keyword}{function}(callback, progressBack) \{
      return this.then(function(value) \{
        return handleCallback(value, true, callback);
      \}, \textcolor{keyword}{function}(error) \{
        return handleCallback(error, false, callback);
      \}, progressBack);
    \}
  \});

  \textcolor{comment}{//Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native}
  \textcolor{keyword}{function} simpleBind(context, fn) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
      fn.call(context, value);
    \};
  \}

  \textcolor{keyword}{function} processQueue(state) \{
    var fn, deferred, pending;

    pending = state.pending;
    state.processScheduled = \textcolor{keyword}{false};
    state.pending = undefined;
    \textcolor{keywordflow}{for} (var i = 0, ii = pending.length; i < ii; ++i) \{
      deferred = pending[i][0];
      fn = pending[i][state.status];
      \textcolor{keywordflow}{try} \{
        \textcolor{keywordflow}{if} (isFunction(fn)) \{
          deferred.resolve(fn(state.value));
        \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state.status === 1) \{
          deferred.resolve(state.value);
        \} \textcolor{keywordflow}{else} \{
          deferred.reject(state.value);
        \}
      \} \textcolor{keywordflow}{catch} (e) \{
        deferred.reject(e);
        exceptionHandler(e);
      \}
    \}
  \}

  \textcolor{keyword}{function} scheduleProcessQueue(state) \{
    \textcolor{keywordflow}{if} (state.processScheduled || !state.pending) \textcolor{keywordflow}{return};
    state.processScheduled = \textcolor{keyword}{true};
    nextTick(\textcolor{keyword}{function}() \{ processQueue(state); \});
  \}

  \textcolor{keyword}{function} Deferred() \{
    this.promise = \textcolor{keyword}{new} Promise();
    \textcolor{comment}{//Necessary to support unbound execution :/}
    this.resolve = simpleBind(\textcolor{keyword}{this}, this.resolve);
    this.reject = simpleBind(\textcolor{keyword}{this}, this.reject);
    this.notify = simpleBind(\textcolor{keyword}{this}, this.notify);
  \}

  extend(Deferred.prototype, \{
    resolve: function(val) \{
      if (this.promise.$$state.status) return;
      if (val === this.promise) \{
        this.$$reject($qMinErr(
          \textcolor{stringliteral}{'qcycle'},
          \textcolor{stringliteral}{"Expected promise to be resolved with value other than itself '\{0\}'"},
          val));
      \} else \{
        this.$$resolve(val);
      \}

    \},

    $$resolve: \textcolor{keyword}{function}(val) \{
      var then, fns;

      fns = callOnce(this, this.$$resolve, this.$$reject);
      try \{
        if ((isObject(val) || isFunction(val))) then = val && val.then;
        if (isFunction(then)) \{
          this.promise.$$state.status = -1;
          then.call(val, fns[0], fns[1], this.notify);
        \} else \{
          this.promise.$$state.value = val;
          this.promise.$$state.status = 1;
          scheduleProcessQueue(this.promise.$$state);
        \}
      \} catch (e) \{
        fns[1](e);
        exceptionHandler(e);
      \}
    \},

    reject: \textcolor{keyword}{function}(reason) \{
      \textcolor{keywordflow}{if} (this.promise.$$state.status) \textcolor{keywordflow}{return};
      this.$$reject(reason);
    \},

    $$reject: \textcolor{keyword}{function}(reason) \{
      this.promise.$$state.value = reason;
      this.promise.$$state.status = 2;
      scheduleProcessQueue(this.promise.$$state);
    \},

    notify: \textcolor{keyword}{function}(progress) \{
      var callbacks = this.promise.$$state.pending;

      \textcolor{keywordflow}{if} ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) \{
        nextTick(\textcolor{keyword}{function}() \{
          var callback, result;
          \textcolor{keywordflow}{for} (var i = 0, ii = callbacks.length; i < ii; i++) \{
            result = callbacks[i][0];
            callback = callbacks[i][3];
            try \{
              result.notify(isFunction(callback) ? callback(progress) : progress);
            \} catch (e) \{
              exceptionHandler(e);
            \}
          \}
        \});
      \}
    \}
  \});

  var reject = \textcolor{keyword}{function}(reason) \{
    var result = \textcolor{keyword}{new} Deferred();
    result.reject(reason);
    \textcolor{keywordflow}{return} result.promise;
  \};

  var makePromise = \textcolor{keyword}{function} makePromise(value, resolved) \{
    var result = \textcolor{keyword}{new} Deferred();
    \textcolor{keywordflow}{if} (resolved) \{
      result.resolve(value);
    \} \textcolor{keywordflow}{else} \{
      result.reject(value);
    \}
    \textcolor{keywordflow}{return} result.promise;
  \};

  var handleCallback = \textcolor{keyword}{function} handleCallback(value, isResolved, callback) \{
    var callbackOutput = null;
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{if} (isFunction(callback)) callbackOutput = callback();
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} makePromise(e, \textcolor{keyword}{false});
    \}
    \textcolor{keywordflow}{if} (isPromiseLike(callbackOutput)) \{
      \textcolor{keywordflow}{return} callbackOutput.then(\textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{return} makePromise(value, isResolved);
      \}, \textcolor{keyword}{function}(error) \{
        \textcolor{keywordflow}{return} makePromise(error, \textcolor{keyword}{false});
      \});
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} makePromise(value, isResolved);
    \}
  \};

  var when = \textcolor{keyword}{function}(value, callback, errback, progressBack) \{
    var result = \textcolor{keyword}{new} Deferred();
    result.resolve(value);
    \textcolor{keywordflow}{return} result.promise.then(callback, errback, progressBack);
  \};

  var resolve = when;

  \textcolor{keyword}{function} all(promises) \{
    var deferred = \textcolor{keyword}{new} Deferred(),
        counter = 0,
        results = isArray(promises) ? [] : \{\};

    forEach(promises, \textcolor{keyword}{function}(promise, key) \{
      counter++;
      when(promise).then(\textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (results.hasOwnProperty(key)) \textcolor{keywordflow}{return};
        results[key] = value;
        \textcolor{keywordflow}{if} (!(--counter)) deferred.resolve(results);
      \}, \textcolor{keyword}{function}(reason) \{
        \textcolor{keywordflow}{if} (results.hasOwnProperty(key)) \textcolor{keywordflow}{return};
        deferred.reject(reason);
      \});
    \});

    \textcolor{keywordflow}{if} (counter === 0) \{
      deferred.resolve(results);
    \}

    \textcolor{keywordflow}{return} deferred.promise;
  \}

  var $Q = \textcolor{keyword}{function} Q(resolver) \{
    \textcolor{keywordflow}{if} (!isFunction(resolver)) \{
      \textcolor{keywordflow}{throw} $qMinErr(\textcolor{stringliteral}{'norslvr'}, \textcolor{stringliteral}{"Expected resolverFn, got '\{0\}'"}, resolver);
    \}

    \textcolor{keywordflow}{if} (!(\textcolor{keyword}{this} instanceof Q)) \{
      \textcolor{comment}{// More useful when $Q is the Promise itself.}
      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Q(resolver);
    \}

    var deferred = \textcolor{keyword}{new} Deferred();

    \textcolor{keyword}{function} resolveFn(value) \{
      deferred.resolve(value);
    \}

    \textcolor{keyword}{function} rejectFn(reason) \{
      deferred.reject(reason);
    \}

    resolver(resolveFn, rejectFn);

    \textcolor{keywordflow}{return} deferred.promise;
  \};

  $Q.defer = defer;
  $Q.reject = reject;
  $Q.when = when;
  $Q.resolve = resolve;
  $Q.all = all;

  \textcolor{keywordflow}{return} $Q;
\}

\textcolor{keyword}{function} $$RAFProvider() \{ \textcolor{comment}{//rAF}
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$timeout'}, \textcolor{keyword}{function}($window, $timeout) \{
    var requestAnimationFrame = $window.requestAnimationFrame ||
                                $window.webkitRequestAnimationFrame;

    var cancelAnimationFrame = $window.cancelAnimationFrame ||
                               $window.webkitCancelAnimationFrame ||
                               $window.webkitCancelRequestAnimationFrame;

    var rafSupported = !!requestAnimationFrame;
    var rafFn = rafSupported
      ? \textcolor{keyword}{function}(fn) \{
          var \textcolor{keywordtype}{id} = requestAnimationFrame(fn);
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            cancelAnimationFrame(\textcolor{keywordtype}{id});
          \};
        \}
      : \textcolor{keyword}{function}(fn) \{
          var timer = $timeout(fn, 16.66, \textcolor{keyword}{false}); \textcolor{comment}{// 1000 / 60 = 16.666}
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
            $timeout.cancel(timer);
          \};
        \};

    queueFn.supported = rafSupported;

    var cancelLastRAF;
    var taskCount = 0;
    var taskQueue = [];
    \textcolor{keywordflow}{return} queueFn;

    \textcolor{keyword}{function} flush() \{
      \textcolor{keywordflow}{for} (var i = 0; i < taskQueue.length; i++) \{
        var task = taskQueue[i];
        \textcolor{keywordflow}{if} (task) \{
          taskQueue[i] = null;
          task();
        \}
      \}
      taskCount = taskQueue.length = 0;
    \}

    \textcolor{keyword}{function} queueFn(asyncFn) \{
      var index = taskQueue.length;

      taskCount++;
      taskQueue.push(asyncFn);

      \textcolor{keywordflow}{if} (index === 0) \{
        cancelLastRAF = rafFn(flush);
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} cancelQueueFn() \{
        \textcolor{keywordflow}{if} (index >= 0) \{
          taskQueue[index] = null;
          index = null;

          \textcolor{keywordflow}{if} (--taskCount === 0 && cancelLastRAF) \{
            cancelLastRAF();
            cancelLastRAF = null;
            taskQueue.length = 0;
          \}
        \}
      \};
    \}
  \}];
\}

\textcolor{keyword}{function} $RootScopeProvider() \{
  var TTL = 10;
  var $rootScopeMinErr = minErr(\textcolor{stringliteral}{'$rootScope'});
  var lastDirtyWatch = null;
  var applyAsyncId = null;

  this.digestTtl = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      TTL = value;
    \}
    \textcolor{keywordflow}{return} TTL;
  \};

  \textcolor{keyword}{function} createChildScopeClass(parent) \{
    \textcolor{keyword}{function} ChildScope() \{
      this.$$watchers = this.$$nextSibling =
          this.$$childHead = this.$$childTail = null;
      this.$$listeners = \{\};
      this.$$listenerCount = \{\};
      this.$$watchersCount = 0;
      this.$id = nextUid();
      this.$$ChildScope = null;
    \}
    ChildScope.prototype = parent;
    \textcolor{keywordflow}{return} ChildScope;
  \}

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$browser'},
      \textcolor{keyword}{function}($injector, $exceptionHandler, $parse, $browser) \{

    \textcolor{keyword}{function} destroyChildScope($event) \{
        $event.currentScope.$$destroyed = \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} Scope() \{
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this.$root = \textcolor{keyword}{this};
      this.$$destroyed = \textcolor{keyword}{false};
      this.$$listeners = \{\};
      this.$$listenerCount = \{\};
      this.$$watchersCount = 0;
      this.$$isolateBindings = null;
    \}

    Scope.prototype = \{
      constructor: Scope,
      $new: \textcolor{keyword}{function}(isolate, parent) \{
        var child;

        parent = parent || \textcolor{keyword}{this};

        \textcolor{keywordflow}{if} (isolate) \{
          child = \textcolor{keyword}{new} Scope();
          child.$root = this.$root;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// Only create a child scope class if somebody asks for one,}
          \textcolor{comment}{// but cache it to allow the VM to optimize lookups.}
          \textcolor{keywordflow}{if} (!this.$$ChildScope) \{
            this.$$ChildScope = createChildScopeClass(\textcolor{keyword}{this});
          \}
          child = \textcolor{keyword}{new} this.$$ChildScope();
        \}
        child.$parent = parent;
        child.$$prevSibling = parent.$$childTail;
        \textcolor{keywordflow}{if} (parent.$$childHead) \{
          parent.$$childTail.$$nextSibling = child;
          parent.$$childTail = child;
        \} \textcolor{keywordflow}{else} \{
          parent.$$childHead = parent.$$childTail = child;
        \}

        \textcolor{comment}{// When the new scope is not isolated or we inherit from `this`, and}
        \textcolor{comment}{// the parent scope is destroyed, the property `$$destroyed` is inherited}
        \textcolor{comment}{// prototypically. In all other cases, this property needs to be set}
        \textcolor{comment}{// when the parent scope is destroyed.}
        \textcolor{comment}{// The listener needs to be added after the parent is set}
        \textcolor{keywordflow}{if} (isolate || parent != \textcolor{keyword}{this}) child.$on(\textcolor{stringliteral}{'$destroy'}, destroyChildScope);

        \textcolor{keywordflow}{return} child;
      \},

      $watch: \textcolor{keyword}{function}(watchExp, listener, objectEquality, prettyPrintExpression) \{
        var \textcolor{keyword}{get} = $parse(watchExp);

        \textcolor{keywordflow}{if} (\textcolor{keyword}{get}.$$watchDelegate) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{get}.$$watchDelegate(\textcolor{keyword}{this}, listener, objectEquality, \textcolor{keyword}{get}, watchExp);
        \}
        var scope = \textcolor{keyword}{this},
            array = scope.$$watchers,
            watcher = \{
              fn: listener,
              last: initWatchVal,
              \textcolor{keyword}{get}: \textcolor{keyword}{get},
              exp: prettyPrintExpression || watchExp,
              eq: !!objectEquality
            \};

        lastDirtyWatch = null;

        \textcolor{keywordflow}{if} (!isFunction(listener)) \{
          watcher.fn = noop;
        \}

        \textcolor{keywordflow}{if} (!array) \{
          array = scope.$$watchers = [];
        \}
        \textcolor{comment}{// we use unshift since we use a while loop in $digest for speed.}
        \textcolor{comment}{// the while loop reads in reverse order.}
        array.unshift(watcher);
        incrementWatchersCount(\textcolor{keyword}{this}, 1);

        \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatch() \{
          \textcolor{keywordflow}{if} (arrayRemove(array, watcher) >= 0) \{
            incrementWatchersCount(scope, -1);
          \}
          lastDirtyWatch = null;
        \};
      \},

      $watchGroup: \textcolor{keyword}{function}(watchExpressions, listener) \{
        var oldValues = \textcolor{keyword}{new} Array(watchExpressions.length);
        var newValues = \textcolor{keyword}{new} Array(watchExpressions.length);
        var deregisterFns = [];
        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        var changeReactionScheduled = \textcolor{keyword}{false};
        var firstRun = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (!watchExpressions.length) \{
          \textcolor{comment}{// No expressions means we call the listener ASAP}
          var shouldCall = \textcolor{keyword}{true};
          \textcolor{keyword}{self}.$evalAsync(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (shouldCall) listener(newValues, newValues, \textcolor{keyword}{self});
          \});
          \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatchGroup() \{
            shouldCall = \textcolor{keyword}{false};
          \};
        \}

        \textcolor{keywordflow}{if} (watchExpressions.length === 1) \{
          \textcolor{comment}{// Special case size of one}
          \textcolor{keywordflow}{return} this.$watch(watchExpressions[0], \textcolor{keyword}{function} watchGroupAction(value, oldValue, scope) \{
            newValues[0] = value;
            oldValues[0] = oldValue;
            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
          \});
        \}

        forEach(watchExpressions, \textcolor{keyword}{function}(expr, i) \{
          var unwatchFn = \textcolor{keyword}{self}.$watch(expr, \textcolor{keyword}{function} watchGroupSubAction(value, oldValue) \{
            newValues[i] = value;
            oldValues[i] = oldValue;
            \textcolor{keywordflow}{if} (!changeReactionScheduled) \{
              changeReactionScheduled = \textcolor{keyword}{true};
              \textcolor{keyword}{self}.$evalAsync(watchGroupAction);
            \}
          \});
          deregisterFns.push(unwatchFn);
        \});

        \textcolor{keyword}{function} watchGroupAction() \{
          changeReactionScheduled = \textcolor{keyword}{false};

          \textcolor{keywordflow}{if} (firstRun) \{
            firstRun = \textcolor{keyword}{false};
            listener(newValues, newValues, \textcolor{keyword}{self});
          \} \textcolor{keywordflow}{else} \{
            listener(newValues, oldValues, \textcolor{keyword}{self});
          \}
        \}

        \textcolor{keywordflow}{return} \textcolor{keyword}{function} deregisterWatchGroup() \{
          \textcolor{keywordflow}{while} (deregisterFns.length) \{
            deregisterFns.shift()();
          \}
        \};
      \},


      $watchCollection: \textcolor{keyword}{function}(obj, listener) \{
        $watchCollectionInterceptor.$stateful = \textcolor{keyword}{true};

        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        \textcolor{comment}{// the current value, updated on each dirty-check run}
        var newValue;
        \textcolor{comment}{// a shallow copy of the newValue from the last dirty-check run,}
        \textcolor{comment}{// updated to match newValue during dirty-check run}
        var oldValue;
        \textcolor{comment}{// a shallow copy of the newValue from when the last change happened}
        var veryOldValue;
        \textcolor{comment}{// only track veryOldValue if the listener is asking for it}
        var trackVeryOldValue = (listener.length > 1);
        var changeDetected = 0;
        var changeDetector = $parse(obj, $watchCollectionInterceptor);
        var internalArray = [];
        var internalObject = \{\};
        var initRun = \textcolor{keyword}{true};
        var oldLength = 0;

        \textcolor{keyword}{function} $watchCollectionInterceptor(\_value) \{
          newValue = \_value;
          var newLength, key, bothNaN, newItem, oldItem;

          \textcolor{comment}{// If the new value is undefined, then return undefined as the watch may be a one-time watch}
          \textcolor{keywordflow}{if} (isUndefined(newValue)) \textcolor{keywordflow}{return};

          \textcolor{keywordflow}{if} (!isObject(newValue)) \{ \textcolor{comment}{// if primitive}
            \textcolor{keywordflow}{if} (oldValue !== newValue) \{
              oldValue = newValue;
              changeDetected++;
            \}
          \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArrayLike(newValue)) \{
            \textcolor{keywordflow}{if} (oldValue !== internalArray) \{
              \textcolor{comment}{// we are transitioning from something which was not an array into array.}
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            \}

            newLength = newValue.length;

            \textcolor{keywordflow}{if} (oldLength !== newLength) \{
              \textcolor{comment}{// if lengths do not match we need to trigger change notification}
              changeDetected++;
              oldValue.length = oldLength = newLength;
            \}
            \textcolor{comment}{// copy the items to oldValue and look for changes.}
            \textcolor{keywordflow}{for} (var i = 0; i < newLength; i++) \{
              oldItem = oldValue[i];
              newItem = newValue[i];

              bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
              \textcolor{keywordflow}{if} (!bothNaN && (oldItem !== newItem)) \{
                changeDetected++;
                oldValue[i] = newItem;
              \}
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (oldValue !== internalObject) \{
              \textcolor{comment}{// we are transitioning from something which was not an object into object.}
              oldValue = internalObject = \{\};
              oldLength = 0;
              changeDetected++;
            \}
            \textcolor{comment}{// copy the items to oldValue and look for changes.}
            newLength = 0;
            \textcolor{keywordflow}{for} (key in newValue) \{
              \textcolor{keywordflow}{if} (newValue.hasOwnProperty(key)) \{
                newLength++;
                newItem = newValue[key];
                oldItem = oldValue[key];

                \textcolor{keywordflow}{if} (key in oldValue) \{
                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                  \textcolor{keywordflow}{if} (!bothNaN && (oldItem !== newItem)) \{
                    changeDetected++;
                    oldValue[key] = newItem;
                  \}
                \} \textcolor{keywordflow}{else} \{
                  oldLength++;
                  oldValue[key] = newItem;
                  changeDetected++;
                \}
              \}
            \}
            \textcolor{keywordflow}{if} (oldLength > newLength) \{
              \textcolor{comment}{// we used to have more keys, need to find them and destroy them.}
              changeDetected++;
              \textcolor{keywordflow}{for} (key in oldValue) \{
                \textcolor{keywordflow}{if} (!newValue.hasOwnProperty(key)) \{
                  oldLength--;
                  \textcolor{keyword}{delete} oldValue[key];
                \}
              \}
            \}
          \}
          \textcolor{keywordflow}{return} changeDetected;
        \}

        \textcolor{keyword}{function} $watchCollectionAction() \{
          \textcolor{keywordflow}{if} (initRun) \{
            initRun = \textcolor{keyword}{false};
            listener(newValue, newValue, \textcolor{keyword}{self});
          \} \textcolor{keywordflow}{else} \{
            listener(newValue, veryOldValue, \textcolor{keyword}{self});
          \}

          \textcolor{comment}{// make a copy for the next time a collection is changed}
          \textcolor{keywordflow}{if} (trackVeryOldValue) \{
            \textcolor{keywordflow}{if} (!isObject(newValue)) \{
              \textcolor{comment}{//primitive}
              veryOldValue = newValue;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArrayLike(newValue)) \{
              veryOldValue = \textcolor{keyword}{new} Array(newValue.length);
              \textcolor{keywordflow}{for} (var i = 0; i < newValue.length; i++) \{
                veryOldValue[i] = newValue[i];
              \}
            \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// if object}
              veryOldValue = \{\};
              \textcolor{keywordflow}{for} (var key in newValue) \{
                \textcolor{keywordflow}{if} (hasOwnProperty.call(newValue, key)) \{
                  veryOldValue[key] = newValue[key];
                \}
              \}
            \}
          \}
        \}

        \textcolor{keywordflow}{return} this.$watch(changeDetector, $watchCollectionAction);
      \},

      $digest: \textcolor{keyword}{function}() \{
        var watch, value, last,
            watchers,
            length,
            dirty, ttl = TTL,
            next, current, target = \textcolor{keyword}{this},
            watchLog = [],
            logIdx, logMsg, asyncTask;

        beginPhase(\textcolor{stringliteral}{'$digest'});
        \textcolor{comment}{// Check for changes to browser url that happened in sync before the call to $digest}
        $browser.$$checkUrlChange();

        \textcolor{keywordflow}{if} (\textcolor{keyword}{this} === $rootScope && applyAsyncId !== null) \{
          \textcolor{comment}{// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then}
          \textcolor{comment}{// cancel the scheduled $apply and flush the queue of expressions to be evaluated.}
          $browser.defer.cancel(applyAsyncId);
          flushApplyAsync();
        \}

        lastDirtyWatch = null;

        \textcolor{keywordflow}{do} \{ \textcolor{comment}{// "while dirty" loop}
          dirty = \textcolor{keyword}{false};
          current = target;

          \textcolor{keywordflow}{while} (asyncQueue.length) \{
            \textcolor{keywordflow}{try} \{
              asyncTask = asyncQueue.shift();
              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
            lastDirtyWatch = null;
          \}

          traverseScopesLoop:
          \textcolor{keywordflow}{do} \{ \textcolor{comment}{// "traverse the scopes" loop}
            \textcolor{keywordflow}{if} ((watchers = current.$$watchers)) \{
              \textcolor{comment}{// process our watches}
              length = watchers.length;
              \textcolor{keywordflow}{while} (length--) \{
                \textcolor{keywordflow}{try} \{
                  watch = watchers[length];
                  \textcolor{comment}{// Most common watches are on primitives, in which case we can short}
                  \textcolor{comment}{// circuit it with === operator, only when === fails do we use .equals}
                  \textcolor{keywordflow}{if} (watch) \{
                    \textcolor{keywordflow}{if} ((value = watch.get(current)) !== (last = watch.last) &&
                        !(watch.eq
                            ? equals(value, last)
                            : (typeof value === \textcolor{stringliteral}{'number'} && typeof last === \textcolor{stringliteral}{'number'}
                               && isNaN(value) && isNaN(last)))) \{
                      dirty = \textcolor{keyword}{true};
                      lastDirtyWatch = watch;
                      watch.last = watch.eq ? copy(value, null) : value;
                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
                      \textcolor{keywordflow}{if} (ttl < 5) \{
                        logIdx = 4 - ttl;
                        \textcolor{keywordflow}{if} (!watchLog[logIdx]) watchLog[logIdx] = [];
                        watchLog[logIdx].push(\{
                          msg: isFunction(watch.exp) ? \textcolor{stringliteral}{'fn: '} + (watch.exp.name || watch.exp.toString()) : 
      watch.exp,
                          newVal: value,
                          oldVal: last
                        \});
                      \}
                    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (watch === lastDirtyWatch) \{
                      \textcolor{comment}{// If the most recently dirty watcher is now clean, short circuit since the remaining
       watchers}
                      \textcolor{comment}{// have already been tested.}
                      dirty = \textcolor{keyword}{false};
                      \textcolor{keywordflow}{break} traverseScopesLoop;
                    \}
                  \}
                \} \textcolor{keywordflow}{catch} (e) \{
                  $exceptionHandler(e);
                \}
              \}
            \}

            \textcolor{comment}{// Insanity Warning: scope depth-first traversal}
            \textcolor{comment}{// yes, this code is a bit crazy, but it works and we have tests to prove it!}
            \textcolor{comment}{// this piece should be kept in sync with the traversal in $broadcast}
            \textcolor{keywordflow}{if} (!(next = ((current.$$watchersCount && current.$$childHead) ||
                (current !== target && current.$$nextSibling)))) \{
              \textcolor{keywordflow}{while} (current !== target && !(next = current.$$nextSibling)) \{
                current = current.$parent;
              \}
            \}
          \} \textcolor{keywordflow}{while} ((current = next));

          \textcolor{comment}{// `break traverseScopesLoop;` takes us to here}

          \textcolor{keywordflow}{if} ((dirty || asyncQueue.length) && !(ttl--)) \{
            clearPhase();
            \textcolor{keywordflow}{throw} $rootScopeMinErr(\textcolor{stringliteral}{'infdig'},
                \textcolor{stringliteral}{'\{0\} $digest() iterations reached. Aborting!\(\backslash\)n'} +
                \textcolor{stringliteral}{'Watchers fired in the last 5 iterations: \{1\}'},
                TTL, watchLog);
          \}

        \} \textcolor{keywordflow}{while} (dirty || asyncQueue.length);

        clearPhase();

        \textcolor{keywordflow}{while} (postDigestQueue.length) \{
          \textcolor{keywordflow}{try} \{
            postDigestQueue.shift()();
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
          \}
        \}
      \},


      $destroy: \textcolor{keyword}{function}() \{
        \textcolor{comment}{// We can't destroy a scope that has been already destroyed.}
        \textcolor{keywordflow}{if} (this.$$destroyed) \textcolor{keywordflow}{return};
        var parent = this.$parent;

        this.$broadcast(\textcolor{stringliteral}{'$destroy'});
        this.$$destroyed = \textcolor{keyword}{true};

        \textcolor{keywordflow}{if} (\textcolor{keyword}{this} === $rootScope) \{
          \textcolor{comment}{//Remove handlers attached to window when $rootScope is removed}
          $browser.$$applicationDestroyed();
        \}

        incrementWatchersCount(\textcolor{keyword}{this}, -this.$$watchersCount);
        \textcolor{keywordflow}{for} (var eventName in this.$$listenerCount) \{
          decrementListenerCount(\textcolor{keyword}{this}, this.$$listenerCount[eventName], eventName);
        \}

        \textcolor{comment}{// sever all the references to parent scopes (after this cleanup, the current scope should}
        \textcolor{comment}{// not be retained by any of our references and should be eligible for garbage collection)}
        \textcolor{keywordflow}{if} (parent && parent.$$childHead == \textcolor{keyword}{this}) parent.$$childHead = this.$$nextSibling;
        \textcolor{keywordflow}{if} (parent && parent.$$childTail == \textcolor{keyword}{this}) parent.$$childTail = this.$$prevSibling;
        \textcolor{keywordflow}{if} (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        \textcolor{keywordflow}{if} (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        \textcolor{comment}{// Disable listeners, watchers and apply/digest methods}
        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
        this.$on = this.$watch = this.$watchGroup = \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} noop; \};
        this.$$listeners = \{\};

        \textcolor{comment}{// All of the code below is bogus code that works around V8's memory leak via optimized code}
        \textcolor{comment}{// and inline caches.}
        \textcolor{comment}{//}
        \textcolor{comment}{// see:}
        \textcolor{comment}{// - https://code.google.com/p/v8/issues/detail?id=2073#c26}
        \textcolor{comment}{// - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909}
        \textcolor{comment}{// - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451}

        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = this.$root = this.$$watchers = null;
      \},

      $eval: \textcolor{keyword}{function}(expr, locals) \{
        \textcolor{keywordflow}{return} $parse(expr)(\textcolor{keyword}{this}, locals);
      \},

      $evalAsync: \textcolor{keyword}{function}(expr, locals) \{
        \textcolor{comment}{// if we are outside of an $digest loop and this is the first time we are scheduling async}
        \textcolor{comment}{// task also schedule async auto-flush}
        \textcolor{keywordflow}{if} (!$rootScope.$$phase && !asyncQueue.length) \{
          $browser.defer(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (asyncQueue.length) \{
              $rootScope.$digest();
            \}
          \});
        \}

        asyncQueue.push(\{scope: \textcolor{keyword}{this}, expression: expr, locals: locals\});
      \},

      $$postDigest: \textcolor{keyword}{function}(fn) \{
        postDigestQueue.push(fn);
      \},

      $apply: \textcolor{keyword}{function}(expr) \{
        \textcolor{keywordflow}{try} \{
          beginPhase(\textcolor{stringliteral}{'$apply'});
          \textcolor{keywordflow}{try} \{
            \textcolor{keywordflow}{return} this.$eval(expr);
          \} \textcolor{keywordflow}{finally} \{
            clearPhase();
          \}
        \} \textcolor{keywordflow}{catch} (e) \{
          $exceptionHandler(e);
        \} \textcolor{keywordflow}{finally} \{
          \textcolor{keywordflow}{try} \{
            $rootScope.$digest();
          \} \textcolor{keywordflow}{catch} (e) \{
            $exceptionHandler(e);
            \textcolor{keywordflow}{throw} e;
          \}
        \}
      \},

      $applyAsync: \textcolor{keyword}{function}(expr) \{
        var scope = \textcolor{keyword}{this};
        expr && applyAsyncQueue.push($applyAsyncExpression);
        scheduleApplyAsync();

        \textcolor{keyword}{function} $applyAsyncExpression() \{
          scope.$eval(expr);
        \}
      \},

      $on: \textcolor{keyword}{function}(name, listener) \{
        var namedListeners = this.$$listeners[name];
        \textcolor{keywordflow}{if} (!namedListeners) \{
          this.$$listeners[name] = namedListeners = [];
        \}
        namedListeners.push(listener);

        var current = \textcolor{keyword}{this};
        \textcolor{keywordflow}{do} \{
          \textcolor{keywordflow}{if} (!current.$$listenerCount[name]) \{
            current.$$listenerCount[name] = 0;
          \}
          current.$$listenerCount[name]++;
        \} \textcolor{keywordflow}{while} ((current = current.$parent));

        var \textcolor{keyword}{self} = \textcolor{keyword}{this};
        \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
          var indexOfListener = namedListeners.indexOf(listener);
          \textcolor{keywordflow}{if} (indexOfListener !== -1) \{
            namedListeners[indexOfListener] = null;
            decrementListenerCount(\textcolor{keyword}{self}, 1, name);
          \}
        \};
      \},


      $emit: \textcolor{keyword}{function}(name, args) \{
        var empty = [],
            namedListeners,
            scope = \textcolor{keyword}{this},
            stopPropagation = \textcolor{keyword}{false},
            event = \{
              name: name,
              targetScope: scope,
              stopPropagation: \textcolor{keyword}{function}() \{stopPropagation = \textcolor{keyword}{true};\},
              preventDefault: \textcolor{keyword}{function}() \{
                event.defaultPrevented = \textcolor{keyword}{true};
              \},
              defaultPrevented: \textcolor{keyword}{false}
            \},
            listenerArgs = concat([event], arguments, 1),
            i, length;

        \textcolor{keywordflow}{do} \{
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          \textcolor{keywordflow}{for} (i = 0, length = namedListeners.length; i < length; i++) \{

            \textcolor{comment}{// if listeners were deregistered, defragment the array}
            \textcolor{keywordflow}{if} (!namedListeners[i]) \{
              namedListeners.splice(i, 1);
              i--;
              length--;
              \textcolor{keywordflow}{continue};
            \}
            \textcolor{keywordflow}{try} \{
              \textcolor{comment}{//allow all listeners attached to the current scope to run}
              namedListeners[i].apply(null, listenerArgs);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
          \}
          \textcolor{comment}{//if any listener on the current scope stops propagation, prevent bubbling}
          \textcolor{keywordflow}{if} (stopPropagation) \{
            event.currentScope = null;
            \textcolor{keywordflow}{return} event;
          \}
          \textcolor{comment}{//traverse upwards}
          scope = scope.$parent;
        \} \textcolor{keywordflow}{while} (scope);

        event.currentScope = null;

        \textcolor{keywordflow}{return} event;
      \},


      $broadcast: \textcolor{keyword}{function}(name, args) \{
        var target = \textcolor{keyword}{this},
            current = target,
            next = target,
            event = \{
              name: name,
              targetScope: target,
              preventDefault: \textcolor{keyword}{function}() \{
                event.defaultPrevented = \textcolor{keyword}{true};
              \},
              defaultPrevented: \textcolor{keyword}{false}
            \};

        \textcolor{keywordflow}{if} (!target.$$listenerCount[name]) \textcolor{keywordflow}{return} event;

        var listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        \textcolor{comment}{//down while you can, then up and next sibling or up and next sibling until back at root}
        \textcolor{keywordflow}{while} ((current = next)) \{
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          \textcolor{keywordflow}{for} (i = 0, length = listeners.length; i < length; i++) \{
            \textcolor{comment}{// if listeners were deregistered, defragment the array}
            \textcolor{keywordflow}{if} (!listeners[i]) \{
              listeners.splice(i, 1);
              i--;
              length--;
              \textcolor{keywordflow}{continue};
            \}

            \textcolor{keywordflow}{try} \{
              listeners[i].apply(null, listenerArgs);
            \} \textcolor{keywordflow}{catch} (e) \{
              $exceptionHandler(e);
            \}
          \}

          \textcolor{comment}{// Insanity Warning: scope depth-first traversal}
          \textcolor{comment}{// yes, this code is a bit crazy, but it works and we have tests to prove it!}
          \textcolor{comment}{// this piece should be kept in sync with the traversal in $digest}
          \textcolor{comment}{// (though it differs due to having the extra check for $$listenerCount)}
          \textcolor{keywordflow}{if} (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
              (current !== target && current.$$nextSibling)))) \{
            \textcolor{keywordflow}{while} (current !== target && !(next = current.$$nextSibling)) \{
              current = current.$parent;
            \}
          \}
        \}

        event.currentScope = null;
        \textcolor{keywordflow}{return} event;
      \}
    \};

    var $rootScope = \textcolor{keyword}{new} Scope();

    \textcolor{comment}{//The internal queues. Expose them on the $rootScope for debugging/testing purposes.}
    var asyncQueue = $rootScope.$$asyncQueue = [];
    var postDigestQueue = $rootScope.$$postDigestQueue = [];
    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];

    \textcolor{keywordflow}{return} $rootScope;


    \textcolor{keyword}{function} beginPhase(phase) \{
      \textcolor{keywordflow}{if} ($rootScope.$$phase) \{
        \textcolor{keywordflow}{throw} $rootScopeMinErr(\textcolor{stringliteral}{'inprog'}, \textcolor{stringliteral}{'\{0\} already in progress'}, $rootScope.$$phase);
      \}

      $rootScope.$$phase = phase;
    \}

    \textcolor{keyword}{function} clearPhase() \{
      $rootScope.$$phase = null;
    \}

    \textcolor{keyword}{function} incrementWatchersCount(current, count) \{
      \textcolor{keywordflow}{do} \{
        current.$$watchersCount += count;
      \} \textcolor{keywordflow}{while} ((current = current.$parent));
    \}

    \textcolor{keyword}{function} decrementListenerCount(current, count, name) \{
      \textcolor{keywordflow}{do} \{
        current.$$listenerCount[name] -= count;

        \textcolor{keywordflow}{if} (current.$$listenerCount[name] === 0) \{
          \textcolor{keyword}{delete} current.$$listenerCount[name];
        \}
      \} \textcolor{keywordflow}{while} ((current = current.$parent));
    \}

    \textcolor{keyword}{function} initWatchVal() \{\}

    \textcolor{keyword}{function} flushApplyAsync() \{
      \textcolor{keywordflow}{while} (applyAsyncQueue.length) \{
        \textcolor{keywordflow}{try} \{
          applyAsyncQueue.shift()();
        \} \textcolor{keywordflow}{catch} (e) \{
          $exceptionHandler(e);
        \}
      \}
      applyAsyncId = null;
    \}

    \textcolor{keyword}{function} scheduleApplyAsync() \{
      \textcolor{keywordflow}{if} (applyAsyncId === null) \{
        applyAsyncId = $browser.defer(\textcolor{keyword}{function}() \{
          $rootScope.$apply(flushApplyAsync);
        \});
      \}
    \}
  \}];
\}

\textcolor{keyword}{function} $$SanitizeUriProvider() \{
  var aHrefSanitizationWhitelist = /^\(\backslash\)s*(https?|ftp|mailto|tel|file):/,
    imgSrcSanitizationWhitelist = /^\(\backslash\)s*((https?|ftp|file|blob):|data:image\(\backslash\)/)/;

  this.aHrefSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      aHrefSanitizationWhitelist = regexp;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} aHrefSanitizationWhitelist;
  \};


  this.imgSrcSanitizationWhitelist = \textcolor{keyword}{function}(regexp) \{
    \textcolor{keywordflow}{if} (isDefined(regexp)) \{
      imgSrcSanitizationWhitelist = regexp;
      \textcolor{keywordflow}{return} \textcolor{keyword}{this};
    \}
    \textcolor{keywordflow}{return} imgSrcSanitizationWhitelist;
  \};

  this.$get = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function} sanitizeUri(uri, isImage) \{
      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
      var normalizedVal;
      normalizedVal = urlResolve(uri).href;
      \textcolor{keywordflow}{if} (normalizedVal !== \textcolor{stringliteral}{''} && !normalizedVal.match(regex)) \{
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{'unsafe:'} + normalizedVal;
      \}
      \textcolor{keywordflow}{return} uri;
    \};
  \};
\}

\textcolor{comment}{/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *}
\textcolor{comment}{ *     Any commits to this file should be reviewed with security in mind.  *}
\textcolor{comment}{ *   Changes to this file can potentially create security vulnerabilities. *}
\textcolor{comment}{ *          An approval from 2 Core members with history of modifying      *}
\textcolor{comment}{ *                         this file is required.                          *}
\textcolor{comment}{ *                                                                         *}
\textcolor{comment}{ *  Does the change somehow allow for arbitrary javascript to be executed? *}
\textcolor{comment}{ *    Or allows for someone to change the prototype of built-in objects?   *}
\textcolor{comment}{ *     Or gives undesired access to variables likes document or window?    *}
\textcolor{comment}{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */}

var $sceMinErr = minErr(\textcolor{stringliteral}{'$sce'});

var SCE\_CONTEXTS = \{
  HTML: \textcolor{stringliteral}{'html'},
  CSS: \textcolor{stringliteral}{'css'},
  URL: \textcolor{stringliteral}{'url'},
  \textcolor{comment}{// RESOURCE\_URL is a subtype of URL used in contexts where a privileged resource is sourced from a}
  \textcolor{comment}{// url.  (e.g. ng-include, script src, templateUrl)}
  RESOURCE\_URL: \textcolor{stringliteral}{'resourceUrl'},
  JS: \textcolor{stringliteral}{'js'}
\};

\textcolor{comment}{// Helper functions follow.}

\textcolor{keyword}{function} adjustMatcher(matcher) \{
  \textcolor{keywordflow}{if} (matcher === \textcolor{stringliteral}{'self'}) \{
    \textcolor{keywordflow}{return} matcher;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(matcher)) \{
    \textcolor{comment}{// Strings match exactly except for 2 wildcards - '*' and '**'.}
    \textcolor{comment}{// '*' matches any character except those from the set ':/.?&'.}
    \textcolor{comment}{// '**' matches any character (like .* in a RegExp).}
    \textcolor{comment}{// More than 2 *'s raises an error as it's ill defined.}
    \textcolor{keywordflow}{if} (matcher.indexOf(\textcolor{stringliteral}{'***'}) > -1) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'iwcard'},
          \textcolor{stringliteral}{'Illegal sequence *** in string matcher.  String: \{0\}'}, matcher);
    \}
    matcher = escapeForRegexp(matcher).
                  replace(\textcolor{stringliteral}{'\(\backslash\)\(\backslash\)*\(\backslash\)\(\backslash\)*'}, \textcolor{stringliteral}{'.*'}).
                  replace(\textcolor{stringliteral}{'\(\backslash\)\(\backslash\)*'}, \textcolor{stringliteral}{'[^:/.?&;]*'});
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} RegExp(\textcolor{charliteral}{'^'} + matcher + \textcolor{charliteral}{'$'});
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isRegExp(matcher)) \{
    \textcolor{comment}{// The only other type of matcher allowed is a Regexp.}
    \textcolor{comment}{// Match entire URL / disallow partial matches.}
    \textcolor{comment}{// Flags are reset (i.e. no global, ignoreCase or multiline)}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} RegExp(\textcolor{charliteral}{'^'} + matcher.source + \textcolor{charliteral}{'$'});
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'imatcher'},
        \textcolor{stringliteral}{'Matchers may only be "self", string patterns or RegExp objects'});
  \}
\}


\textcolor{keyword}{function} adjustMatchers(matchers) \{
  var adjustedMatchers = [];
  \textcolor{keywordflow}{if} (isDefined(matchers)) \{
    forEach(matchers, \textcolor{keyword}{function}(matcher) \{
      adjustedMatchers.push(adjustMatcher(matcher));
    \});
  \}
  \textcolor{keywordflow}{return} adjustedMatchers;
\}


\textcolor{keyword}{function} $SceDelegateProvider() \{
  this.SCE\_CONTEXTS = SCE\_CONTEXTS;

  \textcolor{comment}{// Resource URLs can also be trusted by policy.}
  var resourceUrlWhitelist = [\textcolor{stringliteral}{'self'}],
      resourceUrlBlacklist = [];

  this.resourceUrlWhitelist = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      resourceUrlWhitelist = adjustMatchers(value);
    \}
    \textcolor{keywordflow}{return} resourceUrlWhitelist;
  \};

  this.resourceUrlBlacklist = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      resourceUrlBlacklist = adjustMatchers(value);
    \}
    \textcolor{keywordflow}{return} resourceUrlBlacklist;
  \};

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{

    var htmlSanitizer = \textcolor{keyword}{function} htmlSanitizer(html) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'unsafe'}, \textcolor{stringliteral}{'Attempting to use an unsafe value in a safe context.'});
    \};

    \textcolor{keywordflow}{if} ($injector.has(\textcolor{stringliteral}{'$sanitize'})) \{
      htmlSanitizer = $injector.get(\textcolor{stringliteral}{'$sanitize'});
    \}


    \textcolor{keyword}{function} matchUrl(matcher, parsedUrl) \{
      \textcolor{keywordflow}{if} (matcher === \textcolor{stringliteral}{'self'}) \{
        \textcolor{keywordflow}{return} urlIsSameOrigin(parsedUrl);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// definitely a regex.  See adjustMatchers()}
        \textcolor{keywordflow}{return} !!matcher.exec(parsedUrl.href);
      \}
    \}

    \textcolor{keyword}{function} isResourceUrlAllowedByPolicy(url) \{
      var parsedUrl = urlResolve(url.toString());
      var i, n, allowed = \textcolor{keyword}{false};
      \textcolor{comment}{// Ensure that at least one item from the whitelist allows this url.}
      \textcolor{keywordflow}{for} (i = 0, n = resourceUrlWhitelist.length; i < n; i++) \{
        \textcolor{keywordflow}{if} (matchUrl(resourceUrlWhitelist[i], parsedUrl)) \{
          allowed = \textcolor{keyword}{true};
          \textcolor{keywordflow}{break};
        \}
      \}
      \textcolor{keywordflow}{if} (allowed) \{
        \textcolor{comment}{// Ensure that no item from the blacklist blocked this url.}
        \textcolor{keywordflow}{for} (i = 0, n = resourceUrlBlacklist.length; i < n; i++) \{
          \textcolor{keywordflow}{if} (matchUrl(resourceUrlBlacklist[i], parsedUrl)) \{
            allowed = \textcolor{keyword}{false};
            \textcolor{keywordflow}{break};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} allowed;
    \}

    \textcolor{keyword}{function} generateHolderType(Base) \{
      var holderType = \textcolor{keyword}{function} TrustedValueHolderType(trustedValue) \{
        this.$$unwrapTrustedValue = \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{return} trustedValue;
        \};
      \};
      \textcolor{keywordflow}{if} (Base) \{
        holderType.prototype = \textcolor{keyword}{new} Base();
      \}
      holderType.prototype.valueOf = \textcolor{keyword}{function} sceValueOf() \{
        \textcolor{keywordflow}{return} this.$$unwrapTrustedValue();
      \};
      holderType.prototype.toString = \textcolor{keyword}{function} sceToString() \{
        \textcolor{keywordflow}{return} this.$$unwrapTrustedValue().toString();
      \};
      \textcolor{keywordflow}{return} holderType;
    \}

    var trustedValueHolderBase = generateHolderType(),
        byType = \{\};

    byType[SCE\_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
    byType[SCE\_CONTEXTS.RESOURCE\_URL] = generateHolderType(byType[SCE\_CONTEXTS.URL]);

    \textcolor{keyword}{function} trustAs(type, trustedValue) \{
      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      \textcolor{keywordflow}{if} (!Constructor) \{
        \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'icontext'},
            \textcolor{stringliteral}{'Attempted to trust a value in invalid context. Context: \{0\}; Value: \{1\}'},
            type, trustedValue);
      \}
      \textcolor{keywordflow}{if} (trustedValue === null || trustedValue === undefined || trustedValue === \textcolor{stringliteral}{''}) \{
        \textcolor{keywordflow}{return} trustedValue;
      \}
      \textcolor{comment}{// All the current contexts in SCE\_CONTEXTS happen to be strings.  In order to avoid trusting}
      \textcolor{comment}{// mutable objects, we ensure here that the value passed in is actually a string.}
      \textcolor{keywordflow}{if} (typeof trustedValue !== \textcolor{stringliteral}{'string'}) \{
        \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'itype'},
            \textcolor{stringliteral}{'Attempted to trust a non-string value in a content requiring a string: Context: \{0\}'},
            type);
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Constructor(trustedValue);
    \}

    \textcolor{keyword}{function} valueOf(maybeTrusted) \{
      \textcolor{keywordflow}{if} (maybeTrusted instanceof trustedValueHolderBase) \{
        \textcolor{keywordflow}{return} maybeTrusted.$$unwrapTrustedValue();
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} maybeTrusted;
      \}
    \}

    \textcolor{keyword}{function} getTrusted(type, maybeTrusted) \{
      \textcolor{keywordflow}{if} (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === \textcolor{stringliteral}{''}) \{
        \textcolor{keywordflow}{return} maybeTrusted;
      \}
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      \textcolor{keywordflow}{if} (constructor && maybeTrusted instanceof constructor) \{
        \textcolor{keywordflow}{return} maybeTrusted.$$unwrapTrustedValue();
      \}
      \textcolor{comment}{// If we get here, then we may only take one of two actions.}
      \textcolor{comment}{// 1. sanitize the value for the requested type, or}
      \textcolor{comment}{// 2. throw an exception.}
      \textcolor{keywordflow}{if} (type === SCE\_CONTEXTS.RESOURCE\_URL) \{
        \textcolor{keywordflow}{if} (isResourceUrlAllowedByPolicy(maybeTrusted)) \{
          \textcolor{keywordflow}{return} maybeTrusted;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'insecurl'},
              \textcolor{stringliteral}{'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: \{0\}'},
              maybeTrusted.toString());
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === SCE\_CONTEXTS.HTML) \{
        \textcolor{keywordflow}{return} htmlSanitizer(maybeTrusted);
      \}
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'unsafe'}, \textcolor{stringliteral}{'Attempting to use an unsafe value in a safe context.'});
    \}

    \textcolor{keywordflow}{return} \{ trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf \};
  \}];
\}


\textcolor{comment}{/* jshint maxlen: false*/}

\textcolor{comment}{/* jshint maxlen: 100 */}

\textcolor{keyword}{function} $SceProvider() \{
  var enabled = \textcolor{keyword}{true};

  this.enabled = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (arguments.length) \{
      enabled = !!value;
    \}
    \textcolor{keywordflow}{return} enabled;
  \};


  \textcolor{comment}{/* Design notes on the default implementation for SCE.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The API contract for the SCE delegate}
\textcolor{comment}{   * -------------------------------------}
\textcolor{comment}{   * The SCE delegate object must provide the following 3 methods:}
\textcolor{comment}{   *}
\textcolor{comment}{   * - trustAs(contextEnum, value)}
\textcolor{comment}{   *     This method is used to tell the SCE service that the provided value is OK to use in the}
\textcolor{comment}{   *     contexts specified by contextEnum.  It must return an object that will be accepted by}
\textcolor{comment}{   *     getTrusted() for a compatible contextEnum and return this value.}
\textcolor{comment}{   *}
\textcolor{comment}{   * - valueOf(value)}
\textcolor{comment}{   *     For values that were not produced by trustAs(), return them as is.  For values that were}
\textcolor{comment}{   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if}
\textcolor{comment}{   *     trustAs is wrapping the given values into some type, this operation unwraps it when given}
\textcolor{comment}{   *     such a value.}
\textcolor{comment}{   *}
\textcolor{comment}{   * - getTrusted(contextEnum, value)}
\textcolor{comment}{   *     This function should return the a value that is safe to use in the context specified by}
\textcolor{comment}{   *     contextEnum or throw and exception otherwise.}
\textcolor{comment}{   *}
\textcolor{comment}{   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be}
\textcolor{comment}{   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For}
\textcolor{comment}{   * instance, an implementation could maintain a registry of all trusted objects by context.  In}
\textcolor{comment}{   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would}
\textcolor{comment}{   * return the same object passed in if it was found in the registry under a compatible context or}
\textcolor{comment}{   * throw an exception otherwise.  An implementation might only wrap values some of the time based}
\textcolor{comment}{   * on some criteria.  getTrusted() might return a value and not throw an exception for special}
\textcolor{comment}{   * constants or objects even if not wrapped.  All such implementations fulfill this contract.}
\textcolor{comment}{   *}
\textcolor{comment}{   *}
\textcolor{comment}{   * A note on the inheritance model for SCE contexts}
\textcolor{comment}{   * ------------------------------------------------}
\textcolor{comment}{   * I've used inheritance and made RESOURCE\_URL wrapped types a subtype of URL wrapped types.  This}
\textcolor{comment}{   * is purely an implementation details.}
\textcolor{comment}{   *}
\textcolor{comment}{   * The contract is simply this:}
\textcolor{comment}{   *}
\textcolor{comment}{   *     getTrusted($sce.RESOURCE\_URL, value) succeeding implies that getTrusted($sce.URL, value)}
\textcolor{comment}{   *     will also succeed.}
\textcolor{comment}{   *}
\textcolor{comment}{   * Inheritance happens to capture this in a natural way.  In some future, we}
\textcolor{comment}{   * may not use inheritance anymore.  That is OK because no code outside of}
\textcolor{comment}{   * sce.js and sceSpecs.js would need to be aware of this detail.}
\textcolor{comment}{   */}

  this.$get = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$sceDelegate'}, \textcolor{keyword}{function}(
                $parse,   $sceDelegate) \{
    \textcolor{comment}{// Prereq: Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow}
    \textcolor{comment}{// the "expression(javascript expression)" syntax which is insecure.}
    \textcolor{keywordflow}{if} (enabled && msie < 8) \{
      \textcolor{keywordflow}{throw} $sceMinErr(\textcolor{stringliteral}{'iequirks'},
        \textcolor{stringliteral}{'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks '} +
        \textcolor{stringliteral}{'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML '} +
        \textcolor{stringliteral}{'document.  See http://docs.angularjs.org/api/ng.$sce for more information.'});
    \}

    var sce = shallowCopy(SCE\_CONTEXTS);

    sce.isEnabled = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} enabled;
    \};
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    \textcolor{keywordflow}{if} (!enabled) \{
      sce.trustAs = sce.getTrusted = \textcolor{keyword}{function}(type, value) \{ \textcolor{keywordflow}{return} value; \};
      sce.valueOf = identity;
    \}

    sce.parseAs = \textcolor{keyword}{function} sceParseAs(type, expr) \{
      var parsed = $parse(expr);
      \textcolor{keywordflow}{if} (parsed.literal && parsed.constant) \{
        \textcolor{keywordflow}{return} parsed;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} $parse(expr, \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} sce.getTrusted(type, value);
        \});
      \}
    \};

    \textcolor{comment}{// Shorthand delegations.}
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    forEach(SCE\_CONTEXTS, \textcolor{keyword}{function}(enumValue, name) \{
      var lName = lowercase(name);
      sce[camelCase(\textcolor{stringliteral}{"parse\_as\_"} + lName)] = \textcolor{keyword}{function}(expr) \{
        \textcolor{keywordflow}{return} parse(enumValue, expr);
      \};
      sce[camelCase(\textcolor{stringliteral}{"get\_trusted\_"} + lName)] = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} getTrusted(enumValue, value);
      \};
      sce[camelCase(\textcolor{stringliteral}{"trust\_as\_"} + lName)] = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} trustAs(enumValue, value);
      \};
    \});

    \textcolor{keywordflow}{return} sce;
  \}];
\}

\textcolor{keyword}{function} $SnifferProvider() \{
  this.$get = [\textcolor{stringliteral}{'$window'}, \textcolor{stringliteral}{'$document'}, \textcolor{keyword}{function}($window, $document) \{
    var eventSupport = \{\},
        android =
          toInt((/android (\(\backslash\)d+)/.exec(lowercase(($window.navigator || \{\}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || \{\}).userAgent),
        document = $document[0] || \{\},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = \textcolor{keyword}{false},
        animations = \textcolor{keyword}{false},
        match;

    \textcolor{keywordflow}{if} (bodyStyle) \{
      \textcolor{keywordflow}{for} (var prop in bodyStyle) \{
        \textcolor{keywordflow}{if} (match = vendorRegex.exec(prop)) \{
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          \textcolor{keywordflow}{break};
        \}
      \}

      \textcolor{keywordflow}{if} (!vendorPrefix) \{
        vendorPrefix = (\textcolor{stringliteral}{'WebkitOpacity'} in bodyStyle) && \textcolor{stringliteral}{'webkit'};
      \}

      transitions = !!((\textcolor{stringliteral}{'transition'} in bodyStyle) || (vendorPrefix + \textcolor{stringliteral}{'Transition'} in bodyStyle));
      animations  = !!((\textcolor{stringliteral}{'animation'} in bodyStyle) || (vendorPrefix + \textcolor{stringliteral}{'Animation'} in bodyStyle));

      \textcolor{keywordflow}{if} (android && (!transitions ||  !animations)) \{
        transitions = isString(bodyStyle.webkitTransition);
        animations = isString(bodyStyle.webkitAnimation);
      \}
    \}


    \textcolor{keywordflow}{return} \{
      \textcolor{comment}{// Android has history.pushState, but it does not update location correctly}
      \textcolor{comment}{// so let's not use the history API at all.}
      \textcolor{comment}{// http://code.google.com/p/android/issues/detail?id=17471}
      \textcolor{comment}{// https://github.com/angular/angular.js/issues/904}

      \textcolor{comment}{// older webkit browser (533.9) on Boxee box has exactly the same problem as Android has}
      \textcolor{comment}{// so let's not use the history API also}
      \textcolor{comment}{// We are purposefully using `!(android < 4)` to cover the case when `android` is undefined}
      \textcolor{comment}{// jshint -W018}
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      \textcolor{comment}{// jshint +W018}
      hasEvent: \textcolor{keyword}{function}(event) \{
        \textcolor{comment}{// IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have}
        \textcolor{comment}{// it. In particular the event is not fired when backspace or delete key are pressed or}
        \textcolor{comment}{// when cut operation is performed.}
        \textcolor{comment}{// IE10+ implements 'input' event but it erroneously fires under various situations,}
        \textcolor{comment}{// e.g. when placeholder changes, or a form is focused.}
        \textcolor{keywordflow}{if} (event === \textcolor{stringliteral}{'input'} && msie <= 11) \textcolor{keywordflow}{return} \textcolor{keyword}{false};

        \textcolor{keywordflow}{if} (isUndefined(eventSupport[event])) \{
          var divElm = document.createElement(\textcolor{stringliteral}{'div'});
          eventSupport[event] = \textcolor{stringliteral}{'on'} + event in divElm;
        \}

        \textcolor{keywordflow}{return} eventSupport[event];
      \},
      csp: csp(),
      vendorPrefix: vendorPrefix,
      transitions: transitions,
      animations: animations,
      android: android
    \};
  \}];
\}

var $compileMinErr = minErr(\textcolor{stringliteral}{'$compile'});

\textcolor{keyword}{function} $TemplateRequestProvider() \{
  this.$get = [\textcolor{stringliteral}{'$templateCache'}, \textcolor{stringliteral}{'$http'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$sce'}, \textcolor{keyword}{function}($templateCache, $http, $q, $sce) \{
    \textcolor{keyword}{function} handleRequestFn(tpl, ignoreRequestError) \{
      handleRequestFn.totalPendingRequests++;

      \textcolor{comment}{// We consider the template cache holds only trusted templates, so}
      \textcolor{comment}{// there's no need to go through whitelisting again for keys that already}
      \textcolor{comment}{// are included in there. This also makes Angular accept any script}
      \textcolor{comment}{// directive, no matter its name. However, we still need to unwrap trusted}
      \textcolor{comment}{// types.}
      \textcolor{keywordflow}{if} (!isString(tpl) || !$templateCache.get(tpl)) \{
        tpl = $sce.getTrustedResourceUrl(tpl);
      \}

      var transformResponse = $http.defaults && $http.defaults.transformResponse;

      \textcolor{keywordflow}{if} (isArray(transformResponse)) \{
        transformResponse = transformResponse.filter(\textcolor{keyword}{function}(transformer) \{
          \textcolor{keywordflow}{return} transformer !== defaultHttpResponseTransform;
        \});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (transformResponse === defaultHttpResponseTransform) \{
        transformResponse = null;
      \}

      var httpOptions = \{
        cache: $templateCache,
        transformResponse: transformResponse
      \};

      \textcolor{keywordflow}{return} $http.get(tpl, httpOptions)
        [\textcolor{stringliteral}{'finally'}](\textcolor{keyword}{function}() \{
          handleRequestFn.totalPendingRequests--;
        \})
        .then(\textcolor{keyword}{function}(response) \{
          $templateCache.put(tpl, response.data);
          \textcolor{keywordflow}{return} response.data;
        \}, handleError);

      \textcolor{keyword}{function} handleError(resp) \{
        \textcolor{keywordflow}{if} (!ignoreRequestError) \{
          \textcolor{keywordflow}{throw} $compileMinErr(\textcolor{stringliteral}{'tpload'}, \textcolor{stringliteral}{'Failed to load template: \{0\} (HTTP status: \{1\} \{2\})'},
            tpl, resp.status, resp.statusText);
        \}
        \textcolor{keywordflow}{return} $q.reject(resp);
      \}
    \}

    handleRequestFn.totalPendingRequests = 0;

    \textcolor{keywordflow}{return} handleRequestFn;
  \}];
\}

\textcolor{keyword}{function} $$TestabilityProvider() \{
  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$location'},
       \textcolor{keyword}{function}($rootScope,   $browser,   $location) \{

    var testability = \{\};

    testability.findBindings = \textcolor{keyword}{function}(element, expression, opt\_exactMatch) \{
      var bindings = element.getElementsByClassName(\textcolor{stringliteral}{'ng-binding'});
      var matches = [];
      forEach(bindings, \textcolor{keyword}{function}(binding) \{
        var dataBinding = angular.element(binding).data(\textcolor{stringliteral}{'$binding'});
        \textcolor{keywordflow}{if} (dataBinding) \{
          forEach(dataBinding, \textcolor{keyword}{function}(bindingName) \{
            \textcolor{keywordflow}{if} (opt\_exactMatch) \{
              var matcher = \textcolor{keyword}{new} RegExp(\textcolor{stringliteral}{'(^|\(\backslash\)\(\backslash\)s)'} + escapeForRegexp(expression) + \textcolor{stringliteral}{'(\(\backslash\)\(\backslash\)s|\(\backslash\)\(\backslash\)||$)'});
              \textcolor{keywordflow}{if} (matcher.test(bindingName)) \{
                matches.push(binding);
              \}
            \} \textcolor{keywordflow}{else} \{
              \textcolor{keywordflow}{if} (bindingName.indexOf(expression) != -1) \{
                matches.push(binding);
              \}
            \}
          \});
        \}
      \});
      \textcolor{keywordflow}{return} matches;
    \};

    testability.findModels = \textcolor{keyword}{function}(element, expression, opt\_exactMatch) \{
      var prefixes = [\textcolor{stringliteral}{'ng-'}, \textcolor{stringliteral}{'data-ng-'}, \textcolor{stringliteral}{'ng\(\backslash\)\(\backslash\):'}];
      \textcolor{keywordflow}{for} (var p = 0; p < prefixes.length; ++p) \{
        var attributeEquals = opt\_exactMatch ? \textcolor{charliteral}{'='} : \textcolor{stringliteral}{'*='};
        var selector = \textcolor{charliteral}{'['} + prefixes[p] + \textcolor{stringliteral}{'model'} + attributeEquals + \textcolor{charliteral}{'"'} + expression + \textcolor{stringliteral}{'"]'};
        var elements = element.querySelectorAll(selector);
        \textcolor{keywordflow}{if} (elements.length) \{
          \textcolor{keywordflow}{return} elements;
        \}
      \}
    \};

    testability.getLocation = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} $location.url();
    \};

    testability.setLocation = \textcolor{keyword}{function}(url) \{
      \textcolor{keywordflow}{if} (url !== $location.url()) \{
        $location.url(url);
        $rootScope.$digest();
      \}
    \};

    testability.whenStable = \textcolor{keyword}{function}(callback) \{
      $browser.notifyWhenNoOutstandingRequests(callback);
    \};

    \textcolor{keywordflow}{return} testability;
  \}];
\}

\textcolor{keyword}{function} $TimeoutProvider() \{
  this.$get = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$$q'}, \textcolor{stringliteral}{'$exceptionHandler'},
       \textcolor{keyword}{function}($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) \{

    var deferreds = \{\};


    \textcolor{keyword}{function} timeout(fn, delay, invokeApply) \{
      \textcolor{keywordflow}{if} (!isFunction(fn)) \{
        invokeApply = delay;
        delay = fn;
        fn = noop;
      \}

      var args = sliceArgs(arguments, 3),
          skipApply = (isDefined(invokeApply) && !invokeApply),
          deferred = (skipApply ? $$q : $q).defer(),
          promise = deferred.promise,
          timeoutId;

      timeoutId = $browser.defer(\textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{try} \{
          deferred.resolve(fn.apply(null, args));
        \} \textcolor{keywordflow}{catch} (e) \{
          deferred.reject(e);
          $exceptionHandler(e);
        \}
        \textcolor{keywordflow}{finally} \{
          \textcolor{keyword}{delete} deferreds[promise.$$timeoutId];
        \}

        \textcolor{keywordflow}{if} (!skipApply) $rootScope.$apply();
      \}, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      \textcolor{keywordflow}{return} promise;
    \}


    timeout.cancel = \textcolor{keyword}{function}(promise) \{
      \textcolor{keywordflow}{if} (promise && promise.$$timeoutId in deferreds) \{
        deferreds[promise.$$timeoutId].reject(\textcolor{stringliteral}{'canceled'});
        \textcolor{keyword}{delete} deferreds[promise.$$timeoutId];
        \textcolor{keywordflow}{return} $browser.defer.cancel(promise.$$timeoutId);
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \};

    \textcolor{keywordflow}{return} timeout;
  \}];
\}

\textcolor{comment}{// NOTE:  The usage of window and document instead of $window and $document here is}
\textcolor{comment}{// deliberate.  This service depends on the specific behavior of anchor nodes created by the}
\textcolor{comment}{// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and}
\textcolor{comment}{// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it}
\textcolor{comment}{// doesn't know about mocked locations and resolves URLs to the real document - which is}
\textcolor{comment}{// exactly the behavior needed here.  There is little value is mocking these out for this}
\textcolor{comment}{// service.}
var urlParsingNode = document.createElement(\textcolor{stringliteral}{"a"});
var originUrl = urlResolve(window.location.href);


\textcolor{keyword}{function} urlResolve(url) \{
  var href = url;

  \textcolor{keywordflow}{if} (msie) \{
    \textcolor{comment}{// Normalize before parse.  Refer Implementation Notes on why this is}
    \textcolor{comment}{// done in two steps on IE.}
    urlParsingNode.setAttribute(\textcolor{stringliteral}{"href"}, href);
    href = urlParsingNode.href;
  \}

  urlParsingNode.setAttribute(\textcolor{stringliteral}{'href'}, href);

  \textcolor{comment}{// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils}
  \textcolor{keywordflow}{return} \{
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\(\backslash\)?/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \textcolor{stringliteral}{''}) : \textcolor{stringliteral}{''},
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: (urlParsingNode.pathname.charAt(0) === \textcolor{charliteral}{'/'})
      ? urlParsingNode.pathname
      : \textcolor{charliteral}{'/'} + urlParsingNode.pathname
  \};
\}

\textcolor{keyword}{function} urlIsSameOrigin(requestUrl) \{
  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
  \textcolor{keywordflow}{return} (parsed.protocol === originUrl.protocol &&
          parsed.host === originUrl.host);
\}

\textcolor{keyword}{function} $WindowProvider() \{
  this.$get = valueFn(window);
\}

\textcolor{keyword}{function} $$CookieReader($document) \{
  var rawDocument = $document[0] || \{\};
  var lastCookies = \{\};
  var lastCookieString = \textcolor{stringliteral}{''};

  \textcolor{keyword}{function} safeDecodeURIComponent(str) \{
    \textcolor{keywordflow}{try} \{
      \textcolor{keywordflow}{return} decodeURIComponent(str);
    \} \textcolor{keywordflow}{catch} (e) \{
      \textcolor{keywordflow}{return} str;
    \}
  \}

  \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
    var cookieArray, cookie, i, index, name;
    var currentCookieString = rawDocument.cookie || \textcolor{stringliteral}{''};

    \textcolor{keywordflow}{if} (currentCookieString !== lastCookieString) \{
      lastCookieString = currentCookieString;
      cookieArray = lastCookieString.split(\textcolor{stringliteral}{'; '});
      lastCookies = \{\};

      \textcolor{keywordflow}{for} (i = 0; i < cookieArray.length; i++) \{
        cookie = cookieArray[i];
        index = cookie.indexOf(\textcolor{charliteral}{'='});
        \textcolor{keywordflow}{if} (index > 0) \{ \textcolor{comment}{//ignore nameless cookies}
          name = safeDecodeURIComponent(cookie.substring(0, index));
          \textcolor{comment}{// the first value that is seen for a cookie is the most}
          \textcolor{comment}{// specific one.  values for the same cookie name that}
          \textcolor{comment}{// follow are for less specific paths.}
          \textcolor{keywordflow}{if} (lastCookies[name] === undefined) \{
            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
          \}
        \}
      \}
    \}
    \textcolor{keywordflow}{return} lastCookies;
  \};
\}

$$CookieReader.$inject = [\textcolor{stringliteral}{'$document'}];

\textcolor{keyword}{function} $$CookieReaderProvider() \{
  this.$get = $$CookieReader;
\}

\textcolor{comment}{/* global currencyFilter: true,}
\textcolor{comment}{ dateFilter: true,}
\textcolor{comment}{ filterFilter: true,}
\textcolor{comment}{ jsonFilter: true,}
\textcolor{comment}{ limitToFilter: true,}
\textcolor{comment}{ lowercaseFilter: true,}
\textcolor{comment}{ numberFilter: true,}
\textcolor{comment}{ orderByFilter: true,}
\textcolor{comment}{ uppercaseFilter: true,}
\textcolor{comment}{ */}

$FilterProvider.$inject = [\textcolor{stringliteral}{'$provide'}];
\textcolor{keyword}{function} $FilterProvider($provide) \{
  var suffix = \textcolor{stringliteral}{'Filter'};

  \textcolor{keyword}{function} \textcolor{keyword}{register}(name, factory) \{
    \textcolor{keywordflow}{if} (isObject(name)) \{
      var filters = \{\};
      forEach(name, \textcolor{keyword}{function}(filter, key) \{
        filters[key] = \textcolor{keyword}{register}(key, filter);
      \});
      \textcolor{keywordflow}{return} filters;
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{return} $provide.factory(name + suffix, factory);
    \}
  \}
  this.\textcolor{keyword}{register} = \textcolor{keyword}{register};

  this.$get = [\textcolor{stringliteral}{'$injector'}, \textcolor{keyword}{function}($injector) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(name) \{
      \textcolor{keywordflow}{return} $injector.get(name + suffix);
    \};
  \}];


  \textcolor{comment}{/* global}
\textcolor{comment}{    currencyFilter: false,}
\textcolor{comment}{    dateFilter: false,}
\textcolor{comment}{    filterFilter: false,}
\textcolor{comment}{    jsonFilter: false,}
\textcolor{comment}{    limitToFilter: false,}
\textcolor{comment}{    lowercaseFilter: false,}
\textcolor{comment}{    numberFilter: false,}
\textcolor{comment}{    orderByFilter: false,}
\textcolor{comment}{    uppercaseFilter: false,}
\textcolor{comment}{  */}

  \textcolor{keyword}{register}(\textcolor{stringliteral}{'currency'}, currencyFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'date'}, dateFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'filter'}, filterFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'json'}, jsonFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'limitTo'}, limitToFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'lowercase'}, lowercaseFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'number'}, numberFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'orderBy'}, orderByFilter);
  \textcolor{keyword}{register}(\textcolor{stringliteral}{'uppercase'}, uppercaseFilter);
\}

\textcolor{keyword}{function} filterFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(array, expression, comparator) \{
    \textcolor{keywordflow}{if} (!isArrayLike(array)) \{
      \textcolor{keywordflow}{if} (array == null) \{
        \textcolor{keywordflow}{return} array;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'filter'})(\textcolor{stringliteral}{'notarray'}, \textcolor{stringliteral}{'Expected array but received: \{0\}'}, array);
      \}
    \}

    var expressionType = getTypeForFilter(expression);
    var predicateFn;
    var matchAgainstAnyProp;

    \textcolor{keywordflow}{switch} (expressionType) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
        predicateFn = expression;
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'boolean'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'null'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'number'}:
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
        matchAgainstAnyProp = \textcolor{keyword}{true};
        \textcolor{comment}{//jshint -W086}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'object'}:
        \textcolor{comment}{//jshint +W086}
        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
        \textcolor{keywordflow}{break};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} array;
    \}

    \textcolor{keywordflow}{return} Array.prototype.filter.call(array, predicateFn);
  \};
\}

\textcolor{comment}{// Helper functions for `filterFilter`}
\textcolor{keyword}{function} createPredicateFn(expression, comparator, matchAgainstAnyProp) \{
  var shouldMatchPrimitives = isObject(expression) && (\textcolor{charliteral}{'$'} in expression);
  var predicateFn;

  \textcolor{keywordflow}{if} (comparator === \textcolor{keyword}{true}) \{
    comparator = equals;
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isFunction(comparator)) \{
    comparator = \textcolor{keyword}{function}(actual, expected) \{
      \textcolor{keywordflow}{if} (isUndefined(actual)) \{
        \textcolor{comment}{// No substring matching against `undefined`}
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
      \textcolor{keywordflow}{if} ((actual === null) || (expected === null)) \{
        \textcolor{comment}{// No substring matching against `null`; only match against `null`}
        \textcolor{keywordflow}{return} actual === expected;
      \}
      \textcolor{keywordflow}{if} (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) \{
        \textcolor{comment}{// Should not compare primitives against objects, unless they have custom `toString` method}
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}

      actual = lowercase(\textcolor{stringliteral}{''} + actual);
      expected = lowercase(\textcolor{stringliteral}{''} + expected);
      \textcolor{keywordflow}{return} actual.indexOf(expected) !== -1;
    \};
  \}

  predicateFn = \textcolor{keyword}{function}(item) \{
    \textcolor{keywordflow}{if} (shouldMatchPrimitives && !isObject(item)) \{
      \textcolor{keywordflow}{return} deepCompare(item, expression.$, comparator, \textcolor{keyword}{false});
    \}
    \textcolor{keywordflow}{return} deepCompare(item, expression, comparator, matchAgainstAnyProp);
  \};

  \textcolor{keywordflow}{return} predicateFn;
\}

\textcolor{keyword}{function} deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) \{
  var actualType = getTypeForFilter(actual);
  var expectedType = getTypeForFilter(expected);

  \textcolor{keywordflow}{if} ((expectedType === \textcolor{stringliteral}{'string'}) && (expected.charAt(0) === \textcolor{charliteral}{'!'})) \{
    \textcolor{keywordflow}{return} !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
  \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isArray(actual)) \{
    \textcolor{comment}{// In case `actual` is an array, consider it a match}
    \textcolor{comment}{// if ANY of it's items matches `expected`}
    \textcolor{keywordflow}{return} actual.some(\textcolor{keyword}{function}(item) \{
      \textcolor{keywordflow}{return} deepCompare(item, expected, comparator, matchAgainstAnyProp);
    \});
  \}

  \textcolor{keywordflow}{switch} (actualType) \{
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'object'}:
      var key;
      \textcolor{keywordflow}{if} (matchAgainstAnyProp) \{
        \textcolor{keywordflow}{for} (key in actual) \{
          \textcolor{keywordflow}{if} ((key.charAt(0) !== \textcolor{charliteral}{'$'}) && deepCompare(actual[key], expected, comparator, \textcolor{keyword}{true})) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
          \}
        \}
        \textcolor{keywordflow}{return} dontMatchWholeObject ? \textcolor{keyword}{false} : deepCompare(actual, expected, comparator, \textcolor{keyword}{false});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (expectedType === \textcolor{stringliteral}{'object'}) \{
        \textcolor{keywordflow}{for} (key in expected) \{
          var expectedVal = expected[key];
          \textcolor{keywordflow}{if} (isFunction(expectedVal) || isUndefined(expectedVal)) \{
            \textcolor{keywordflow}{continue};
          \}

          var matchAnyProperty = key === \textcolor{charliteral}{'$'};
          var actualVal = matchAnyProperty ? actual : actual[key];
          \textcolor{keywordflow}{if} (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) \{
            \textcolor{keywordflow}{return} \textcolor{keyword}{false};
          \}
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} comparator(actual, expected);
      \}
      \textcolor{keywordflow}{break};
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'function'}:
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \textcolor{keywordflow}{default}:
      \textcolor{keywordflow}{return} comparator(actual, expected);
  \}
\}

\textcolor{comment}{// Used for easily differentiating between `null` and actual `object`}
\textcolor{keyword}{function} getTypeForFilter(val) \{
  \textcolor{keywordflow}{return} (val === null) ? \textcolor{stringliteral}{'null'} : typeof val;
\}

currencyFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} currencyFilter($locale) \{
  var formats = $locale.NUMBER\_FORMATS;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(amount, currencySymbol, fractionSize) \{
    \textcolor{keywordflow}{if} (isUndefined(currencySymbol)) \{
      currencySymbol = formats.CURRENCY\_SYM;
    \}

    \textcolor{keywordflow}{if} (isUndefined(fractionSize)) \{
      fractionSize = formats.PATTERNS[1].maxFrac;
    \}

    \textcolor{comment}{// if null or undefined pass it through}
    \textcolor{keywordflow}{return} (amount == null)
        ? amount
        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP\_SEP, formats.DECIMAL\_SEP, fractionSize).
            replace(/\(\backslash\)u00A4/g, currencySymbol);
  \};
\}

numberFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} numberFilter($locale) \{
  var formats = $locale.NUMBER\_FORMATS;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(number, fractionSize) \{

    \textcolor{comment}{// if null or undefined pass it through}
    \textcolor{keywordflow}{return} (number == null)
        ? number
        : formatNumber(number, formats.PATTERNS[0], formats.GROUP\_SEP, formats.DECIMAL\_SEP,
                       fractionSize);
  \};
\}

var DECIMAL\_SEP = \textcolor{charliteral}{'.'};
\textcolor{keyword}{function} formatNumber(number, pattern, groupSep, decimalSep, fractionSize) \{
  \textcolor{keywordflow}{if} (isObject(number)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};

  var isNegative = number < 0;
  number = Math.abs(number);

  var isInfinity = number === Infinity;
  \textcolor{keywordflow}{if} (!isInfinity && !isFinite(number)) \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};

  var numStr = number + \textcolor{stringliteral}{''},
      formatedText = \textcolor{stringliteral}{''},
      hasExponent = \textcolor{keyword}{false},
      parts = [];

  \textcolor{keywordflow}{if} (isInfinity) formatedText = \textcolor{stringliteral}{'\(\backslash\)u221e'};

  \textcolor{keywordflow}{if} (!isInfinity && numStr.indexOf(\textcolor{charliteral}{'e'}) !== -1) \{
    var match = numStr.match(/([\(\backslash\)d\(\backslash\).]+)e(-?)(\(\backslash\)d+)/);
    \textcolor{keywordflow}{if} (match && match[2] == \textcolor{charliteral}{'-'} && match[3] > fractionSize + 1) \{
      number = 0;
    \} \textcolor{keywordflow}{else} \{
      formatedText = numStr;
      hasExponent = \textcolor{keyword}{true};
    \}
  \}

  \textcolor{keywordflow}{if} (!isInfinity && !hasExponent) \{
    var fractionLen = (numStr.split(DECIMAL\_SEP)[1] || \textcolor{stringliteral}{''}).length;

    \textcolor{comment}{// determine fractionSize if it is not specified}
    \textcolor{keywordflow}{if} (isUndefined(fractionSize)) \{
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    \}

    \textcolor{comment}{// safely round numbers in JS without hitting imprecisions of floating-point arithmetics}
    \textcolor{comment}{// inspired by:}
    \textcolor{comment}{// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Math/round}
    number = +(Math.round(+(number.toString() + \textcolor{charliteral}{'e'} + fractionSize)).toString() + \textcolor{charliteral}{'e'} + -fractionSize);

    var fraction = (\textcolor{stringliteral}{''} + number).split(DECIMAL\_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || \textcolor{stringliteral}{''};

    var i, pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    \textcolor{keywordflow}{if} (whole.length >= (lgroup + group)) \{
      pos = whole.length - lgroup;
      \textcolor{keywordflow}{for} (i = 0; i < pos; i++) \{
        \textcolor{keywordflow}{if} ((pos - i) % group === 0 && i !== 0) \{
          formatedText += groupSep;
        \}
        formatedText += whole.charAt(i);
      \}
    \}

    \textcolor{keywordflow}{for} (i = pos; i < whole.length; i++) \{
      \textcolor{keywordflow}{if} ((whole.length - i) % lgroup === 0 && i !== 0) \{
        formatedText += groupSep;
      \}
      formatedText += whole.charAt(i);
    \}

    \textcolor{comment}{// format fraction part.}
    \textcolor{keywordflow}{while} (fraction.length < fractionSize) \{
      fraction += \textcolor{charliteral}{'0'};
    \}

    \textcolor{keywordflow}{if} (fractionSize && fractionSize !== \textcolor{stringliteral}{"0"}) formatedText += decimalSep + fraction.substr(0, fractionSize)
      ;
  \} \textcolor{keywordflow}{else} \{
    \textcolor{keywordflow}{if} (fractionSize > 0 && number < 1) \{
      formatedText = number.toFixed(fractionSize);
      number = parseFloat(formatedText);
    \}
  \}

  \textcolor{keywordflow}{if} (number === 0) \{
    isNegative = \textcolor{keyword}{false};
  \}

  parts.push(isNegative ? pattern.negPre : pattern.posPre,
             formatedText,
             isNegative ? pattern.negSuf : pattern.posSuf);
  \textcolor{keywordflow}{return} parts.join(\textcolor{stringliteral}{''});
\}

\textcolor{keyword}{function} padNumber(num, digits, trim) \{
  var neg = \textcolor{stringliteral}{''};
  \textcolor{keywordflow}{if} (num < 0) \{
    neg =  \textcolor{charliteral}{'-'};
    num = -num;
  \}
  num = \textcolor{stringliteral}{''} + num;
  \textcolor{keywordflow}{while} (num.length < digits) num = \textcolor{charliteral}{'0'} + num;
  \textcolor{keywordflow}{if} (trim) \{
    num = num.substr(num.length - digits);
  \}
  \textcolor{keywordflow}{return} neg + num;
\}


\textcolor{keyword}{function} dateGetter(name, size, offset, trim) \{
  offset = offset || 0;
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date) \{
    var value = date[\textcolor{stringliteral}{'get'} + name]();
    \textcolor{keywordflow}{if} (offset > 0 || value > -offset) \{
      value += offset;
    \}
    \textcolor{keywordflow}{if} (value === 0 && offset == -12) value = 12;
    \textcolor{keywordflow}{return} padNumber(value, size, trim);
  \};
\}

\textcolor{keyword}{function} dateStrGetter(name, shortForm) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date, formats) \{
    var value = date[\textcolor{stringliteral}{'get'} + name]();
    var \textcolor{keyword}{get} = uppercase(shortForm ? (\textcolor{stringliteral}{'SHORT'} + name) : name);

    \textcolor{keywordflow}{return} formats[\textcolor{keyword}{get}][value];
  \};
\}

\textcolor{keyword}{function} timeZoneGetter(date, formats, offset) \{
  var zone = -1 * offset;
  var paddedZone = (zone >= 0) ? \textcolor{stringliteral}{"+"} : \textcolor{stringliteral}{""};

  paddedZone += padNumber(Math[zone > 0 ? \textcolor{stringliteral}{'floor'} : \textcolor{stringliteral}{'ceil'}](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  \textcolor{keywordflow}{return} paddedZone;
\}

\textcolor{keyword}{function} getFirstThursdayOfYear(year) \{
    \textcolor{comment}{// 0 = index of January}
    var dayOfWeekOnFirst = (\textcolor{keyword}{new} Date(year, 0, 1)).getDay();
    \textcolor{comment}{// 4 = index of Thursday (+1 to account for 1st = 5)}
    \textcolor{comment}{// 11 = index of *next* Thursday (+1 account for 1st = 12)}
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
\}

\textcolor{keyword}{function} getThursdayThisWeek(datetime) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(datetime.getFullYear(), datetime.getMonth(),
      \textcolor{comment}{// 4 = index of Thursday}
      datetime.getDate() + (4 - datetime.getDay()));
\}

\textcolor{keyword}{function} weekGetter(size) \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date) \{
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
         thisThurs = getThursdayThisWeek(date);

      var diff = +thisThurs - +firstThurs,
         result = 1 + Math.round(diff / 6.048e8); \textcolor{comment}{// 6.048e8 ms per week}

      \textcolor{keywordflow}{return} padNumber(result, size);
   \};
\}

\textcolor{keyword}{function} ampmGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
\}

\textcolor{keyword}{function} eraGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
\}

\textcolor{keyword}{function} longEraGetter(date, formats) \{
  \textcolor{keywordflow}{return} date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
\}

var DATE\_FORMATS = \{
  yyyy: dateGetter(\textcolor{stringliteral}{'FullYear'}, 4),
    yy: dateGetter(\textcolor{stringliteral}{'FullYear'}, 2, 0, \textcolor{keyword}{true}),
     y: dateGetter(\textcolor{stringliteral}{'FullYear'}, 1),
  MMMM: dateStrGetter(\textcolor{stringliteral}{'Month'}),
   MMM: dateStrGetter(\textcolor{stringliteral}{'Month'}, \textcolor{keyword}{true}),
    MM: dateGetter(\textcolor{stringliteral}{'Month'}, 2, 1),
     M: dateGetter(\textcolor{stringliteral}{'Month'}, 1, 1),
    dd: dateGetter(\textcolor{stringliteral}{'Date'}, 2),
     d: dateGetter(\textcolor{stringliteral}{'Date'}, 1),
    HH: dateGetter(\textcolor{stringliteral}{'Hours'}, 2),
     H: dateGetter(\textcolor{stringliteral}{'Hours'}, 1),
    hh: dateGetter(\textcolor{stringliteral}{'Hours'}, 2, -12),
     h: dateGetter(\textcolor{stringliteral}{'Hours'}, 1, -12),
    mm: dateGetter(\textcolor{stringliteral}{'Minutes'}, 2),
     m: dateGetter(\textcolor{stringliteral}{'Minutes'}, 1),
    ss: dateGetter(\textcolor{stringliteral}{'Seconds'}, 2),
     s: dateGetter(\textcolor{stringliteral}{'Seconds'}, 1),
     \textcolor{comment}{// while ISO 8601 requires fractions to be prefixed with `.` or `,`}
     \textcolor{comment}{// we can be just safely rely on using `sss` since we currently don't support single or two digit
       fractions}
   sss: dateGetter(\textcolor{stringliteral}{'Milliseconds'}, 3),
  EEEE: dateStrGetter(\textcolor{stringliteral}{'Day'}),
   EEE: dateStrGetter(\textcolor{stringliteral}{'Day'}, \textcolor{keyword}{true}),
     a: ampmGetter,
     Z: timeZoneGetter,
    ww: weekGetter(2),
     w: weekGetter(1),
     G: eraGetter,
     GG: eraGetter,
     GGG: eraGetter,
     GGGG: longEraGetter
\};

var DATE\_FORMATS\_SPLIT = /((?:[^yMdHhmsaZEwG\textcolor{stringliteral}{']+)|(?:'}(?:[^\textcolor{stringliteral}{']|'}\textcolor{stringliteral}{')*'})|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(
      .*)/,
    NUMBER\_STRING = /^\(\backslash\)-?\(\backslash\)d+$/;

dateFilter.$inject = [\textcolor{stringliteral}{'$locale'}];
\textcolor{keyword}{function} dateFilter($locale) \{


  var R\_ISO8601\_STR = /^(\(\backslash\)d\{4\})-?(\(\backslash\)d\(\backslash\)d)-?(\(\backslash\)d\(\backslash\)d)(?:T(\(\backslash\)d\(\backslash\)d)(?::?(\(\backslash\)d\(\backslash\)d)(?::?(\(\backslash\)d\(\backslash\)d)(?:\(\backslash\).(\(\backslash\)d+))?)?)?(Z|([+-])(\(\backslash\)d
      \(\backslash\)d):?(\(\backslash\)d\(\backslash\)d))?)?$/;
                     \textcolor{comment}{// 1        2       3         4          5          6          7          8  9     10 
           11}
  \textcolor{keyword}{function} jsonStringToDate(\textcolor{keywordtype}{string}) \{
    var match;
    \textcolor{keywordflow}{if} (match = \textcolor{keywordtype}{string}.match(R\_ISO8601\_STR)) \{
      var date = \textcolor{keyword}{new} Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      \textcolor{keywordflow}{if} (match[9]) \{
        tzHour = toInt(match[9] + match[10]);
        tzMin = toInt(match[9] + match[11]);
      \}
      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
      var h = toInt(match[4] || 0) - tzHour;
      var m = toInt(match[5] || 0) - tzMin;
      var s = toInt(match[6] || 0);
      var ms = Math.round(parseFloat(\textcolor{stringliteral}{'0.'} + (match[7] || 0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      \textcolor{keywordflow}{return} date;
    \}
    \textcolor{keywordflow}{return} string;
  \}


  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(date, format, timezone) \{
    var text = \textcolor{stringliteral}{''},
        parts = [],
        fn, match;

    format = format || \textcolor{stringliteral}{'mediumDate'};
    format = $locale.DATETIME\_FORMATS[format] || format;
    \textcolor{keywordflow}{if} (isString(date)) \{
      date = NUMBER\_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
    \}

    \textcolor{keywordflow}{if} (isNumber(date)) \{
      date = \textcolor{keyword}{new} Date(date);
    \}

    \textcolor{keywordflow}{if} (!isDate(date) || !isFinite(date.getTime())) \{
      \textcolor{keywordflow}{return} date;
    \}

    \textcolor{keywordflow}{while} (format) \{
      match = DATE\_FORMATS\_SPLIT.exec(format);
      \textcolor{keywordflow}{if} (match) \{
        parts = concat(parts, match, 1);
        format = parts.pop();
      \} \textcolor{keywordflow}{else} \{
        parts.push(format);
        format = null;
      \}
    \}

    var dateTimezoneOffset = date.getTimezoneOffset();
    \textcolor{keywordflow}{if} (timezone) \{
      dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      date = convertTimezoneToLocal(date, timezone, \textcolor{keyword}{true});
    \}
    forEach(parts, \textcolor{keyword}{function}(value) \{
      fn = DATE\_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME\_FORMATS, dateTimezoneOffset)
                 : value.replace(/(^\textcolor{stringliteral}{'|'}$)/g, \textcolor{stringliteral}{''}).replace(/\textcolor{stringliteral}{''}/g, \textcolor{stringliteral}{"'"});
    \});

    \textcolor{keywordflow}{return} text;
  \};
\}


\textcolor{keyword}{function} jsonFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(object, spacing) \{
    \textcolor{keywordflow}{if} (isUndefined(spacing)) \{
        spacing = 2;
    \}
    \textcolor{keywordflow}{return} toJson(\textcolor{keywordtype}{object}, spacing);
  \};
\}


var lowercaseFilter = valueFn(lowercase);


var uppercaseFilter = valueFn(uppercase);

\textcolor{keyword}{function} limitToFilter() \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(input, limit, begin) \{
    \textcolor{keywordflow}{if} (Math.abs(Number(limit)) === Infinity) \{
      limit = Number(limit);
    \} \textcolor{keywordflow}{else} \{
      limit = toInt(limit);
    \}
    \textcolor{keywordflow}{if} (isNaN(limit)) \textcolor{keywordflow}{return} input;

    \textcolor{keywordflow}{if} (isNumber(input)) input = input.toString();
    \textcolor{keywordflow}{if} (!isArray(input) && !isString(input)) \textcolor{keywordflow}{return} input;

    begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
    begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;

    if (limit >= 0) \{
      \textcolor{keywordflow}{return} input.slice(begin, begin + limit);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (begin === 0) \{
        \textcolor{keywordflow}{return} input.slice(limit, input.length);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} input.slice(Math.max(0, begin + limit), begin);
      \}
    \}
  \};
\}

orderByFilter.$inject = [\textcolor{stringliteral}{'$parse'}];
\textcolor{keyword}{function} orderByFilter($parse) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(array, sortPredicate, reverseOrder) \{

    \textcolor{keywordflow}{if} (!(isArrayLike(array))) \textcolor{keywordflow}{return} array;

    \textcolor{keywordflow}{if} (!isArray(sortPredicate)) \{ sortPredicate = [sortPredicate]; \}
    \textcolor{keywordflow}{if} (sortPredicate.length === 0) \{ sortPredicate = [\textcolor{charliteral}{'+'}]; \}

    var predicates = processPredicates(sortPredicate, reverseOrder);
    \textcolor{comment}{// Add a predicate at the end that evaluates to the element index. This makes the}
    \textcolor{comment}{// sort stable as it works as a tie-breaker when all the input predicates cannot}
    \textcolor{comment}{// distinguish between two elements.}
    predicates.push(\{ \textcolor{keyword}{get}: \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} \{\}; \}, descending: reverseOrder ? -1 : 1\});

    \textcolor{comment}{// The next three lines are a version of a Swartzian Transform idiom from Perl}
    \textcolor{comment}{// (sometimes called the Decorate-Sort-Undecorate idiom)}
    \textcolor{comment}{// See https://en.wikipedia.org/wiki/Schwartzian\_transform}
    var compareValues = Array.prototype.map.call(array, getComparisonObject);
    compareValues.sort(doComparison);
    array = compareValues.map(\textcolor{keyword}{function}(item) \{ \textcolor{keywordflow}{return} item.value; \});

    \textcolor{keywordflow}{return} array;

    \textcolor{keyword}{function} getComparisonObject(value, index) \{
      \textcolor{keywordflow}{return} \{
        value: value,
        predicateValues: predicates.map(\textcolor{keyword}{function}(predicate) \{
          \textcolor{keywordflow}{return} getPredicateValue(predicate.get(value), index);
        \})
      \};
    \}

    \textcolor{keyword}{function} doComparison(v1, v2) \{
      var result = 0;
      \textcolor{keywordflow}{for} (var index=0, length = predicates.length; index < length; ++index) \{
        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].
      descending;
        \textcolor{keywordflow}{if} (result) \textcolor{keywordflow}{break};
      \}
      \textcolor{keywordflow}{return} result;
    \}
  \};

  \textcolor{keyword}{function} processPredicates(sortPredicate, reverseOrder) \{
    reverseOrder = reverseOrder ? -1 : 1;
    \textcolor{keywordflow}{return} sortPredicate.map(\textcolor{keyword}{function}(predicate) \{
      var descending = 1, \textcolor{keyword}{get} = identity;

      \textcolor{keywordflow}{if} (isFunction(predicate)) \{
        \textcolor{keyword}{get} = predicate;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(predicate)) \{
        \textcolor{keywordflow}{if} ((predicate.charAt(0) == \textcolor{charliteral}{'+'} || predicate.charAt(0) == \textcolor{charliteral}{'-'})) \{
          descending = predicate.charAt(0) == \textcolor{charliteral}{'-'} ? -1 : 1;
          predicate = predicate.substring(1);
        \}
        \textcolor{keywordflow}{if} (predicate !== \textcolor{stringliteral}{''}) \{
          \textcolor{keyword}{get} = $parse(predicate);
          \textcolor{keywordflow}{if} (\textcolor{keyword}{get}.constant) \{
            var key = \textcolor{keyword}{get}();
            \textcolor{keyword}{get} = \textcolor{keyword}{function}(value) \{ \textcolor{keywordflow}{return} value[key]; \};
          \}
        \}
      \}
      \textcolor{keywordflow}{return} \{ \textcolor{keyword}{get}: \textcolor{keyword}{get}, descending: descending * reverseOrder \};
    \});
  \}

  \textcolor{keyword}{function} isPrimitive(value) \{
    \textcolor{keywordflow}{switch} (typeof value) \{
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'number'}: \textcolor{comment}{/* falls through */}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'boolean'}: \textcolor{comment}{/* falls through */}
      \textcolor{keywordflow}{case} \textcolor{stringliteral}{'string'}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{true};
      \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
  \}

  \textcolor{keyword}{function} objectValue(value, index) \{
    \textcolor{comment}{// If `valueOf` is a valid function use that}
    \textcolor{keywordflow}{if} (typeof value.valueOf === \textcolor{stringliteral}{'function'}) \{
      value = value.valueOf();
      \textcolor{keywordflow}{if} (isPrimitive(value)) \textcolor{keywordflow}{return} value;
    \}
    \textcolor{comment}{// If `toString` is a valid function and not the one from `Object.prototype` use that}
    \textcolor{keywordflow}{if} (hasCustomToString(value)) \{
      value = value.toString();
      \textcolor{keywordflow}{if} (isPrimitive(value)) \textcolor{keywordflow}{return} value;
    \}
    \textcolor{comment}{// We have a basic object so we use the position of the object in the collection}
    \textcolor{keywordflow}{return} index;
  \}

  \textcolor{keyword}{function} getPredicateValue(value, index) \{
    var type = typeof value;
    \textcolor{keywordflow}{if} (value === null) \{
      type = \textcolor{stringliteral}{'string'};
      value = \textcolor{stringliteral}{'null'};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'string'}) \{
      value = value.toLowerCase();
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type === \textcolor{stringliteral}{'object'}) \{
      value = objectValue(value, index);
    \}
    \textcolor{keywordflow}{return} \{ value: value, type: type \};
  \}

  \textcolor{keyword}{function} compare(v1, v2) \{
    var result = 0;
    \textcolor{keywordflow}{if} (v1.type === v2.type) \{
      \textcolor{keywordflow}{if} (v1.value !== v2.value) \{
        result = v1.value < v2.value ? -1 : 1;
      \}
    \} \textcolor{keywordflow}{else} \{
      result = v1.type < v2.type ? -1 : 1;
    \}
    \textcolor{keywordflow}{return} result;
  \}
\}

\textcolor{keyword}{function} ngDirective(directive) \{
  \textcolor{keywordflow}{if} (isFunction(directive)) \{
    directive = \{
      link: directive
    \};
  \}
  directive.restrict = directive.restrict || \textcolor{stringliteral}{'AC'};
  \textcolor{keywordflow}{return} valueFn(directive);
\}

var htmlAnchorDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'E'},
  compile: \textcolor{keyword}{function}(element, attr) \{
    \textcolor{keywordflow}{if} (!attr.href && !attr.xlinkHref) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element) \{
        \textcolor{comment}{// If the linked element is not an anchor tag anymore, do nothing}
        \textcolor{keywordflow}{if} (element[0].nodeName.toLowerCase() !== \textcolor{charliteral}{'a'}) \textcolor{keywordflow}{return};

        \textcolor{comment}{// SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.}
        var href = toString.call(element.prop(\textcolor{stringliteral}{'href'})) === \textcolor{stringliteral}{'[object SVGAnimatedString]'} ?
                   \textcolor{stringliteral}{'xlink:href'} : \textcolor{stringliteral}{'href'};
        element.on(\textcolor{stringliteral}{'click'}, \textcolor{keyword}{function}(event) \{
          \textcolor{comment}{// if we have no href url, then don't navigate anywhere.}
          \textcolor{keywordflow}{if} (!element.attr(href)) \{
            event.preventDefault();
          \}
        \});
      \};
    \}
  \}
\});

var ngAttributeAliasDirectives = \{\};

\textcolor{comment}{// boolean attrs are evaluated}
forEach(BOOLEAN\_ATTR, \textcolor{keyword}{function}(propName, attrName) \{
  \textcolor{comment}{// binding to multiple is not supported}
  \textcolor{keywordflow}{if} (propName == \textcolor{stringliteral}{"multiple"}) \textcolor{keywordflow}{return};

  \textcolor{keyword}{function} defaultLinkFn(scope, element, attr) \{
    scope.$watch(attr[normalized], \textcolor{keyword}{function} ngBooleanAttrWatchAction(value) \{
      attr.$set(attrName, !!value);
    \});
  \}

  var normalized = directiveNormalize(\textcolor{stringliteral}{'ng-'} + attrName);
  var linkFn = defaultLinkFn;

  \textcolor{keywordflow}{if} (propName === \textcolor{stringliteral}{'checked'}) \{
    linkFn = \textcolor{keyword}{function}(scope, element, attr) \{
      \textcolor{comment}{// ensuring ngChecked doesn't interfere with ngModel when both are set on the same input}
      \textcolor{keywordflow}{if} (attr.ngModel !== attr[normalized]) \{
        defaultLinkFn(scope, element, attr);
      \}
    \};
  \}

  ngAttributeAliasDirectives[normalized] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{charliteral}{'A'},
      priority: 100,
      link: linkFn
    \};
  \};
\});

\textcolor{comment}{// aliased input attrs are evaluated}
forEach(ALIASED\_ATTR, \textcolor{keyword}{function}(htmlAttr, ngAttr) \{
  ngAttributeAliasDirectives[ngAttr] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      priority: 100,
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        \textcolor{comment}{//special case ngPattern when a literal regular expression value}
        \textcolor{comment}{//is used as the expression (this way we don't have to watch anything).}
        \textcolor{keywordflow}{if} (ngAttr === \textcolor{stringliteral}{"ngPattern"} && attr.ngPattern.charAt(0) == \textcolor{stringliteral}{"/"}) \{
          var match = attr.ngPattern.match(REGEX\_STRING\_REGEXP);
          \textcolor{keywordflow}{if} (match) \{
            attr.$set(\textcolor{stringliteral}{"ngPattern"}, \textcolor{keyword}{new} RegExp(match[1], match[2]));
            \textcolor{keywordflow}{return};
          \}
        \}

        scope.$watch(attr[ngAttr], \textcolor{keyword}{function} ngAttrAliasWatchAction(value) \{
          attr.$set(ngAttr, value);
        \});
      \}
    \};
  \};
\});

\textcolor{comment}{// ng-src, ng-srcset, ng-href are interpolated}
forEach([\textcolor{stringliteral}{'src'}, \textcolor{stringliteral}{'srcset'}, \textcolor{stringliteral}{'href'}], \textcolor{keyword}{function}(attrName) \{
  var normalized = directiveNormalize(\textcolor{stringliteral}{'ng-'} + attrName);
  ngAttributeAliasDirectives[normalized] = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      priority: 99, \textcolor{comment}{// it needs to run after the attributes are interpolated}
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        var propName = attrName,
            name = attrName;

        \textcolor{keywordflow}{if} (attrName === \textcolor{stringliteral}{'href'} &&
            toString.call(element.prop(\textcolor{stringliteral}{'href'})) === \textcolor{stringliteral}{'[object SVGAnimatedString]'}) \{
          name = \textcolor{stringliteral}{'xlinkHref'};
          attr.$attr[name] = \textcolor{stringliteral}{'xlink:href'};
          propName = null;
        \}

        attr.$observe(normalized, \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{if} (!value) \{
            \textcolor{keywordflow}{if} (attrName === \textcolor{stringliteral}{'href'}) \{
              attr.$set(name, null);
            \}
            \textcolor{keywordflow}{return};
          \}

          attr.$set(name, value);

          \textcolor{comment}{// on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist}
          \textcolor{comment}{// then calling element.setAttribute('src', 'foo') doesn't do anything, so we need}
          \textcolor{comment}{// to set the property as well to achieve the desired effect.}
          \textcolor{comment}{// we use attr[attrName] value since $set can sanitize the url.}
          \textcolor{keywordflow}{if} (msie && propName) element.prop(propName, attr[name]);
        \});
      \}
    \};
  \};
\});

\textcolor{comment}{/* global -nullFormCtrl, -SUBMITTED\_CLASS, addSetValidityMethod: true}
\textcolor{comment}{ */}
var nullFormCtrl = \{
  $addControl: noop,
  $$renameControl: nullFormRenameControl,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop,
  $setSubmitted: noop
\},
SUBMITTED\_CLASS = \textcolor{stringliteral}{'ng-submitted'};

\textcolor{keyword}{function} nullFormRenameControl(control, name) \{
  control.$name = name;
\}

\textcolor{comment}{//asks for $scope to fool the BC controller module}
FormController.$inject = [\textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'$interpolate'}];
\textcolor{keyword}{function} FormController(element, attrs, $scope, $animate, $interpolate) \{
  var form = \textcolor{keyword}{this},
      controls = [];

  var parentForm = form.$$parentForm = element.parent().controller(\textcolor{stringliteral}{'form'}) || nullFormCtrl;

  \textcolor{comment}{// init state}
  form.$error = \{\};
  form.$$success = \{\};
  form.$pending = undefined;
  form.$name = $interpolate(attrs.name || attrs.ngForm || \textcolor{stringliteral}{''})($scope);
  form.$dirty = \textcolor{keyword}{false};
  form.$pristine = \textcolor{keyword}{true};
  form.$valid = \textcolor{keyword}{true};
  form.$invalid = \textcolor{keyword}{false};
  form.$submitted = \textcolor{keyword}{false};

  parentForm.$addControl(form);

  form.$rollbackViewValue = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$rollbackViewValue();
    \});
  \};

  form.$commitViewValue = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$commitViewValue();
    \});
  \};

  form.$addControl = \textcolor{keyword}{function}(control) \{
    \textcolor{comment}{// Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored}
    \textcolor{comment}{// and not added to the scope.  Now we throw an error.}
    assertNotHasOwnProperty(control.$name, \textcolor{stringliteral}{'input'});
    controls.push(control);

    \textcolor{keywordflow}{if} (control.$name) \{
      form[control.$name] = control;
    \}
  \};

  \textcolor{comment}{// Private API: rename a form control}
  form.$$renameControl = \textcolor{keyword}{function}(control, newName) \{
    var oldName = control.$name;

    \textcolor{keywordflow}{if} (form[oldName] === control) \{
      \textcolor{keyword}{delete} form[oldName];
    \}
    form[newName] = control;
    control.$name = newName;
  \};

  form.$removeControl = \textcolor{keyword}{function}(control) \{
    \textcolor{keywordflow}{if} (control.$name && form[control.$name] === control) \{
      \textcolor{keyword}{delete} form[control.$name];
    \}
    forEach(form.$pending, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});
    forEach(form.$error, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});
    forEach(form.$$success, \textcolor{keyword}{function}(value, name) \{
      form.$setValidity(name, null, control);
    \});

    arrayRemove(controls, control);
  \};


  addSetValidityMethod(\{
    ctrl: \textcolor{keyword}{this},
    $element: element,
    set: \textcolor{keyword}{function}(object, property, controller) \{
      var list = \textcolor{keywordtype}{object}[property];
      \textcolor{keywordflow}{if} (!list) \{
        \textcolor{keywordtype}{object}[property] = [controller];
      \} \textcolor{keywordflow}{else} \{
        var index = list.indexOf(controller);
        \textcolor{keywordflow}{if} (index === -1) \{
          list.push(controller);
        \}
      \}
    \},
    unset: \textcolor{keyword}{function}(object, property, controller) \{
      var list = \textcolor{keywordtype}{object}[property];
      \textcolor{keywordflow}{if} (!list) \{
        \textcolor{keywordflow}{return};
      \}
      arrayRemove(list, controller);
      \textcolor{keywordflow}{if} (list.length === 0) \{
        \textcolor{keyword}{delete} \textcolor{keywordtype}{object}[property];
      \}
    \},
    parentForm: parentForm,
    $animate: $animate
  \});

  form.$setDirty = \textcolor{keyword}{function}() \{
    $animate.removeClass(element, PRISTINE\_CLASS);
    $animate.addClass(element, DIRTY\_CLASS);
    form.$dirty = \textcolor{keyword}{true};
    form.$pristine = \textcolor{keyword}{false};
    parentForm.$setDirty();
  \};

  form.$setPristine = \textcolor{keyword}{function}() \{
    $animate.setClass(element, PRISTINE\_CLASS, DIRTY\_CLASS + \textcolor{charliteral}{' '} + SUBMITTED\_CLASS);
    form.$dirty = \textcolor{keyword}{false};
    form.$pristine = \textcolor{keyword}{true};
    form.$submitted = \textcolor{keyword}{false};
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$setPristine();
    \});
  \};

  form.$setUntouched = \textcolor{keyword}{function}() \{
    forEach(controls, \textcolor{keyword}{function}(control) \{
      control.$setUntouched();
    \});
  \};

  form.$setSubmitted = \textcolor{keyword}{function}() \{
    $animate.addClass(element, SUBMITTED\_CLASS);
    form.$submitted = \textcolor{keyword}{true};
    parentForm.$setSubmitted();
  \};
\}

var formDirectiveFactory = \textcolor{keyword}{function}(isNgForm) \{
  \textcolor{keywordflow}{return} [\textcolor{stringliteral}{'$timeout'}, \textcolor{stringliteral}{'$parse'}, \textcolor{keyword}{function}($timeout, $parse) \{
    var formDirective = \{
      name: \textcolor{stringliteral}{'form'},
      restrict: isNgForm ? \textcolor{stringliteral}{'EAC'} : \textcolor{charliteral}{'E'},
      controller: FormController,
      compile: \textcolor{keyword}{function} ngFormCompile(formElement, attr) \{
        \textcolor{comment}{// Setup initial state of the control}
        formElement.addClass(PRISTINE\_CLASS).addClass(VALID\_CLASS);

        var nameAttr = attr.name ? \textcolor{stringliteral}{'name'} : (isNgForm && attr.ngForm ? \textcolor{stringliteral}{'ngForm'} : \textcolor{keyword}{false});

        \textcolor{keywordflow}{return} \{
          pre: \textcolor{keyword}{function} ngFormPreLink(scope, formElement, attr, controller) \{
            \textcolor{comment}{// if `action` attr is not present on the form, prevent the default action (submission)}
            \textcolor{keywordflow}{if} (!(\textcolor{stringliteral}{'action'} in attr)) \{
              \textcolor{comment}{// we can't use jq events because if a form is destroyed during submission the default}
              \textcolor{comment}{// action is not prevented. see #1238}
              \textcolor{comment}{//}
              \textcolor{comment}{// IE 9 is not affected because it doesn't fire a submit event and try to do a full}
              \textcolor{comment}{// page reload if the form was destroyed by submission of the form via a click handler}
              \textcolor{comment}{// on a button in the form. Looks like an IE9 specific bug.}
              var handleFormSubmission = \textcolor{keyword}{function}(event) \{
                scope.$apply(\textcolor{keyword}{function}() \{
                  controller.$commitViewValue();
                  controller.$setSubmitted();
                \});

                event.preventDefault();
              \};

              addEventListenerFn(formElement[0], \textcolor{stringliteral}{'submit'}, handleFormSubmission);

              \textcolor{comment}{// unregister the preventDefault listener so that we don't not leak memory but in a}
              \textcolor{comment}{// way that will achieve the prevention of the default action.}
              formElement.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
                $timeout(\textcolor{keyword}{function}() \{
                  removeEventListenerFn(formElement[0], \textcolor{stringliteral}{'submit'}, handleFormSubmission);
                \}, 0, \textcolor{keyword}{false});
              \});
            \}

            var parentFormCtrl = controller.$$parentForm;
            var setter = nameAttr ? getSetter(controller.$name) : noop;

            \textcolor{keywordflow}{if} (nameAttr) \{
              setter(scope, controller);
              attr.$observe(nameAttr, \textcolor{keyword}{function}(newValue) \{
                \textcolor{keywordflow}{if} (controller.$name === newValue) \textcolor{keywordflow}{return};
                setter(scope, undefined);
                parentFormCtrl.$$renameControl(controller, newValue);
                setter = getSetter(controller.$name);
                setter(scope, controller);
              \});
            \}
            formElement.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
              parentFormCtrl.$removeControl(controller);
              setter(scope, undefined);
              extend(controller, nullFormCtrl); \textcolor{comment}{//stop propagating child destruction handlers upwards}
            \});
          \}
        \};
      \}
    \};

    \textcolor{keywordflow}{return} formDirective;

    \textcolor{keyword}{function} getSetter(expression) \{
      \textcolor{keywordflow}{if} (expression === \textcolor{stringliteral}{''}) \{
        \textcolor{comment}{//create an assignable expression, so forms with an empty name can be renamed later}
        \textcolor{keywordflow}{return} $parse(\textcolor{stringliteral}{'this[""]'}).assign;
      \}
      \textcolor{keywordflow}{return} $parse(expression).assign || noop;
    \}
  \}];
\};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(\textcolor{keyword}{true});

\textcolor{comment}{/* global VALID\_CLASS: false,}
\textcolor{comment}{  INVALID\_CLASS: false,}
\textcolor{comment}{  PRISTINE\_CLASS: false,}
\textcolor{comment}{  DIRTY\_CLASS: false,}
\textcolor{comment}{  UNTOUCHED\_CLASS: false,}
\textcolor{comment}{  TOUCHED\_CLASS: false,}
\textcolor{comment}{  ngModelMinErr: false,}
\textcolor{comment}{*/}

\textcolor{comment}{// Regex code is obtained from SO:
       https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231}
var ISO\_DATE\_REGEXP = /\(\backslash\)d\{4\}-[01]\(\backslash\)d-[0-3]\(\backslash\)dT[0-2]\(\backslash\)d:[0-5]\(\backslash\)d:[0-5]\(\backslash\)d\(\backslash\).\(\backslash\)d+([+-][0-2]\(\backslash\)d:[0-5]\(\backslash\)d|Z)/;
var URL\_REGEXP = /^(ftp|http|https):\(\backslash\)/\(\backslash\)/(\(\backslash\)w+:\{0,1\}\(\backslash\)w*@)?(\(\backslash\)S+)(:[0-9]+)?(\(\backslash\)/|\(\backslash\)/([\(\backslash\)w#!:.?+=&%@!\(\backslash\)-\(\backslash\)/]))?$/;
var EMAIL\_REGEXP = /^[a-z0-9!#$%&\textcolor{stringliteral}{'*+\(\backslash\)/=?^\_`\{|\}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\(\backslash\).
      [a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;}
\textcolor{stringliteral}{var NUMBER\_REGEXP = /^\(\backslash\)s*(\(\backslash\)-|\(\backslash\)+)?(\(\backslash\)d+|(\(\backslash\)d*(\(\backslash\).\(\backslash\)d*)))([eE][+-]?\(\backslash\)d+)?\(\backslash\)s*$/;}
\textcolor{stringliteral}{var DATE\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\{2\})-(\(\backslash\)d\{2\})$/;}
\textcolor{stringliteral}{var DATETIMELOCAL\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\(\backslash\)d)-(\(\backslash\)d\(\backslash\)d)T(\(\backslash\)d\(\backslash\)d):(\(\backslash\)d\(\backslash\)d)(?::(\(\backslash\)d\(\backslash\)d)(\(\backslash\).\(\backslash\)d\{1,3\})?)?$/;}
\textcolor{stringliteral}{var WEEK\_REGEXP = /^(\(\backslash\)d\{4\})-W(\(\backslash\)d\(\backslash\)d)$/;}
\textcolor{stringliteral}{var MONTH\_REGEXP = /^(\(\backslash\)d\{4\})-(\(\backslash\)d\(\backslash\)d)$/;}
\textcolor{stringliteral}{var TIME\_REGEXP = /^(\(\backslash\)d\(\backslash\)d):(\(\backslash\)d\(\backslash\)d)(?::(\(\backslash\)d\(\backslash\)d)(\(\backslash\).\(\backslash\)d\{1,3\})?)?$/;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{var inputType = \{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}text\textcolor{stringliteral}{': textInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}date\textcolor{stringliteral}{': createDateInputType('}date\textcolor{stringliteral}{', DATE\_REGEXP,}
\textcolor{stringliteral}{         createDateParser(DATE\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{', '}dd\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{         '}yyyy-MM-dd\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}datetime-local\textcolor{stringliteral}{': createDateInputType('}datetimelocal\textcolor{stringliteral}{', DATETIMELOCAL\_REGEXP,}
\textcolor{stringliteral}{      createDateParser(DATETIMELOCAL\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{', '}dd\textcolor{stringliteral}{', '}HH\textcolor{stringliteral}{', '}mm\textcolor{stringliteral}{', '}ss\textcolor{stringliteral}{', '}sss\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{      '}yyyy-MM-ddTHH:mm:ss.sss\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}time\textcolor{stringliteral}{': createDateInputType('}time\textcolor{stringliteral}{', TIME\_REGEXP,}
\textcolor{stringliteral}{      createDateParser(TIME\_REGEXP, ['}HH\textcolor{stringliteral}{', '}mm\textcolor{stringliteral}{', '}ss\textcolor{stringliteral}{', '}sss\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{     '}HH:mm:ss.sss\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}week\textcolor{stringliteral}{': createDateInputType('}week\textcolor{stringliteral}{', WEEK\_REGEXP, weekParser, '}yyyy-Www\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}month\textcolor{stringliteral}{': createDateInputType('}month\textcolor{stringliteral}{', MONTH\_REGEXP,}
\textcolor{stringliteral}{     createDateParser(MONTH\_REGEXP, ['}yyyy\textcolor{stringliteral}{', '}MM\textcolor{stringliteral}{']),}
\textcolor{stringliteral}{     '}yyyy-MM\textcolor{stringliteral}{'),}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}number\textcolor{stringliteral}{': numberInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}url\textcolor{stringliteral}{': urlInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}email\textcolor{stringliteral}{': emailInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}radio\textcolor{stringliteral}{': radioInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}checkbox\textcolor{stringliteral}{': checkboxInputType,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  '}hidden\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}button\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}submit\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}reset\textcolor{stringliteral}{': noop,}
\textcolor{stringliteral}{  '}file\textcolor{stringliteral}{': noop}
\textcolor{stringliteral}{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function stringBasedInputType(ctrl) \{}
\textcolor{stringliteral}{  ctrl.$formatters.push(function(value) \{}
\textcolor{stringliteral}{    return ctrl.$isEmpty(value) ? value : value.toString();}
\textcolor{stringliteral}{  \});}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function textInputType(scope, element, attr, ctrl, $sniffer, $browser) \{}
\textcolor{stringliteral}{  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);}
\textcolor{stringliteral}{  stringBasedInputType(ctrl);}
\textcolor{stringliteral}{\}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) \{}
\textcolor{stringliteral}{  var type = lowercase(element[0].type);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  // In composition mode, users are still inputing intermediate text buffer,}
\textcolor{stringliteral}{  // hold the listener until composition is done.}
\textcolor{stringliteral}{  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent}
\textcolor{stringliteral}{  if (!$sniffer.android) \{}
\textcolor{stringliteral}{    var composing = false;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    element.on('}compositionstart\textcolor{stringliteral}{', function(data) \{}
\textcolor{stringliteral}{      composing = true;}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    element.on('}compositionend\textcolor{stringliteral}{', function() \{}
\textcolor{stringliteral}{      composing = false;}
\textcolor{stringliteral}{      listener();}
\textcolor{stringliteral}{    \});}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var listener = function(ev) \{}
\textcolor{stringliteral}{    if (timeout) \{}
\textcolor{stringliteral}{      $browser.defer.cancel(timeout);}
\textcolor{stringliteral}{      timeout = null;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    if (composing) return;}
\textcolor{stringliteral}{    var value = element.val(),}
\textcolor{stringliteral}{        event = ev && ev.type;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // By default we will trim the value}
\textcolor{stringliteral}{    // If the attribute ng-trim exists we will avoid trimming}
\textcolor{stringliteral}{    // If input type is '}password\textcolor{stringliteral}{', the value is never trimmed}
\textcolor{stringliteral}{    if (type !== '}password\textcolor{stringliteral}{' && (!attr.ngTrim || attr.ngTrim !== '}\textcolor{keyword}{false}\textcolor{stringliteral}{')) \{}
\textcolor{stringliteral}{      value = trim(value);}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    // If a control is suffering from bad input (due to native validators), browsers discard its}
\textcolor{stringliteral}{    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the}
\textcolor{stringliteral}{    // control'}s value is the same empty value twice in a row.
    \textcolor{keywordflow}{if} (ctrl.$viewValue !== value || (value === \textcolor{stringliteral}{''} && ctrl.$$hasNativeValidators)) \{
      ctrl.$setViewValue(value, event);
    \}
  \};

  \textcolor{comment}{// if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the}
  \textcolor{comment}{// input event on backspace, delete or cut}
  \textcolor{keywordflow}{if} ($sniffer.hasEvent(\textcolor{stringliteral}{'input'})) \{
    element.on(\textcolor{stringliteral}{'input'}, listener);
  \} \textcolor{keywordflow}{else} \{
    var timeout;

    var deferListener = \textcolor{keyword}{function}(ev, input, origValue) \{
      \textcolor{keywordflow}{if} (!timeout) \{
        timeout = $browser.defer(\textcolor{keyword}{function}() \{
          timeout = null;
          \textcolor{keywordflow}{if} (!input || input.value !== origValue) \{
            listener(ev);
          \}
        \});
      \}
    \};

    element.on(\textcolor{stringliteral}{'keydown'}, \textcolor{keyword}{function}(event) \{
      var key = event.keyCode;

      \textcolor{comment}{// ignore}
      \textcolor{comment}{//    command            modifiers                   arrows}
      \textcolor{keywordflow}{if} (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) \textcolor{keywordflow}{return};

      deferListener(event, \textcolor{keyword}{this}, this.value);
    \});

    \textcolor{comment}{// if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it}
    \textcolor{keywordflow}{if} ($sniffer.hasEvent(\textcolor{stringliteral}{'paste'})) \{
      element.on(\textcolor{stringliteral}{'paste cut'}, deferListener);
    \}
  \}

  \textcolor{comment}{// if user paste into input using mouse on older browser}
  \textcolor{comment}{// or form autocomplete on newer browser, we need "change" event to catch it}
  element.on(\textcolor{stringliteral}{'change'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    \textcolor{comment}{// Workaround for Firefox validation #12102.}
    var value = ctrl.$isEmpty(ctrl.$viewValue) ? \textcolor{stringliteral}{''} : ctrl.$viewValue;
    \textcolor{keywordflow}{if} (element.val() !== value) \{
      element.val(value);
    \}
  \};
\}

\textcolor{keyword}{function} weekParser(isoWeek, existingDate) \{
  \textcolor{keywordflow}{if} (isDate(isoWeek)) \{
    \textcolor{keywordflow}{return} isoWeek;
  \}

  \textcolor{keywordflow}{if} (isString(isoWeek)) \{
    WEEK\_REGEXP.lastIndex = 0;
    var parts = WEEK\_REGEXP.exec(isoWeek);
    \textcolor{keywordflow}{if} (parts) \{
      var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;

      \textcolor{keywordflow}{if} (existingDate) \{
        hours = existingDate.getHours();
        minutes = existingDate.getMinutes();
        seconds = existingDate.getSeconds();
        milliseconds = existingDate.getMilliseconds();
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
    \}
  \}

  \textcolor{keywordflow}{return} NaN;
\}

\textcolor{keyword}{function} createDateParser(regexp, mapping) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function}(iso, date) \{
    var parts, map;

    \textcolor{keywordflow}{if} (isDate(iso)) \{
      \textcolor{keywordflow}{return} iso;
    \}

    \textcolor{keywordflow}{if} (isString(iso)) \{
      \textcolor{comment}{// When a date is JSON'ified to wraps itself inside of an extra}
      \textcolor{comment}{// set of double quotes. This makes the date parsing code unable}
      \textcolor{comment}{// to match the date string and parse it as a date.}
      \textcolor{keywordflow}{if} (iso.charAt(0) == \textcolor{charliteral}{'"'} && iso.charAt(iso.length - 1) == \textcolor{charliteral}{'"'}) \{
        iso = iso.substring(1, iso.length - 1);
      \}
      \textcolor{keywordflow}{if} (ISO\_DATE\_REGEXP.test(iso)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(iso);
      \}
      regexp.lastIndex = 0;
      parts = regexp.exec(iso);

      \textcolor{keywordflow}{if} (parts) \{
        parts.shift();
        \textcolor{keywordflow}{if} (date) \{
          map = \{
            yyyy: date.getFullYear(),
            MM: date.getMonth() + 1,
            dd: date.getDate(),
            HH: date.getHours(),
            mm: date.getMinutes(),
            ss: date.getSeconds(),
            sss: date.getMilliseconds() / 1000
          \};
        \} \textcolor{keywordflow}{else} \{
          map = \{ yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 \};
        \}

        forEach(parts, \textcolor{keyword}{function}(part, index) \{
          \textcolor{keywordflow}{if} (index < mapping.length) \{
            map[mapping[index]] = +part;
          \}
        \});
        \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
      \}
    \}

    \textcolor{keywordflow}{return} NaN;
  \};
\}

\textcolor{keyword}{function} createDateInputType(type, regexp, parseDate, format) \{
  \textcolor{keywordflow}{return} \textcolor{keyword}{function} dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) \{
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
    var previousDate;

    ctrl.$$parserName = type;
    ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{if} (ctrl.$isEmpty(value)) \textcolor{keywordflow}{return} null;
      \textcolor{keywordflow}{if} (regexp.test(value)) \{
        \textcolor{comment}{// Note: We cannot read ctrl.$modelValue, as there might be a different}
        \textcolor{comment}{// parser/formatter in the processing chain so that the model}
        \textcolor{comment}{// contains some different data format!}
        var parsedDate = parseDate(value, previousDate);
        \textcolor{keywordflow}{if} (timezone) \{
          parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        \}
        \textcolor{keywordflow}{return} parsedDate;
      \}
      \textcolor{keywordflow}{return} undefined;
    \});

    ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{if} (value && !isDate(value)) \{
        \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'datefmt'}, \textcolor{stringliteral}{'Expected `\{0\}` to be a date'}, value);
      \}
      \textcolor{keywordflow}{if} (isValidDate(value)) \{
        previousDate = value;
        \textcolor{keywordflow}{if} (previousDate && timezone) \{
          previousDate = convertTimezoneToLocal(previousDate, timezone, \textcolor{keyword}{true});
        \}
        \textcolor{keywordflow}{return} $filter(\textcolor{stringliteral}{'date'})(value, format, timezone);
      \} \textcolor{keywordflow}{else} \{
        previousDate = null;
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{''};
      \}
    \});

    \textcolor{keywordflow}{if} (isDefined(attr.min) || attr.ngMin) \{
      var minVal;
      ctrl.$validators.min = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
      \};
      attr.$observe(\textcolor{stringliteral}{'min'}, \textcolor{keyword}{function}(val) \{
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
      \});
    \}

    \textcolor{keywordflow}{if} (isDefined(attr.max) || attr.ngMax) \{
      var maxVal;
      ctrl.$validators.max = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
      \};
      attr.$observe(\textcolor{stringliteral}{'max'}, \textcolor{keyword}{function}(val) \{
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
      \});
    \}

    \textcolor{keyword}{function} isValidDate(value) \{
      \textcolor{comment}{// Invalid Date: getTime() returns NaN}
      \textcolor{keywordflow}{return} value && !(value.getTime && value.getTime() !== value.getTime());
    \}

    \textcolor{keyword}{function} parseObservedDateValue(val) \{
      \textcolor{keywordflow}{return} isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
    \}
  \};
\}

\textcolor{keyword}{function} badInputChecker(scope, element, attr, ctrl) \{
  var node = element[0];
  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
  \textcolor{keywordflow}{if} (nativeValidation) \{
    ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
      var validity = element.prop(VALIDITY\_STATE\_PROPERTY) || \{\};
      \textcolor{comment}{// Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show\_bug.cgi?id=1064430):}
      \textcolor{comment}{// - also sets validity.badInput (should only be validity.typeMismatch).}
      \textcolor{comment}{// - see
       http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)}
      \textcolor{comment}{// - can ignore this case as we can still read out the erroneous email...}
      \textcolor{keywordflow}{return} validity.badInput && !validity.typeMismatch ? undefined : value;
    \});
  \}
\}

\textcolor{keyword}{function} numberInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  badInputChecker(scope, element, attr, ctrl);
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$$parserName = \textcolor{stringliteral}{'number'};
  ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (ctrl.$isEmpty(value))      \textcolor{keywordflow}{return} null;
    \textcolor{keywordflow}{if} (NUMBER\_REGEXP.test(value)) \textcolor{keywordflow}{return} parseFloat(value);
    \textcolor{keywordflow}{return} undefined;
  \});

  ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{if} (!ctrl.$isEmpty(value)) \{
      \textcolor{keywordflow}{if} (!isNumber(value)) \{
        \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'numfmt'}, \textcolor{stringliteral}{'Expected `\{0\}` to be a number'}, value);
      \}
      value = value.toString();
    \}
    \textcolor{keywordflow}{return} value;
  \});

  \textcolor{keywordflow}{if} (isDefined(attr.min) || attr.ngMin) \{
    var minVal;
    ctrl.$validators.min = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
    \};

    attr.$observe(\textcolor{stringliteral}{'min'}, \textcolor{keyword}{function}(val) \{
      \textcolor{keywordflow}{if} (isDefined(val) && !isNumber(val)) \{
        val = parseFloat(val, 10);
      \}
      minVal = isNumber(val) && !isNaN(val) ? val : undefined;
      \textcolor{comment}{// TODO(matsko): implement validateLater to reduce number of validations}
      ctrl.$validate();
    \});
  \}

  \textcolor{keywordflow}{if} (isDefined(attr.max) || attr.ngMax) \{
    var maxVal;
    ctrl.$validators.max = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
    \};

    attr.$observe(\textcolor{stringliteral}{'max'}, \textcolor{keyword}{function}(val) \{
      \textcolor{keywordflow}{if} (isDefined(val) && !isNumber(val)) \{
        val = parseFloat(val, 10);
      \}
      maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
      \textcolor{comment}{// TODO(matsko): implement validateLater to reduce number of validations}
      ctrl.$validate();
    \});
  \}
\}

\textcolor{keyword}{function} urlInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  \textcolor{comment}{// Note: no badInputChecker here by purpose as `url` is only a validation}
  \textcolor{comment}{// in browsers, i.e. we can always read out input.value even if it is not valid!}
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = \textcolor{stringliteral}{'url'};
  ctrl.$validators.url = \textcolor{keyword}{function}(modelValue, viewValue) \{
    var value = modelValue || viewValue;
    \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || URL\_REGEXP.test(value);
  \};
\}

\textcolor{keyword}{function} emailInputType(scope, element, attr, ctrl, $sniffer, $browser) \{
  \textcolor{comment}{// Note: no badInputChecker here by purpose as `url` is only a validation}
  \textcolor{comment}{// in browsers, i.e. we can always read out input.value even if it is not valid!}
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
  stringBasedInputType(ctrl);

  ctrl.$$parserName = \textcolor{stringliteral}{'email'};
  ctrl.$validators.email = \textcolor{keyword}{function}(modelValue, viewValue) \{
    var value = modelValue || viewValue;
    \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || EMAIL\_REGEXP.test(value);
  \};
\}

\textcolor{keyword}{function} radioInputType(scope, element, attr, ctrl) \{
  \textcolor{comment}{// make the name unique, if not defined}
  \textcolor{keywordflow}{if} (isUndefined(attr.name)) \{
    element.attr(\textcolor{stringliteral}{'name'}, nextUid());
  \}

  var listener = \textcolor{keyword}{function}(ev) \{
    \textcolor{keywordflow}{if} (element[0].checked) \{
      ctrl.$setViewValue(attr.value, ev && ev.type);
    \}
  \};

  element.on(\textcolor{stringliteral}{'click'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  \};

  attr.$observe(\textcolor{stringliteral}{'value'}, ctrl.$render);
\}

\textcolor{keyword}{function} parseConstantExpr($parse, context, name, expression, fallback) \{
  var parseFn;
  \textcolor{keywordflow}{if} (isDefined(expression)) \{
    parseFn = $parse(expression);
    \textcolor{keywordflow}{if} (!parseFn.constant) \{
      \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'constexpr'}, \textcolor{stringliteral}{'Expected constant expression for `\{0\}`, but saw '} +
                                   \textcolor{stringliteral}{'`\{1\}`.'}, name, expression);
    \}
    \textcolor{keywordflow}{return} parseFn(context);
  \}
  \textcolor{keywordflow}{return} fallback;
\}

\textcolor{keyword}{function} checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) \{
  var trueValue = parseConstantExpr($parse, scope, \textcolor{stringliteral}{'ngTrueValue'}, attr.ngTrueValue, \textcolor{keyword}{true});
  var falseValue = parseConstantExpr($parse, scope, \textcolor{stringliteral}{'ngFalseValue'}, attr.ngFalseValue, \textcolor{keyword}{false});

  var listener = \textcolor{keyword}{function}(ev) \{
    ctrl.$setViewValue(element[0].checked, ev && ev.type);
  \};

  element.on(\textcolor{stringliteral}{'click'}, listener);

  ctrl.$render = \textcolor{keyword}{function}() \{
    element[0].checked = ctrl.$viewValue;
  \};

  \textcolor{comment}{// Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`}
  \textcolor{comment}{// This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert}
  \textcolor{comment}{// it to a boolean.}
  ctrl.$isEmpty = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} value === \textcolor{keyword}{false};
  \};

  ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} equals(value, trueValue);
  \});

  ctrl.$parsers.push(\textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} value ? trueValue : falseValue;
  \});
\}


var inputDirective = [\textcolor{stringliteral}{'$browser'}, \textcolor{stringliteral}{'$sniffer'}, \textcolor{stringliteral}{'$filter'}, \textcolor{stringliteral}{'$parse'},
    \textcolor{keyword}{function}($browser, $sniffer, $filter, $parse) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    require: [\textcolor{stringliteral}{'?ngModel'}],
    link: \{
      pre: \textcolor{keyword}{function}(scope, element, attr, ctrls) \{
        \textcolor{keywordflow}{if} (ctrls[0]) \{
          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
                                                              $browser, $filter, $parse);
        \}
      \}
    \}
  \};
\}];



var CONSTANT\_VALUE\_REGEXP = /^(\textcolor{keyword}{true}|\textcolor{keyword}{false}|\(\backslash\)d+)$/;
var ngValueDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    priority: 100,
    compile: \textcolor{keyword}{function}(tpl, tplAttr) \{
      \textcolor{keywordflow}{if} (CONSTANT\_VALUE\_REGEXP.test(tplAttr.ngValue)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngValueConstantLink(scope, elm, attr) \{
          attr.$set(\textcolor{stringliteral}{'value'}, scope.$eval(attr.ngValue));
        \};
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngValueLink(scope, elm, attr) \{
          scope.$watch(attr.ngValue, \textcolor{keyword}{function} valueWatchAction(value) \{
            attr.$set(\textcolor{stringliteral}{'value'}, value);
          \});
        \};
      \}
    \}
  \};
\};

var ngBindDirective = [\textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($compile) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{stringliteral}{'AC'},
    compile: \textcolor{keyword}{function} ngBindCompile(templateElement) \{
      $compile.$$addBindingClass(templateElement);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindLink(scope, element, attr) \{
        $compile.$$addBindingInfo(element, attr.ngBind);
        element = element[0];
        scope.$watch(attr.ngBind, \textcolor{keyword}{function} ngBindWatchAction(value) \{
          element.textContent = value === undefined ? \textcolor{stringliteral}{''} : value;
        \});
      \};
    \}
  \};
\}];


var ngBindTemplateDirective = [\textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($interpolate, $compile) \{
  \textcolor{keywordflow}{return} \{
    compile: \textcolor{keyword}{function} ngBindTemplateCompile(templateElement) \{
      $compile.$$addBindingClass(templateElement);
      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindTemplateLink(scope, element, attr) \{
        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
        $compile.$$addBindingInfo(element, interpolateFn.expressions);
        element = element[0];
        attr.$observe(\textcolor{stringliteral}{'ngBindTemplate'}, \textcolor{keyword}{function}(value) \{
          element.textContent = value === undefined ? \textcolor{stringliteral}{''} : value;
        \});
      \};
    \}
  \};
\}];


var ngBindHtmlDirective = [\textcolor{stringliteral}{'$sce'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$compile'}, \textcolor{keyword}{function}($sce, $parse, $compile) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    compile: \textcolor{keyword}{function} ngBindHtmlCompile(tElement, tAttrs) \{
      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, \textcolor{keyword}{function} getStringValue(value) \{
        \textcolor{keywordflow}{return} (value || \textcolor{stringliteral}{''}).toString();
      \});
      $compile.$$addBindingClass(tElement);

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngBindHtmlLink(scope, element, attr) \{
        $compile.$$addBindingInfo(element, attr.ngBindHtml);

        scope.$watch(ngBindHtmlWatch, \textcolor{keyword}{function} ngBindHtmlWatchAction() \{
          \textcolor{comment}{// we re-evaluate the expr because we want a TrustedValueHolderType}
          \textcolor{comment}{// for $sce, not a string}
          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || \textcolor{stringliteral}{''});
        \});
      \};
    \}
  \};
\}];

var ngChangeDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'A'},
  require: \textcolor{stringliteral}{'ngModel'},
  link: \textcolor{keyword}{function}(scope, element, attr, ctrl) \{
    ctrl.$viewChangeListeners.push(\textcolor{keyword}{function}() \{
      scope.$eval(attr.ngChange);
    \});
  \}
\});

\textcolor{keyword}{function} classDirective(name, selector) \{
  name = \textcolor{stringliteral}{'ngClass'} + name;
  \textcolor{keywordflow}{return} [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{stringliteral}{'AC'},
      link: \textcolor{keyword}{function}(scope, element, attr) \{
        var oldVal;

        scope.$watch(attr[name], ngClassWatchAction, \textcolor{keyword}{true});

        attr.$observe(\textcolor{stringliteral}{'class'}, \textcolor{keyword}{function}(value) \{
          ngClassWatchAction(scope.$eval(attr[name]));
        \});


        \textcolor{keywordflow}{if} (name !== \textcolor{stringliteral}{'ngClass'}) \{
          scope.$watch(\textcolor{stringliteral}{'$index'}, \textcolor{keyword}{function}($index, old$index) \{
            \textcolor{comment}{// jshint bitwise: false}
            var mod = $index & 1;
            \textcolor{keywordflow}{if} (mod !== (old$index & 1)) \{
              var classes = arrayClasses(scope.$eval(attr[name]));
              mod === selector ?
                addClasses(classes) :
                removeClasses(classes);
            \}
          \});
        \}

        \textcolor{keyword}{function} addClasses(classes) \{
          var newClasses = digestClassCounts(classes, 1);
          attr.$addClass(newClasses);
        \}

        \textcolor{keyword}{function} removeClasses(classes) \{
          var newClasses = digestClassCounts(classes, -1);
          attr.$removeClass(newClasses);
        \}

        \textcolor{keyword}{function} digestClassCounts(classes, count) \{
          \textcolor{comment}{// Use createMap() to prevent class assumptions involving property}
          \textcolor{comment}{// names in Object.prototype}
          var classCounts = element.data(\textcolor{stringliteral}{'$classCounts'}) || createMap();
          var classesToUpdate = [];
          forEach(classes, \textcolor{keyword}{function}(className) \{
            \textcolor{keywordflow}{if} (count > 0 || classCounts[className]) \{
              classCounts[className] = (classCounts[className] || 0) + count;
              \textcolor{keywordflow}{if} (classCounts[className] === +(count > 0)) \{
                classesToUpdate.push(className);
              \}
            \}
          \});
          element.data(\textcolor{stringliteral}{'$classCounts'}, classCounts);
          \textcolor{keywordflow}{return} classesToUpdate.join(\textcolor{charliteral}{' '});
        \}

        \textcolor{keyword}{function} updateClasses(oldClasses, newClasses) \{
          var toAdd = arrayDifference(newClasses, oldClasses);
          var toRemove = arrayDifference(oldClasses, newClasses);
          toAdd = digestClassCounts(toAdd, 1);
          toRemove = digestClassCounts(toRemove, -1);
          \textcolor{keywordflow}{if} (toAdd && toAdd.length) \{
            $animate.addClass(element, toAdd);
          \}
          \textcolor{keywordflow}{if} (toRemove && toRemove.length) \{
            $animate.removeClass(element, toRemove);
          \}
        \}

        \textcolor{keyword}{function} ngClassWatchAction(newVal) \{
          \textcolor{keywordflow}{if} (selector === \textcolor{keyword}{true} || scope.$index % 2 === selector) \{
            var newClasses = arrayClasses(newVal || []);
            \textcolor{keywordflow}{if} (!oldVal) \{
              addClasses(newClasses);
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!equals(newVal,oldVal)) \{
              var oldClasses = arrayClasses(oldVal);
              updateClasses(oldClasses, newClasses);
            \}
          \}
          oldVal = shallowCopy(newVal);
        \}
      \}
    \};

    \textcolor{keyword}{function} arrayDifference(tokens1, tokens2) \{
      var values = [];

      outer:
      \textcolor{keywordflow}{for} (var i = 0; i < tokens1.length; i++) \{
        var token = tokens1[i];
        \textcolor{keywordflow}{for} (var j = 0; j < tokens2.length; j++) \{
          \textcolor{keywordflow}{if} (token == tokens2[j]) \textcolor{keywordflow}{continue} outer;
        \}
        values.push(token);
      \}
      \textcolor{keywordflow}{return} values;
    \}

    \textcolor{keyword}{function} arrayClasses(classVal) \{
      var classes = [];
      \textcolor{keywordflow}{if} (isArray(classVal)) \{
        forEach(classVal, \textcolor{keyword}{function}(v) \{
          classes = classes.concat(arrayClasses(v));
        \});
        \textcolor{keywordflow}{return} classes;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isString(classVal)) \{
        \textcolor{keywordflow}{return} classVal.split(\textcolor{charliteral}{' '});
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(classVal)) \{
        forEach(classVal, \textcolor{keyword}{function}(v, k) \{
          \textcolor{keywordflow}{if} (v) \{
            classes = classes.concat(k.split(\textcolor{charliteral}{' '}));
          \}
        \});
        \textcolor{keywordflow}{return} classes;
      \}
      \textcolor{keywordflow}{return} classVal;
    \}
  \}];
\}

var ngClassDirective = classDirective(\textcolor{stringliteral}{''}, \textcolor{keyword}{true});

var ngClassOddDirective = classDirective(\textcolor{stringliteral}{'Odd'}, 0);

var ngClassEvenDirective = classDirective(\textcolor{stringliteral}{'Even'}, 1);

var ngCloakDirective = ngDirective(\{
  compile: \textcolor{keyword}{function}(element, attr) \{
    attr.$set(\textcolor{stringliteral}{'ngCloak'}, undefined);
    element.removeClass(\textcolor{stringliteral}{'ng-cloak'});
  \}
\});

var ngControllerDirective = [\textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    scope: \textcolor{keyword}{true},
    controller: \textcolor{charliteral}{'@'},
    priority: 500
  \};
\}];

\textcolor{comment}{// ngCsp is not implemented as a proper directive any more, because we need it be processed while we}
\textcolor{comment}{// bootstrap the system (before $parse is instantiated), for this reason we just have}
\textcolor{comment}{// the csp() fn that looks for the `ng-csp` attribute anywhere in the current doc}

\textcolor{comment}{/*}
\textcolor{comment}{ * A collection of directives that allows creation of custom event handlers that are defined as}
\textcolor{comment}{ * angular expressions and are compiled and executed within the current scope.}
\textcolor{comment}{ */}
var ngEventDirectives = \{\};

\textcolor{comment}{// For events that might fire synchronously during DOM manipulation}
\textcolor{comment}{// we need to execute their event handlers asynchronously using $evalAsync,}
\textcolor{comment}{// so that they are not executed in an inconsistent state.}
var forceAsyncEvents = \{
  \textcolor{stringliteral}{'blur'}: \textcolor{keyword}{true},
  \textcolor{stringliteral}{'focus'}: \textcolor{keyword}{true}
\};
forEach(
  \textcolor{stringliteral}{'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup
       keypress submit focus blur copy cut paste'}.split(\textcolor{charliteral}{' '}),
  \textcolor{keyword}{function}(eventName) \{
    var directiveName = directiveNormalize(\textcolor{stringliteral}{'ng-'} + eventName);
    ngEventDirectives[directiveName] = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($parse, $rootScope) \{
      \textcolor{keywordflow}{return} \{
        restrict: \textcolor{charliteral}{'A'},
        compile: \textcolor{keyword}{function}($element, attr) \{
          \textcolor{comment}{// We expose the powerful $event object on the scope that provides access to the Window,}
          \textcolor{comment}{// etc. that isn't protected by the fast paths in $parse.  We explicitly request better}
          \textcolor{comment}{// checks at the cost of speed since event handler expressions are not executed as}
          \textcolor{comment}{// frequently as regular change detection.}
          var fn = $parse(attr[directiveName], \textcolor{comment}{/* interceptorFn */} null, \textcolor{comment}{/* expensiveChecks */} \textcolor{keyword}{true});
          \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngEventHandler(scope, element) \{
            element.on(eventName, \textcolor{keyword}{function}(event) \{
              var callback = \textcolor{keyword}{function}() \{
                fn(scope, \{$event:event\});
              \};
              \textcolor{keywordflow}{if} (forceAsyncEvents[eventName] && $rootScope.$$phase) \{
                scope.$evalAsync(callback);
              \} \textcolor{keywordflow}{else} \{
                scope.$apply(callback);
              \}
            \});
          \};
        \}
      \};
    \}];
  \}
);

var ngIfDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    multiElement: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    priority: 600,
    terminal: \textcolor{keyword}{true},
    restrict: \textcolor{charliteral}{'A'},
    $$tlb: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}($scope, $element, $attr, ctrl, $transclude) \{
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, \textcolor{keyword}{function} ngIfWatchAction(value) \{

          \textcolor{keywordflow}{if} (value) \{
            \textcolor{keywordflow}{if} (!childScope) \{
              $transclude(\textcolor{keyword}{function}(clone, newScope) \{
                childScope = newScope;
                clone[clone.length++] = document.createComment(\textcolor{stringliteral}{' end ngIf: '} + $attr.ngIf + \textcolor{charliteral}{' '});
                \textcolor{comment}{// Note: We only need the first/last node of the cloned nodes.}
                \textcolor{comment}{// However, we need to keep the reference to the jqlite wrapper as it might be changed
       later}
                \textcolor{comment}{// by a directive with templateUrl when its template arrives.}
                block = \{
                  clone: clone
                \};
                $animate.enter(clone, $element.parent(), $element);
              \});
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (previousElements) \{
              previousElements.remove();
              previousElements = null;
            \}
            \textcolor{keywordflow}{if} (childScope) \{
              childScope.$destroy();
              childScope = null;
            \}
            \textcolor{keywordflow}{if} (block) \{
              previousElements = getBlockNodes(block.clone);
              $animate.leave(previousElements).then(\textcolor{keyword}{function}() \{
                previousElements = null;
              \});
              block = null;
            \}
          \}
        \});
    \}
  \};
\}];

var ngIncludeDirective = [\textcolor{stringliteral}{'$templateRequest'}, \textcolor{stringliteral}{'$anchorScroll'}, \textcolor{stringliteral}{'$animate'},
                  \textcolor{keyword}{function}($templateRequest,   $anchorScroll,   $animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{stringliteral}{'ECA'},
    priority: 400,
    terminal: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    controller: angular.noop,
    compile: \textcolor{keyword}{function}(element, attr) \{
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || \textcolor{stringliteral}{''},
          autoScrollExp = attr.autoscroll;

      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, $element, $attr, ctrl, $transclude) \{
        var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;

        var cleanupLastIncludeContent = \textcolor{keyword}{function}() \{
          \textcolor{keywordflow}{if} (previousElement) \{
            previousElement.remove();
            previousElement = null;
          \}
          \textcolor{keywordflow}{if} (currentScope) \{
            currentScope.$destroy();
            currentScope = null;
          \}
          \textcolor{keywordflow}{if} (currentElement) \{
            $animate.leave(currentElement).then(\textcolor{keyword}{function}() \{
              previousElement = null;
            \});
            previousElement = currentElement;
            currentElement = null;
          \}
        \};

        scope.$watch(srcExp, \textcolor{keyword}{function} ngIncludeWatchAction(src) \{
          var afterAnimation = \textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) \{
              $anchorScroll();
            \}
          \};
          var thisChangeId = ++changeCounter;

          \textcolor{keywordflow}{if} (src) \{
            \textcolor{comment}{//set the 2nd param to true to ignore the template request error so that the inner}
            \textcolor{comment}{//contents and scope can be cleaned up.}
            $templateRequest(src, \textcolor{keyword}{true}).then(\textcolor{keyword}{function}(response) \{
              \textcolor{keywordflow}{if} (thisChangeId !== changeCounter) \textcolor{keywordflow}{return};
              var newScope = scope.$new();
              ctrl.template = response;

              \textcolor{comment}{// Note: This will also link all children of ng-include that were contained in the original}
              \textcolor{comment}{// html. If that content contains controllers, ... they could pollute/change the scope.}
              \textcolor{comment}{// However, using ng-include on an element with additional content does not make sense...}
              \textcolor{comment}{// Note: We can't remove them in the cloneAttchFn of $transclude as that}
              \textcolor{comment}{// function is called before linking the content, which would apply child}
              \textcolor{comment}{// directives to non existing elements.}
              var clone = $transclude(newScope, \textcolor{keyword}{function}(clone) \{
                cleanupLastIncludeContent();
                $animate.enter(clone, null, $element).then(afterAnimation);
              \});

              currentScope = newScope;
              currentElement = clone;

              currentScope.$emit(\textcolor{stringliteral}{'$includeContentLoaded'}, src);
              scope.$eval(onloadExp);
            \}, \textcolor{keyword}{function}() \{
              \textcolor{keywordflow}{if} (thisChangeId === changeCounter) \{
                cleanupLastIncludeContent();
                scope.$emit(\textcolor{stringliteral}{'$includeContentError'}, src);
              \}
            \});
            scope.$emit(\textcolor{stringliteral}{'$includeContentRequested'}, src);
          \} \textcolor{keywordflow}{else} \{
            cleanupLastIncludeContent();
            ctrl.template = null;
          \}
        \});
      \};
    \}
  \};
\}];

\textcolor{comment}{// This directive is called during the $transclude call of the first `ngInclude` directive.}
\textcolor{comment}{// It will replace and compile the content of the element with the loaded template.}
\textcolor{comment}{// We need this directive so that the element content is already filled when}
\textcolor{comment}{// the link function of another directive on the same element as ngInclude}
\textcolor{comment}{// is called.}
var ngIncludeFillContentDirective = [\textcolor{stringliteral}{'$compile'},
  \textcolor{keyword}{function}($compile) \{
    \textcolor{keywordflow}{return} \{
      restrict: \textcolor{stringliteral}{'ECA'},
      priority: -400,
      require: \textcolor{stringliteral}{'ngInclude'},
      link: \textcolor{keyword}{function}(scope, $element, $attr, ctrl) \{
        \textcolor{keywordflow}{if} (/SVG/.test($element[0].toString())) \{
          \textcolor{comment}{// WebKit: https://bugs.webkit.org/show\_bug.cgi?id=135698 --- SVG elements do not}
          \textcolor{comment}{// support innerHTML, so detect this here and try to generate the contents}
          \textcolor{comment}{// specially.}
          $element.empty();
          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
              \textcolor{keyword}{function} namespaceAdaptedClone(clone) \{
            $element.append(clone);
          \}, \{futureParentElement: $element\});
          \textcolor{keywordflow}{return};
        \}

        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      \}
    \};
  \}];

var ngInitDirective = ngDirective(\{
  priority: 450,
  compile: \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \{
      pre: \textcolor{keyword}{function}(scope, element, attrs) \{
        scope.$eval(attrs.ngInit);
      \}
    \};
  \}
\});

var ngListDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    priority: 100,
    require: \textcolor{stringliteral}{'ngModel'},
    link: \textcolor{keyword}{function}(scope, element, attr, ctrl) \{
      \textcolor{comment}{// We want to control whitespace trimming so we use this convoluted approach}
      \textcolor{comment}{// to access the ngList attribute, which doesn't pre-trim the attribute}
      var ngList = element.attr(attr.$attr.ngList) || \textcolor{stringliteral}{', '};
      var trimValues = attr.ngTrim !== \textcolor{stringliteral}{'false'};
      var separator = trimValues ? trim(ngList) : ngList;

      var parse = \textcolor{keyword}{function}(viewValue) \{
        \textcolor{comment}{// If the viewValue is invalid (say required but empty) it will be `undefined`}
        \textcolor{keywordflow}{if} (isUndefined(viewValue)) \textcolor{keywordflow}{return};

        var list = [];

        \textcolor{keywordflow}{if} (viewValue) \{
          forEach(viewValue.split(separator), \textcolor{keyword}{function}(value) \{
            \textcolor{keywordflow}{if} (value) list.push(trimValues ? trim(value) : value);
          \});
        \}

        \textcolor{keywordflow}{return} list;
      \};

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(\textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{if} (isArray(value)) \{
          \textcolor{keywordflow}{return} value.join(ngList);
        \}

        \textcolor{keywordflow}{return} undefined;
      \});

      \textcolor{comment}{// Override the standard $isEmpty because an empty array means the input is empty.}
      ctrl.$isEmpty = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} !value || !value.length;
      \};
    \}
  \};
\};

\textcolor{comment}{/* global VALID\_CLASS: true,}
\textcolor{comment}{  INVALID\_CLASS: true,}
\textcolor{comment}{  PRISTINE\_CLASS: true,}
\textcolor{comment}{  DIRTY\_CLASS: true,}
\textcolor{comment}{  UNTOUCHED\_CLASS: true,}
\textcolor{comment}{  TOUCHED\_CLASS: true,}
\textcolor{comment}{*/}

var VALID\_CLASS = \textcolor{stringliteral}{'ng-valid'},
    INVALID\_CLASS = \textcolor{stringliteral}{'ng-invalid'},
    PRISTINE\_CLASS = \textcolor{stringliteral}{'ng-pristine'},
    DIRTY\_CLASS = \textcolor{stringliteral}{'ng-dirty'},
    UNTOUCHED\_CLASS = \textcolor{stringliteral}{'ng-untouched'},
    TOUCHED\_CLASS = \textcolor{stringliteral}{'ng-touched'},
    PENDING\_CLASS = \textcolor{stringliteral}{'ng-pending'};

var ngModelMinErr = minErr(\textcolor{stringliteral}{'ngModel'});

var NgModelController = [\textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$exceptionHandler'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$animate'}, \textcolor{stringliteral}{'
      $timeout'}, \textcolor{stringliteral}{'$rootScope'}, \textcolor{stringliteral}{'$q'}, \textcolor{stringliteral}{'$interpolate'},
    \textcolor{keyword}{function}($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, 
      $interpolate) \{
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$$rawModelValue = undefined; \textcolor{comment}{// stores the parsed modelValue / model set from scope regardless of
       validity.}
  this.$validators = \{\};
  this.$asyncValidators = \{\};
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$untouched = \textcolor{keyword}{true};
  this.$touched = \textcolor{keyword}{false};
  this.$pristine = \textcolor{keyword}{true};
  this.$dirty = \textcolor{keyword}{false};
  this.$valid = \textcolor{keyword}{true};
  this.$invalid = \textcolor{keyword}{false};
  this.$error = \{\}; \textcolor{comment}{// keep invalid keys here}
  this.$$success = \{\}; \textcolor{comment}{// keep valid keys here}
  this.$pending = undefined; \textcolor{comment}{// keep pending keys here}
  this.$name = $interpolate($attr.name || \textcolor{stringliteral}{''}, \textcolor{keyword}{false})($scope);


  var parsedNgModel = $parse($attr.ngModel),
      parsedNgModelAssign = parsedNgModel.assign,
      ngModelGet = parsedNgModel,
      ngModelSet = parsedNgModelAssign,
      pendingDebounce = null,
      parserValid,
      ctrl = \textcolor{keyword}{this};

  this.$$setOptions = \textcolor{keyword}{function}(options) \{
    ctrl.$options = options;
    \textcolor{keywordflow}{if} (options && options.getterSetter) \{
      var invokeModelGetter = $parse($attr.ngModel + \textcolor{stringliteral}{'()'}),
          invokeModelSetter = $parse($attr.ngModel + \textcolor{stringliteral}{'($$$p)'});

      ngModelGet = \textcolor{keyword}{function}($scope) \{
        var modelValue = parsedNgModel($scope);
        \textcolor{keywordflow}{if} (isFunction(modelValue)) \{
          modelValue = invokeModelGetter($scope);
        \}
        \textcolor{keywordflow}{return} modelValue;
      \};
      ngModelSet = \textcolor{keyword}{function}($scope, newValue) \{
        \textcolor{keywordflow}{if} (isFunction(parsedNgModel($scope))) \{
          invokeModelSetter($scope, \{$$$p: ctrl.$modelValue\});
        \} \textcolor{keywordflow}{else} \{
          parsedNgModelAssign($scope, ctrl.$modelValue);
        \}
      \};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!parsedNgModel.assign) \{
      \textcolor{keywordflow}{throw} ngModelMinErr(\textcolor{stringliteral}{'nonassign'}, \textcolor{stringliteral}{"Expression '\{0\}' is non-assignable. Element: \{1\}"},
          $attr.ngModel, startingTag($element));
    \}
  \};

  this.$render = noop;

  this.$isEmpty = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} isUndefined(value) || value === \textcolor{stringliteral}{''} || value === null || value !== value;
  \};

  var parentForm = $element.inheritedData(\textcolor{stringliteral}{'$formController'}) || nullFormCtrl,
      currentValidationRunId = 0;

  addSetValidityMethod(\{
    ctrl: \textcolor{keyword}{this},
    $element: $element,
    set: \textcolor{keyword}{function}(object, property) \{
      \textcolor{keywordtype}{object}[property] = \textcolor{keyword}{true};
    \},
    unset: \textcolor{keyword}{function}(object, property) \{
      \textcolor{keyword}{delete} \textcolor{keywordtype}{object}[property];
    \},
    parentForm: parentForm,
    $animate: $animate
  \});

  this.$setPristine = \textcolor{keyword}{function}() \{
    ctrl.$dirty = \textcolor{keyword}{false};
    ctrl.$pristine = \textcolor{keyword}{true};
    $animate.removeClass($element, DIRTY\_CLASS);
    $animate.addClass($element, PRISTINE\_CLASS);
  \};

  this.$setDirty = \textcolor{keyword}{function}() \{
    ctrl.$dirty = \textcolor{keyword}{true};
    ctrl.$pristine = \textcolor{keyword}{false};
    $animate.removeClass($element, PRISTINE\_CLASS);
    $animate.addClass($element, DIRTY\_CLASS);
    parentForm.$setDirty();
  \};

  this.$setUntouched = \textcolor{keyword}{function}() \{
    ctrl.$touched = \textcolor{keyword}{false};
    ctrl.$untouched = \textcolor{keyword}{true};
    $animate.setClass($element, UNTOUCHED\_CLASS, TOUCHED\_CLASS);
  \};

  this.$setTouched = \textcolor{keyword}{function}() \{
    ctrl.$touched = \textcolor{keyword}{true};
    ctrl.$untouched = \textcolor{keyword}{false};
    $animate.setClass($element, TOUCHED\_CLASS, UNTOUCHED\_CLASS);
  \};

  this.$rollbackViewValue = \textcolor{keyword}{function}() \{
    $timeout.cancel(pendingDebounce);
    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
    ctrl.$render();
  \};

  this.$validate = \textcolor{keyword}{function}() \{
    \textcolor{comment}{// ignore $validate before model is initialized}
    \textcolor{keywordflow}{if} (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) \{
      \textcolor{keywordflow}{return};
    \}

    var viewValue = ctrl.$$lastCommittedViewValue;
    \textcolor{comment}{// Note: we use the $$rawModelValue as $modelValue might have been}
    \textcolor{comment}{// set to undefined during a view -> model update that found validation}
    \textcolor{comment}{// errors. We can't parse the view here, since that could change}
    \textcolor{comment}{// the model although neither viewValue nor the model on the scope changed}
    var modelValue = ctrl.$$rawModelValue;

    var prevValid = ctrl.$valid;
    var prevModelValue = ctrl.$modelValue;

    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;

    ctrl.$$runValidators(modelValue, viewValue, \textcolor{keyword}{function}(allValid) \{
      \textcolor{comment}{// If there was no change in validity, don't update the model}
      \textcolor{comment}{// This prevents changing an invalid modelValue to undefined}
      \textcolor{keywordflow}{if} (!allowInvalid && prevValid !== allValid) \{
        \textcolor{comment}{// Note: Don't check ctrl.$valid here, as we could have}
        \textcolor{comment}{// external validators (e.g. calculated on the server),}
        \textcolor{comment}{// that just call $setValidity and need the model value}
        \textcolor{comment}{// to calculate their validity.}
        ctrl.$modelValue = allValid ? modelValue : undefined;

        \textcolor{keywordflow}{if} (ctrl.$modelValue !== prevModelValue) \{
          ctrl.$$writeModelToScope();
        \}
      \}
    \});

  \};

  this.$$runValidators = \textcolor{keyword}{function}(modelValue, viewValue, doneCallback) \{
    currentValidationRunId++;
    var localValidationRunId = currentValidationRunId;

    \textcolor{comment}{// check parser error}
    \textcolor{keywordflow}{if} (!processParseErrors()) \{
      validationDone(\textcolor{keyword}{false});
      \textcolor{keywordflow}{return};
    \}
    \textcolor{keywordflow}{if} (!processSyncValidators()) \{
      validationDone(\textcolor{keyword}{false});
      \textcolor{keywordflow}{return};
    \}
    processAsyncValidators();

    \textcolor{keyword}{function} processParseErrors() \{
      var errorKey = ctrl.$$parserName || \textcolor{stringliteral}{'parse'};
      \textcolor{keywordflow}{if} (parserValid === undefined) \{
        setValidity(errorKey, null);
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (!parserValid) \{
          forEach(ctrl.$validators, \textcolor{keyword}{function}(v, name) \{
            setValidity(name, null);
          \});
          forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(v, name) \{
            setValidity(name, null);
          \});
        \}
        \textcolor{comment}{// Set the parse error last, to prevent unsetting it, should a $validators key == parserName}
        setValidity(errorKey, parserValid);
        \textcolor{keywordflow}{return} parserValid;
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} processSyncValidators() \{
      var syncValidatorsValid = \textcolor{keyword}{true};
      forEach(ctrl.$validators, \textcolor{keyword}{function}(validator, name) \{
        var result = validator(modelValue, viewValue);
        syncValidatorsValid = syncValidatorsValid && result;
        setValidity(name, result);
      \});
      \textcolor{keywordflow}{if} (!syncValidatorsValid) \{
        forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(v, name) \{
          setValidity(name, null);
        \});
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}

    \textcolor{keyword}{function} processAsyncValidators() \{
      var validatorPromises = [];
      var allValid = \textcolor{keyword}{true};
      forEach(ctrl.$asyncValidators, \textcolor{keyword}{function}(validator, name) \{
        var promise = validator(modelValue, viewValue);
        if (!isPromiseLike(promise)) \{
          throw ngModelMinErr(\textcolor{stringliteral}{"$asyncValidators"},
            \textcolor{stringliteral}{"Expected asynchronous validator to return a promise but got '\{0\}' instead."}, promise);
        \}
        setValidity(name, undefined);
        validatorPromises.push(promise.then(\textcolor{keyword}{function}() \{
          setValidity(name, true);
        \}, \textcolor{keyword}{function}(error) \{
          allValid = false;
          setValidity(name, false);
        \}));
      \});
      \textcolor{keywordflow}{if} (!validatorPromises.length) \{
        validationDone(\textcolor{keyword}{true});
      \} \textcolor{keywordflow}{else} \{
        $q.all(validatorPromises).then(\textcolor{keyword}{function}() \{
          validationDone(allValid);
        \}, noop);
      \}
    \}

    \textcolor{keyword}{function} setValidity(name, isValid) \{
      \textcolor{keywordflow}{if} (localValidationRunId === currentValidationRunId) \{
        ctrl.$setValidity(name, isValid);
      \}
    \}

    \textcolor{keyword}{function} validationDone(allValid) \{
      \textcolor{keywordflow}{if} (localValidationRunId === currentValidationRunId) \{

        doneCallback(allValid);
      \}
    \}
  \};

  this.$commitViewValue = \textcolor{keyword}{function}() \{
    var viewValue = ctrl.$viewValue;

    $timeout.cancel(pendingDebounce);

    \textcolor{comment}{// If the view value has not changed then we should just exit, except in the case where there is}
    \textcolor{comment}{// a native validator on the element. In this case the validation state may have changed even though}
    \textcolor{comment}{// the viewValue has stayed empty.}
    \textcolor{keywordflow}{if} (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== \textcolor{stringliteral}{''} || !ctrl.$$hasNativeValidators)) \{
      \textcolor{keywordflow}{return};
    \}
    ctrl.$$lastCommittedViewValue = viewValue;

    \textcolor{comment}{// change to dirty}
    \textcolor{keywordflow}{if} (ctrl.$pristine) \{
      this.$setDirty();
    \}
    this.$$parseAndValidate();
  \};

  this.$$parseAndValidate = \textcolor{keyword}{function}() \{
    var viewValue = ctrl.$$lastCommittedViewValue;
    var modelValue = viewValue;
    parserValid = isUndefined(modelValue) ? undefined : \textcolor{keyword}{true};

    \textcolor{keywordflow}{if} (parserValid) \{
      \textcolor{keywordflow}{for} (var i = 0; i < ctrl.$parsers.length; i++) \{
        modelValue = ctrl.$parsers[i](modelValue);
        \textcolor{keywordflow}{if} (isUndefined(modelValue)) \{
          parserValid = \textcolor{keyword}{false};
          \textcolor{keywordflow}{break};
        \}
      \}
    \}
    \textcolor{keywordflow}{if} (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) \{
      \textcolor{comment}{// ctrl.$modelValue has not been touched yet...}
      ctrl.$modelValue = ngModelGet($scope);
    \}
    var prevModelValue = ctrl.$modelValue;
    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
    ctrl.$$rawModelValue = modelValue;

    \textcolor{keywordflow}{if} (allowInvalid) \{
      ctrl.$modelValue = modelValue;
      writeToModelIfNeeded();
    \}

    \textcolor{comment}{// Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.}
    \textcolor{comment}{// This can happen if e.g. $setViewValue is called from inside a parser}
    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, \textcolor{keyword}{function}(allValid) \{
      if (!allowInvalid) \{
        \textcolor{comment}{// Note: Don't check ctrl.$valid here, as we could have}
        \textcolor{comment}{// external validators (e.g. calculated on the server),}
        \textcolor{comment}{// that just call $setValidity and need the model value}
        \textcolor{comment}{// to calculate their validity.}
        ctrl.$modelValue = allValid ? modelValue : undefined;
        writeToModelIfNeeded();
      \}
    \});

    \textcolor{keyword}{function} writeToModelIfNeeded() \{
      \textcolor{keywordflow}{if} (ctrl.$modelValue !== prevModelValue) \{
        ctrl.$$writeModelToScope();
      \}
    \}
  \};

  this.$$writeModelToScope = \textcolor{keyword}{function}() \{
    ngModelSet($scope, ctrl.$modelValue);
    forEach(ctrl.$viewChangeListeners, \textcolor{keyword}{function}(listener) \{
      try \{
        listener();
      \} catch (e) \{
        $exceptionHandler(e);
      \}
    \});
  \};

  this.$setViewValue = \textcolor{keyword}{function}(value, trigger) \{
    ctrl.$viewValue = value;
    \textcolor{keywordflow}{if} (!ctrl.$options || ctrl.$options.updateOnDefault) \{
      ctrl.$$debounceViewValueCommit(trigger);
    \}
  \};

  this.$$debounceViewValueCommit = \textcolor{keyword}{function}(trigger) \{
    var debounceDelay = 0,
        options = ctrl.$options,
        debounce;

    \textcolor{keywordflow}{if} (options && isDefined(options.debounce)) \{
      debounce = options.debounce;
      \textcolor{keywordflow}{if} (isNumber(debounce)) \{
        debounceDelay = debounce;
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isNumber(debounce[trigger])) \{
        debounceDelay = debounce[trigger];
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isNumber(debounce[\textcolor{stringliteral}{'default'}])) \{
        debounceDelay = debounce[\textcolor{stringliteral}{'default'}];
      \}
    \}

    $timeout.cancel(pendingDebounce);
    \textcolor{keywordflow}{if} (debounceDelay) \{
      pendingDebounce = $timeout(\textcolor{keyword}{function}() \{
        ctrl.$commitViewValue();
      \}, debounceDelay);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ($rootScope.$$phase) \{
      ctrl.$commitViewValue();
    \} \textcolor{keywordflow}{else} \{
      $scope.$apply(\textcolor{keyword}{function}() \{
        ctrl.$commitViewValue();
      \});
    \}
  \};

  \textcolor{comment}{// model -> value}
  \textcolor{comment}{// Note: we cannot use a normal scope.$watch as we want to detect the following:}
  \textcolor{comment}{// 1. scope value is 'a'}
  \textcolor{comment}{// 2. user enters 'b'}
  \textcolor{comment}{// 3. ng-change kicks in and reverts scope value to 'a'}
  \textcolor{comment}{//    -> scope value did not change since the last digest as}
  \textcolor{comment}{//       ng-change executes in apply phase}
  \textcolor{comment}{// 4. view should be changed back to 'a'}
  $scope.$watch(\textcolor{keyword}{function} ngModelWatch() \{
    var modelValue = ngModelGet($scope);

    \textcolor{comment}{// if scope model value and ngModel value are out of sync}
    \textcolor{comment}{// TODO(perf): why not move this to the action fn?}
    \textcolor{keywordflow}{if} (modelValue !== ctrl.$modelValue &&
       \textcolor{comment}{// checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator}
       (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
    ) \{
      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
      parserValid = undefined;

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      var viewValue = modelValue;
      \textcolor{keywordflow}{while} (idx--) \{
        viewValue = formatters[idx](viewValue);
      \}
      \textcolor{keywordflow}{if} (ctrl.$viewValue !== viewValue) \{
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
        ctrl.$render();

        ctrl.$$runValidators(modelValue, viewValue, noop);
      \}
    \}

    \textcolor{keywordflow}{return} modelValue;
  \});
\}];


var ngModelDirective = [\textcolor{stringliteral}{'$rootScope'}, \textcolor{keyword}{function}($rootScope) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: [\textcolor{stringliteral}{'ngModel'}, \textcolor{stringliteral}{'^?form'}, \textcolor{stringliteral}{'^?ngModelOptions'}],
    controller: NgModelController,
    \textcolor{comment}{// Prelink needs to run before any input directive}
    \textcolor{comment}{// so that we can set the NgModelOptions in NgModelController}
    \textcolor{comment}{// before anyone else uses it.}
    priority: 1,
    compile: \textcolor{keyword}{function} ngModelCompile(element) \{
      \textcolor{comment}{// Setup initial state of the control}
      element.addClass(PRISTINE\_CLASS).addClass(UNTOUCHED\_CLASS).addClass(VALID\_CLASS);

      \textcolor{keywordflow}{return} \{
        pre: \textcolor{keyword}{function} ngModelPreLink(scope, element, attr, ctrls) \{
          var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || nullFormCtrl;

          modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);

          \textcolor{comment}{// notify others, especially parent forms}
          formCtrl.$addControl(modelCtrl);

          attr.$observe(\textcolor{stringliteral}{'name'}, \textcolor{keyword}{function}(newValue) \{
            \textcolor{keywordflow}{if} (modelCtrl.$name !== newValue) \{
              formCtrl.$$renameControl(modelCtrl, newValue);
            \}
          \});

          scope.$on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
            formCtrl.$removeControl(modelCtrl);
          \});
        \},
        post: \textcolor{keyword}{function} ngModelPostLink(scope, element, attr, ctrls) \{
          var modelCtrl = ctrls[0];
          \textcolor{keywordflow}{if} (modelCtrl.$options && modelCtrl.$options.updateOn) \{
            element.on(modelCtrl.$options.updateOn, \textcolor{keyword}{function}(ev) \{
              modelCtrl.$$debounceViewValueCommit(ev && ev.type);
            \});
          \}

          element.on(\textcolor{stringliteral}{'blur'}, \textcolor{keyword}{function}(ev) \{
            \textcolor{keywordflow}{if} (modelCtrl.$touched) \textcolor{keywordflow}{return};

            if ($rootScope.$$phase) \{
              scope.$evalAsync(modelCtrl.$setTouched);
            \} \textcolor{keywordflow}{else} \{
              scope.$apply(modelCtrl.$setTouched);
            \}
          \});
        \}
      \};
    \}
  \};
\}];

var DEFAULT\_REGEXP = /(\(\backslash\)s+|^)\textcolor{keywordflow}{default}(\(\backslash\)s+|$)/;

var ngModelOptionsDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    controller: [\textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{keyword}{function}($scope, $attrs) \{
      var that = \textcolor{keyword}{this};
      this.$options = copy($scope.$eval($attrs.ngModelOptions));
      \textcolor{comment}{// Allow adding/overriding bound events}
      \textcolor{keywordflow}{if} (this.$options.updateOn !== undefined) \{
        this.$options.updateOnDefault = \textcolor{keyword}{false};
        \textcolor{comment}{// extract "default" pseudo-event from list of events that can trigger a model update}
        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT\_REGEXP, \textcolor{keyword}{function}() \{
          that.$options.updateOnDefault = true;
          return \textcolor{stringliteral}{' '};
        \}));
      \} \textcolor{keywordflow}{else} \{
        this.$options.updateOnDefault = \textcolor{keyword}{true};
      \}
    \}]
  \};
\};



\textcolor{comment}{// helper methods}
\textcolor{keyword}{function} addSetValidityMethod(context) \{
  var ctrl = context.ctrl,
      $element = context.$element,
      classCache = \{\},
      set = context.set,
      unset = context.unset,
      parentForm = context.parentForm,
      $animate = context.$animate;

  classCache[INVALID\_CLASS] = !(classCache[VALID\_CLASS] = $element.hasClass(VALID\_CLASS));

  ctrl.$setValidity = setValidity;

  \textcolor{keyword}{function} setValidity(validationErrorKey, state, controller) \{
    \textcolor{keywordflow}{if} (state === undefined) \{
      createAndSet(\textcolor{stringliteral}{'$pending'}, validationErrorKey, controller);
    \} \textcolor{keywordflow}{else} \{
      unsetAndCleanup(\textcolor{stringliteral}{'$pending'}, validationErrorKey, controller);
    \}
    \textcolor{keywordflow}{if} (!isBoolean(state)) \{
      unset(ctrl.$error, validationErrorKey, controller);
      unset(ctrl.$$success, validationErrorKey, controller);
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (state) \{
        unset(ctrl.$error, validationErrorKey, controller);
        set(ctrl.$$success, validationErrorKey, controller);
      \} \textcolor{keywordflow}{else} \{
        set(ctrl.$error, validationErrorKey, controller);
        unset(ctrl.$$success, validationErrorKey, controller);
      \}
    \}
    \textcolor{keywordflow}{if} (ctrl.$pending) \{
      cachedToggleClass(PENDING\_CLASS, \textcolor{keyword}{true});
      ctrl.$valid = ctrl.$invalid = undefined;
      toggleValidationCss(\textcolor{stringliteral}{''}, null);
    \} \textcolor{keywordflow}{else} \{
      cachedToggleClass(PENDING\_CLASS, \textcolor{keyword}{false});
      ctrl.$valid = isObjectEmpty(ctrl.$error);
      ctrl.$invalid = !ctrl.$valid;
      toggleValidationCss(\textcolor{stringliteral}{''}, ctrl.$valid);
    \}

    \textcolor{comment}{// re-read the state as the set/unset methods could have}
    \textcolor{comment}{// combined state in ctrl.$error[validationError] (used for forms),}
    \textcolor{comment}{// where setting/unsetting only increments/decrements the value,}
    \textcolor{comment}{// and does not replace it.}
    var combinedState;
    \textcolor{keywordflow}{if} (ctrl.$pending && ctrl.$pending[validationErrorKey]) \{
      combinedState = undefined;
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ctrl.$error[validationErrorKey]) \{
      combinedState = \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ctrl.$$success[validationErrorKey]) \{
      combinedState = \textcolor{keyword}{true};
    \} \textcolor{keywordflow}{else} \{
      combinedState = null;
    \}

    toggleValidationCss(validationErrorKey, combinedState);
    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
  \}

  \textcolor{keyword}{function} createAndSet(name, value, controller) \{
    \textcolor{keywordflow}{if} (!ctrl[name]) \{
      ctrl[name] = \{\};
    \}
    set(ctrl[name], value, controller);
  \}

  \textcolor{keyword}{function} unsetAndCleanup(name, value, controller) \{
    \textcolor{keywordflow}{if} (ctrl[name]) \{
      unset(ctrl[name], value, controller);
    \}
    \textcolor{keywordflow}{if} (isObjectEmpty(ctrl[name])) \{
      ctrl[name] = undefined;
    \}
  \}

  \textcolor{keyword}{function} cachedToggleClass(className, switchValue) \{
    \textcolor{keywordflow}{if} (switchValue && !classCache[className]) \{
      $animate.addClass($element, className);
      classCache[className] = \textcolor{keyword}{true};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!switchValue && classCache[className]) \{
      $animate.removeClass($element, className);
      classCache[className] = \textcolor{keyword}{false};
    \}
  \}

  \textcolor{keyword}{function} toggleValidationCss(validationErrorKey, isValid) \{
    validationErrorKey = validationErrorKey ? \textcolor{charliteral}{'-'} + snake\_case(validationErrorKey, \textcolor{charliteral}{'-'}) : \textcolor{stringliteral}{''};

    cachedToggleClass(VALID\_CLASS + validationErrorKey, isValid === \textcolor{keyword}{true});
    cachedToggleClass(INVALID\_CLASS + validationErrorKey, isValid === \textcolor{keyword}{false});
  \}
\}

\textcolor{keyword}{function} isObjectEmpty(obj) \{
  \textcolor{keywordflow}{if} (obj) \{
    \textcolor{keywordflow}{for} (var prop in obj) \{
      \textcolor{keywordflow}{if} (obj.hasOwnProperty(prop)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
    \}
  \}
  \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\}

var ngNonBindableDirective = ngDirective(\{ terminal: \textcolor{keyword}{true}, priority: 1000 \});

\textcolor{comment}{/* global jqLiteRemove */}

var ngOptionsMinErr = minErr(\textcolor{stringliteral}{'ngOptions'});

\textcolor{comment}{// jshint maxlen: false}
\textcolor{comment}{//                    
       //00001111111111000000000002222222222000000000000000000000333333333300000000000000000
      000000004444444444400000000000005555555555555550000000006666666666666660000000777777777777777000000000000000888888888800000000000000000009999999999}
var NG\_OPTIONS\_REGEXP = /^\(\backslash\)s*([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+as\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+group\(\backslash\)s+by\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+disable\(\backslash\)
      s+when\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?\(\backslash\)s+\textcolor{keywordflow}{for}\(\backslash\)s+(?:([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)|(?:\(\backslash\)(\(\backslash\)s*([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)\(\backslash\)s*,\(\backslash\)s*([\(\backslash\)$\(\backslash\)w][\(\backslash\)$\(\backslash\)w]*)\(\backslash\)s*\(\backslash\))))\(\backslash\)s+in\(\backslash\)s
      +([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+track\(\backslash\)s+by\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?$/;
                        \textcolor{comment}{// 1: value expression (valueFn)}
                        \textcolor{comment}{// 2: label expression (displayFn)}
                        \textcolor{comment}{// 3: group by expression (groupByFn)}
                        \textcolor{comment}{// 4: disable when expression (disableWhenFn)}
                        \textcolor{comment}{// 5: array item variable name}
                        \textcolor{comment}{// 6: object item key variable name}
                        \textcolor{comment}{// 7: object item value variable name}
                        \textcolor{comment}{// 8: collection expression}
                        \textcolor{comment}{// 9: track by expression}
\textcolor{comment}{// jshint maxlen: 100}


var ngOptionsDirective = [\textcolor{stringliteral}{'$compile'}, \textcolor{stringliteral}{'$parse'}, \textcolor{keyword}{function}($compile, $parse) \{

  \textcolor{keyword}{function} parseOptionsExpression(optionsExp, selectElement, scope) \{

    var match = optionsExp.match(NG\_OPTIONS\_REGEXP);
    \textcolor{keywordflow}{if} (!(match)) \{
      \textcolor{keywordflow}{throw} ngOptionsMinErr(\textcolor{stringliteral}{'iexp'},
        \textcolor{stringliteral}{"Expected expression in form of "} +
        \textcolor{stringliteral}{"'\_select\_ (as \_label\_)? for (\_key\_,)?\_value\_ in \_collection\_'"} +
        \textcolor{stringliteral}{" but got '\{0\}'. Element: \{1\}"},
        optionsExp, startingTag(selectElement));
    \}

    \textcolor{comment}{// Extract the parts from the ngOptions expression}

    \textcolor{comment}{// The variable name for the value of the item in the collection}
    var valueName = match[5] || match[7];
    \textcolor{comment}{// The variable name for the key of the item in the collection}
    var keyName = match[6];

    \textcolor{comment}{// An expression that generates the viewValue for an option if there is a label expression}
    var selectAs = / as /.test(match[0]) && match[1];
    \textcolor{comment}{// An expression that is used to track the id of each object in the options collection}
    var trackBy = match[9];
    \textcolor{comment}{// An expression that generates the viewValue for an option if there is no label expression}
    var valueFn = $parse(match[2] ? match[1] : valueName);
    var selectAsFn = selectAs && $parse(selectAs);
    var viewValueFn = selectAsFn || valueFn;
    var trackByFn = trackBy && $parse(trackBy);

    \textcolor{comment}{// Get the value by which we are going to track the option}
    \textcolor{comment}{// if we have a trackFn then use that (passing scope and locals)}
    \textcolor{comment}{// otherwise just hash the given viewValue}
    var getTrackByValueFn = trackBy ?
                              \textcolor{keyword}{function}(value, locals) \{ \textcolor{keywordflow}{return} trackByFn(scope, locals); \} :
                              \textcolor{keyword}{function} getHashOfValue(value) \{ \textcolor{keywordflow}{return} hashKey(value); \};
    var getTrackByValue = \textcolor{keyword}{function}(value, key) \{
      \textcolor{keywordflow}{return} getTrackByValueFn(value, getLocals(value, key));
    \};

    var displayFn = $parse(match[2] || match[1]);
    var groupByFn = $parse(match[3] || \textcolor{stringliteral}{''});
    var disableWhenFn = $parse(match[4] || \textcolor{stringliteral}{''});
    var valuesFn = $parse(match[8]);

    var locals = \{\};
    var getLocals = keyName ? \textcolor{keyword}{function}(value, key) \{
      locals[keyName] = key;
      locals[valueName] = value;
      \textcolor{keywordflow}{return} locals;
    \} : \textcolor{keyword}{function}(value) \{
      locals[valueName] = value;
      \textcolor{keywordflow}{return} locals;
    \};


    \textcolor{keyword}{function} Option(selectValue, viewValue, label, group, disabled) \{
      this.selectValue = selectValue;
      this.viewValue = viewValue;
      this.label = label;
      this.group = group;
      this.disabled = disabled;
    \}

    \textcolor{keyword}{function} getOptionValuesKeys(optionValues) \{
      var optionValuesKeys;

      \textcolor{keywordflow}{if} (!keyName && isArrayLike(optionValues)) \{
        optionValuesKeys = optionValues;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{comment}{// if object, extract keys, in enumeration order, unsorted}
        optionValuesKeys = [];
        \textcolor{keywordflow}{for} (var itemKey in optionValues) \{
          \textcolor{keywordflow}{if} (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== \textcolor{charliteral}{'$'}) \{
            optionValuesKeys.push(itemKey);
          \}
        \}
      \}
      \textcolor{keywordflow}{return} optionValuesKeys;
    \}

    \textcolor{keywordflow}{return} \{
      trackBy: trackBy,
      getTrackByValue: getTrackByValue,
      getWatchables: $parse(valuesFn, \textcolor{keyword}{function}(optionValues) \{
        \textcolor{comment}{// Create a collection of things that we would like to watch (watchedArray)}
        \textcolor{comment}{// so that they can all be watched using a single $watchCollection}
        \textcolor{comment}{// that only runs the handler once if anything changes}
        var watchedArray = [];
        optionValues = optionValues || [];

        var optionValuesKeys = getOptionValuesKeys(optionValues);
        var optionValuesLength = optionValuesKeys.length;
        \textcolor{keywordflow}{for} (var index = 0; index < optionValuesLength; index++) \{
          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
          var value = optionValues[key];

          var locals = getLocals(optionValues[key], key);
          var selectValue = getTrackByValueFn(optionValues[key], locals);
          watchedArray.push(selectValue);

          \textcolor{comment}{// Only need to watch the displayFn if there is a specific label expression}
          \textcolor{keywordflow}{if} (match[2] || match[1]) \{
            var label = displayFn(scope, locals);
            watchedArray.push(label);
          \}

          \textcolor{comment}{// Only need to watch the disableWhenFn if there is a specific disable expression}
          \textcolor{keywordflow}{if} (match[4]) \{
            var disableWhen = disableWhenFn(scope, locals);
            watchedArray.push(disableWhen);
          \}
        \}
        \textcolor{keywordflow}{return} watchedArray;
      \}),

      getOptions: \textcolor{keyword}{function}() \{

        var optionItems = [];
        var selectValueMap = \{\};

        \textcolor{comment}{// The option values were already computed in the `getWatchables` fn,}
        \textcolor{comment}{// which must have been called to trigger `getOptions`}
        var optionValues = valuesFn(scope) || [];
        var optionValuesKeys = getOptionValuesKeys(optionValues);
        var optionValuesLength = optionValuesKeys.length;

        \textcolor{keywordflow}{for} (var index = 0; index < optionValuesLength; index++) \{
          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
          var value = optionValues[key];
          var locals = getLocals(value, key);
          var viewValue = viewValueFn(scope, locals);
          var selectValue = getTrackByValueFn(viewValue, locals);
          var label = displayFn(scope, locals);
          var group = groupByFn(scope, locals);
          var disabled = disableWhenFn(scope, locals);
          var optionItem = \textcolor{keyword}{new} Option(selectValue, viewValue, label, group, disabled);

          optionItems.push(optionItem);
          selectValueMap[selectValue] = optionItem;
        \}

        \textcolor{keywordflow}{return} \{
          items: optionItems,
          selectValueMap: selectValueMap,
          getOptionFromViewValue: \textcolor{keyword}{function}(value) \{
            \textcolor{keywordflow}{return} selectValueMap[getTrackByValue(value)];
          \},
          getViewValueFromOption: \textcolor{keyword}{function}(option) \{
            \textcolor{comment}{// If the viewValue could be an object that may be mutated by the application,}
            \textcolor{comment}{// we need to make a copy and not return the reference to the value on the option.}
            \textcolor{keywordflow}{return} trackBy ? angular.copy(option.viewValue) : option.viewValue;
          \}
        \};
      \}
    \};
  \}


  \textcolor{comment}{// we can't just jqLite('<option>') since jqLite is not smart enough}
  \textcolor{comment}{// to create it in <select> and IE barfs otherwise.}
  var optionTemplate = document.createElement(\textcolor{stringliteral}{'option'}),
      optGroupTemplate = document.createElement(\textcolor{stringliteral}{'optgroup'});

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    terminal: \textcolor{keyword}{true},
    require: [\textcolor{stringliteral}{'select'}, \textcolor{stringliteral}{'?ngModel'}],
    link: \textcolor{keyword}{function}(scope, selectElement, attr, ctrls) \{

      \textcolor{comment}{// if ngModel is not defined, we don't need to do anything}
      var ngModelCtrl = ctrls[1];
      \textcolor{keywordflow}{if} (!ngModelCtrl) \textcolor{keywordflow}{return};

      var selectCtrl = ctrls[0];
      var multiple = attr.multiple;

      \textcolor{comment}{// The emptyOption allows the application developer to provide their own custom "empty"}
      \textcolor{comment}{// option when the viewValue does not match any of the option values.}
      var emptyOption;
      \textcolor{keywordflow}{for} (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) \{
        \textcolor{keywordflow}{if} (children[i].value === \textcolor{stringliteral}{''}) \{
          emptyOption = children.eq(i);
          \textcolor{keywordflow}{break};
        \}
      \}

      var providedEmptyOption = !!emptyOption;

      var unknownOption = jqLite(optionTemplate.cloneNode(\textcolor{keyword}{false}));
      unknownOption.val(\textcolor{charliteral}{'?'});

      var options;
      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);


      var renderEmptyOption = \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!providedEmptyOption) \{
          selectElement.prepend(emptyOption);
        \}
        selectElement.val(\textcolor{stringliteral}{''});
        emptyOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// needed for IE}
        emptyOption.attr(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true});
      \};

      var removeEmptyOption = \textcolor{keyword}{function}() \{
        \textcolor{keywordflow}{if} (!providedEmptyOption) \{
          emptyOption.remove();
        \}
      \};


      var renderUnknownOption = \textcolor{keyword}{function}() \{
        selectElement.prepend(unknownOption);
        selectElement.val(\textcolor{charliteral}{'?'});
        unknownOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// needed for IE}
        unknownOption.attr(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true});
      \};

      var removeUnknownOption = \textcolor{keyword}{function}() \{
        unknownOption.remove();
      \};


      \textcolor{comment}{// Update the controller methods for multiple selectable options}
      \textcolor{keywordflow}{if} (!multiple) \{

        selectCtrl.writeValue = \textcolor{keyword}{function} writeNgOptionsValue(value) \{
          var option = options.getOptionFromViewValue(value);

          \textcolor{keywordflow}{if} (option && !option.disabled) \{
            \textcolor{keywordflow}{if} (selectElement[0].value !== option.selectValue) \{
              removeUnknownOption();
              removeEmptyOption();

              selectElement[0].value = option.selectValue;
              option.element.selected = \textcolor{keyword}{true};
              option.element.setAttribute(\textcolor{stringliteral}{'selected'}, \textcolor{stringliteral}{'selected'});
            \}
          \} \textcolor{keywordflow}{else} \{
            \textcolor{keywordflow}{if} (value === null || providedEmptyOption) \{
              removeUnknownOption();
              renderEmptyOption();
            \} \textcolor{keywordflow}{else} \{
              removeEmptyOption();
              renderUnknownOption();
            \}
          \}
        \};

        selectCtrl.readValue = \textcolor{keyword}{function} readNgOptionsValue() \{

          var selectedOption = options.selectValueMap[selectElement.val()];

          \textcolor{keywordflow}{if} (selectedOption && !selectedOption.disabled) \{
            removeEmptyOption();
            removeUnknownOption();
            \textcolor{keywordflow}{return} options.getViewValueFromOption(selectedOption);
          \}
          \textcolor{keywordflow}{return} null;
        \};

        \textcolor{comment}{// If we are using `track by` then we must watch the tracked value on the model}
        \textcolor{comment}{// since ngModel only watches for object identity change}
        \textcolor{keywordflow}{if} (ngOptions.trackBy) \{
          scope.$watch(
            \textcolor{keyword}{function}() \{ \textcolor{keywordflow}{return} ngOptions.getTrackByValue(ngModelCtrl.$viewValue); \},
            \textcolor{keyword}{function}() \{ ngModelCtrl.$render(); \}
          );
        \}

      \} \textcolor{keywordflow}{else} \{

        ngModelCtrl.$isEmpty = \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} !value || value.length === 0;
        \};


        selectCtrl.writeValue = \textcolor{keyword}{function} writeNgOptionsMultiple(value) \{
          options.items.forEach(\textcolor{keyword}{function}(option) \{
            option.element.selected = \textcolor{keyword}{false};
          \});

          \textcolor{keywordflow}{if} (value) \{
            value.forEach(\textcolor{keyword}{function}(item) \{
              var option = options.getOptionFromViewValue(item);
              \textcolor{keywordflow}{if} (option && !option.disabled) option.element.selected = \textcolor{keyword}{true};
            \});
          \}
        \};


        selectCtrl.readValue = \textcolor{keyword}{function} readNgOptionsMultiple() \{
          var selectedValues = selectElement.val() || [],
              selections = [];

          forEach(selectedValues, \textcolor{keyword}{function}(value) \{
            var option = options.selectValueMap[value];
            \textcolor{keywordflow}{if} (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
          \});

          \textcolor{keywordflow}{return} selections;
        \};

        \textcolor{comment}{// If we are using `track by` then we must watch these tracked values on the model}
        \textcolor{comment}{// since ngModel only watches for object identity change}
        \textcolor{keywordflow}{if} (ngOptions.trackBy) \{

          scope.$watchCollection(\textcolor{keyword}{function}() \{
            \textcolor{keywordflow}{if} (isArray(ngModelCtrl.$viewValue)) \{
              return ngModelCtrl.$viewValue.map(function(value) \{
                return ngOptions.getTrackByValue(value);
              \});
            \}
          \}, \textcolor{keyword}{function}() \{
            ngModelCtrl.$render();
          \});

        \}
      \}


      \textcolor{keywordflow}{if} (providedEmptyOption) \{

        \textcolor{comment}{// we need to remove it before calling selectElement.empty() because otherwise IE will}
        \textcolor{comment}{// remove the label from the element. wtf?}
        emptyOption.remove();

        \textcolor{comment}{// compile the element since there might be bindings in it}
        $compile(emptyOption)(scope);

        \textcolor{comment}{// remove the class, which is added automatically because we recompile the element and it}
        \textcolor{comment}{// becomes the compilation root}
        emptyOption.removeClass(\textcolor{stringliteral}{'ng-scope'});
      \} \textcolor{keywordflow}{else} \{
        emptyOption = jqLite(optionTemplate.cloneNode(\textcolor{keyword}{false}));
      \}

      \textcolor{comment}{// We need to do this here to ensure that the options object is defined}
      \textcolor{comment}{// when we first hit it in writeNgOptionsValue}
      updateOptions();

      \textcolor{comment}{// We will re-render the option elements if the option values or labels change}
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);

      \textcolor{comment}{// ------------------------------------------------------------------ //}


      \textcolor{keyword}{function} updateOptionElement(option, element) \{
        option.element = element;
        element.disabled = option.disabled;
        \textcolor{keywordflow}{if} (option.value !== element.value) element.value = option.selectValue;
        \textcolor{keywordflow}{if} (option.label !== element.label) \{
          element.label = option.label;
          element.textContent = option.label;
        \}
      \}

      \textcolor{keyword}{function} addOrReuseElement(parent, current, type, templateElement) \{
        var element;
        \textcolor{comment}{// Check whether we can reuse the next element}
        \textcolor{keywordflow}{if} (current && lowercase(current.nodeName) === type) \{
          \textcolor{comment}{// The next element is the right type so reuse it}
          element = current;
        \} \textcolor{keywordflow}{else} \{
          \textcolor{comment}{// The next element is not the right type so create a new one}
          element = templateElement.cloneNode(\textcolor{keyword}{false});
          \textcolor{keywordflow}{if} (!current) \{
            \textcolor{comment}{// There are no more elements so just append it to the select}
            parent.appendChild(element);
          \} \textcolor{keywordflow}{else} \{
            \textcolor{comment}{// The next element is not a group so insert the new one}
            parent.insertBefore(element, current);
          \}
        \}
        \textcolor{keywordflow}{return} element;
      \}


      \textcolor{keyword}{function} removeExcessElements(current) \{
        var next;
        \textcolor{keywordflow}{while} (current) \{
          next = current.nextSibling;
          jqLiteRemove(current);
          current = next;
        \}
      \}


      \textcolor{keyword}{function} skipEmptyAndUnknownOptions(current) \{
        var emptyOption\_ = emptyOption && emptyOption[0];
        var unknownOption\_ = unknownOption && unknownOption[0];

        \textcolor{keywordflow}{if} (emptyOption\_ || unknownOption\_) \{
          \textcolor{keywordflow}{while} (current &&
                (current === emptyOption\_ ||
                current === unknownOption\_)) \{
            current = current.nextSibling;
          \}
        \}
        \textcolor{keywordflow}{return} current;
      \}


      \textcolor{keyword}{function} updateOptions() \{

        var previousValue = options && selectCtrl.readValue();

        options = ngOptions.getOptions();

        var groupMap = \{\};
        var currentElement = selectElement[0].firstChild;

        \textcolor{comment}{// Ensure that the empty option is always there if it was explicitly provided}
        \textcolor{keywordflow}{if} (providedEmptyOption) \{
          selectElement.prepend(emptyOption);
        \}

        currentElement = skipEmptyAndUnknownOptions(currentElement);

        options.items.forEach(\textcolor{keyword}{function} updateOption(option) \{
          var group;
          var groupElement;
          var optionElement;

          \textcolor{keywordflow}{if} (option.group) \{

            \textcolor{comment}{// This option is to live in a group}
            \textcolor{comment}{// See if we have already created this group}
            group = groupMap[option.group];

            if (!group) \{

              \textcolor{comment}{// We have not already created this group}
              groupElement = addOrReuseElement(selectElement[0],
                                               currentElement,
                                               \textcolor{stringliteral}{'optgroup'},
                                               optGroupTemplate);
              \textcolor{comment}{// Move to the next element}
              currentElement = groupElement.nextSibling;

              \textcolor{comment}{// Update the label on the group element}
              groupElement.label = option.group;

              \textcolor{comment}{// Store it for use later}
              group = groupMap[option.group] = \{
                groupElement: groupElement,
                currentOptionElement: groupElement.firstChild
              \};

            \}

            \textcolor{comment}{// So now we have a group for this option we add the option to the group}
            optionElement = addOrReuseElement(group.groupElement,
                                              group.currentOptionElement,
                                              \textcolor{stringliteral}{'option'},
                                              optionTemplate);
            updateOptionElement(option, optionElement);
            \textcolor{comment}{// Move to the next element}
            group.currentOptionElement = optionElement.nextSibling;

          \} \textcolor{keywordflow}{else} \{

            \textcolor{comment}{// This option is not in a group}
            optionElement = addOrReuseElement(selectElement[0],
                                              currentElement,
                                              \textcolor{stringliteral}{'option'},
                                              optionTemplate);
            updateOptionElement(option, optionElement);
            \textcolor{comment}{// Move to the next element}
            currentElement = optionElement.nextSibling;
          \}
        \});


        \textcolor{comment}{// Now remove all excess options and group}
        Object.keys(groupMap).forEach(\textcolor{keyword}{function}(key) \{
          removeExcessElements(groupMap[key].currentOptionElement);
        \});
        removeExcessElements(currentElement);

        ngModelCtrl.$render();

        \textcolor{comment}{// Check to see if the value has changed due to the update to the options}
        \textcolor{keywordflow}{if} (!ngModelCtrl.$isEmpty(previousValue)) \{
          var nextValue = selectCtrl.readValue();
          \textcolor{keywordflow}{if} (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) \{
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          \}
        \}

      \}

    \}
  \};
\}];

var ngPluralizeDirective = [\textcolor{stringliteral}{'$locale'}, \textcolor{stringliteral}{'$interpolate'}, \textcolor{stringliteral}{'$log'}, \textcolor{keyword}{function}($locale, $interpolate, $log) \{
  var BRACE = /\{\}/g,
      IS\_WHEN = /^when(Minus)?(.+)$/;

  \textcolor{keywordflow}{return} \{
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when), \textcolor{comment}{// we have \{\{\}\} in attrs}
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || \{\},
          whensExpFns = \{\},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          braceReplacement = startSymbol + numberExp + \textcolor{charliteral}{'-'} + offset + endSymbol,
          watchRemover = angular.noop,
          lastCount;

      forEach(attr, \textcolor{keyword}{function}(expression, attributeName) \{
        var tmpMatch = IS\_WHEN.exec(attributeName);
        \textcolor{keywordflow}{if} (tmpMatch) \{
          var whenKey = (tmpMatch[1] ? \textcolor{charliteral}{'-'} : \textcolor{stringliteral}{''}) + lowercase(tmpMatch[2]);
          whens[whenKey] = element.attr(attr.$attr[attributeName]);
        \}
      \});
      forEach(whens, \textcolor{keyword}{function}(expression, key) \{
        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));

      \});

      scope.$watch(numberExp, \textcolor{keyword}{function} ngPluralizeWatchAction(newVal) \{
        var count = parseFloat(newVal);
        var countIsNaN = isNaN(count);

        \textcolor{keywordflow}{if} (!countIsNaN && !(count in whens)) \{
          \textcolor{comment}{// If an explicit number rule such as 1, 2, 3... is defined, just use it.}
          \textcolor{comment}{// Otherwise, check it against pluralization rules in $locale service.}
          count = $locale.pluralCat(count - offset);
        \}

        \textcolor{comment}{// If both `count` and `lastCount` are NaN, we don't need to re-register a watch.}
        \textcolor{comment}{// In JS `NaN !== NaN`, so we have to exlicitly check.}
        \textcolor{keywordflow}{if} ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) \{
          watchRemover();
          var whenExpFn = whensExpFns[count];
          \textcolor{keywordflow}{if} (isUndefined(whenExpFn)) \{
            \textcolor{keywordflow}{if} (newVal != null) \{
              $log.debug(\textcolor{stringliteral}{"ngPluralize: no rule defined for '"} + count + \textcolor{stringliteral}{"' in "} + whenExp);
            \}
            watchRemover = noop;
            updateElementText();
          \} \textcolor{keywordflow}{else} \{
            watchRemover = scope.$watch(whenExpFn, updateElementText);
          \}
          lastCount = count;
        \}
      \});

      \textcolor{keyword}{function} updateElementText(newText) \{
        element.text(newText || \textcolor{stringliteral}{''});
      \}
    \}
  \};
\}];

var ngRepeatDirective = [\textcolor{stringliteral}{'$parse'}, \textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($parse, $animate) \{
  var NG\_REMOVED = \textcolor{stringliteral}{'$$NG\_REMOVED'};
  var ngRepeatMinErr = minErr(\textcolor{stringliteral}{'ngRepeat'});

  var updateScope = \textcolor{keyword}{function}(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) \{
    \textcolor{comment}{// TODO(perf): generate setters to shave off ~40ms or 1-1.5%}
    scope[valueIdentifier] = value;
    \textcolor{keywordflow}{if} (keyIdentifier) scope[keyIdentifier] = key;
    scope.$index = index;
    scope.$first = (index === 0);
    scope.$last = (index === (arrayLength - 1));
    scope.$middle = !(scope.$first || scope.$last);
    \textcolor{comment}{// jshint bitwise: false}
    scope.$odd = !(scope.$even = (index&1) === 0);
    \textcolor{comment}{// jshint bitwise: true}
  \};

  var getBlockStart = \textcolor{keyword}{function}(block) \{
    \textcolor{keywordflow}{return} block.clone[0];
  \};

  var getBlockEnd = \textcolor{keyword}{function}(block) \{
    \textcolor{keywordflow}{return} block.clone[block.clone.length - 1];
  \};


  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    transclude: \textcolor{stringliteral}{'element'},
    priority: 1000,
    terminal: \textcolor{keyword}{true},
    $$tlb: \textcolor{keyword}{true},
    compile: \textcolor{keyword}{function} ngRepeatCompile($element, $attr) \{
      var expression = $attr.ngRepeat;
      var ngRepeatEndComment = document.createComment(\textcolor{stringliteral}{' end ngRepeat: '} + expression + \textcolor{charliteral}{' '});

      var match = expression.match(/^\(\backslash\)s*([\(\backslash\)s\(\backslash\)S]+?)\(\backslash\)s+in\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?)(?:\(\backslash\)s+as\(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?(?:\(\backslash\)s+track\(\backslash\)s+by
      \(\backslash\)s+([\(\backslash\)s\(\backslash\)S]+?))?\(\backslash\)s*$/);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'iexp'}, \textcolor{stringliteral}{"Expected expression in form of '\_item\_ in \_collection\_[ track by
       \_id\_]' but got '\{0\}'."},
            expression);
      \}

      var lhs = match[1];
      var rhs = match[2];
      var aliasAs = match[3];
      var trackByExp = match[4];

      match = lhs.match(/^(?:(\(\backslash\)s*[\(\backslash\)$\(\backslash\)w]+)|\(\backslash\)(\(\backslash\)s*([\(\backslash\)$\(\backslash\)w]+)\(\backslash\)s*,\(\backslash\)s*([\(\backslash\)$\(\backslash\)w]+)\(\backslash\)s*\(\backslash\)))$/);

      \textcolor{keywordflow}{if} (!match) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'iidexp'}, \textcolor{stringliteral}{"'\_item\_' in '\_item\_ in \_collection\_' should be an identifier or
       '(\_key\_, \_value\_)' expression, but got '\{0\}'."},
            lhs);
      \}
      var valueIdentifier = match[3] || match[1];
      var keyIdentifier = match[2];

      \textcolor{keywordflow}{if} (aliasAs && (!/^[$a-zA-Z\_][$a-zA-Z0-9\_]*$/.test(aliasAs) ||
          /^(null|undefined|\textcolor{keyword}{this}|\(\backslash\)$index|\(\backslash\)$first|\(\backslash\)$middle|\(\backslash\)$last|\(\backslash\)$even|\(\backslash\)$odd|\(\backslash\)$parent|\(\backslash\)$root|\(\backslash\)$id)$/.test(
      aliasAs))) \{
        \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'badident'}, \textcolor{stringliteral}{"alias '\{0\}' is invalid --- must be a valid JS identifier which is
       not a reserved name."},
          aliasAs);
      \}

      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
      var hashFnLocals = \{$id: hashKey\};

      \textcolor{keywordflow}{if} (trackByExp) \{
        trackByExpGetter = $parse(trackByExp);
      \} \textcolor{keywordflow}{else} \{
        trackByIdArrayFn = \textcolor{keyword}{function}(key, value) \{
          \textcolor{keywordflow}{return} hashKey(value);
        \};
        trackByIdObjFn = \textcolor{keyword}{function}(key) \{
          \textcolor{keywordflow}{return} key;
        \};
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function} ngRepeatLink($scope, $element, $attr, ctrl, $transclude) \{

        \textcolor{keywordflow}{if} (trackByExpGetter) \{
          trackByIdExpFn = \textcolor{keyword}{function}(key, value, index) \{
            \textcolor{comment}{// assign key, value, and $index to the locals so that they can be used in hash functions}
            \textcolor{keywordflow}{if} (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            \textcolor{keywordflow}{return} trackByExpGetter($scope, hashFnLocals);
          \};
        \}

        \textcolor{comment}{// Store a list of elements from previous run. This is a hash where key is the item from the}
        \textcolor{comment}{// iterator, and the value is objects with following properties.}
        \textcolor{comment}{//   - scope: bound scope}
        \textcolor{comment}{//   - element: previous element.}
        \textcolor{comment}{//   - index: position}
        \textcolor{comment}{//}
        \textcolor{comment}{// We are using no-proto object so that we don't need to guard against inherited props via}
        \textcolor{comment}{// hasOwnProperty.}
        var lastBlockMap = createMap();

        \textcolor{comment}{//watch props}
        $scope.$watchCollection(rhs, \textcolor{keyword}{function} ngRepeatAction(collection) \{
          var index, length,
              previousNode = $element[0],     \textcolor{comment}{// node that cloned nodes should be inserted after}
                                              \textcolor{comment}{// initialized to the comment node anchor}
              nextNode,
              \textcolor{comment}{// Same as lastBlockMap but it has the current state. It will become the}
              \textcolor{comment}{// lastBlockMap on the next iteration.}
              nextBlockMap = createMap(),
              collectionLength,
              key, value, \textcolor{comment}{// key/value of iteration}
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       \textcolor{comment}{// last object information \{scope, element, id\}}
              nextBlockOrder,
              elementsToRemove;

          \textcolor{keywordflow}{if} (aliasAs) \{
            $scope[aliasAs] = collection;
          \}

          \textcolor{keywordflow}{if} (isArrayLike(collection)) \{
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          \} \textcolor{keywordflow}{else} \{
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            \textcolor{comment}{// if object, extract keys, in enumeration order, unsorted}
            collectionKeys = [];
            \textcolor{keywordflow}{for} (var itemKey in collection) \{
              \textcolor{keywordflow}{if} (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== \textcolor{charliteral}{'$'}) \{
                collectionKeys.push(itemKey);
              \}
            \}
          \}

          collectionLength = collectionKeys.length;
          nextBlockOrder = \textcolor{keyword}{new} Array(collectionLength);

          \textcolor{comment}{// locate existing items}
          \textcolor{keywordflow}{for} (index = 0; index < collectionLength; index++) \{
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);
            \textcolor{keywordflow}{if} (lastBlockMap[trackById]) \{
              \textcolor{comment}{// found previously seen block}
              block = lastBlockMap[trackById];
              \textcolor{keyword}{delete} lastBlockMap[trackById];
              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextBlockMap[trackById]) \{
              \textcolor{comment}{// if collision detected. restore lastBlockMap and throw an error}
              forEach(nextBlockOrder, \textcolor{keyword}{function}(block) \{
                \textcolor{keywordflow}{if} (block && block.scope) lastBlockMap[block.id] = block;
              \});
              \textcolor{keywordflow}{throw} ngRepeatMinErr(\textcolor{stringliteral}{'dupes'},
                  \textcolor{stringliteral}{"Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique
       keys. Repeater: \{0\}, Duplicate key: \{1\}, Duplicate value: \{2\}"},
                  expression, trackById, value);
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// new never before seen block}
              nextBlockOrder[index] = \{\textcolor{keywordtype}{id}: trackById, scope: undefined, clone: undefined\};
              nextBlockMap[trackById] = \textcolor{keyword}{true};
            \}
          \}

          \textcolor{comment}{// remove leftover items}
          \textcolor{keywordflow}{for} (var blockKey in lastBlockMap) \{
            block = lastBlockMap[blockKey];
            elementsToRemove = getBlockNodes(block.clone);
            $animate.leave(elementsToRemove);
            \textcolor{keywordflow}{if} (elementsToRemove[0].parentNode) \{
              \textcolor{comment}{// if the element was not removed yet because of pending animation, mark it as deleted}
              \textcolor{comment}{// so that we can ignore it later}
              \textcolor{keywordflow}{for} (index = 0, length = elementsToRemove.length; index < length; index++) \{
                elementsToRemove[index][NG\_REMOVED] = \textcolor{keyword}{true};
              \}
            \}
            block.scope.$destroy();
          \}

          \textcolor{comment}{// we are not using forEach for perf reasons (trying to avoid #call)}
          \textcolor{keywordflow}{for} (index = 0; index < collectionLength; index++) \{
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            \textcolor{keywordflow}{if} (block.scope) \{
              \textcolor{comment}{// if we have already seen this object, then we need to reuse the}
              \textcolor{comment}{// associated scope/element}

              nextNode = previousNode;

              \textcolor{comment}{// skip nodes that are already pending removal via leave animation}
              \textcolor{keywordflow}{do} \{
                nextNode = nextNode.nextSibling;
              \} \textcolor{keywordflow}{while} (nextNode && nextNode[NG\_REMOVED]);

              \textcolor{keywordflow}{if} (getBlockStart(block) != nextNode) \{
                \textcolor{comment}{// existing item which got moved}
                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
              \}
              previousNode = getBlockEnd(block);
              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
      ;
            \} \textcolor{keywordflow}{else} \{
              \textcolor{comment}{// new item which we don't know about}
              $transclude(\textcolor{keyword}{function} ngRepeatTransclude(clone, scope) \{
                block.scope = scope;
                \textcolor{comment}{// http://jsperf.com/clone-vs-createcomment}
                var endNode = ngRepeatEndComment.cloneNode(\textcolor{keyword}{false});
                clone[clone.length++] = endNode;

                \textcolor{comment}{// TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?}
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = endNode;
                \textcolor{comment}{// Note: We only need the first/last node of the cloned nodes.}
                \textcolor{comment}{// However, we need to keep the reference to the jqlite wrapper as it might be changed
       later}
                \textcolor{comment}{// by a directive with templateUrl when its template arrives.}
                block.clone = clone;
                nextBlockMap[block.id] = block;
                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, 
      collectionLength);
              \});
            \}
          \}
          lastBlockMap = nextBlockMap;
        \});
      \};
    \}
  \};
\}];

var NG\_HIDE\_CLASS = \textcolor{stringliteral}{'ng-hide'};
var NG\_HIDE\_IN\_PROGRESS\_CLASS = \textcolor{stringliteral}{'ng-hide-animate'};
var ngShowDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      scope.$watch(attr.ngShow, \textcolor{keyword}{function} ngShowWatchAction(value) \{
        \textcolor{comment}{// we're adding a temporary, animation-specific class for ng-hide since this way}
        \textcolor{comment}{// we can control when the element is actually displayed on screen without having}
        \textcolor{comment}{// to have a global/greedy CSS selector that breaks when other animations are run.}
        \textcolor{comment}{// Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845}
        $animate[value ? \textcolor{stringliteral}{'removeClass'} : \textcolor{stringliteral}{'addClass'}](element, NG\_HIDE\_CLASS, \{
          tempClasses: NG\_HIDE\_IN\_PROGRESS\_CLASS
        \});
      \});
    \}
  \};
\}];


var ngHideDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    multiElement: \textcolor{keyword}{true},
    link: \textcolor{keyword}{function}(scope, element, attr) \{
      scope.$watch(attr.ngHide, \textcolor{keyword}{function} ngHideWatchAction(value) \{
        \textcolor{comment}{// The comment inside of the ngShowDirective explains why we add and}
        \textcolor{comment}{// remove a temporary class for the show/hide animation}
        $animate[value ? \textcolor{stringliteral}{'addClass'} : \textcolor{stringliteral}{'removeClass'}](element,NG\_HIDE\_CLASS, \{
          tempClasses: NG\_HIDE\_IN\_PROGRESS\_CLASS
        \});
      \});
    \}
  \};
\}];

var ngStyleDirective = ngDirective(\textcolor{keyword}{function}(scope, element, attr) \{
  scope.$watch(attr.ngStyle, \textcolor{keyword}{function} ngStyleWatchAction(newStyles, oldStyles) \{
    \textcolor{keywordflow}{if} (oldStyles && (newStyles !== oldStyles)) \{
      forEach(oldStyles, \textcolor{keyword}{function}(val, style) \{ element.css(style, \textcolor{stringliteral}{''});\});
    \}
    \textcolor{keywordflow}{if} (newStyles) element.css(newStyles);
  \}, \textcolor{keyword}{true});
\});

var ngSwitchDirective = [\textcolor{stringliteral}{'$animate'}, \textcolor{keyword}{function}($animate) \{
  \textcolor{keywordflow}{return} \{
    require: \textcolor{stringliteral}{'ngSwitch'},

    \textcolor{comment}{// asks for $scope to fool the BC controller module}
    controller: [\textcolor{stringliteral}{'$scope'}, \textcolor{keyword}{function} ngSwitchController() \{
     this.cases = \{\};
    \}],
    link: \textcolor{keyword}{function}(scope, element, attr, ngSwitchController) \{
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes = [],
          selectedElements = [],
          previousLeaveAnimations = [],
          selectedScopes = [];

      var spliceFactory = \textcolor{keyword}{function}(array, index) \{
          \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{ array.splice(index, 1); \};
      \};

      scope.$watch(watchExpr, \textcolor{keyword}{function} ngSwitchWatchAction(value) \{
        var i, ii;
        \textcolor{keywordflow}{for} (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) \{
          $animate.cancel(previousLeaveAnimations[i]);
        \}
        previousLeaveAnimations.length = 0;

        for (i = 0, ii = selectedScopes.length; i < ii; ++i) \{
          var selected = getBlockNodes(selectedElements[i].clone);
          selectedScopes[i].$destroy();
          var promise = previousLeaveAnimations[i] = $animate.leave(selected);
          promise.then(spliceFactory(previousLeaveAnimations, i));
        \}

        selectedElements.length = 0;
        selectedScopes.length = 0;

        if ((selectedTranscludes = ngSwitchController.cases[\textcolor{charliteral}{'!'} + value] || ngSwitchController.cases[\textcolor{charliteral}{'?'}]))
       \{
          forEach(selectedTranscludes, function(selectedTransclude) \{
            selectedTransclude.transclude(function(caseElement, selectedScope) \{
              selectedScopes.push(selectedScope);
              var anchor = selectedTransclude.element;
              caseElement[caseElement.length++] = document.createComment(\textcolor{stringliteral}{' end ngSwitchWhen: '});
              var block = \{ clone: caseElement \};

              selectedElements.push(block);
              $animate.enter(caseElement, anchor.parent(), anchor);
            \});
          \});
        \}
      \});
    \}
  \};
\}];

var ngSwitchWhenDirective = ngDirective(\{
  transclude: \textcolor{stringliteral}{'element'},
  priority: 1200,
  require: \textcolor{stringliteral}{'^ngSwitch'},
  multiElement: \textcolor{keyword}{true},
  link: \textcolor{keyword}{function}(scope, element, attrs, ctrl, $transclude) \{
    ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen] = (ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen] || []);
    ctrl.cases[\textcolor{charliteral}{'!'} + attrs.ngSwitchWhen].push(\{ transclude: $transclude, element: element \});
  \}
\});

var ngSwitchDefaultDirective = ngDirective(\{
  transclude: \textcolor{stringliteral}{'element'},
  priority: 1200,
  require: \textcolor{stringliteral}{'^ngSwitch'},
  multiElement: \textcolor{keyword}{true},
  link: \textcolor{keyword}{function}(scope, element, attr, ctrl, $transclude) \{
    ctrl.cases[\textcolor{charliteral}{'?'}] = (ctrl.cases[\textcolor{charliteral}{'?'}] || []);
    ctrl.cases[\textcolor{charliteral}{'?'}].push(\{ transclude: $transclude, element: element \});
   \}
\});

var ngTranscludeDirective = ngDirective(\{
  restrict: \textcolor{stringliteral}{'EAC'},
  link: \textcolor{keyword}{function}($scope, $element, $attrs, controller, $transclude) \{
    \textcolor{keywordflow}{if} (!$transclude) \{
      \textcolor{keywordflow}{throw} minErr(\textcolor{stringliteral}{'ngTransclude'})(\textcolor{stringliteral}{'orphan'},
       \textcolor{stringliteral}{'Illegal use of ngTransclude directive in the template! '} +
       \textcolor{stringliteral}{'No parent directive that requires a transclusion found. '} +
       \textcolor{stringliteral}{'Element: \{0\}'},
       startingTag($element));
    \}

    $transclude(\textcolor{keyword}{function}(clone) \{
      $element.empty();
      $element.append(clone);
    \});
  \}
\});

var scriptDirective = [\textcolor{stringliteral}{'$templateCache'}, \textcolor{keyword}{function}($templateCache) \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    terminal: \textcolor{keyword}{true},
    compile: \textcolor{keyword}{function}(element, attr) \{
      \textcolor{keywordflow}{if} (attr.type == \textcolor{stringliteral}{'text/ng-template'}) \{
        var templateUrl = attr.id,
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      \}
    \}
  \};
\}];

var noopNgModelController = \{ $setViewValue: noop, $render: noop \};

var SelectController =
        [\textcolor{stringliteral}{'$element'}, \textcolor{stringliteral}{'$scope'}, \textcolor{stringliteral}{'$attrs'}, \textcolor{keyword}{function}($element, $scope, $attrs) \{

  var \textcolor{keyword}{self} = \textcolor{keyword}{this},
      optionsMap = \textcolor{keyword}{new} HashMap();

  \textcolor{comment}{// If the ngModel doesn't get provided then provide a dummy noop version to prevent errors}
  \textcolor{keyword}{self}.ngModelCtrl = noopNgModelController;

  \textcolor{comment}{// The "unknown" option is one that is prepended to the list if the viewValue}
  \textcolor{comment}{// does not match any of the options. When it is rendered the value of the unknown}
  \textcolor{comment}{// option is '? XXX ?' where XXX is the hashKey of the value that is not known.}
  \textcolor{comment}{//}
  \textcolor{comment}{// We can't just jqLite('<option>') since jqLite is not smart enough}
  \textcolor{comment}{// to create it in <select> and IE barfs otherwise.}
  \textcolor{keyword}{self}.unknownOption = jqLite(document.createElement(\textcolor{stringliteral}{'option'}));
  \textcolor{keyword}{self}.renderUnknownOption = \textcolor{keyword}{function}(val) \{
    var unknownVal = \textcolor{stringliteral}{'? '} + hashKey(val) + \textcolor{stringliteral}{' ?'};
    \textcolor{keyword}{self}.unknownOption.val(unknownVal);
    $element.prepend(\textcolor{keyword}{self}.unknownOption);
    $element.val(unknownVal);
  \};

  $scope.$on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
    \textcolor{comment}{// disable unknown option so that we don't do work when the whole select is being destroyed}
    \textcolor{keyword}{self}.renderUnknownOption = noop;
  \});

  \textcolor{keyword}{self}.removeUnknownOption = \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.unknownOption.parent()) \textcolor{keyword}{self}.unknownOption.remove();
  \};


  \textcolor{comment}{// Read the value of the select control, the implementation of this changes depending}
  \textcolor{comment}{// upon whether the select can have multiple values and whether ngOptions is at work.}
  \textcolor{keyword}{self}.readValue = \textcolor{keyword}{function} readSingleValue() \{
    \textcolor{keyword}{self}.removeUnknownOption();
    \textcolor{keywordflow}{return} $element.val();
  \};


  \textcolor{comment}{// Write the value to the select control, the implementation of this changes depending}
  \textcolor{comment}{// upon whether the select can have multiple values and whether ngOptions is at work.}
  \textcolor{keyword}{self}.writeValue = \textcolor{keyword}{function} writeSingleValue(value) \{
    \textcolor{keywordflow}{if} (\textcolor{keyword}{self}.hasOption(value)) \{
      \textcolor{keyword}{self}.removeUnknownOption();
      $element.val(value);
      \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \textcolor{keyword}{self}.emptyOption.prop(\textcolor{stringliteral}{'selected'}, \textcolor{keyword}{true}); \textcolor{comment}{// to make IE9 happy}
    \} \textcolor{keywordflow}{else} \{
      \textcolor{keywordflow}{if} (value == null && \textcolor{keyword}{self}.emptyOption) \{
        \textcolor{keyword}{self}.removeUnknownOption();
        $element.val(\textcolor{stringliteral}{''});
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keyword}{self}.renderUnknownOption(value);
      \}
    \}
  \};


  \textcolor{comment}{// Tell the select control that an option, with the given value, has been added}
  \textcolor{keyword}{self}.addOption = \textcolor{keyword}{function}(value, element) \{
    assertNotHasOwnProperty(value, \textcolor{stringliteral}{'"option value"'});
    \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \{
      \textcolor{keyword}{self}.emptyOption = element;
    \}
    var count = optionsMap.get(value) || 0;
    optionsMap.put(value, count + 1);
  \};

  \textcolor{comment}{// Tell the select control that an option, with the given value, has been removed}
  \textcolor{keyword}{self}.removeOption = \textcolor{keyword}{function}(value) \{
    var count = optionsMap.get(value);
    \textcolor{keywordflow}{if} (count) \{
      \textcolor{keywordflow}{if} (count === 1) \{
        optionsMap.remove(value);
        \textcolor{keywordflow}{if} (value === \textcolor{stringliteral}{''}) \{
          \textcolor{keyword}{self}.emptyOption = undefined;
        \}
      \} \textcolor{keywordflow}{else} \{
        optionsMap.put(value, count - 1);
      \}
    \}
  \};

  \textcolor{comment}{// Check whether the select control has an option matching the given value}
  \textcolor{keyword}{self}.hasOption = \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} !!optionsMap.get(value);
  \};
\}];

var selectDirective = \textcolor{keyword}{function}() \{

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    require: [\textcolor{stringliteral}{'select'}, \textcolor{stringliteral}{'?ngModel'}],
    controller: SelectController,
    link: \textcolor{keyword}{function}(scope, element, attr, ctrls) \{

      \textcolor{comment}{// if ngModel is not defined, we don't need to do anything}
      var ngModelCtrl = ctrls[1];
      \textcolor{keywordflow}{if} (!ngModelCtrl) \textcolor{keywordflow}{return};

      var selectCtrl = ctrls[0];

      selectCtrl.ngModelCtrl = ngModelCtrl;

      \textcolor{comment}{// We delegate rendering to the `writeValue` method, which can be changed}
      \textcolor{comment}{// if the select can have multiple selected values or if the options are being}
      \textcolor{comment}{// generated by `ngOptions`}
      ngModelCtrl.$render = \textcolor{keyword}{function}() \{
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      \};

      \textcolor{comment}{// When the selected item(s) changes we delegate getting the value of the select control}
      \textcolor{comment}{// to the `readValue` method, which can be changed if the select can have multiple}
      \textcolor{comment}{// selected values or if the options are being generated by `ngOptions`}
      element.on(\textcolor{stringliteral}{'change'}, \textcolor{keyword}{function}() \{
        scope.$apply(\textcolor{keyword}{function}() \{
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        \});
      \});

      \textcolor{comment}{// If the select allows multiple values then we need to modify how we read and write}
      \textcolor{comment}{// values from and to the control; also what it means for the value to be empty and}
      \textcolor{comment}{// we have to add an extra watch since ngModel doesn't work well with arrays - it}
      \textcolor{comment}{// doesn't trigger rendering if only an item in the array changes.}
      \textcolor{keywordflow}{if} (attr.multiple) \{

        \textcolor{comment}{// Read value now needs to check each option to see if it is selected}
        selectCtrl.readValue = \textcolor{keyword}{function} readMultipleValue() \{
          var array = [];
          forEach(element.find(\textcolor{stringliteral}{'option'}), \textcolor{keyword}{function}(option) \{
            \textcolor{keywordflow}{if} (option.selected) \{
              array.push(option.value);
            \}
          \});
          \textcolor{keywordflow}{return} array;
        \};

        \textcolor{comment}{// Write value now needs to set the selected property of each matching option}
        selectCtrl.writeValue = \textcolor{keyword}{function} writeMultipleValue(value) \{
          var items = \textcolor{keyword}{new} HashMap(value);
          forEach(element.find(\textcolor{stringliteral}{'option'}), \textcolor{keyword}{function}(option) \{
            option.selected = isDefined(items.get(option.value));
          \});
        \};

        \textcolor{comment}{// we have to do it on each watch since ngModel watches reference, but}
        \textcolor{comment}{// we need to work of an array, so we need to see if anything was inserted/removed}
        var lastView, lastViewRef = NaN;
        scope.$watch(\textcolor{keyword}{function} selectMultipleWatch() \{
          \textcolor{keywordflow}{if} (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) \{
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          \}
          lastViewRef = ngModelCtrl.$viewValue;
        \});

        \textcolor{comment}{// If we are a multiple select then value is now a collection}
        \textcolor{comment}{// so the meaning of $isEmpty changes}
        ngModelCtrl.$isEmpty = \textcolor{keyword}{function}(value) \{
          \textcolor{keywordflow}{return} !value || value.length === 0;
        \};

      \}
    \}
  \};
\};


\textcolor{comment}{// The option directive is purely designed to communicate the existence (or lack of)}
\textcolor{comment}{// of dynamically created (and destroyed) option elements to their containing select}
\textcolor{comment}{// directive via its controller.}
var optionDirective = [\textcolor{stringliteral}{'$interpolate'}, \textcolor{keyword}{function}($interpolate) \{

  \textcolor{keyword}{function} chromeHack(optionElement) \{
    \textcolor{comment}{// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459}
    \textcolor{comment}{// Adding an <option selected="selected"> element to a <select required="required"> should}
    \textcolor{comment}{// automatically select the new element}
    \textcolor{keywordflow}{if} (optionElement[0].hasAttribute(\textcolor{stringliteral}{'selected'})) \{
      optionElement[0].selected = \textcolor{keyword}{true};
    \}
  \}

  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'E'},
    priority: 100,
    compile: \textcolor{keyword}{function}(element, attr) \{

      \textcolor{comment}{// If the value attribute is not defined then we fall back to the}
      \textcolor{comment}{// text content of the option element, which may be interpolated}
      \textcolor{keywordflow}{if} (isUndefined(attr.value)) \{
        var interpolateFn = $interpolate(element.text(), \textcolor{keyword}{true});
        \textcolor{keywordflow}{if} (!interpolateFn) \{
          attr.$set(\textcolor{stringliteral}{'value'}, element.text());
        \}
      \}

      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(scope, element, attr) \{

        \textcolor{comment}{// This is an optimization over using ^^ since we don't want to have to search}
        \textcolor{comment}{// all the way to the root of the DOM for every single option element}
        var selectCtrlName = \textcolor{stringliteral}{'$selectController'},
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); \textcolor{comment}{// in case we are in optgroup}

        \textcolor{comment}{// Only update trigger option updates if this is an option within a `select`}
        \textcolor{comment}{// that also has `ngModel` attached}
        \textcolor{keywordflow}{if} (selectCtrl && selectCtrl.ngModelCtrl) \{

          \textcolor{keywordflow}{if} (interpolateFn) \{
            scope.$watch(interpolateFn, \textcolor{keyword}{function} interpolateWatchAction(newVal, oldVal) \{
              attr.$set(\textcolor{stringliteral}{'value'}, newVal);
              \textcolor{keywordflow}{if} (oldVal !== newVal) \{
                selectCtrl.removeOption(oldVal);
              \}
              selectCtrl.addOption(newVal, element);
              selectCtrl.ngModelCtrl.$render();
              chromeHack(element);
            \});
          \} \textcolor{keywordflow}{else} \{
            selectCtrl.addOption(attr.value, element);
            selectCtrl.ngModelCtrl.$render();
            chromeHack(element);
          \}

          element.on(\textcolor{stringliteral}{'$destroy'}, \textcolor{keyword}{function}() \{
            selectCtrl.removeOption(attr.value);
            selectCtrl.ngModelCtrl.$render();
          \});
        \}
      \};
    \}
  \};
\}];

var styleDirective = valueFn(\{
  restrict: \textcolor{charliteral}{'E'},
  terminal: \textcolor{keyword}{false}
\});

var requiredDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};
      attr.required = \textcolor{keyword}{true}; \textcolor{comment}{// force truthy in case we are on non input element}

      ctrl.$validators.required = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} !attr.required || !ctrl.$isEmpty(viewValue);
      \};

      attr.$observe(\textcolor{stringliteral}{'required'}, \textcolor{keyword}{function}() \{
        ctrl.$validate();
      \});
    \}
  \};
\};


var patternDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var regexp, patternExp = attr.ngPattern || attr.pattern;
      attr.$observe(\textcolor{stringliteral}{'pattern'}, \textcolor{keyword}{function}(regex) \{
        \textcolor{keywordflow}{if} (isString(regex) && regex.length > 0) \{
          regex = new RegExp(\textcolor{stringliteral}{'^'} + regex + \textcolor{stringliteral}{'$'});
        \}

        if (regex && !regex.test) \{
          throw minErr(\textcolor{stringliteral}{'ngPattern'})(\textcolor{stringliteral}{'noregexp'},
            \textcolor{stringliteral}{'Expected \{0\} to be a RegExp but was \{1\}. Element: \{2\}'}, patternExp,
            regex, startingTag(elm));
        \}

        regexp = regex || undefined;
        ctrl.$validate();
      \});

      ctrl.$validators.pattern = \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
      \};
    \}
  \};
\};


var maxlengthDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var maxlength = -1;
      attr.$observe(\textcolor{stringliteral}{'maxlength'}, \textcolor{keyword}{function}(value) \{
        var intVal = toInt(value);
        maxlength = isNaN(intVal) ? -1 : intVal;
        ctrl.$validate();
      \});
      ctrl.$validators.maxlength = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
      \};
    \}
  \};
\};

var minlengthDirective = \textcolor{keyword}{function}() \{
  \textcolor{keywordflow}{return} \{
    restrict: \textcolor{charliteral}{'A'},
    require: \textcolor{stringliteral}{'?ngModel'},
    link: \textcolor{keyword}{function}(scope, elm, attr, ctrl) \{
      \textcolor{keywordflow}{if} (!ctrl) \textcolor{keywordflow}{return};

      var minlength = 0;
      attr.$observe(\textcolor{stringliteral}{'minlength'}, \textcolor{keyword}{function}(value) \{
        minlength = toInt(value) || 0;
        ctrl.$validate();
      \});
      ctrl.$validators.minlength = \textcolor{keyword}{function}(modelValue, viewValue) \{
        \textcolor{keywordflow}{return} ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
      \};
    \}
  \};
\};

\textcolor{keywordflow}{if} (window.angular.bootstrap) \{
  \textcolor{comment}{//AngularJS is already loaded, so we can return here...}
  console.log(\textcolor{stringliteral}{'WARNING: Tried to load angular more than once.'});
  \textcolor{keywordflow}{return};
\}

\textcolor{comment}{//try to bind to jquery now so that one can write jqLite(document).ready()}
\textcolor{comment}{//but we will rebind on bootstrap again.}
bindJQuery();

publishExternalAPI(angular);

angular.module(\textcolor{stringliteral}{"ngLocale"}, [], [\textcolor{stringliteral}{"$provide"}, \textcolor{keyword}{function}($provide) \{
var PLURAL\_CATEGORY = \{ZERO: \textcolor{stringliteral}{"zero"}, ONE: \textcolor{stringliteral}{"one"}, TWO: \textcolor{stringliteral}{"two"}, FEW: \textcolor{stringliteral}{"few"}, MANY: \textcolor{stringliteral}{"many"}, OTHER: \textcolor{stringliteral}{"other"}\};
\textcolor{keyword}{function} getDecimals(n) \{
  n = n + \textcolor{stringliteral}{''};
  var i = n.indexOf(\textcolor{charliteral}{'.'});
  \textcolor{keywordflow}{return} (i == -1) ? 0 : n.length - i - 1;
\}

\textcolor{keyword}{function} getVF(n, opt\_precision) \{
  var v = opt\_precision;

  \textcolor{keywordflow}{if} (undefined === v) \{
    v = Math.min(getDecimals(n), 3);
  \}

  var base = Math.pow(10, v);
  var f = ((n * base) | 0) % base;
  \textcolor{keywordflow}{return} \{v: v, f: f\};
\}

$provide.value(\textcolor{stringliteral}{"$locale"}, \{
  \textcolor{stringliteral}{"DATETIME\_FORMATS"}: \{
    \textcolor{stringliteral}{"AMPMS"}: [
      \textcolor{stringliteral}{"AM"},
      \textcolor{stringliteral}{"PM"}
    ],
    \textcolor{stringliteral}{"DAY"}: [
      \textcolor{stringliteral}{"Sunday"},
      \textcolor{stringliteral}{"Monday"},
      \textcolor{stringliteral}{"Tuesday"},
      \textcolor{stringliteral}{"Wednesday"},
      \textcolor{stringliteral}{"Thursday"},
      \textcolor{stringliteral}{"Friday"},
      \textcolor{stringliteral}{"Saturday"}
    ],
    \textcolor{stringliteral}{"ERANAMES"}: [
      \textcolor{stringliteral}{"Before Christ"},
      \textcolor{stringliteral}{"Anno Domini"}
    ],
    \textcolor{stringliteral}{"ERAS"}: [
      \textcolor{stringliteral}{"BC"},
      \textcolor{stringliteral}{"AD"}
    ],
    \textcolor{stringliteral}{"FIRSTDAYOFWEEK"}: 6,
    \textcolor{stringliteral}{"MONTH"}: [
      \textcolor{stringliteral}{"January"},
      \textcolor{stringliteral}{"February"},
      \textcolor{stringliteral}{"March"},
      \textcolor{stringliteral}{"April"},
      \textcolor{stringliteral}{"May"},
      \textcolor{stringliteral}{"June"},
      \textcolor{stringliteral}{"July"},
      \textcolor{stringliteral}{"August"},
      \textcolor{stringliteral}{"September"},
      \textcolor{stringliteral}{"October"},
      \textcolor{stringliteral}{"November"},
      \textcolor{stringliteral}{"December"}
    ],
    \textcolor{stringliteral}{"SHORTDAY"}: [
      \textcolor{stringliteral}{"Sun"},
      \textcolor{stringliteral}{"Mon"},
      \textcolor{stringliteral}{"Tue"},
      \textcolor{stringliteral}{"Wed"},
      \textcolor{stringliteral}{"Thu"},
      \textcolor{stringliteral}{"Fri"},
      \textcolor{stringliteral}{"Sat"}
    ],
    \textcolor{stringliteral}{"SHORTMONTH"}: [
      \textcolor{stringliteral}{"Jan"},
      \textcolor{stringliteral}{"Feb"},
      \textcolor{stringliteral}{"Mar"},
      \textcolor{stringliteral}{"Apr"},
      \textcolor{stringliteral}{"May"},
      \textcolor{stringliteral}{"Jun"},
      \textcolor{stringliteral}{"Jul"},
      \textcolor{stringliteral}{"Aug"},
      \textcolor{stringliteral}{"Sep"},
      \textcolor{stringliteral}{"Oct"},
      \textcolor{stringliteral}{"Nov"},
      \textcolor{stringliteral}{"Dec"}
    ],
    \textcolor{stringliteral}{"WEEKENDRANGE"}: [
      5,
      6
    ],
    \textcolor{stringliteral}{"fullDate"}: \textcolor{stringliteral}{"EEEE, MMMM d, y"},
    \textcolor{stringliteral}{"longDate"}: \textcolor{stringliteral}{"MMMM d, y"},
    \textcolor{stringliteral}{"medium"}: \textcolor{stringliteral}{"MMM d, y h:mm:ss a"},
    \textcolor{stringliteral}{"mediumDate"}: \textcolor{stringliteral}{"MMM d, y"},
    \textcolor{stringliteral}{"mediumTime"}: \textcolor{stringliteral}{"h:mm:ss a"},
    \textcolor{stringliteral}{"short"}: \textcolor{stringliteral}{"M/d/yy h:mm a"},
    \textcolor{stringliteral}{"shortDate"}: \textcolor{stringliteral}{"M/d/yy"},
    \textcolor{stringliteral}{"shortTime"}: \textcolor{stringliteral}{"h:mm a"}
  \},
  \textcolor{stringliteral}{"NUMBER\_FORMATS"}: \{
    \textcolor{stringliteral}{"CURRENCY\_SYM"}: \textcolor{stringliteral}{"$"},
    \textcolor{stringliteral}{"DECIMAL\_SEP"}: \textcolor{stringliteral}{"."},
    \textcolor{stringliteral}{"GROUP\_SEP"}: \textcolor{stringliteral}{","},
    \textcolor{stringliteral}{"PATTERNS"}: [
      \{
        \textcolor{stringliteral}{"gSize"}: 3,
        \textcolor{stringliteral}{"lgSize"}: 3,
        \textcolor{stringliteral}{"maxFrac"}: 3,
        \textcolor{stringliteral}{"minFrac"}: 0,
        \textcolor{stringliteral}{"minInt"}: 1,
        \textcolor{stringliteral}{"negPre"}: \textcolor{stringliteral}{"-"},
        \textcolor{stringliteral}{"negSuf"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posPre"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posSuf"}: \textcolor{stringliteral}{""}
      \},
      \{
        \textcolor{stringliteral}{"gSize"}: 3,
        \textcolor{stringliteral}{"lgSize"}: 3,
        \textcolor{stringliteral}{"maxFrac"}: 2,
        \textcolor{stringliteral}{"minFrac"}: 2,
        \textcolor{stringliteral}{"minInt"}: 1,
        \textcolor{stringliteral}{"negPre"}: \textcolor{stringliteral}{"-\(\backslash\)u00a4"},
        \textcolor{stringliteral}{"negSuf"}: \textcolor{stringliteral}{""},
        \textcolor{stringliteral}{"posPre"}: \textcolor{stringliteral}{"\(\backslash\)u00a4"},
        \textcolor{stringliteral}{"posSuf"}: \textcolor{stringliteral}{""}
      \}
    ]
  \},
  \textcolor{stringliteral}{"id"}: \textcolor{stringliteral}{"en-us"},
  \textcolor{stringliteral}{"pluralCat"}: \textcolor{keyword}{function}(n, opt\_precision) \{  var i = n | 0;  var vf = getVF(n, opt\_precision);  \textcolor{keywordflow}{if} (i == 1 
      && vf.v == 0) \{    \textcolor{keywordflow}{return} PLURAL\_CATEGORY.ONE;  \}  \textcolor{keywordflow}{return} PLURAL\_CATEGORY.OTHER;\}
\});
\}]);

  jqLite(document).ready(\textcolor{keyword}{function}() \{
    angularInit(document, bootstrap);
  \});

\})(window, document);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(\textcolor{stringliteral}{'<style
       type="text/css">@charset "UTF-8";[ng\(\backslash\)\(\backslash\)
      :cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate)\{display:none !important;\}ng\(\backslash\)\(\backslash\)
      :form\{display:block;\}.ng-animate-shim\{visibility:hidden;\}.ng-anchor\{position:absolute;\}</style>'});
\end{DoxyCodeInclude}
 