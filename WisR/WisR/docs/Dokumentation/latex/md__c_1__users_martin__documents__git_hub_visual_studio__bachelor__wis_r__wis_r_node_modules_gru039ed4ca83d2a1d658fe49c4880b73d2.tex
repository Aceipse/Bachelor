

 {\bfseries Hawk} is an H\+T\+T\+P authentication scheme using a message authentication code (M\+A\+C) algorithm to provide partial H\+T\+T\+P request cryptographic verification. For more complex use cases such as access delegation, see \href{https://github.com/hueniverse/oz}{\tt Oz}.

Current version\+: {\bfseries 1.\+0}

\href{http://travis-ci.org/hueniverse/hawk}{\tt !\mbox{[}Build Status\mbox{]}(https\+://secure.\+travis-\/ci.\+org/hueniverse/hawk.\+png)}

\section*{Table of Content}


\begin{DoxyItemize}
\item \href{#introduction}{\tt $\ast$$\ast$\+Introduction$\ast$$\ast$}
\begin{DoxyItemize}
\item \href{#replay-protection}{\tt Replay Protection}
\item \href{#usage-example}{\tt Usage Example}
\item \href{#protocol-example}{\tt Protocol Example}
\begin{DoxyItemize}
\item \href{#payload-validation}{\tt Payload Validation}
\item \href{#response-payload-validation}{\tt Response Payload Validation}
\end{DoxyItemize}
\item \href{#browser-support-and-considerations}{\tt Browser Support and Considerations} 
\end{DoxyItemize}
\item \href{#single-uri-authorization}{\tt $\ast$$\ast$\+Single U\+R\+I Authorization$\ast$$\ast$}
\begin{DoxyItemize}
\item \href{#bewit-usage-example}{\tt Usage Example} 
\end{DoxyItemize}
\item \href{#security-considerations}{\tt $\ast$$\ast$\+Security Considerations$\ast$$\ast$}
\begin{DoxyItemize}
\item \href{#mac-keys-transmission}{\tt M\+A\+C Keys Transmission}
\item \href{#confidentiality-of-requests}{\tt Confidentiality of Requests}
\item \href{#spoofing-by-counterfeit-servers}{\tt Spoofing by Counterfeit Servers}
\item \href{#plaintext-storage-of-credentials}{\tt Plaintext Storage of Credentials}
\item \href{#entropy-of-keys}{\tt Entropy of Keys}
\item \href{#coverage-limitations}{\tt Coverage Limitations}
\item \href{#future-time-manipulation}{\tt Future Time Manipulation}
\item \href{#client-clock-poisoning}{\tt Client Clock Poisoning}
\item \href{#bewit-limitations}{\tt Bewit Limitations}
\item \href{#host-header-forgery}{\tt Host Header Forgery} 
\end{DoxyItemize}
\item \href{#frequently-asked-questions}{\tt $\ast$$\ast$\+Frequently Asked Questions$\ast$$\ast$} 
\end{DoxyItemize}


\begin{DoxyItemize}
\item \href{#acknowledgements}{\tt $\ast$$\ast$\+Acknowledgements$\ast$$\ast$}
\end{DoxyItemize}

\section*{Introduction}

{\bfseries Hawk} is an H\+T\+T\+P authentication scheme providing mechanisms for making authenticated H\+T\+T\+P requests with partial cryptographic verification of the request and response, covering the H\+T\+T\+P method, request U\+R\+I, host, and optionally the request payload.

Similar to the H\+T\+T\+P \href{http://www.ietf.org/rfc/rfc2617.txt}{\tt Digest access authentication schemes}, {\bfseries Hawk} uses a set of client credentials which include an identifier (e.\+g. username) and key (e.\+g. password). Likewise, just as with the Digest scheme, the key is never included in authenticated requests. Instead, it is used to calculate a request M\+A\+C value which is included in its place.

However, {\bfseries Hawk} has several differences from Digest. In particular, while both use a nonce to limit the possibility of replay attacks, in {\bfseries Hawk} the client generates the nonce and uses it in combination with a timestamp, leading to less \char`\"{}chattiness\char`\"{} (interaction with the server).

Also unlike Digest, this scheme is not intended to protect the key itself (the password in Digest) because the client and server must both have access to the key material in the clear.

The primary design goals of this scheme are to\+:
\begin{DoxyItemize}
\item simplify and improve H\+T\+T\+P authentication for services that are unwilling or unable to deploy T\+L\+S for all resources,
\item secure credentials against leakage (e.\+g., when the client uses some form of dynamic configuration to determine where to send an authenticated request), and
\item avoid the exposure of credentials sent to a malicious server over an unauthenticated secure channel due to client failure to validate the server\textquotesingle{}s identity as part of its T\+L\+S handshake.
\end{DoxyItemize}

In addition, {\bfseries Hawk} supports a method for granting third-\/parties temporary access to individual resources using a query parameter called {\itshape bewit} (in falconry, a leather strap used to attach a tracking device to the leg of a hawk).

The {\bfseries Hawk} scheme requires the establishment of a shared symmetric key between the client and the server, which is beyond the scope of this module. Typically, the shared credentials are established via an initial T\+L\+S-\/protected phase or derived from some other shared confidential information available to both the client and the server.

\subsection*{Replay Protection}

Without replay protection, an attacker can use a compromised (but otherwise valid and authenticated) request more than once, gaining access to a protected resource. To mitigate this, clients include both a nonce and a timestamp when making requests. This gives the server enough information to prevent replay attacks.

The nonce is generated by the client, and is a string unique across all requests with the same timestamp and key identifier combination.

The timestamp enables the server to restrict the validity period of the credentials where requests occuring afterwards are rejected. It also removes the need for the server to retain an unbounded number of nonce values for future checks. By default, {\bfseries Hawk} uses a time window of 1 minute to allow for time skew between the client and server (which in practice translates to a maximum of 2 minutes as the skew can be positive or negative).

Using a timestamp requires the client\textquotesingle{}s clock to be in sync with the server\textquotesingle{}s clock. {\bfseries Hawk} requires both the client clock and the server clock to use N\+T\+P to ensure synchronization. However, given the limitations of some client types (e.\+g. browsers) to deploy N\+T\+P, the server provides the client with its current time (in seconds precision) in response to a bad timestamp.

There is no expectation that the client will adjust its system clock to match the server (in fact, this would be a potential attack vector). Instead, the client only uses the server\textquotesingle{}s time to calculate an offset used only for communications with that particular server. The protocol rewards clients with synchronized clocks by reducing the number of round trips required to authenticate the first request.

\subsection*{Usage Example}

Server code\+:


\begin{DoxyCode}
1 var Http = require('http');
2 var Hawk = require('hawk');
3 
4 
5 // Credentials lookup function
6 
7 var credentialsFunc = function (id, callback) \{
8 
9     var credentials = \{
10         key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',
11         algorithm: 'sha256',
12         user: 'Steve'
13     \};
14 
15     return callback(null, credentials);
16 \};
17 
18 // Create HTTP server
19 
20 var handler = function (req, res) \{
21 
22     // Authenticate incoming request
23 
24     Hawk.server.authenticate(req, credentialsFunc, \{\}, function (err, credentials, artifacts) \{
25 
26         // Prepare response
27 
28         var payload = (!err ? 'Hello ' + credentials.user + ' ' + artifacts.ext : 'Shoosh!');
29         var headers = \{ 'Content-Type': 'text/plain' \};
30 
31         // Generate Server-Authorization response header
32 
33         var header = Hawk.server.header(credentials, artifacts, \{ payload: payload, contentType:
       headers['Content-Type'] \});
34         headers['Server-Authorization'] = header;
35 
36         // Send the response back
37 
38         res.writeHead(!err ? 200 : 401, headers);
39         res.end(payload);
40     \});
41 \};
42 
43 // Start server
44 
45 Http.createServer(handler).listen(8000, 'example.com');
\end{DoxyCode}


Client code\+:


\begin{DoxyCode}
1 var Request = require('request');
2 var Hawk = require('hawk');
3 
4 
5 // Client credentials
6 
7 var credentials = \{
8     id: 'dh37fgj492je',
9     key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',
10     algorithm: 'sha256'
11 \}
12 
13 // Request options
14 
15 var requestOptions = \{
16     uri: 'http://example.com:8000/resource/1?b=1&a=2',
17     method: 'GET',
18     headers: \{\}
19 \};
20 
21 // Generate Authorization request header
22 
23 var header = Hawk.client.header('http://example.com:8000/resource/1?b=1&a=2', 'GET', \{ credentials:
       credentials, ext: 'some-app-data' \});
24 requestOptions.headers.Authorization = header.field;
25 
26 // Send authenticated request
27 
28 Request(requestOptions, function (error, response, body) \{
29 
30     // Authenticate the server's response
31 
32     var isValid = Hawk.client.authenticate(response, credentials, header.artifacts, \{ payload: body \});
33 
34     // Output results
35 
36     console.log(response.statusCode + ': ' + body + (isValid ? ' (valid)' : ' (invalid)'));
37 \});
\end{DoxyCode}


{\bfseries Hawk} utilized the \href{https://github.com/hueniverse/sntp}{\tt $\ast$$\ast$\+S\+N\+T\+P$\ast$$\ast$} module for time sync management. By default, the local machine time is used. To automatically retrieve and synchronice the clock within the application, use the S\+N\+T\+P \textquotesingle{}start()\textquotesingle{} method.


\begin{DoxyCode}
1 Hawk.sntp.start();
\end{DoxyCode}


\subsection*{Protocol Example}

The client attempts to access a protected resource without authentication, sending the following H\+T\+T\+P request to the resource server\+:


\begin{DoxyCode}
1 GET /resource/1?b=1&a=2 HTTP/1.1
2 Host: example.com:8000
\end{DoxyCode}


The resource server returns an authentication challenge.


\begin{DoxyCode}
1 HTTP/1.1 401 Unauthorized
2 WWW-Authenticate: Hawk
\end{DoxyCode}


The client has previously obtained a set of {\bfseries Hawk} credentials for accessing resources on the \char`\"{}http\+://example.\+com/\char`\"{} server. The {\bfseries Hawk} credentials issued to the client include the following attributes\+:


\begin{DoxyItemize}
\item Key identifier\+: dh37fgj492je
\item Key\+: werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn
\item Algorithm\+: sha256
\end{DoxyItemize}

The client generates the authentication header by calculating a timestamp (e.\+g. the number of seconds since January 1, 1970 00\+:00\+:00 G\+M\+T), generating a nonce, and constructing the normalized request string (each value followed by a newline character)\+:


\begin{DoxyCode}
1 hawk.1.header
2 1353832234
3 j4h3g2
4 GET
5 /resource/1?b=1&a=2
6 example.com
7 8000
8 
9 some-app-ext-data
\end{DoxyCode}


The request M\+A\+C is calculated using H\+M\+A\+C with the specified hash algorithm \char`\"{}sha256\char`\"{} and the key over the normalized request string. The result is base64-\/encoded to produce the request M\+A\+C\+:


\begin{DoxyCode}
1 6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=
\end{DoxyCode}


The client includes the {\bfseries Hawk} key identifier, timestamp, nonce, application specific data, and request M\+A\+C with the request using the H\+T\+T\+P {\ttfamily Authorization} request header field\+:


\begin{DoxyCode}
1 GET /resource/1?b=1&a=2 HTTP/1.1
2 Host: example.com:8000
3 Authorization: Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data",
       mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="
\end{DoxyCode}


The server validates the request by calculating the request M\+A\+C again based on the request received and verifies the validity and scope of the {\bfseries Hawk} credentials. If valid, the server responds with the requested resource.

\subsubsection*{Payload Validation}

{\bfseries Hawk} provides optional payload validation. When generating the authentication header, the client calculates a payload hash using the specified hash algorithm. The hash is calculated over the concatenated value of (each followed by a newline character)\+:
\begin{DoxyItemize}
\item {\ttfamily hawk.\+1.\+payload}
\item the content-\/type in lowercase, without any parameters (e.\+g. {\ttfamily application/json})
\item the request payload prior to any content encoding (the exact representation requirements should be specified by the server for payloads other than simple single-\/part ascii to ensure interoperability)
\end{DoxyItemize}

For example\+:


\begin{DoxyItemize}
\item Payload\+: {\ttfamily Thank you for flying Hawk}
\item Content Type\+: {\ttfamily text/plain}
\item Hash (sha256)\+: {\ttfamily Yi9\+Lf\+I\+I\+F\+Rt\+B\+E\+Pt74\+P\+Vmb\+T\+F/x\+V\+Aw\+Pn7ub15e\+P\+I\+Cfgnu\+Y=}
\end{DoxyItemize}

Results in the following input to the payload hash function (newline terminated values)\+:


\begin{DoxyCode}
1 hawk.1.payload
2 text/plain
3 Thank you for flying Hawk
\end{DoxyCode}


Which produces the following hash value\+:


\begin{DoxyCode}
1 Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=
\end{DoxyCode}


The client constructs the normalized request string (newline terminated values)\+:


\begin{DoxyCode}
1 hawk.1.header
2 1353832234
3 j4h3g2
4 POST
5 /resource/1?a=1&b=2
6 example.com
7 8000
8 Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=
9 some-app-ext-data
\end{DoxyCode}


Then calculates the request M\+A\+C and includes the {\bfseries Hawk} key identifier, timestamp, nonce, payload hash, application specific data, and request M\+A\+C, with the request using the H\+T\+T\+P {\ttfamily Authorization} request header field\+:


\begin{DoxyCode}
1 POST /resource/1?a=1&b=2 HTTP/1.1
2 Host: example.com:8000
3 Authorization: Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2",
       hash="Yi9LfIIFRtBEPt74PVmbTF/xVAwPn7ub15ePICfgnuY=", ext="some-app-ext-data", mac="aSe1DERmZuRl3pI36/9BdZmnErTw3sNzOOAUlfeKjVw="
\end{DoxyCode}


It is up to the server if and when it validates the payload for any given request, based solely on it\textquotesingle{}s security policy and the nature of the data included.

If the payload is available at the time of authentication, the server uses the hash value provided by the client to construct the normalized string and validates the M\+A\+C. If the M\+A\+C is valid, the server calculates the payload hash and compares the value with the provided payload hash in the header. In many cases, checking the M\+A\+C first is faster than calculating the payload hash.

However, if the payload is not available at authentication time (e.\+g. too large to fit in memory, streamed elsewhere, or processed at a different stage in the application), the server may choose to defer payload validation for later by retaining the hash value provided by the client after validating the M\+A\+C.

It is important to note that M\+A\+C validation does not mean the hash value provided by the client is valid, only that the value included in the header was not modified. Without calculating the payload hash on the server and comparing it to the value provided by the client, the payload may be modified by an attacker.

\subsection*{Response Payload Validation}

{\bfseries Hawk} provides partial response payload validation. The server includes the {\ttfamily Server-\/\+Authorization} response header which enables the client to authenticate the response and ensure it is talking to the right server. {\bfseries Hawk} defines the H\+T\+T\+P {\ttfamily Server-\/\+Authorization} header as a response header using the exact same syntax as the {\ttfamily Authorization} request header field.

The header is contructed using the same process as the client\textquotesingle{}s request header. The server uses the same credentials and other artifacts provided by the client to constructs the normalized request string. The {\ttfamily ext} and {\ttfamily hash} values are replaced with new values based on the server response. The rest as identical to those used by the client.

The result M\+A\+C digest is included with the optional {\ttfamily hash} and {\ttfamily ext} values\+:


\begin{DoxyCode}
1 Server-Authorization: Hawk mac="XIJRsMl/4oL+nn+vKoeVZPdCHXB4yJkNnBbTbHFZUYE=",
       hash="f9cDF/TDm7TkYRLnGwRMfeDzT6LixQVLvrIKhh0vgmM=", ext="response-specific"
\end{DoxyCode}


\subsection*{Browser Support and Considerations}

A browser script is provided for including using a {\ttfamily $<$script$>$} tag in \href{/lib/browser.js}{\tt lib/browser.\+js}.

{\bfseries Hawk} relies on the {\itshape Server-\/\+Authorization} and {\itshape W\+W\+W-\/\+Authenticate} headers in its response to communicate with the client. Therefore, in case of C\+O\+R\+S requests, it is important to consider sending {\itshape Access-\/\+Control-\/\+Expose-\/\+Headers} with the value \+\_\+\char`\"{}\+W\+W\+W-\/\+Authenticate, Server-\/\+Authorization\char`\"{}\+\_\+ on each response from your server. As explained in the \href{http://www.w3.org/TR/cors/#access-control-expose-headers-response-header}{\tt specifications}, it will indicate that these headers can safely be accessed by the client (using get\+Response\+Header() on the Xml\+Http\+Request object). Otherwise you will be met with a \href{http://www.w3.org/TR/cors/#simple-response-header}{\tt \char`\"{}simple response header\char`\"{}} which excludes these fields and would prevent the Hawk client from authenticating the requests.\+You can read more about the why and how in this \href{http://www.html5rocks.com/en/tutorials/cors/#toc-adding-cors-support-to-the-server}{\tt article}

\section*{Single U\+R\+I Authorization}

There are cases in which limited and short-\/term access to a protected resource is granted to a third party which does not have access to the shared credentials. For example, displaying a protected image on a web page accessed by anyone. {\bfseries Hawk} provides limited support for such U\+R\+Is in the form of a {\itshape bewit} -\/ a U\+R\+I query parameter appended to the request U\+R\+I which contains the necessary credentials to authenticate the request.

Because of the significant security risks involved in issuing such access, bewit usage is purposely limited only to G\+E\+T requests and for a finite period of time. Both the client and server can issue bewit credentials, however, the server should not use the same credentials as the client to maintain clear traceability as to who issued which credentials.

In order to simplify implementation, bewit credentials do not support single-\/use policy and can be replayed multiple times within the granted access timeframe.

\subsection*{Bewit Usage Example}

Server code\+:


\begin{DoxyCode}
1 var Http = require('http');
2 var Hawk = require('hawk');
3 
4 
5 // Credentials lookup function
6 
7 var credentialsFunc = function (id, callback) \{
8 
9     var credentials = \{
10         key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',
11         algorithm: 'sha256'
12     \};
13 
14     return callback(null, credentials);
15 \};
16 
17 // Create HTTP server
18 
19 var handler = function (req, res) \{
20 
21     Hawk.uri.authenticate(req, credentialsFunc, \{\}, function (err, credentials, attributes) \{
22 
23         res.writeHead(!err ? 200 : 401, \{ 'Content-Type': 'text/plain' \});
24         res.end(!err ? 'Access granted' : 'Shoosh!');
25     \});
26 \};
27 
28 Http.createServer(handler).listen(8000, 'example.com');
\end{DoxyCode}


Bewit code generation\+:


\begin{DoxyCode}
1 var Request = require('request');
2 var Hawk = require('hawk');
3 
4 
5 // Client credentials
6 
7 var credentials = \{
8     id: 'dh37fgj492je',
9     key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',
10     algorithm: 'sha256'
11 \}
12 
13 // Generate bewit
14 
15 var duration = 60 * 5;      // 5 Minutes
16 var bewit = Hawk.uri.getBewit('http://example.com:8080/resource/1?b=1&a=2', \{ credentials: credentials,
       ttlSec: duration, ext: 'some-app-data' \});
17 var uri = 'http://example.com:8000/resource/1?b=1&a=2' + '&bewit=' + bewit;
\end{DoxyCode}


\section*{Security Considerations}

The greatest sources of security risks are usually found not in {\bfseries Hawk} but in the policies and procedures surrounding its use. Implementers are strongly encouraged to assess how this module addresses their security requirements. This section includes an incomplete list of security considerations that must be reviewed and understood before deploying {\bfseries Hawk} on the server. Many of the protections provided in {\bfseries Hawk} depends on whether and how they are used.

\subsubsection*{M\+A\+C Keys Transmission}

{\bfseries Hawk} does not provide any mechanism for obtaining or transmitting the set of shared credentials required. Any mechanism used to obtain {\bfseries Hawk} credentials must ensure that these transmissions are protected using transport-\/layer mechanisms such as T\+L\+S.

\subsubsection*{Confidentiality of Requests}

While {\bfseries Hawk} provides a mechanism for verifying the integrity of H\+T\+T\+P requests, it provides no guarantee of request confidentiality. Unless other precautions are taken, eavesdroppers will have full access to the request content. Servers should carefully consider the types of data likely to be sent as part of such requests, and employ transport-\/layer security mechanisms to protect sensitive resources.

\subsubsection*{Spoofing by Counterfeit Servers}

{\bfseries Hawk} provides limited verification of the server authenticity. When receiving a response back from the server, the server may choose to include a response {\ttfamily Server-\/\+Authorization} header which the client can use to verify the response. However, it is up to the server to determine when such measure is included, to up to the client to enforce that policy.

A hostile party could take advantage of this by intercepting the client\textquotesingle{}s requests and returning misleading or otherwise incorrect responses. Service providers should consider such attacks when developing services using this protocol, and should require transport-\/layer security for any requests where the authenticity of the resource server or of server responses is an issue.

\subsubsection*{Plaintext Storage of Credentials}

The {\bfseries Hawk} key functions the same way passwords do in traditional authentication systems. In order to compute the request M\+A\+C, the server must have access to the key in plaintext form. This is in contrast, for example, to modern operating systems, which store only a one-\/way hash of user credentials.

If an attacker were to gain access to these keys -\/ or worse, to the server\textquotesingle{}s database of all such keys -\/ he or she would be able to perform any action on behalf of any resource owner. Accordingly, it is critical that servers protect these keys from unauthorized access.

\subsubsection*{Entropy of Keys}

Unless a transport-\/layer security protocol is used, eavesdroppers will have full access to authenticated requests and request M\+A\+C values, and will thus be able to mount offline brute-\/force attacks to recover the key used. Servers should be careful to assign keys which are long enough, and random enough, to resist such attacks for at least the length of time that the {\bfseries Hawk} credentials are valid.

For example, if the credentials are valid for two weeks, servers should ensure that it is not possible to mount a brute force attack that recovers the key in less than two weeks. Of course, servers are urged to err on the side of caution, and use the longest key reasonable.

It is equally important that the pseudo-\/random number generator (P\+R\+N\+G) used to generate these keys be of sufficiently high quality. Many P\+R\+N\+G implementations generate number sequences that may appear to be random, but which nevertheless exhibit patterns or other weaknesses which make cryptanalysis or brute force attacks easier. Implementers should be careful to use cryptographically secure P\+R\+N\+Gs to avoid these problems.

\subsubsection*{Coverage Limitations}

The request M\+A\+C only covers the H\+T\+T\+P {\ttfamily Host} header and optionally the {\ttfamily Content-\/\+Type} header. It does not cover any other headers which can often affect how the request body is interpreted by the server. If the server behavior is influenced by the presence or value of such headers, an attacker can manipulate the request headers without being detected. Implementers should use the {\ttfamily ext} feature to pass application-\/specific information via the {\ttfamily Authorization} header which is protected by the request M\+A\+C.

The response authentication, when performed, only covers the response payload, content-\/type, and the request information provided by the client in it\textquotesingle{}s request (method, resource, timestamp, nonce, etc.). It does not cover the H\+T\+T\+P status code or any other response header field (e.\+g. Location) which can affect the client\textquotesingle{}s behaviour.

\subsubsection*{Future Time Manipulation}

The protocol relies on a clock sync between the client and server. To accomplish this, the server informs the client of its current time when an invalid timestamp is received.

If an attacker is able to manipulate this information and cause the client to use an incorrect time, it would be able to cause the client to generate authenticated requests using time in the future. Such requests will fail when sent by the client, and will not likely leave a trace on the server (given the common implementation of nonce, if at all enforced). The attacker will then be able to replay the request at the correct time without detection.

The client must only use the time information provided by the server if\+:
\begin{DoxyItemize}
\item it was delivered over a T\+L\+S connection and the server identity has been verified, or
\item the {\ttfamily tsm} M\+A\+C digest calculated using the same client credentials over the timestamp has been verified.
\end{DoxyItemize}

\subsubsection*{Client Clock Poisoning}

When receiving a request with a bad timestamp, the server provides the client with its current time. The client must never use the time received from the server to adjust its own clock, and must only use it to calculate an offset for communicating with that particular server.

\subsubsection*{Bewit Limitations}

Special care must be taken when issuing bewit credentials to third parties. Bewit credentials are valid until expiration and cannot be revoked or limited without using other means. Whatever resource they grant access to will be completely exposed to anyone with access to the bewit credentials which act as bearer credentials for that particular resource. While bewit usage is limited to G\+E\+T requests only and therefore cannot be used to perform transactions or change server state, it can still be used to expose private and sensitive information.

\subsubsection*{Host Header Forgery}

Hawk validates the incoming request M\+A\+C against the incoming H\+T\+T\+P Host header. However, unless the optional {\ttfamily host} and {\ttfamily port} options are used with {\ttfamily server.\+authenticate()}, a malicous client can mint new host names pointing to the server\textquotesingle{}s I\+P address and use that to craft an attack by sending a valid request that\textquotesingle{}s meant for another hostname than the one used by the server. Server implementors must manually verify that the host header received matches their expectation (or use the options mentioned above).

\section*{Frequently Asked Questions}

\subsubsection*{Where is the protocol specification?}

If you are looking for some prose explaining how all this works, {\bfseries this is it}. {\bfseries Hawk} is being developed as an open source project instead of a standard. In other words, the \href{/hueniverse/hawk/tree/master/lib}{\tt code} is the specification. Not sure about something? Open an issue!

\subsubsection*{Is it done?}

At if version 0.\+10.\+0, {\bfseries Hawk} is feature-\/complete. However, until this module reaches version 1.\+0.\+0 it is considered experimental and is likely to change. This also means your feedback and contribution are very welcome. Feel free to open issues with questions and suggestions.

\subsubsection*{Where can I find {\bfseries Hawk} implementations in other languages?}

{\bfseries Hawk}\textquotesingle{}s only reference implementation is provided in Java\+Script as a node.\+js module. However, it has been ported to other languages. The full list is maintained \href{https://github.com/hueniverse/hawk/issues?labels=port&state=closed}{\tt here}. Please add an issue if you are working on another port. A cross-\/platform test-\/suite is in the works.

\subsubsection*{Why isn\textquotesingle{}t the algorithm part of the challenge or dynamically negotiated?}

The algorithm used is closely related to the key issued as different algorithms require different key sizes (and other requirements). While some keys can be used for multiple algorithm, the protocol is designed to closely bind the key and algorithm together as part of the issued credentials.

\subsubsection*{Why is Host and Content-\/\+Type the only headers covered by the request M\+A\+C?}

It is really hard to include other headers. Headers can be changed by proxies and other intermediaries and there is no well-\/established way to normalize them. Many platforms change the case of header field names and values. The only straight-\/forward solution is to include the headers in some blob (say, base64 encoded J\+S\+O\+N) and include that with the request, an approach taken by J\+W\+T and other such formats. However, that design violates the H\+T\+T\+P header boundaries, repeats information, and introduces other security issues because firewalls will not be aware of these \char`\"{}hidden\char`\"{} headers. In addition, any information repeated must be compared to the duplicated information in the header and therefore only moves the problem elsewhere.

\subsubsection*{Why not just use H\+T\+T\+P Digest?}

Digest requires pre-\/negotiation to establish a nonce. This means you can\textquotesingle{}t just make a request -\/ you must first send a protocol handshake to the server. This pattern has become unacceptable for most web services, especially mobile where extra round-\/trip are costly.

\subsubsection*{Why bother with all this nonce and timestamp business?}

{\bfseries Hawk} is an attempt to find a reasonable, practical compromise between security and usability. O\+Auth 1.\+0 got timestamp and nonces halfway right but failed when it came to scalability and consistent developer experience. {\bfseries Hawk} addresses it by requiring the client to sync its clock, but provides it with tools to accomplish it.

In general, replay protection is a matter of application-\/specific threat model. It is less of an issue on a T\+L\+S-\/protected system where the clients are implemented using best practices and are under the control of the server. Instead of dropping replay protection, {\bfseries Hawk} offers a required time window and an optional nonce verification. Together, it provides developers with the ability to decide how to enforce their security policy without impacting the client\textquotesingle{}s implementation.

\subsubsection*{What are {\ttfamily app} and {\ttfamily dlg} in the authorization header and normalized mac string?}

The original motivation for {\bfseries Hawk} was to replace the O\+Auth 1.\+0 use cases. This included both a simple client-\/server mode which this module is specifically designed for, and a delegated access mode which is being developed separately in \href{https://github.com/hueniverse/oz}{\tt Oz}. In addition to the {\bfseries Hawk} use cases, Oz requires another attribute\+: the application id {\ttfamily app}. This provides binding between the credentials and the application in a way that prevents an attacker from tricking an application to use credentials issued to someone else. It also has an optional \textquotesingle{}delegated-\/by\textquotesingle{} attribute {\ttfamily dlg} which is the application id of the application the credentials were directly issued to. The goal of these two additions is to allow Oz to utilize {\bfseries Hawk} directly, but with the additional security of delegated credentials.

\subsubsection*{What is the purpose of the static strings used in each normalized M\+A\+C input?}

When calculating a hash or M\+A\+C, a static prefix (tag) is added. The prefix is used to prevent M\+A\+C values from being used or reused for a purpose other than what they were created for (i.\+e. prevents switching M\+A\+C values between a request, response, and a bewit use cases). It also protects against expliots created after a potential change in how the protocol creates the normalized string. For example, if a future version would switch the order of nonce and timestamp, it can create an exploit opportunity for cases where the nonce is similar in format to a timestamp.

\subsubsection*{Does {\bfseries Hawk} have anything to do with O\+Auth?}

Short answer\+: no.

{\bfseries Hawk} was originally proposed as the O\+Auth M\+A\+C Token specification. However, the O\+Auth working group in its consistent incompetence failed to produce a final, usable solution to address one of the most popular use cases of O\+Auth 1.\+0 -\/ using it to authenticate simple client-\/server transactions (i.\+e. two-\/legged). As you can guess, the O\+Auth working group is still hard at work to produce more garbage.

{\bfseries Hawk} provides a simple H\+T\+T\+P authentication scheme for making client-\/server requests. It does not address the O\+Auth use case of delegating access to a third party. If you are looking for an O\+Auth alternative, check out \href{https://github.com/hueniverse/oz}{\tt Oz}.

\section*{Acknowledgements}

{\bfseries Hawk} is a derivative work of the \href{http://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05}{\tt H\+T\+T\+P M\+A\+C Authentication Scheme} proposal co-\/authored by Ben Adida, Adam Barth, and Eran Hammer, which in turn was based on the O\+Auth 1.\+0 community specification.

Special thanks to Ben Laurie for his always insightful feedback and advice.

The {\bfseries Hawk} logo was created by \href{http://chriscarrasco.com}{\tt Chris Carrasco}. 