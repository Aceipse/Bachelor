\href{https://nodei.co/npm/request/}{\tt !\mbox{[}N\+P\+M\mbox{]}(https\+://nodei.\+co/npm/request.\+png?downloads=true\&download\+Rank=true\&stars=true)}

\subsection*{Super simple to use}

Request is designed to be the simplest way possible to make http calls. It supports H\+T\+T\+P\+S and follows redirects by default.


\begin{DoxyCode}
1 var request = require('request');
2 request('http://www.google.com', function (error, response, body) \{
3   if (!error && response.statusCode == 200) \{
4     console.log(body) // Print the google web page.
5   \}
6 \})
\end{DoxyCode}


\subsection*{Streaming}

You can stream any response to a file stream.


\begin{DoxyCode}
1 request('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'))
\end{DoxyCode}


You can also stream a file to a P\+U\+T or P\+O\+S\+T request. This method will also check the file extension against a mapping of file extensions to content-\/types (in this case {\ttfamily application/json}) and use the proper {\ttfamily content-\/type} in the P\+U\+T request (if the headers don’t already provide one).


\begin{DoxyCode}
1 fs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'))
\end{DoxyCode}


Request can also {\ttfamily pipe} to itself. When doing so, {\ttfamily content-\/type} and {\ttfamily content-\/length} are preserved in the P\+U\+T headers.


\begin{DoxyCode}
1 request.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'))
\end{DoxyCode}


Now let’s get fancy.


\begin{DoxyCode}
1 http.createServer(function (req, resp) \{
2   if (req.url === '/doodle.png') \{
3     if (req.method === 'PUT') \{
4       req.pipe(request.put('http://mysite.com/doodle.png'))
5     \} else if (req.method === 'GET' || req.method === 'HEAD') \{
6       request.get('http://mysite.com/doodle.png').pipe(resp)
7     \}
8   \}
9 \})
\end{DoxyCode}


You can also {\ttfamily pipe()} from {\ttfamily http.\+Server\+Request} instances, as well as to {\ttfamily http.\+Server\+Response} instances. The H\+T\+T\+P method, headers, and entity-\/body data will be sent. Which means that, if you don\textquotesingle{}t really care about security, you can do\+:


\begin{DoxyCode}
1 http.createServer(function (req, resp) \{
2   if (req.url === '/doodle.png') \{
3     var x = request('http://mysite.com/doodle.png')
4     req.pipe(x)
5     x.pipe(resp)
6   \}
7 \})
\end{DoxyCode}


And since {\ttfamily pipe()} returns the destination stream in ≥ Node 0.\+5.\+x you can do one line proxying. \+:)


\begin{DoxyCode}
1 req.pipe(request('http://mysite.com/doodle.png')).pipe(resp)
\end{DoxyCode}


Also, none of this new functionality conflicts with requests previous features, it just expands them.


\begin{DoxyCode}
1 var r = request.defaults(\{'proxy':'http://localproxy.com'\})
2 
3 http.createServer(function (req, resp) \{
4   if (req.url === '/doodle.png') \{
5     r.get('http://google.com/doodle.png').pipe(resp)
6   \}
7 \})
\end{DoxyCode}


You can still use intermediate proxies, the requests will still follow H\+T\+T\+P forwards, etc.

\subsection*{Proxies}

If you specify a {\ttfamily proxy} option, then the request (and any subsequent redirects) will be sent via a connection to the proxy server.

If your endpoint is an {\ttfamily https} url, and you are using a proxy, then request will send a {\ttfamily C\+O\+N\+N\+E\+C\+T} request to the proxy server {\itshape first}, and then use the supplied connection to connect to the endpoint.

That is, first it will make a request like\+:


\begin{DoxyCode}
1 HTTP/1.1 CONNECT endpoint-server.com:80
2 Host: proxy-server.com
3 User-Agent: whatever user agent you specify
\end{DoxyCode}


and then the proxy server make a T\+C\+P connection to {\ttfamily endpoint-\/server} on port {\ttfamily 80}, and return a response that looks like\+:


\begin{DoxyCode}
1 HTTP/1.1 200 OK
\end{DoxyCode}


At this point, the connection is left open, and the client is communicating directly with the {\ttfamily endpoint-\/server.\+com} machine.

See (the wikipedia page on H\+T\+T\+P Tunneling)\mbox{[}\href{http://en.wikipedia.org/wiki/HTTP_tunnel}{\tt http\+://en.\+wikipedia.\+org/wiki/\+H\+T\+T\+P\+\_\+tunnel}\mbox{]} for more information.

By default, when proxying {\ttfamily http} traffic, request will simply make a standard proxied {\ttfamily http} request. This is done by making the {\ttfamily url} section of the initial line of the request a fully qualified url to the endpoint.

For example, it will make a single request that looks like\+:


\begin{DoxyCode}
1 HTTP/1.1 GET http://endpoint-server.com/some-url
2 Host: proxy-server.com
3 Other-Headers: all go here
4 
5 request body or whatever
\end{DoxyCode}


Because a pure \char`\"{}http over http\char`\"{} tunnel offers no additional security or other features, it is generally simpler to go with a straightforward H\+T\+T\+P proxy in this case. However, if you would like to force a tunneling proxy, you may set the {\ttfamily tunnel} option to {\ttfamily true}.

If you are using a tunneling proxy, you may set the {\ttfamily proxy\+Header\+White\+List} to share certain headers with the proxy.

By default, this set is\+:


\begin{DoxyCode}
1 accept
2 accept-charset
3 accept-encoding
4 accept-language
5 accept-ranges
6 cache-control
7 content-encoding
8 content-language
9 content-length
10 content-location
11 content-md5
12 content-range
13 content-type
14 connection
15 date
16 expect
17 max-forwards
18 pragma
19 proxy-authorization
20 referer
21 te
22 transfer-encoding
23 user-agent
24 via
\end{DoxyCode}


Note that, when using a tunneling proxy, the {\ttfamily proxy-\/authorization} header is {\itshape never} sent to the endpoint server, but only to the proxy server. All other headers are sent as-\/is over the established connection.

\subsection*{U\+N\+I\+X Socket}

{\ttfamily request} supports the {\ttfamily unix\+://} protocol for all requests. The path is assumed to be absolute to the root of the host file system.

H\+T\+T\+P paths are extracted from the supplied U\+R\+L by testing each level of the full U\+R\+L against net.\+connect for a socket response.

Thus the following request will G\+E\+T {\ttfamily /httppath} from the H\+T\+T\+P server listening on {\ttfamily /tmp/unix.socket}


\begin{DoxyCode}
1 request.get('unix://tmp/unix.socket/httppath')
\end{DoxyCode}


\subsection*{Forms}

{\ttfamily request} supports {\ttfamily application/x-\/www-\/form-\/urlencoded} and {\ttfamily multipart/form-\/data} form uploads. For {\ttfamily multipart/related} refer to the {\ttfamily multipart} A\+P\+I.

U\+R\+L-\/encoded forms are simple.


\begin{DoxyCode}
1 request.post('http://service.com/upload', \{form:\{key:'value'\}\})
2 // or
3 request.post('http://service.com/upload').form(\{key:'value'\})
\end{DoxyCode}


For {\ttfamily multipart/form-\/data} we use the \href{https://github.com/felixge/node-form-data}{\tt form-\/data} library by \href{https://github.com/felixge}{\tt }. You don’t need to worry about piping the form object or setting the headers, {\ttfamily request} will handle that for you.


\begin{DoxyCode}
1 var r = request.post('http://service.com/upload', function optionalCallback (err, httpResponse, body) \{
2   if (err) \{
3     return console.error('upload failed:', err);
4   \}
5   console.log('Upload successful!  Server responded with:', body);
6 \})
7 var form = r.form()
8 form.append('my\_field', 'my\_value')
9 form.append('my\_buffer', new Buffer([1, 2, 3]))
10 form.append('my\_file', fs.createReadStream(path.join(\_\_dirname, 'doodle.png')))
11 form.append('remote\_file', request('http://google.com/doodle.png'))
12 
13 // Just like always, `r` is a writable stream, and can be used as such (you have until nextTick to pipe it,
       etc.)
14 // Alternatively, you can provide a callback (that's what this example does — see `optionalCallback`
       above).
\end{DoxyCode}


\subsection*{H\+T\+T\+P Authentication}


\begin{DoxyCode}
1 request.get('http://some.server.com/').auth('username', 'password', false);
2 // or
3 request.get('http://some.server.com/', \{
4   'auth': \{
5     'user': 'username',
6     'pass': 'password',
7     'sendImmediately': false
8   \}
9 \});
10 // or
11 request.get('http://some.server.com/').auth(null, null, true, 'bearerToken');
12 // or
13 request.get('http://some.server.com/', \{
14   'auth': \{
15     'bearer': 'bearerToken'
16   \}
17 \});
\end{DoxyCode}


If passed as an option, {\ttfamily auth} should be a hash containing values {\ttfamily user} $\vert$$\vert$ {\ttfamily username}, {\ttfamily pass} $\vert$$\vert$ {\ttfamily password}, and {\ttfamily send\+Immediately} (optional). The method form takes parameters {\ttfamily auth(username, password, send\+Immediately)}.

{\ttfamily send\+Immediately} defaults to {\ttfamily true}, which causes a basic authentication header to be sent. If {\ttfamily send\+Immediately} is {\ttfamily false}, then {\ttfamily request} will retry with a proper authentication header after receiving a {\ttfamily 401} response from the server (which must contain a {\ttfamily W\+W\+W-\/\+Authenticate} header indicating the required authentication method).

Note that you can also use for basic authentication a trick using the U\+R\+L itself, as specified in \href{http://www.ietf.org/rfc/rfc1738.txt}{\tt R\+F\+C 1738}. Simply pass the {\ttfamily user\+:password} before the host with an {\ttfamily @} sign.


\begin{DoxyCode}
1 var username = 'username',
2     password = 'password',
3     url = 'http://' + username + ':' + password + '@some.server.com';
4 
5 request(\{url: url\}, function (error, response, body) \{
6    // Do more stuff with 'body' here
7 \});
\end{DoxyCode}


Digest authentication is supported, but it only works with {\ttfamily send\+Immediately} set to {\ttfamily false}; otherwise {\ttfamily request} will send basic authentication on the initial request, which will probably cause the request to fail.

Bearer authentication is supported, and is activated when the {\ttfamily bearer} value is available. The value may be either a {\ttfamily String} or a {\ttfamily Function} returning a {\ttfamily String}. Using a function to supply the bearer token is particularly useful if used in conjuction with {\ttfamily defaults} to allow a single function to supply the last known token at the time or sending a request or to compute one on the fly.

\subsection*{O\+Auth Signing}


\begin{DoxyCode}
1 // Twitter OAuth
2 var qs = require('querystring')
3   , oauth =
4     \{ callback: 'http://mysite.com/callback/'
5     , consumer\_key: CONSUMER\_KEY
6     , consumer\_secret: CONSUMER\_SECRET
7     \}
8   , url = 'https://api.twitter.com/oauth/request\_token'
9   ;
10 request.post(\{url:url, oauth:oauth\}, function (e, r, body) \{
11   // Ideally, you would take the body in the response
12   // and construct a URL that a user clicks on (like a sign in button).
13   // The verifier is only available in the response after a user has
14   // verified with twitter that they are authorizing your app.
15   var access\_token = qs.parse(body)
16     , oauth =
17       \{ consumer\_key: CONSUMER\_KEY
18       , consumer\_secret: CONSUMER\_SECRET
19       , token: access\_token.oauth\_token
20       , verifier: access\_token.oauth\_verifier
21       \}
22     , url = 'https://api.twitter.com/oauth/access\_token'
23     ;
24   request.post(\{url:url, oauth:oauth\}, function (e, r, body) \{
25     var perm\_token = qs.parse(body)
26       , oauth =
27         \{ consumer\_key: CONSUMER\_KEY
28         , consumer\_secret: CONSUMER\_SECRET
29         , token: perm\_token.oauth\_token
30         , token\_secret: perm\_token.oauth\_token\_secret
31         \}
32       , url = 'https://api.twitter.com/1.1/users/show.json?'
33       , params =
34         \{ screen\_name: perm\_token.screen\_name
35         , user\_id: perm\_token.user\_id
36         \}
37       ;
38     url += qs.stringify(params)
39     request.get(\{url:url, oauth:oauth, json:true\}, function (e, r, user) \{
40       console.log(user)
41     \})
42   \})
43 \})
\end{DoxyCode}


\subsection*{Custom H\+T\+T\+P Headers}

H\+T\+T\+P Headers, such as {\ttfamily User-\/\+Agent}, can be set in the {\ttfamily options} object. In the example below, we call the github A\+P\+I to find out the number of stars and forks for the request repository. This requires a custom {\ttfamily User-\/\+Agent} header as well as https.


\begin{DoxyCode}
1 var request = require('request');
2 
3 var options = \{
4     url: 'https://api.github.com/repos/mikeal/request',
5     headers: \{
6         'User-Agent': 'request'
7     \}
8 \};
9 
10 function callback(error, response, body) \{
11     if (!error && response.statusCode == 200) \{
12         var info = JSON.parse(body);
13         console.log(info.stargazers\_count + " Stars");
14         console.log(info.forks\_count + " Forks");
15     \}
16 \}
17 
18 request(options, callback);
\end{DoxyCode}


\subsection*{request(options, callback)}

The first argument can be either a {\ttfamily url} or an {\ttfamily options} object. The only required option is {\ttfamily uri}; all others are optional.


\begin{DoxyItemize}
\item {\ttfamily uri} $\vert$$\vert$ {\ttfamily url} -\/ fully qualified uri or a parsed url object from {\ttfamily url.\+parse()}
\item {\ttfamily qs} -\/ object containing querystring values to be appended to the {\ttfamily uri}
\item {\ttfamily method} -\/ http method (default\+: {\ttfamily \char`\"{}\+G\+E\+T\char`\"{}})
\item {\ttfamily headers} -\/ http headers (default\+: {\ttfamily \{\}})
\item {\ttfamily body} -\/ entity body for P\+A\+T\+C\+H, P\+O\+S\+T and P\+U\+T requests. Must be a {\ttfamily Buffer} or {\ttfamily String}.
\item {\ttfamily form} -\/ when passed an object or a querystring, this sets {\ttfamily body} to a querystring representation of value, and adds {\ttfamily Content-\/type\+: application/x-\/www-\/form-\/urlencoded; charset=utf-\/8} header. When passed no options, a {\ttfamily Form\+Data} instance is returned (and is piped to request).
\item {\ttfamily auth} -\/ A hash containing values {\ttfamily user} $\vert$$\vert$ {\ttfamily username}, {\ttfamily pass} $\vert$$\vert$ {\ttfamily password}, and {\ttfamily send\+Immediately} (optional). See documentation above.
\item {\ttfamily json} -\/ sets {\ttfamily body} but to J\+S\+O\+N representation of value and adds {\ttfamily Content-\/type\+: application/json} header. Additionally, parses the response body as J\+S\+O\+N.
\item {\ttfamily multipart} -\/ (experimental) array of objects which contains their own headers and {\ttfamily body} attribute. Sends {\ttfamily multipart/related} request. See example below.
\item {\ttfamily follow\+Redirect} -\/ follow H\+T\+T\+P 3xx responses as redirects (default\+: {\ttfamily true}). This property can also be implemented as function which gets {\ttfamily response} object as a single argument and should return {\ttfamily true} if redirects should continue or {\ttfamily false} otherwise.
\item {\ttfamily follow\+All\+Redirects} -\/ follow non-\/\+G\+E\+T H\+T\+T\+P 3xx responses as redirects (default\+: {\ttfamily false})
\item {\ttfamily max\+Redirects} -\/ the maximum number of redirects to follow (default\+: {\ttfamily 10})
\item {\ttfamily encoding} -\/ Encoding to be used on {\ttfamily set\+Encoding} of response data. If {\ttfamily null}, the {\ttfamily body} is returned as a {\ttfamily Buffer}.
\item {\ttfamily pool} -\/ A hash object containing the agents for these requests. If omitted, the request will use the global pool (which is set to node\textquotesingle{}s default {\ttfamily max\+Sockets})
\item {\ttfamily pool.\+max\+Sockets} -\/ Integer containing the maximum amount of sockets in the pool.
\item {\ttfamily timeout} -\/ Integer containing the number of milliseconds to wait for a request to respond before aborting the request
\item {\ttfamily proxy} -\/ An H\+T\+T\+P proxy to be used. Supports proxy Auth with Basic Auth, identical to support for the {\ttfamily url} parameter (by embedding the auth info in the {\ttfamily uri})
\item {\ttfamily oauth} -\/ Options for O\+Auth H\+M\+A\+C-\/\+S\+H\+A1 signing. See documentation above.
\item {\ttfamily hawk} -\/ Options for \href{https://github.com/hueniverse/hawk}{\tt Hawk signing}. The {\ttfamily credentials} key must contain the necessary signing info, \href{https://github.com/hueniverse/hawk#usage-example}{\tt see hawk docs for details}.
\item {\ttfamily strict\+S\+S\+L} -\/ If {\ttfamily true}, requires S\+S\+L certificates be valid. {\bfseries Note\+:} to use your own certificate authority, you need to specify an agent that was created with that C\+A as an option.
\item {\ttfamily jar} -\/ If {\ttfamily true} and {\ttfamily tough-\/cookie} is installed, remember cookies for future use (or define your custom cookie jar; see examples section)
\item {\ttfamily aws} -\/ {\ttfamily object} containing A\+W\+S signing information. Should have the properties {\ttfamily key}, {\ttfamily secret}. Also requires the property {\ttfamily bucket}, unless you’re specifying your {\ttfamily bucket} as part of the path, or the request doesn’t use a bucket (i.\+e. G\+E\+T Services)
\item {\ttfamily http\+Signature} -\/ Options for the https\+://github.com/joyent/node-\/http-\/signature/blob/master/http\+\_\+signing.\+md \char`\"{}\+H\+T\+T\+P Signature Scheme\char`\"{} using \href{https://github.com/joyent/node-http-signature}{\tt Joyent\textquotesingle{}s library}. The {\ttfamily key\+Id} and {\ttfamily key} properties must be specified. See the docs for other options.
\item {\ttfamily local\+Address} -\/ Local interface to bind for network connections.
\item {\ttfamily gzip} -\/ If {\ttfamily true}, add an {\ttfamily Accept-\/\+Encoding} header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response.
\item {\ttfamily tunnel} -\/ If {\ttfamily true}, then {\itshape always} use a tunneling proxy. If {\ttfamily false} (default), then tunneling will only be used if the destination is {\ttfamily https}, or if a previous request in the redirect chain used a tunneling proxy.
\item {\ttfamily proxy\+Header\+White\+List} -\/ A whitelist of headers to send to a tunneling proxy.
\end{DoxyItemize}

The callback argument gets 3 arguments\+:


\begin{DoxyEnumerate}
\item An {\ttfamily error} when applicable (usually from \href{http://nodejs.org/api/http.html#http_class_http_clientrequest}{\tt `http.Client\+Request`} object)
\item An \href{http://nodejs.org/api/http.html#http_http_incomingmessage}{\tt `http.Incoming\+Message`} object
\item The third is the {\ttfamily response} body ({\ttfamily String} or {\ttfamily Buffer}, or J\+S\+O\+N object if the {\ttfamily json} option is supplied)
\end{DoxyEnumerate}

\subsection*{Convenience methods}

There are also shorthand methods for different H\+T\+T\+P M\+E\+T\+H\+O\+Ds and some other conveniences.

\subsubsection*{request.\+defaults(options)}

This method returns a wrapper around the normal request A\+P\+I that defaults to whatever options you pass in to it.

{\bfseries Note\+:} You can call {\ttfamily .defaults()} on the wrapper that is returned from {\ttfamily request.\+defaults} to add/override defaults that were previously defaulted.

For example\+: 
\begin{DoxyCode}
1 //requests using baseRequest() will set the 'x-token' header
2 var baseRequest = request.defaults(\{
3   headers: \{x-token: 'my-token'\}
4 \})
5 
6 //requests using specialRequest() will include the 'x-token' header set in
7 //baseRequest and will also include the 'special' header
8 var specialRequest = baseRequest.defaults(\{
9   headers: \{special: 'special value'\}
10 \})
\end{DoxyCode}


\subsubsection*{request.\+put}

Same as {\ttfamily request()}, but defaults to {\ttfamily method\+: \char`\"{}\+P\+U\+T\char`\"{}}.


\begin{DoxyCode}
1 request.put(url)
\end{DoxyCode}


\subsubsection*{request.\+patch}

Same as {\ttfamily request()}, but defaults to {\ttfamily method\+: \char`\"{}\+P\+A\+T\+C\+H\char`\"{}}.


\begin{DoxyCode}
1 request.patch(url)
\end{DoxyCode}


\subsubsection*{request.\+post}

Same as {\ttfamily request()}, but defaults to {\ttfamily method\+: \char`\"{}\+P\+O\+S\+T\char`\"{}}.


\begin{DoxyCode}
1 request.post(url)
\end{DoxyCode}


\subsubsection*{request.\+head}

Same as request() but defaults to {\ttfamily method\+: \char`\"{}\+H\+E\+A\+D\char`\"{}}.


\begin{DoxyCode}
1 request.head(url)
\end{DoxyCode}


\subsubsection*{request.\+del}

Same as {\ttfamily request()}, but defaults to {\ttfamily method\+: \char`\"{}\+D\+E\+L\+E\+T\+E\char`\"{}}.


\begin{DoxyCode}
1 request.del(url)
\end{DoxyCode}


\subsubsection*{request.\+get}

Same as {\ttfamily request()} (for uniformity).


\begin{DoxyCode}
1 request.get(url)
\end{DoxyCode}
 \subsubsection*{request.\+cookie}

Function that creates a new cookie.


\begin{DoxyCode}
1 request.cookie('cookie\_string\_here')
\end{DoxyCode}
 \subsubsection*{request.\+jar}

Function that creates a new cookie jar.


\begin{DoxyCode}
1 request.jar()
\end{DoxyCode}


\subsection*{Examples\+:}


\begin{DoxyCode}
1 var request = require('request')
2   , rand = Math.floor(Math.random()*100000000).toString()
3   ;
4 request(
5   \{ method: 'PUT'
6   , uri: 'http://mikeal.iriscouch.com/testjs/' + rand
7   , multipart:
8     [ \{ 'content-type': 'application/json'
9       ,  body: JSON.stringify(\{foo: 'bar', \_attachments: \{'message.txt': \{follows: true, length: 18,
       'content\_type': 'text/plain' \}\}\})
10       \}
11     , \{ body: 'I am an attachment' \}
12     ]
13   \}
14 , function (error, response, body) \{
15     if(response.statusCode == 201)\{
16       console.log('document saved as: http://mikeal.iriscouch.com/testjs/'+ rand)
17     \} else \{
18       console.log('error: '+ response.statusCode)
19       console.log(body)
20     \}
21   \}
22 )
\end{DoxyCode}


Cookies are disabled by default (else, they would be used in subsequent requests). To enable cookies, set {\ttfamily jar} to {\ttfamily true} (either in {\ttfamily defaults} or {\ttfamily options}) and install {\ttfamily tough-\/cookie}.


\begin{DoxyCode}
1 var request = request.defaults(\{jar: true\})
2 request('http://www.google.com', function () \{
3   request('http://images.google.com')
4 \})
\end{DoxyCode}


To use a custom cookie jar (instead of {\ttfamily request}’s global cookie jar), set {\ttfamily jar} to an instance of {\ttfamily request.\+jar()} (either in {\ttfamily defaults} or {\ttfamily options})


\begin{DoxyCode}
1 var j = request.jar()
2 var request = request.defaults(\{jar:j\})
3 request('http://www.google.com', function () \{
4   request('http://images.google.com')
5 \})
\end{DoxyCode}


O\+R


\begin{DoxyCode}
1 // `npm install --save tough-cookie` before this works
2 var j = request.jar()
3 var cookie = request.cookie('your\_cookie\_here')
4 j.setCookie(cookie, uri);
5 request(\{url: 'http://www.google.com', jar: j\}, function () \{
6   request('http://images.google.com')
7 \})
\end{DoxyCode}


To inspect your cookie jar after a request


\begin{DoxyCode}
1 var j = request.jar() 
2 request(\{url: 'http://www.google.com', jar: j\}, function () \{
3   var cookie\_string = j.getCookieString(uri); // "key1=value1; key2=value2; ..."
4   var cookies = j.getCookies(uri); 
5   // [\{key: 'key1', value: 'value1', domain: "www.google.com", ...\}, ...]
6 \})
\end{DoxyCode}


\subsection*{Debugging}

There are at least three ways to debug the operation of {\ttfamily request}\+:


\begin{DoxyEnumerate}
\item Launch the node process like {\ttfamily N\+O\+D\+E\+\_\+\+D\+E\+B\+U\+G=request node script.\+js} ({\ttfamily lib,request,otherlib} works too).
\item Set `require(\textquotesingle{}request\textquotesingle{}).debug = true` at any time (this does the same thing as \#1).
\item Use the \href{https://github.com/nylen/request-debug}{\tt request-\/debug module} to view request and response headers and bodies. 
\end{DoxyEnumerate}