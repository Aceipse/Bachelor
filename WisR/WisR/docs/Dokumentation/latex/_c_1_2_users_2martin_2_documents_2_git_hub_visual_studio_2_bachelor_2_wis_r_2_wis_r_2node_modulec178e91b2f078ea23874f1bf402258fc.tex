\hypertarget{_c_1_2_users_2martin_2_documents_2_git_hub_visual_studio_2_bachelor_2_wis_r_2_wis_r_2node_modulec178e91b2f078ea23874f1bf402258fc}{}\section{C\+:/\+Users/martin/\+Documents/\+Git\+Hub\+Visual\+Studio/\+Bachelor/\+Wis\+R/\+Wis\+R/node\+\_\+modules/grunt/node\+\_\+modules/findup-\/sync/node\+\_\+modules/lodash/dist/lodash.\+underscore.\+js}
var wrapped = \+\_\+(\mbox{[}1, 2, 3\mbox{]});

// returns an unwrapped value wrapped.\+reduce(function(sum, num) \{ return sum + num; \}); // =$>$ 6

// returns a wrapped value var squares = wrapped.\+map(function(num) \{ return num $\ast$ num; \});

\+\_\+.\+is\+Array(squares); // =$>$ false

\+\_\+.\+is\+Array(squares.\+value()); // =$>$ true


\begin{DoxyCodeInclude}

;(\textcolor{keyword}{function}() \{

  var undefined;

  var idCounter = 0;

  var indicatorObject = \{\};

  var keyPrefix = +\textcolor{keyword}{new} Date + \textcolor{stringliteral}{''};

  var reInterpolate = /<%=([\(\backslash\)s\(\backslash\)S]+?)%>/g;

  var reNoMatch = /($^)/;

  var reUnescapedString = /[\textcolor{stringliteral}{'\(\backslash\)n\(\backslash\)r\(\backslash\)t\(\backslash\)u2028\(\backslash\)u2029\(\backslash\)\(\backslash\)]/g;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var argsClass = '}[\textcolor{keywordtype}{object} Arguments]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      arrayClass = '}[\textcolor{keywordtype}{object} Array]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      boolClass = '}[\textcolor{keywordtype}{object} Boolean]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      dateClass = '}[\textcolor{keywordtype}{object} Date]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      funcClass = '}[\textcolor{keywordtype}{object} Function]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      numberClass = '}[\textcolor{keywordtype}{object} Number]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      objectClass = '}[\textcolor{keywordtype}{object} Object]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      regexpClass = '}[\textcolor{keywordtype}{object} RegExp]\textcolor{stringliteral}{',}
\textcolor{stringliteral}{      stringClass = '}[\textcolor{keywordtype}{object} String]\textcolor{stringliteral}{';}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var objectTypes = \{}
\textcolor{stringliteral}{    '}\textcolor{keywordtype}{boolean}\textcolor{stringliteral}{': false,}
\textcolor{stringliteral}{    '}\textcolor{keyword}{function}\textcolor{stringliteral}{': true,}
\textcolor{stringliteral}{    '}\textcolor{keywordtype}{object}\textcolor{stringliteral}{': true,}
\textcolor{stringliteral}{    '}number\textcolor{stringliteral}{': false,}
\textcolor{stringliteral}{    '}\textcolor{keywordtype}{string}\textcolor{stringliteral}{': false,}
\textcolor{stringliteral}{    '}undefined\textcolor{stringliteral}{': false}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var stringEscapes = \{}
\textcolor{stringliteral}{    '}\(\backslash\)\(\backslash\)\textcolor{stringliteral}{': '}\(\backslash\)\(\backslash\)\textcolor{stringliteral}{',}
\textcolor{stringliteral}{    "'}\textcolor{stringliteral}{": "}\textcolor{stringliteral}{'",}
\textcolor{stringliteral}{    '}\(\backslash\)n\textcolor{stringliteral}{': '}n\textcolor{stringliteral}{',}
\textcolor{stringliteral}{    '}\(\backslash\)r\textcolor{stringliteral}{': '}r\textcolor{stringliteral}{',}
\textcolor{stringliteral}{    '}\(\backslash\)t\textcolor{stringliteral}{': '}t\textcolor{stringliteral}{',}
\textcolor{stringliteral}{    '}\(\backslash\)u2028\textcolor{stringliteral}{': '}u2028\textcolor{stringliteral}{',}
\textcolor{stringliteral}{    '}\(\backslash\)u2029\textcolor{stringliteral}{': '}u2029\textcolor{stringliteral}{'}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var root = (objectTypes[typeof window] && window) || this;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var freeGlobal = objectTypes[typeof global] && global;}
\textcolor{stringliteral}{  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) \{}
\textcolor{stringliteral}{    root = freeGlobal;}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  /*--------------------------------------------------------------------------*/}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function baseIndexOf(array, value, fromIndex) \{}
\textcolor{stringliteral}{    var index = (fromIndex || 0) - 1,}
\textcolor{stringliteral}{        length = array ? array.length : 0;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    while (++index < length) \{}
\textcolor{stringliteral}{      if (array[index] === value) \{}
\textcolor{stringliteral}{        return index;}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    return -1;}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function compareAscending(a, b) \{}
\textcolor{stringliteral}{    var ac = a.criteria,}
\textcolor{stringliteral}{        bc = b.criteria,}
\textcolor{stringliteral}{        index = -1,}
\textcolor{stringliteral}{        length = ac.length;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    while (++index < length) \{}
\textcolor{stringliteral}{      var value = ac[index],}
\textcolor{stringliteral}{          other = bc[index];}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{      if (value !== other) \{}
\textcolor{stringliteral}{        if (value > other || typeof value == '}undefined\textcolor{stringliteral}{') \{}
\textcolor{stringliteral}{          return 1;}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{        if (value < other || typeof other == '}undefined\textcolor{stringliteral}{') \{}
\textcolor{stringliteral}{          return -1;}
\textcolor{stringliteral}{        \}}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications}
\textcolor{stringliteral}{    // that causes it, under certain circumstances, to return the same value for}
\textcolor{stringliteral}{    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247}
\textcolor{stringliteral}{    //}
\textcolor{stringliteral}{    // This also ensures a stable sort in V8 and other engines.}
\textcolor{stringliteral}{    // See http://code.google.com/p/v8/issues/detail?id=90}
\textcolor{stringliteral}{    return a.index - b.index;}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function escapeStringChar(match) \{}
\textcolor{stringliteral}{    return '}\(\backslash\)\(\backslash\)\textcolor{stringliteral}{' + stringEscapes[match];}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function slice(array, start, end) \{}
\textcolor{stringliteral}{    start || (start = 0);}
\textcolor{stringliteral}{    if (typeof end == '}undefined\textcolor{stringliteral}{') \{}
\textcolor{stringliteral}{      end = array ? array.length : 0;}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    var index = -1,}
\textcolor{stringliteral}{        length = end - start || 0,}
\textcolor{stringliteral}{        result = Array(length < 0 ? 0 : length);}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    while (++index < length) \{}
\textcolor{stringliteral}{      result[index] = array[start + index];}
\textcolor{stringliteral}{    \}}
\textcolor{stringliteral}{    return result;}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  /*--------------------------------------------------------------------------*/}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var arrayRef = [];}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var objectProto = Object.prototype;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var oldDash = root.\_;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var toString = objectProto.toString;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var reNative = RegExp('}^\textcolor{stringliteral}{' +}
\textcolor{stringliteral}{    String(toString)}
\textcolor{stringliteral}{      .replace(/[.*+?^$\{\}()|[\(\backslash\)]\(\backslash\)\(\backslash\)]/g, '}\(\backslash\)\(\backslash\)$&\textcolor{stringliteral}{')}
\textcolor{stringliteral}{      .replace(/toString| for [^\(\backslash\)]]+/g, '}.*?\textcolor{stringliteral}{') + '}$\textcolor{stringliteral}{'}
\textcolor{stringliteral}{  );}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var ceil = Math.ceil,}
\textcolor{stringliteral}{      floor = Math.floor,}
\textcolor{stringliteral}{      hasOwnProperty = objectProto.hasOwnProperty,}
\textcolor{stringliteral}{      push = arrayRef.push,}
\textcolor{stringliteral}{      propertyIsEnumerable = objectProto.propertyIsEnumerable;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  /* Native method shortcuts for methods with the same name as other `lodash` methods */}
\textcolor{stringliteral}{  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,}
\textcolor{stringliteral}{      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,}
\textcolor{stringliteral}{      nativeIsFinite = root.isFinite,}
\textcolor{stringliteral}{      nativeIsNaN = root.isNaN,}
\textcolor{stringliteral}{      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,}
\textcolor{stringliteral}{      nativeMax = Math.max,}
\textcolor{stringliteral}{      nativeMin = Math.min,}
\textcolor{stringliteral}{      nativeRandom = Math.random;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  /*--------------------------------------------------------------------------*/}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function lodash(value) \{}
\textcolor{stringliteral}{    return (value instanceof lodash)}
\textcolor{stringliteral}{      ? value}
\textcolor{stringliteral}{      : new lodashWrapper(value);}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function lodashWrapper(value, chainAll) \{}
\textcolor{stringliteral}{    this.\_\_chain\_\_ = !!chainAll;}
\textcolor{stringliteral}{    this.\_\_wrapped\_\_ = value;}
\textcolor{stringliteral}{  \}}
\textcolor{stringliteral}{  // ensure `new lodashWrapper` is an instance of `lodash`}
\textcolor{stringliteral}{  lodashWrapper.prototype = lodash.prototype;}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  var support = \{\};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  (function() \{}
\textcolor{stringliteral}{    var object = \{ '}0\textcolor{stringliteral}{': 1, '}length\textcolor{stringliteral}{': 1 \};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);}
\textcolor{stringliteral}{  \}(1));}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  lodash.templateSettings = \{}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    '}escape\textcolor{stringliteral}{': /<%-([\(\backslash\)s\(\backslash\)S]+?)%>/g,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    '}evaluate\textcolor{stringliteral}{': /<%([\(\backslash\)s\(\backslash\)S]+?)%>/g,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    '}interpolate\textcolor{stringliteral}{': reInterpolate,}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    '}variable\textcolor{stringliteral}{': '}\textcolor{stringliteral}{'}
\textcolor{stringliteral}{  \};}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  /*--------------------------------------------------------------------------*/}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{  function baseBind(bindData) \{}
\textcolor{stringliteral}{    var func = bindData[0],}
\textcolor{stringliteral}{        partialArgs = bindData[2],}
\textcolor{stringliteral}{        thisArg = bindData[4];}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    function bound() \{}
\textcolor{stringliteral}{      // `Function#bind` spec}
\textcolor{stringliteral}{      // http://es5.github.io/#x15.3.4.5}
\textcolor{stringliteral}{      if (partialArgs) \{}
\textcolor{stringliteral}{        // avoid `arguments` object deoptimizations by using `slice` instead}
\textcolor{stringliteral}{        // of `Array.prototype.slice.call` and not assigning `arguments` to a}
\textcolor{stringliteral}{        // variable as a ternary expression}
\textcolor{stringliteral}{        var args = slice(partialArgs);}
\textcolor{stringliteral}{        push.apply(args, arguments);}
\textcolor{stringliteral}{      \}}
\textcolor{stringliteral}{      // mimic the constructor'}s `\textcolor{keywordflow}{return}` behavior
      \textcolor{comment}{// http://es5.github.io/#x13.2.2}
      \textcolor{keywordflow}{if} (\textcolor{keyword}{this} instanceof bound) \{
        \textcolor{comment}{// ensure `new bound` is an instance of `func`}
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        \textcolor{keywordflow}{return} isObject(result) ? result : thisBinding;
      \}
      \textcolor{keywordflow}{return} func.apply(thisArg, args || arguments);
    \}
    \textcolor{keywordflow}{return} bound;
  \}

  \textcolor{keyword}{function} baseCreate(prototype, properties) \{
    \textcolor{keywordflow}{return} isObject(prototype) ? nativeCreate(prototype) : \{\};
  \}
  \textcolor{comment}{// fallback for browsers without `Object.create`}
  \textcolor{keywordflow}{if} (!nativeCreate) \{
    baseCreate = (\textcolor{keyword}{function}() \{
      \textcolor{keyword}{function} Object() \{\}
      \textcolor{keywordflow}{return} \textcolor{keyword}{function}(prototype) \{
        \textcolor{keywordflow}{if} (isObject(prototype)) \{
          Object.prototype = prototype;
          var result = \textcolor{keyword}{new} Object;
          Object.prototype = null;
        \}
        \textcolor{keywordflow}{return} result || root.Object();
      \};
    \}());
  \}

  \textcolor{keyword}{function} baseCreateCallback(func, thisArg, argCount) \{
    \textcolor{keywordflow}{if} (typeof func != \textcolor{stringliteral}{'function'}) \{
      \textcolor{keywordflow}{return} identity;
    \}
    \textcolor{comment}{// exit early for no `thisArg` or already bound by `Function#bind`}
    \textcolor{keywordflow}{if} (typeof thisArg == \textcolor{stringliteral}{'undefined'} || !(\textcolor{stringliteral}{'prototype'} in func)) \{
      \textcolor{keywordflow}{return} func;
    \}
    \textcolor{keywordflow}{switch} (argCount) \{
      \textcolor{keywordflow}{case} 1: \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} func.call(thisArg, value);
      \};
      \textcolor{keywordflow}{case} 2: \textcolor{keywordflow}{return} \textcolor{keyword}{function}(a, b) \{
        \textcolor{keywordflow}{return} func.call(thisArg, a, b);
      \};
      \textcolor{keywordflow}{case} 3: \textcolor{keywordflow}{return} \textcolor{keyword}{function}(value, index, collection) \{
        \textcolor{keywordflow}{return} func.call(thisArg, value, index, collection);
      \};
      \textcolor{keywordflow}{case} 4: \textcolor{keywordflow}{return} \textcolor{keyword}{function}(accumulator, value, index, collection) \{
        \textcolor{keywordflow}{return} func.call(thisArg, accumulator, value, index, collection);
      \};
    \}
    \textcolor{keywordflow}{return} bind(func, thisArg);
  \}

  \textcolor{keyword}{function} baseCreateWrapper(bindData) \{
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    \textcolor{keyword}{function} bound() \{
      var thisBinding = isBind ? thisArg : \textcolor{keyword}{this};
      \textcolor{keywordflow}{if} (partialArgs) \{
        var args = slice(partialArgs);
        push.apply(args, arguments);
      \}
      \textcolor{keywordflow}{if} (partialRightArgs || isCurry) \{
        args || (args = slice(arguments));
        \textcolor{keywordflow}{if} (partialRightArgs) \{
          push.apply(args, partialRightArgs);
        \}
        \textcolor{keywordflow}{if} (isCurry && args.length < arity) \{
          bitmask |= 16 & ~32;
          \textcolor{keywordflow}{return} baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, 
      arity]);
        \}
      \}
      args || (args = arguments);
      \textcolor{keywordflow}{if} (isBindKey) \{
        func = thisBinding[key];
      \}
      \textcolor{keywordflow}{if} (\textcolor{keyword}{this} instanceof bound) \{
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        \textcolor{keywordflow}{return} isObject(result) ? result : thisBinding;
      \}
      \textcolor{keywordflow}{return} func.apply(thisBinding, args);
    \}
    \textcolor{keywordflow}{return} bound;
  \}

  \textcolor{keyword}{function} baseDifference(array, values) \{
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    \textcolor{keywordflow}{while} (++index < length) \{
      var value = array[index];
      \textcolor{keywordflow}{if} (indexOf(values, value) < 0) \{
        result.push(value);
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} baseFlatten(array, isShallow, isStrict, fromIndex) \{
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) \{
      var value = array[index];

      \textcolor{keywordflow}{if} (value && typeof value == \textcolor{stringliteral}{'object'} && typeof value.length == \textcolor{stringliteral}{'number'}
          && (isArray(value) || isArguments(value))) \{
        \textcolor{comment}{// recursively flatten arrays (susceptible to call stack limits)}
        \textcolor{keywordflow}{if} (!isShallow) \{
          value = baseFlatten(value, isShallow, isStrict);
        \}
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        \textcolor{keywordflow}{while} (++valIndex < valLength) \{
          result[resIndex++] = value[valIndex];
        \}
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isStrict) \{
        result.push(value);
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} baseIsEqual(a, b, stackA, stackB) \{
    \textcolor{keywordflow}{if} (a === b) \{
      \textcolor{keywordflow}{return} a !== 0 || (1 / a == 1 / b);
    \}
    var type = typeof a,
        otherType = typeof b;

    \textcolor{keywordflow}{if} (a === a &&
        !(a && objectTypes[type]) &&
        !(b && objectTypes[otherType])) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
    \textcolor{keywordflow}{if} (a == null || b == null) \{
      \textcolor{keywordflow}{return} a === b;
    \}
    var className = toString.call(a),
        otherClass = toString.call(b);

    \textcolor{keywordflow}{if} (className != otherClass) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{false};
    \}
    \textcolor{keywordflow}{switch} (className) \{
      \textcolor{keywordflow}{case} boolClass:
      \textcolor{keywordflow}{case} dateClass:
        \textcolor{keywordflow}{return} +a == +b;

      \textcolor{keywordflow}{case} numberClass:
        \textcolor{keywordflow}{return} a != +a
          ? b != +b
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      \textcolor{keywordflow}{case} regexpClass:
      \textcolor{keywordflow}{case} stringClass:
        \textcolor{keywordflow}{return} a == String(b);
    \}
    var isArr = className == arrayClass;
    \textcolor{keywordflow}{if} (!isArr) \{
      var aWrapped = a instanceof lodash,
          bWrapped = b instanceof lodash;

      \textcolor{keywordflow}{if} (aWrapped || bWrapped) \{
        \textcolor{keywordflow}{return} baseIsEqual(aWrapped ? a.\_\_wrapped\_\_ : a, bWrapped ? b.\_\_wrapped\_\_ : b, stackA, stackB);
      \}
      \textcolor{keywordflow}{if} (className != objectClass) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
      var ctorA = a.constructor,
          ctorB = b.constructor;

      \textcolor{keywordflow}{if} (ctorA != ctorB &&
            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) 
      &&
            (\textcolor{stringliteral}{'constructor'} in a && \textcolor{stringliteral}{'constructor'} in b)
          ) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
    \}
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    \textcolor{keywordflow}{while} (length--) \{
      \textcolor{keywordflow}{if} (stackA[length] == a) \{
        \textcolor{keywordflow}{return} stackB[length] == b;
      \}
    \}
    var result = \textcolor{keyword}{true},
        size = 0;

    stackA.push(a);
    stackB.push(b);

    \textcolor{keywordflow}{if} (isArr) \{
      size = b.length;
      result = size == a.length;

      \textcolor{keywordflow}{if} (result) \{
        \textcolor{keywordflow}{while} (size--) \{
          \textcolor{keywordflow}{if} (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) \{
            \textcolor{keywordflow}{break};
          \}
        \}
      \}
    \}
    \textcolor{keywordflow}{else} \{
      forIn(b, \textcolor{keyword}{function}(value, key, b) \{
        \textcolor{keywordflow}{if} (hasOwnProperty.call(b, key)) \{
          size++;
          \textcolor{keywordflow}{return} !(result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, stackA, stackB)) && 
      indicatorObject;
        \}
      \});

      \textcolor{keywordflow}{if} (result) \{
        forIn(a, \textcolor{keyword}{function}(value, key, a) \{
          \textcolor{keywordflow}{if} (hasOwnProperty.call(a, key)) \{
            \textcolor{keywordflow}{return} !(result = --size > -1) && indicatorObject;
          \}
        \});
      \}
    \}
    stackA.pop();
    stackB.pop();
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} baseRandom(min, max) \{
    \textcolor{keywordflow}{return} min + floor(nativeRandom() * (max - min + 1));
  \}

  \textcolor{keyword}{function} baseUniq(array, isSorted, callback) \{
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [],
        seen = callback ? [] : result;

    \textcolor{keywordflow}{while} (++index < length) \{
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      \textcolor{keywordflow}{if} (isSorted
            ? !index || seen[seen.length - 1] !== computed
            : indexOf(seen, computed) < 0
          ) \{
        \textcolor{keywordflow}{if} (callback) \{
          seen.push(computed);
        \}
        result.push(value);
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} createAggregator(setter) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(collection, callback, thisArg) \{
      var result = \{\};
      callback = createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
        \textcolor{keywordflow}{while} (++index < length) \{
          var value = collection[index];
          setter(result, value, callback(value, index, collection), collection);
        \}
      \} \textcolor{keywordflow}{else} \{
        forOwn(collection, \textcolor{keyword}{function}(value, key, collection) \{
          setter(result, value, callback(value, key, collection), collection);
        \});
      \}
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) \{
    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        isPartial = bitmask & 16,
        isPartialRight = bitmask & 32;

    \textcolor{keywordflow}{if} (!isBindKey && !isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    \textcolor{keywordflow}{if} (isPartial && !partialArgs.length) \{
      bitmask &= ~16;
      isPartial = partialArgs = \textcolor{keyword}{false};
    \}
    \textcolor{keywordflow}{if} (isPartialRight && !partialRightArgs.length) \{
      bitmask &= ~32;
      isPartialRight = partialRightArgs = \textcolor{keyword}{false};
    \}
    \textcolor{comment}{// fast path for `\_.bind`}
    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
    \textcolor{keywordflow}{return} creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  \}

  \textcolor{keyword}{function} escapeHtmlChar(match) \{
    \textcolor{keywordflow}{return} htmlEscapes[match];
  \}

  \textcolor{keyword}{function} getIndexOf() \{
    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} isNative(value) \{
    \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'function'} && reNative.test(value);
  \}

  \textcolor{keyword}{function} unescapeHtmlChar(match) \{
    \textcolor{keywordflow}{return} htmlUnescapes[match];
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} isArguments(value) \{
    \textcolor{keywordflow}{return} value && typeof value == \textcolor{stringliteral}{'object'} && typeof value.length == \textcolor{stringliteral}{'number'} &&
      toString.call(value) == argsClass || \textcolor{keyword}{false};
  \}
  \textcolor{comment}{// fallback for browsers that can't detect `arguments` objects by [[Class]]}
  \textcolor{keywordflow}{if} (!isArguments(arguments)) \{
    isArguments = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} value && typeof value == \textcolor{stringliteral}{'object'} && typeof value.length == \textcolor{stringliteral}{'number'} &&
        hasOwnProperty.call(value, \textcolor{stringliteral}{'callee'}) && !propertyIsEnumerable.call(value, \textcolor{stringliteral}{'callee'}) || \textcolor{keyword}{false};
    \};
  \}

  var isArray = nativeIsArray || \textcolor{keyword}{function}(value) \{
    \textcolor{keywordflow}{return} value && typeof value == \textcolor{stringliteral}{'object'} && typeof value.length == \textcolor{stringliteral}{'number'} &&
      toString.call(value) == arrayClass || \textcolor{keyword}{false};
  \};

  var shimKeys = \textcolor{keyword}{function}(object) \{
    var index, iterable = object, result = [];
    \textcolor{keywordflow}{if} (!iterable) \textcolor{keywordflow}{return} result;
    \textcolor{keywordflow}{if} (!(objectTypes[typeof \textcolor{keywordtype}{object}])) \textcolor{keywordflow}{return} result;
      \textcolor{keywordflow}{for} (index in iterable) \{
        \textcolor{keywordflow}{if} (hasOwnProperty.call(iterable, index)) \{
          result.push(index);
        \}
      \}
    \textcolor{keywordflow}{return} result
  \};

  var keys = !nativeKeys ? shimKeys : \textcolor{keyword}{function}(object) \{
    \textcolor{keywordflow}{if} (!isObject(\textcolor{keywordtype}{object})) \{
      \textcolor{keywordflow}{return} [];
    \}
    \textcolor{keywordflow}{return} nativeKeys(\textcolor{keywordtype}{object});
  \};

  var htmlEscapes = \{
    \textcolor{charliteral}{'&'}: \textcolor{stringliteral}{'&amp;'},
    \textcolor{charliteral}{'<'}: \textcolor{stringliteral}{'&lt;'},
    \textcolor{charliteral}{'>'}: \textcolor{stringliteral}{'&gt;'},
    \textcolor{charliteral}{'"'}: \textcolor{stringliteral}{'&quot;'},
    \textcolor{stringliteral}{"'"}: \textcolor{stringliteral}{'&#x27;'}
  \};

  var htmlUnescapes = invert(htmlEscapes);

  var reEscapedHtml = RegExp(\textcolor{charliteral}{'('} + keys(htmlUnescapes).join(\textcolor{charliteral}{'|'}) + \textcolor{charliteral}{')'}, \textcolor{charliteral}{'g'}),
      reUnescapedHtml = RegExp(\textcolor{charliteral}{'['} + keys(htmlEscapes).join(\textcolor{stringliteral}{''}) + \textcolor{charliteral}{']'}, \textcolor{charliteral}{'g'});

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} assign(\textcolor{keywordtype}{object}) \{
    \textcolor{keywordflow}{if} (!\textcolor{keywordtype}{object}) \{
      \textcolor{keywordflow}{return} object;
    \}
    \textcolor{keywordflow}{for} (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) \{
      var iterable = arguments[argsIndex];
      \textcolor{keywordflow}{if} (iterable) \{
        \textcolor{keywordflow}{for} (var key in iterable) \{
          \textcolor{keywordtype}{object}[key] = iterable[key];
        \}
      \}
    \}
    \textcolor{keywordflow}{return} object;
  \}

  \textcolor{keyword}{function} clone(value) \{
    \textcolor{keywordflow}{return} isObject(value)
      ? (isArray(value) ? slice(value) : assign(\{\}, value))
      : value;
  \}

  \textcolor{keyword}{function} defaults(\textcolor{keywordtype}{object}) \{
    \textcolor{keywordflow}{if} (!\textcolor{keywordtype}{object}) \{
      \textcolor{keywordflow}{return} object;
    \}
    \textcolor{keywordflow}{for} (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) \{
      var iterable = arguments[argsIndex];
      \textcolor{keywordflow}{if} (iterable) \{
        \textcolor{keywordflow}{for} (var key in iterable) \{
          \textcolor{keywordflow}{if} (typeof \textcolor{keywordtype}{object}[key] == \textcolor{stringliteral}{'undefined'}) \{
            \textcolor{keywordtype}{object}[key] = iterable[key];
          \}
        \}
      \}
    \}
    \textcolor{keywordflow}{return} object;
  \}

  var forIn = \textcolor{keyword}{function}(collection, callback) \{
    var index, iterable = collection, result = iterable;
    \textcolor{keywordflow}{if} (!iterable) \textcolor{keywordflow}{return} result;
    \textcolor{keywordflow}{if} (!objectTypes[typeof iterable]) \textcolor{keywordflow}{return} result;
      \textcolor{keywordflow}{for} (index in iterable) \{
        \textcolor{keywordflow}{if} (callback(iterable[index], index, collection) === indicatorObject) \textcolor{keywordflow}{return} result;
      \}
    \textcolor{keywordflow}{return} result
  \};

  var forOwn = \textcolor{keyword}{function}(collection, callback) \{
    var index, iterable = collection, result = iterable;
    \textcolor{keywordflow}{if} (!iterable) \textcolor{keywordflow}{return} result;
    \textcolor{keywordflow}{if} (!objectTypes[typeof iterable]) \textcolor{keywordflow}{return} result;
      \textcolor{keywordflow}{for} (index in iterable) \{
        \textcolor{keywordflow}{if} (hasOwnProperty.call(iterable, index)) \{
          \textcolor{keywordflow}{if} (callback(iterable[index], index, collection) === indicatorObject) \textcolor{keywordflow}{return} result;
        \}
      \}
    \textcolor{keywordflow}{return} result
  \};

  \textcolor{keyword}{function} functions(\textcolor{keywordtype}{object}) \{
    var result = [];
    forIn(\textcolor{keywordtype}{object}, \textcolor{keyword}{function}(value, key) \{
      \textcolor{keywordflow}{if} (isFunction(value)) \{
        result.push(key);
      \}
    \});
    \textcolor{keywordflow}{return} result.sort();
  \}

  \textcolor{keyword}{function} has(\textcolor{keywordtype}{object}, key) \{
    \textcolor{keywordflow}{return} \textcolor{keywordtype}{object} ? hasOwnProperty.call(\textcolor{keywordtype}{object}, key) : \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} invert(\textcolor{keywordtype}{object}) \{
    var index = -1,
        props = keys(\textcolor{keywordtype}{object}),
        length = props.length,
        result = \{\};

    \textcolor{keywordflow}{while} (++index < length) \{
      var key = props[index];
      result[\textcolor{keywordtype}{object}[key]] = key;
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} isBoolean(value) \{
    \textcolor{keywordflow}{return} value === \textcolor{keyword}{true} || value === \textcolor{keyword}{false} ||
      value && typeof value == \textcolor{stringliteral}{'object'} && toString.call(value) == boolClass || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isDate(value) \{
    \textcolor{keywordflow}{return} value && typeof value == \textcolor{stringliteral}{'object'} && toString.call(value) == dateClass || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isElement(value) \{
    \textcolor{keywordflow}{return} value && value.nodeType === 1 || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isEmpty(value) \{
    \textcolor{keywordflow}{if} (!value) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{if} (isArray(value) || isString(value)) \{
      \textcolor{keywordflow}{return} !value.length;
    \}
    \textcolor{keywordflow}{for} (var key in value) \{
      \textcolor{keywordflow}{if} (hasOwnProperty.call(value, key)) \{
        \textcolor{keywordflow}{return} \textcolor{keyword}{false};
      \}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}

  \textcolor{keyword}{function} isEqual(a, b) \{
    \textcolor{keywordflow}{return} baseIsEqual(a, b);
  \}

  \textcolor{keyword}{function} isFinite(value) \{
    \textcolor{keywordflow}{return} nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
  \}

  \textcolor{keyword}{function} isFunction(value) \{
    \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'function'};
  \}
  \textcolor{comment}{// fallback for older versions of Chrome and Safari}
  \textcolor{keywordflow}{if} (isFunction(/x/)) \{
    isFunction = \textcolor{keyword}{function}(value) \{
      \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'function'} && toString.call(value) == funcClass;
    \};
  \}

  \textcolor{keyword}{function} isObject(value) \{
    \textcolor{comment}{// check if the value is the ECMAScript language type of Object}
    \textcolor{comment}{// http://es5.github.io/#x8}
    \textcolor{comment}{// and avoid a V8 bug}
    \textcolor{comment}{// http://code.google.com/p/v8/issues/detail?id=2291}
    \textcolor{keywordflow}{return} !!(value && objectTypes[typeof value]);
  \}

  \textcolor{keyword}{function} isNaN(value) \{
    \textcolor{comment}{// `NaN` as a primitive is the only value that is not equal to itself}
    \textcolor{comment}{// (perform the [[Class]] check first to avoid errors with some host objects in IE)}
    \textcolor{keywordflow}{return} isNumber(value) && value != +value;
  \}

  \textcolor{keyword}{function} isNull(value) \{
    \textcolor{keywordflow}{return} value === null;
  \}

  \textcolor{keyword}{function} isNumber(value) \{
    \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'number'} ||
      value && typeof value == \textcolor{stringliteral}{'object'} && toString.call(value) == numberClass || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isRegExp(value) \{
    \textcolor{keywordflow}{return} value && objectTypes[typeof value] && toString.call(value) == regexpClass || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isString(value) \{
    \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'string'} ||
      value && typeof value == \textcolor{stringliteral}{'object'} && toString.call(value) == stringClass || \textcolor{keyword}{false};
  \}

  \textcolor{keyword}{function} isUndefined(value) \{
    \textcolor{keywordflow}{return} typeof value == \textcolor{stringliteral}{'undefined'};
  \}

  \textcolor{keyword}{function} omit(\textcolor{keywordtype}{object}) \{
    var props = [];
    forIn(\textcolor{keywordtype}{object}, \textcolor{keyword}{function}(value, key) \{
      props.push(key);
    \});
    props = baseDifference(props, baseFlatten(arguments, \textcolor{keyword}{true}, \textcolor{keyword}{false}, 1));

    var index = -1,
        length = props.length,
        result = \{\};

    \textcolor{keywordflow}{while} (++index < length) \{
      var key = props[index];
      result[key] = \textcolor{keywordtype}{object}[key];
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} pairs(\textcolor{keywordtype}{object}) \{
    var index = -1,
        props = keys(\textcolor{keywordtype}{object}),
        length = props.length,
        result = Array(length);

    \textcolor{keywordflow}{while} (++index < length) \{
      var key = props[index];
      result[index] = [key, \textcolor{keywordtype}{object}[key]];
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} pick(\textcolor{keywordtype}{object}) \{
    var index = -1,
        props = baseFlatten(arguments, \textcolor{keyword}{true}, \textcolor{keyword}{false}, 1),
        length = props.length,
        result = \{\};

    \textcolor{keywordflow}{while} (++index < length) \{
      var key = props[index];
      \textcolor{keywordflow}{if} (key in \textcolor{keywordtype}{object}) \{
        result[key] = \textcolor{keywordtype}{object}[key];
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} values(\textcolor{keywordtype}{object}) \{
    var index = -1,
        props = keys(\textcolor{keywordtype}{object}),
        length = props.length,
        result = Array(length);

    \textcolor{keywordflow}{while} (++index < length) \{
      result[index] = \textcolor{keywordtype}{object}[props[index]];
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} contains(collection, target) \{
    var indexOf = getIndexOf(),
        length = collection ? collection.length : 0,
        result = \textcolor{keyword}{false};
    \textcolor{keywordflow}{if} (length && typeof length == \textcolor{stringliteral}{'number'}) \{
      result = indexOf(collection, target) > -1;
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, \textcolor{keyword}{function}(value) \{
        \textcolor{keywordflow}{return} (result = value === target) && indicatorObject;
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  var countBy = createAggregator(\textcolor{keyword}{function}(result, value, key) \{
    (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
  \});

  \textcolor{keyword}{function} every(collection, callback, thisArg) \{
    var result = \textcolor{keyword}{true};
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        \textcolor{keywordflow}{if} (!(result = !!callback(collection[index], index, collection))) \{
          \textcolor{keywordflow}{break};
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, \textcolor{keyword}{function}(value, index, collection) \{
        \textcolor{keywordflow}{return} !(result = !!callback(value, index, collection)) && indicatorObject;
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} filter(collection, callback, thisArg) \{
    var result = [];
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        var value = collection[index];
        \textcolor{keywordflow}{if} (callback(value, index, collection)) \{
          result.push(value);
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, \textcolor{keyword}{function}(value, index, collection) \{
        \textcolor{keywordflow}{if} (callback(value, index, collection)) \{
          result.push(value);
        \}
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} find(collection, callback, thisArg) \{
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        var value = collection[index];
        \textcolor{keywordflow}{if} (callback(value, index, collection)) \{
          \textcolor{keywordflow}{return} value;
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      var result;
      forOwn(collection, \textcolor{keyword}{function}(value, index, collection) \{
        \textcolor{keywordflow}{if} (callback(value, index, collection)) \{
          result = value;
          \textcolor{keywordflow}{return} indicatorObject;
        \}
      \});
      \textcolor{keywordflow}{return} result;
    \}
  \}

  \textcolor{keyword}{function} findWhere(\textcolor{keywordtype}{object}, properties) \{
    \textcolor{keywordflow}{return} where(\textcolor{keywordtype}{object}, properties, \textcolor{keyword}{true});
  \}

  \textcolor{keyword}{function} forEach(collection, callback, thisArg) \{
    var index = -1,
        length = collection ? collection.length : 0;

    callback = callback && typeof thisArg == \textcolor{stringliteral}{'undefined'} ? callback : baseCreateCallback(callback, thisArg,
       3);
    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        \textcolor{keywordflow}{if} (callback(collection[index], index, collection) === indicatorObject) \{
          \textcolor{keywordflow}{break};
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, callback);
    \}
  \}

  \textcolor{keyword}{function} forEachRight(collection, callback) \{
    var length = collection ? collection.length : 0;
    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (length--) \{
        \textcolor{keywordflow}{if} (callback(collection[length], length, collection) === \textcolor{keyword}{false}) \{
          \textcolor{keywordflow}{break};
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      var props = keys(collection);
      length = props.length;
      forOwn(collection, \textcolor{keyword}{function}(value, key, collection) \{
        key = props ? props[--length] : --length;
        \textcolor{keywordflow}{return} callback(collection[key], key, collection) === \textcolor{keyword}{false} && indicatorObject;
      \});
    \}
  \}

  var groupBy = createAggregator(\textcolor{keyword}{function}(result, value, key) \{
    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
  \});

  var indexBy = createAggregator(\textcolor{keyword}{function}(result, value, key) \{
    result[key] = value;
  \});

  \textcolor{keyword}{function} invoke(collection, methodName) \{
    var args = slice(arguments, 2),
        index = -1,
        isFunc = typeof methodName == \textcolor{stringliteral}{'function'},
        length = collection ? collection.length : 0,
        result = Array(typeof length == \textcolor{stringliteral}{'number'} ? length : 0);

    forEach(collection, \textcolor{keyword}{function}(value) \{
      result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
    \});
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} map(collection, callback, thisArg) \{
    var index = -1,
        length = collection ? collection.length : 0;

    callback = createCallback(callback, thisArg, 3);
    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      var result = Array(length);
      \textcolor{keywordflow}{while} (++index < length) \{
        result[index] = callback(collection[index], index, collection);
      \}
    \} \textcolor{keywordflow}{else} \{
      result = [];
      forOwn(collection, \textcolor{keyword}{function}(value, key, collection) \{
        result[++index] = callback(value, key, collection);
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} max(collection, callback, thisArg) \{
    var computed = -Infinity,
        result = computed;

    \textcolor{comment}{// allows working with functions like `\_.map` without using}
    \textcolor{comment}{// their `index` argument as a callback}
    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'function'} && thisArg && thisArg[callback] === collection) \{
      callback = null;
    \}
    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (callback == null && typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        var value = collection[index];
        \textcolor{keywordflow}{if} (value > result) \{
          result = value;
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, \textcolor{keyword}{function}(value, index, collection) \{
        var current = callback(value, index, collection);
        \textcolor{keywordflow}{if} (current > computed) \{
          computed = current;
          result = value;
        \}
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} min(collection, callback, thisArg) \{
    var computed = Infinity,
        result = computed;

    \textcolor{comment}{// allows working with functions like `\_.map` without using}
    \textcolor{comment}{// their `index` argument as a callback}
    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'function'} && thisArg && thisArg[callback] === collection) \{
      callback = null;
    \}
    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (callback == null && typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        var value = collection[index];
        \textcolor{keywordflow}{if} (value < result) \{
          result = value;
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, \textcolor{keyword}{function}(value, index, collection) \{
        var current = callback(value, index, collection);
        \textcolor{keywordflow}{if} (current < computed) \{
          computed = current;
          result = value;
        \}
      \});
    \}
    \textcolor{keywordflow}{return} result;
  \}

  var pluck = map;

  \textcolor{keyword}{function} reduce(collection, callback, accumulator, thisArg) \{
    \textcolor{keywordflow}{if} (!collection) \textcolor{keywordflow}{return} accumulator;
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg, 4);

    var index = -1,
        length = collection.length;

    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{if} (noaccum) \{
        accumulator = collection[++index];
      \}
      \textcolor{keywordflow}{while} (++index < length) \{
        accumulator = callback(accumulator, collection[index], index, collection);
      \}
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, \textcolor{keyword}{function}(value, index, collection) \{
        accumulator = noaccum
          ? (noaccum = \textcolor{keyword}{false}, value)
          : callback(accumulator, value, index, collection)
      \});
    \}
    \textcolor{keywordflow}{return} accumulator;
  \}

  \textcolor{keyword}{function} reduceRight(collection, callback, accumulator, thisArg) \{
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg, 4);
    forEachRight(collection, \textcolor{keyword}{function}(value, index, collection) \{
      accumulator = noaccum
        ? (noaccum = \textcolor{keyword}{false}, value)
        : callback(accumulator, value, index, collection);
    \});
    \textcolor{keywordflow}{return} accumulator;
  \}

  \textcolor{keyword}{function} reject(collection, callback, thisArg) \{
    callback = createCallback(callback, thisArg, 3);
    \textcolor{keywordflow}{return} filter(collection, \textcolor{keyword}{function}(value, index, collection) \{
      \textcolor{keywordflow}{return} !callback(value, index, collection);
    \});
  \}

  \textcolor{keyword}{function} sample(collection, n, guard) \{
    \textcolor{keywordflow}{if} (collection && typeof collection.length != \textcolor{stringliteral}{'number'}) \{
      collection = values(collection);
    \}
    \textcolor{keywordflow}{if} (n == null || guard) \{
      \textcolor{keywordflow}{return} collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
    \}
    var result = shuffle(collection);
    result.length = nativeMin(nativeMax(0, n), result.length);
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} shuffle(collection) \{
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == \textcolor{stringliteral}{'number'} ? length : 0);

    forEach(collection, \textcolor{keyword}{function}(value) \{
      var rand = baseRandom(0, ++index);
      result[index] = result[rand];
      result[rand] = value;
    \});
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} size(collection) \{
    var length = collection ? collection.length : 0;
    \textcolor{keywordflow}{return} typeof length == \textcolor{stringliteral}{'number'} ? length : keys(collection).length;
  \}

  \textcolor{keyword}{function} some(collection, callback, thisArg) \{
    var result;
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    \textcolor{keywordflow}{if} (typeof length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{while} (++index < length) \{
        \textcolor{keywordflow}{if} ((result = callback(collection[index], index, collection))) \{
          \textcolor{keywordflow}{break};
        \}
      \}
    \} \textcolor{keywordflow}{else} \{
      forOwn(collection, \textcolor{keyword}{function}(value, index, collection) \{
        \textcolor{keywordflow}{return} (result = callback(value, index, collection)) && indicatorObject;
      \});
    \}
    \textcolor{keywordflow}{return} !!result;
  \}

  \textcolor{keyword}{function} sortBy(collection, callback, thisArg) \{
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == \textcolor{stringliteral}{'number'} ? length : 0);

    callback = createCallback(callback, thisArg, 3);
    forEach(collection, \textcolor{keyword}{function}(value, key, collection) \{
      result[++index] = \{
        \textcolor{stringliteral}{'criteria'}: [callback(value, key, collection)],
        \textcolor{stringliteral}{'index'}: index,
        \textcolor{stringliteral}{'value'}: value
      \};
    \});

    length = result.length;
    result.sort(compareAscending);
    \textcolor{keywordflow}{while} (length--) \{
      result[length] = result[length].value;
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} toArray(collection) \{
    \textcolor{keywordflow}{if} (isArray(collection)) \{
      \textcolor{keywordflow}{return} slice(collection);
    \}
    \textcolor{keywordflow}{if} (collection && typeof collection.length == \textcolor{stringliteral}{'number'}) \{
      \textcolor{keywordflow}{return} map(collection);
    \}
    \textcolor{keywordflow}{return} values(collection);
  \}

  \textcolor{keyword}{function} where(collection, properties, first) \{
    \textcolor{keywordflow}{return} (first && isEmpty(properties))
      ? undefined
      : (first ? find : filter)(collection, properties);
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} compact(array) \{
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    \textcolor{keywordflow}{while} (++index < length) \{
      var value = array[index];
      \textcolor{keywordflow}{if} (value) \{
        result.push(value);
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} difference(array) \{
    \textcolor{keywordflow}{return} baseDifference(array, baseFlatten(arguments, \textcolor{keyword}{true}, \textcolor{keyword}{true}, 1));
  \}

  \textcolor{keyword}{function} first(array, callback, thisArg) \{
    var n = 0,
        length = array ? array.length : 0;

    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'number'} && callback != null) \{
      var index = -1;
      callback = createCallback(callback, thisArg, 3);
      \textcolor{keywordflow}{while} (++index < length && callback(array[index], index, array)) \{
        n++;
      \}
    \} \textcolor{keywordflow}{else} \{
      n = callback;
      \textcolor{keywordflow}{if} (n == null || thisArg) \{
        \textcolor{keywordflow}{return} array ? array[0] : undefined;
      \}
    \}
    \textcolor{keywordflow}{return} slice(array, 0, nativeMin(nativeMax(0, n), length));
  \}

  \textcolor{keyword}{function} flatten(array, isShallow) \{
    \textcolor{keywordflow}{return} baseFlatten(array, isShallow);
  \}

  \textcolor{keyword}{function} indexOf(array, value, fromIndex) \{
    \textcolor{keywordflow}{if} (typeof fromIndex == \textcolor{stringliteral}{'number'}) \{
      var length = array ? array.length : 0;
      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fromIndex) \{
      var index = sortedIndex(array, value);
      \textcolor{keywordflow}{return} array[index] === value ? index : -1;
    \}
    \textcolor{keywordflow}{return} baseIndexOf(array, value, fromIndex);
  \}

  \textcolor{keyword}{function} initial(array, callback, thisArg) \{
    var n = 0,
        length = array ? array.length : 0;

    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'number'} && callback != null) \{
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      \textcolor{keywordflow}{while} (index-- && callback(array[index], index, array)) \{
        n++;
      \}
    \} \textcolor{keywordflow}{else} \{
      n = (callback == null || thisArg) ? 1 : callback || n;
    \}
    \textcolor{keywordflow}{return} slice(array, 0, nativeMin(nativeMax(0, length - n), length));
  \}

  \textcolor{keyword}{function} intersection() \{
    var args = [],
        argsIndex = -1,
        argsLength = arguments.length;

    \textcolor{keywordflow}{while} (++argsIndex < argsLength) \{
      var value = arguments[argsIndex];
       \textcolor{keywordflow}{if} (isArray(value) || isArguments(value)) \{
         args.push(value);
       \}
    \}
    var array = args[0],
        index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    outer:
    \textcolor{keywordflow}{while} (++index < length) \{
      value = array[index];
      \textcolor{keywordflow}{if} (indexOf(result, value) < 0) \{
        var argsIndex = argsLength;
        \textcolor{keywordflow}{while} (--argsIndex) \{
          \textcolor{keywordflow}{if} (indexOf(args[argsIndex], value) < 0) \{
            \textcolor{keywordflow}{continue} outer;
          \}
        \}
        result.push(value);
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} last(array, callback, thisArg) \{
    var n = 0,
        length = array ? array.length : 0;

    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'number'} && callback != null) \{
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      \textcolor{keywordflow}{while} (index-- && callback(array[index], index, array)) \{
        n++;
      \}
    \} \textcolor{keywordflow}{else} \{
      n = callback;
      \textcolor{keywordflow}{if} (n == null || thisArg) \{
        \textcolor{keywordflow}{return} array ? array[length - 1] : undefined;
      \}
    \}
    \textcolor{keywordflow}{return} slice(array, nativeMax(0, length - n));
  \}

  \textcolor{keyword}{function} lastIndexOf(array, value, fromIndex) \{
    var index = array ? array.length : 0;
    \textcolor{keywordflow}{if} (typeof fromIndex == \textcolor{stringliteral}{'number'}) \{
      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
    \}
    \textcolor{keywordflow}{while} (index--) \{
      \textcolor{keywordflow}{if} (array[index] === value) \{
        \textcolor{keywordflow}{return} index;
      \}
    \}
    \textcolor{keywordflow}{return} -1;
  \}

  \textcolor{keyword}{function} range(start, end, step) \{
    start = +start || 0;
    step =  (+step || 1);

    \textcolor{keywordflow}{if} (end == null) \{
      end = start;
      start = 0;
    \}
    \textcolor{comment}{// use `Array(length)` so engines like Chakra and V8 avoid slower modes}
    \textcolor{comment}{// http://youtu.be/XAqIpGU8ZZk#t=17m25s}
    var index = -1,
        length = nativeMax(0, ceil((end - start) / step)),
        result = Array(length);

    \textcolor{keywordflow}{while} (++index < length) \{
      result[index] = start;
      start += step;
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} rest(array, callback, thisArg) \{
    \textcolor{keywordflow}{if} (typeof callback != \textcolor{stringliteral}{'number'} && callback != null) \{
      var n = 0,
          index = -1,
          length = array ? array.length : 0;

      callback = createCallback(callback, thisArg, 3);
      \textcolor{keywordflow}{while} (++index < length && callback(array[index], index, array)) \{
        n++;
      \}
    \} \textcolor{keywordflow}{else} \{
      n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
    \}
    \textcolor{keywordflow}{return} slice(array, n);
  \}

  \textcolor{keyword}{function} sortedIndex(array, value, callback, thisArg) \{
    var low = 0,
        high = array ? array.length : low;

    \textcolor{comment}{// explicitly reference `identity` for better inlining in Firefox}
    callback = callback ? createCallback(callback, thisArg, 1) : identity;
    value = callback(value);

    \textcolor{keywordflow}{while} (low < high) \{
      var mid = (low + high) >>> 1;
      (callback(array[mid]) < value)
        ? low = mid + 1
        : high = mid;
    \}
    \textcolor{keywordflow}{return} low;
  \}

  \textcolor{keyword}{function} \textcolor{keyword}{union}() \{
    \textcolor{keywordflow}{return} baseUniq(baseFlatten(arguments, \textcolor{keyword}{true}, \textcolor{keyword}{true}));
  \}

  \textcolor{keyword}{function} uniq(array, isSorted, callback, thisArg) \{
    \textcolor{comment}{// juggle arguments}
    \textcolor{keywordflow}{if} (typeof isSorted != \textcolor{stringliteral}{'boolean'} && isSorted != null) \{
      thisArg = callback;
      callback = (typeof isSorted != \textcolor{stringliteral}{'function'} && thisArg && thisArg[isSorted] === array) ? null : 
      isSorted;
      isSorted = \textcolor{keyword}{false};
    \}
    \textcolor{keywordflow}{if} (callback != null) \{
      callback = createCallback(callback, thisArg, 3);
    \}
    \textcolor{keywordflow}{return} baseUniq(array, isSorted, callback);
  \}

  \textcolor{keyword}{function} without(array) \{
    \textcolor{keywordflow}{return} baseDifference(array, slice(arguments, 1));
  \}

  \textcolor{keyword}{function} zip() \{
    var index = -1,
        length = max(pluck(arguments, \textcolor{stringliteral}{'length'})),
        result = Array(length < 0 ? 0 : length);

    \textcolor{keywordflow}{while} (++index < length) \{
      result[index] = pluck(arguments, index);
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} zipObject(keys, values) \{
    var index = -1,
        length = keys ? keys.length : 0,
        result = \{\};

    \textcolor{keywordflow}{if} (!values && length && !isArray(keys[0])) \{
      values = [];
    \}
    \textcolor{keywordflow}{while} (++index < length) \{
      var key = keys[index];
      \textcolor{keywordflow}{if} (values) \{
        result[key] = values[index];
      \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key) \{
        result[key[0]] = key[1];
      \}
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} after(n, func) \{
    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{if} (--n < 1) \{
        \textcolor{keywordflow}{return} func.apply(\textcolor{keyword}{this}, arguments);
      \}
    \};
  \}

  \textcolor{keyword}{function} bind(func, thisArg) \{
    \textcolor{keywordflow}{return} arguments.length > 2
      ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
      : createWrapper(func, 1, null, null, thisArg);
  \}

  \textcolor{keyword}{function} bindAll(\textcolor{keywordtype}{object}) \{
    var funcs = arguments.length > 1 ? baseFlatten(arguments, \textcolor{keyword}{true}, \textcolor{keyword}{false}, 1) : functions(object),
        index = -1,
        length = funcs.length;

    \textcolor{keywordflow}{while} (++index < length) \{
      var key = funcs[index];
      \textcolor{keywordtype}{object}[key] = createWrapper(\textcolor{keywordtype}{object}[key], 1, null, null, \textcolor{keywordtype}{object});
    \}
    \textcolor{keywordflow}{return} object;
  \}

  \textcolor{keyword}{function} compose() \{
    var funcs = arguments,
        length = funcs.length;

    \textcolor{keywordflow}{while} (length--) \{
      \textcolor{keywordflow}{if} (!isFunction(funcs[length])) \{
        \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
      \}
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      var args = arguments,
          length = funcs.length;

      \textcolor{keywordflow}{while} (length--) \{
        args = [funcs[length].apply(\textcolor{keyword}{this}, args)];
      \}
      \textcolor{keywordflow}{return} args[0];
    \};
  \}

  \textcolor{keyword}{function} debounce(func, wait, options) \{
    var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = \textcolor{keyword}{false},
        trailing = \textcolor{keyword}{true};

    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    wait = nativeMax(0, wait) || 0;
    \textcolor{keywordflow}{if} (options === \textcolor{keyword}{true}) \{
      var leading = \textcolor{keyword}{true};
      trailing = \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(options)) \{
      leading = options.leading;
      maxWait = \textcolor{stringliteral}{'maxWait'} in options && (nativeMax(wait, options.maxWait) || 0);
      trailing = \textcolor{stringliteral}{'trailing'} in options ? options.trailing : trailing;
    \}
    var delayed = \textcolor{keyword}{function}() \{
      var remaining = wait - (now() - stamp);
      \textcolor{keywordflow}{if} (remaining <= 0) \{
        \textcolor{keywordflow}{if} (maxTimeoutId) \{
          clearTimeout(maxTimeoutId);
        \}
        var isCalled = trailingCall;
        maxTimeoutId = timeoutId = trailingCall = undefined;
        \textcolor{keywordflow}{if} (isCalled) \{
          lastCalled = now();
          result = func.apply(thisArg, args);
          \textcolor{keywordflow}{if} (!timeoutId && !maxTimeoutId) \{
            args = thisArg = null;
          \}
        \}
      \} \textcolor{keywordflow}{else} \{
        timeoutId = setTimeout(delayed, remaining);
      \}
    \};

    var maxDelayed = \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{if} (timeoutId) \{
        clearTimeout(timeoutId);
      \}
      maxTimeoutId = timeoutId = trailingCall = undefined;
      \textcolor{keywordflow}{if} (trailing || (maxWait !== wait)) \{
        lastCalled = now();
        result = func.apply(thisArg, args);
        \textcolor{keywordflow}{if} (!timeoutId && !maxTimeoutId) \{
          args = thisArg = null;
        \}
      \}
    \};

    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      args = arguments;
      stamp = now();
      thisArg = \textcolor{keyword}{this};
      trailingCall = trailing && (timeoutId || !leading);

      \textcolor{keywordflow}{if} (maxWait === \textcolor{keyword}{false}) \{
        var leadingCall = leading && !timeoutId;
      \} \textcolor{keywordflow}{else} \{
        \textcolor{keywordflow}{if} (!maxTimeoutId && !leading) \{
          lastCalled = stamp;
        \}
        var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining <= 0;

        \textcolor{keywordflow}{if} (isCalled) \{
          \textcolor{keywordflow}{if} (maxTimeoutId) \{
            maxTimeoutId = clearTimeout(maxTimeoutId);
          \}
          lastCalled = stamp;
          result = func.apply(thisArg, args);
        \}
        \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!maxTimeoutId) \{
          maxTimeoutId = setTimeout(maxDelayed, remaining);
        \}
      \}
      \textcolor{keywordflow}{if} (isCalled && timeoutId) \{
        timeoutId = clearTimeout(timeoutId);
      \}
      \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!timeoutId && wait !== maxWait) \{
        timeoutId = setTimeout(delayed, wait);
      \}
      \textcolor{keywordflow}{if} (leadingCall) \{
        isCalled = \textcolor{keyword}{true};
        result = func.apply(thisArg, args);
      \}
      \textcolor{keywordflow}{if} (isCalled && !timeoutId && !maxTimeoutId) \{
        args = thisArg = null;
      \}
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} defer(func) \{
    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    var args = slice(arguments, 1);
    \textcolor{keywordflow}{return} setTimeout(\textcolor{keyword}{function}() \{ func.apply(undefined, args); \}, 1);
  \}

  \textcolor{keyword}{function} delay(func, wait) \{
    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    var args = slice(arguments, 2);
    \textcolor{keywordflow}{return} setTimeout(\textcolor{keyword}{function}() \{ func.apply(undefined, args); \}, wait);
  \}

  \textcolor{keyword}{function} memoize(func, resolver) \{
    var cache = \{\};
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      var key = resolver ? resolver.apply(\textcolor{keyword}{this}, arguments) : keyPrefix + arguments[0];
      \textcolor{keywordflow}{return} hasOwnProperty.call(cache, key)
        ? cache[key]
        : (cache[key] = func.apply(\textcolor{keyword}{this}, arguments));
    \};
  \}

  \textcolor{keyword}{function} once(func) \{
    var ran,
        result;

    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{if} (ran) \{
        \textcolor{keywordflow}{return} result;
      \}
      ran = \textcolor{keyword}{true};
      result = func.apply(\textcolor{keyword}{this}, arguments);

      \textcolor{comment}{// clear the `func` variable so the function may be garbage collected}
      func = null;
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} partial(func) \{
    \textcolor{keywordflow}{return} createWrapper(func, 16, slice(arguments, 1));
  \}

  \textcolor{keyword}{function} throttle(func, wait, options) \{
    var leading = \textcolor{keyword}{true},
        trailing = \textcolor{keyword}{true};

    \textcolor{keywordflow}{if} (!isFunction(func)) \{
      \textcolor{keywordflow}{throw} \textcolor{keyword}{new} TypeError;
    \}
    \textcolor{keywordflow}{if} (options === \textcolor{keyword}{false}) \{
      leading = \textcolor{keyword}{false};
    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isObject(options)) \{
      leading = \textcolor{stringliteral}{'leading'} in options ? options.leading : leading;
      trailing = \textcolor{stringliteral}{'trailing'} in options ? options.trailing : trailing;
    \}
    options = \{\};
    options.leading = leading;
    options.maxWait = wait;
    options.trailing = trailing;

    \textcolor{keywordflow}{return} debounce(func, wait, options);
  \}

  \textcolor{keyword}{function} wrap(value, wrapper) \{
    \textcolor{keywordflow}{return} createWrapper(wrapper, 16, [value]);
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} createCallback(func, thisArg, argCount) \{
    var type = typeof func;
    \textcolor{keywordflow}{if} (func == null || type == \textcolor{stringliteral}{'function'}) \{
      \textcolor{keywordflow}{return} baseCreateCallback(func, thisArg, argCount);
    \}
    \textcolor{comment}{// handle "\_.pluck" style callback shorthands}
    \textcolor{keywordflow}{if} (type != \textcolor{stringliteral}{'object'}) \{
      \textcolor{keywordflow}{return} property(func);
    \}
    var props = keys(func);
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(object) \{
      var length = props.length,
          result = \textcolor{keyword}{false};

      \textcolor{keywordflow}{while} (length--) \{
        \textcolor{keywordflow}{if} (!(result = \textcolor{keywordtype}{object}[props[length]] === func[props[length]])) \{
          \textcolor{keywordflow}{break};
        \}
      \}
      \textcolor{keywordflow}{return} result;
    \};
  \}

  \textcolor{keyword}{function} escape(\textcolor{keywordtype}{string}) \{
    \textcolor{keywordflow}{return} \textcolor{keywordtype}{string} == null ? \textcolor{stringliteral}{''} : String(\textcolor{keywordtype}{string}).replace(reUnescapedHtml, escapeHtmlChar);
  \}

  \textcolor{keyword}{function} identity(value) \{
    \textcolor{keywordflow}{return} value;
  \}

  \textcolor{keyword}{function} mixin(\textcolor{keywordtype}{object}) \{
    forEach(functions(\textcolor{keywordtype}{object}), \textcolor{keyword}{function}(methodName) \{
      var func = lodash[methodName] = \textcolor{keywordtype}{object}[methodName];

      lodash.prototype[methodName] = \textcolor{keyword}{function}() \{
        var args = [this.\_\_wrapped\_\_];
        push.apply(args, arguments);

        var result = func.apply(lodash, args);
        \textcolor{keywordflow}{return} this.\_\_chain\_\_
          ? \textcolor{keyword}{new} lodashWrapper(result, \textcolor{keyword}{true})
          : result;
      \};
    \});
  \}

  \textcolor{keyword}{function} noConflict() \{
    root.\_ = oldDash;
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \}

  \textcolor{keyword}{function} noop() \{
    \textcolor{comment}{// no operation performed}
  \}

  var now = isNative(now = Date.now) && now || \textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Date().getTime();
  \};

  \textcolor{keyword}{function} property(key) \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{function}(object) \{
      \textcolor{keywordflow}{return} \textcolor{keywordtype}{object}[key];
    \};
  \}

  \textcolor{keyword}{function} random(min, max) \{
    \textcolor{keywordflow}{if} (min == null && max == null) \{
      max = 1;
    \}
    min = +min || 0;
    \textcolor{keywordflow}{if} (max == null) \{
      max = min;
      min = 0;
    \} \textcolor{keywordflow}{else} \{
      max = +max || 0;
    \}
    \textcolor{keywordflow}{return} min + floor(nativeRandom() * (max - min + 1));
  \}

  \textcolor{keyword}{function} result(\textcolor{keywordtype}{object}, key) \{
    \textcolor{keywordflow}{if} (\textcolor{keywordtype}{object}) \{
      var value = \textcolor{keywordtype}{object}[key];
      \textcolor{keywordflow}{return} isFunction(value) ? \textcolor{keywordtype}{object}[key]() : value;
    \}
  \}

  \textcolor{keyword}{function} \textcolor{keyword}{template}(text, data, options) \{
    var \_ = lodash,
        settings = \_.templateSettings;

    text = String(text || \textcolor{stringliteral}{''});
    options = defaults(\{\}, options, settings);

    var index = 0,
        source = \textcolor{stringliteral}{"\_\_p += '"},
        variable = options.variable;

    var reDelimiters = RegExp(
      (options.escape || reNoMatch).source + \textcolor{charliteral}{'|'} +
      (options.interpolate || reNoMatch).source + \textcolor{charliteral}{'|'} +
      (options.evaluate || reNoMatch).source + \textcolor{stringliteral}{'|$'}
    , \textcolor{charliteral}{'g'});

    text.replace(reDelimiters, \textcolor{keyword}{function}(match, escapeValue, interpolateValue, evaluateValue, offset) \{
      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      \textcolor{keywordflow}{if} (escapeValue) \{
        source += \textcolor{stringliteral}{"' +\(\backslash\)n\_.escape("} + escapeValue + \textcolor{stringliteral}{") +\(\backslash\)n'"};
      \}
      \textcolor{keywordflow}{if} (evaluateValue) \{
        source += \textcolor{stringliteral}{"';\(\backslash\)n"} + evaluateValue + \textcolor{stringliteral}{";\(\backslash\)n\_\_p += '"};
      \}
      \textcolor{keywordflow}{if} (interpolateValue) \{
        source += \textcolor{stringliteral}{"' +\(\backslash\)n((\_\_t = ("} + interpolateValue + \textcolor{stringliteral}{")) == null ? '' : \_\_t) +\(\backslash\)n'"};
      \}
      index = offset + match.length;
      \textcolor{keywordflow}{return} match;
    \});

    source += \textcolor{stringliteral}{"';\(\backslash\)n"};
    \textcolor{keywordflow}{if} (!variable) \{
      variable = \textcolor{stringliteral}{'obj'};
      source = \textcolor{stringliteral}{'with ('} + variable + \textcolor{stringliteral}{' || \{\}) \{\(\backslash\)n'} + source + \textcolor{stringliteral}{'\(\backslash\)n\}\(\backslash\)n'};
    \}
    source = \textcolor{stringliteral}{'function('} + variable + \textcolor{stringliteral}{') \{\(\backslash\)n'} +
      \textcolor{stringliteral}{"var \_\_t, \_\_p = '', \_\_j = Array.prototype.join;\(\backslash\)n"} +
      \textcolor{stringliteral}{"function print() \{ \_\_p += \_\_j.call(arguments, '') \}\(\backslash\)n"} +
      source +
      \textcolor{stringliteral}{'return \_\_p\(\backslash\)n\}'};

    \textcolor{keywordflow}{try} \{
      var result = Function(\textcolor{charliteral}{'\_'}, \textcolor{stringliteral}{'return '} + source)(\_);
    \} \textcolor{keywordflow}{catch}(e) \{
      e.source = source;
      \textcolor{keywordflow}{throw} e;
    \}
    \textcolor{keywordflow}{if} (data) \{
      \textcolor{keywordflow}{return} result(data);
    \}
    result.source = source;
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} times(n, callback, thisArg) \{
    n = (n = +n) > -1 ? n : 0;
    var index = -1,
        result = Array(n);

    callback = baseCreateCallback(callback, thisArg, 1);
    \textcolor{keywordflow}{while} (++index < n) \{
      result[index] = callback(index);
    \}
    \textcolor{keywordflow}{return} result;
  \}

  \textcolor{keyword}{function} unescape(\textcolor{keywordtype}{string}) \{
    \textcolor{keywordflow}{return} \textcolor{keywordtype}{string} == null ? \textcolor{stringliteral}{''} : String(\textcolor{keywordtype}{string}).replace(reEscapedHtml, unescapeHtmlChar);
  \}

  \textcolor{keyword}{function} uniqueId(prefix) \{
    var \textcolor{keywordtype}{id} = ++idCounter + \textcolor{stringliteral}{''};
    \textcolor{keywordflow}{return} prefix ? prefix + \textcolor{keywordtype}{id} : id;
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{keyword}{function} chain(value) \{
    value = \textcolor{keyword}{new} lodashWrapper(value);
    value.\_\_chain\_\_ = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} value;
  \}

  \textcolor{keyword}{function} tap(value, interceptor) \{
    interceptor(value);
    \textcolor{keywordflow}{return} value;
  \}

  \textcolor{keyword}{function} wrapperChain() \{
    this.\_\_chain\_\_ = \textcolor{keyword}{true};
    \textcolor{keywordflow}{return} \textcolor{keyword}{this};
  \}

  \textcolor{keyword}{function} wrapperValueOf() \{
    \textcolor{keywordflow}{return} this.\_\_wrapped\_\_;
  \}

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{comment}{// add functions that return wrapped values when chaining}
  lodash.after = after;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.compose = compose;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.difference = difference;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.functions = functions;
  lodash.groupBy = groupBy;
  lodash.indexBy = indexBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.invert = invert;
  lodash.invoke = invoke;
  lodash.keys = keys;
  lodash.map = map;
  lodash.max = max;
  lodash.memoize = memoize;
  lodash.min = min;
  lodash.omit = omit;
  lodash.once = once;
  lodash.pairs = pairs;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pluck = pluck;
  lodash.range = range;
  lodash.reject = reject;
  lodash.rest = rest;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.throttle = throttle;
  lodash.times = times;
  lodash.toArray = toArray;
  lodash.union = \textcolor{keyword}{union};
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.where = where;
  lodash.without = without;
  lodash.wrap = wrap;
  lodash.zip = zip;

  \textcolor{comment}{// add aliases}
  lodash.collect = map;
  lodash.drop = rest;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.object = zipObject;
  lodash.select = filter;
  lodash.tail = rest;
  lodash.unique = uniq;

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{comment}{// add functions that return unwrapped values when chaining}
  lodash.clone = clone;
  lodash.contains = contains;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.has = has;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isElement = isElement;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.lastIndexOf = lastIndexOf;
  lodash.mixin = mixin;
  lodash.noConflict = noConflict;
  lodash.random = random;
  lodash.reduce = reduce;
  lodash.reduceRight = reduceRight;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.sortedIndex = sortedIndex;
  lodash.template = \textcolor{keyword}{template};
  lodash.unescape = unescape;
  lodash.uniqueId = uniqueId;

  \textcolor{comment}{// add aliases}
  lodash.all = every;
  lodash.any = some;
  lodash.detect = find;
  lodash.findWhere = findWhere;
  lodash.foldl = reduce;
  lodash.foldr = reduceRight;
  lodash.include = contains;
  lodash.inject = reduce;

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{comment}{// add functions capable of returning wrapped and unwrapped values when chaining}
  lodash.first = first;
  lodash.last = last;
  lodash.sample = sample;

  \textcolor{comment}{// add aliases}
  lodash.take = first;
  lodash.head = first;

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{comment}{// add functions to `lodash.prototype`}
  mixin(lodash);

  lodash.VERSION = \textcolor{stringliteral}{'2.4.2'};

  \textcolor{comment}{// add "Chaining" functions to the wrapper}
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.value = wrapperValueOf;

    \textcolor{comment}{// add `Array` mutator functions to the wrapper}
    forEach([\textcolor{stringliteral}{'pop'}, \textcolor{stringliteral}{'push'}, \textcolor{stringliteral}{'reverse'}, \textcolor{stringliteral}{'shift'}, \textcolor{stringliteral}{'sort'}, \textcolor{stringliteral}{'splice'}, \textcolor{stringliteral}{'unshift'}], \textcolor{keyword}{function}(methodName) \{
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = \textcolor{keyword}{function}() \{
        var value = this.\_\_wrapped\_\_;
        func.apply(value, arguments);

        \textcolor{comment}{// avoid array-like object bugs with `Array#shift` and `Array#splice`}
        \textcolor{comment}{// in Firefox < 10 and IE < 9}
        \textcolor{keywordflow}{if} (!support.spliceObjects && value.length === 0) \{
          \textcolor{keyword}{delete} value[0];
        \}
        \textcolor{keywordflow}{return} \textcolor{keyword}{this};
      \};
    \});

    \textcolor{comment}{// add `Array` accessor functions to the wrapper}
    forEach([\textcolor{stringliteral}{'concat'}, \textcolor{stringliteral}{'join'}, \textcolor{stringliteral}{'slice'}], \textcolor{keyword}{function}(methodName) \{
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = \textcolor{keyword}{function}() \{
        var value = this.\_\_wrapped\_\_,
            result = func.apply(value, arguments);

        \textcolor{keywordflow}{if} (this.\_\_chain\_\_) \{
          result = \textcolor{keyword}{new} lodashWrapper(result);
          result.\_\_chain\_\_ = \textcolor{keyword}{true};
        \}
        \textcolor{keywordflow}{return} result;
      \};
    \});

  \textcolor{comment}{/*--------------------------------------------------------------------------*/}

  \textcolor{comment}{// some AMD build optimizers like r.js check for condition patterns like the following:}
  \textcolor{keywordflow}{if} (typeof define == \textcolor{stringliteral}{'function'} && typeof define.amd == \textcolor{stringliteral}{'object'} && define.amd) \{
    \textcolor{comment}{// Expose Lo-Dash to the global object even when an AMD loader is present in}
    \textcolor{comment}{// case Lo-Dash is loaded with a RequireJS shim config.}
    \textcolor{comment}{// See http://requirejs.org/docs/api.html#config-shim}
    root.\_ = lodash;

    \textcolor{comment}{// define as an anonymous module so, through path mapping, it can be}
    \textcolor{comment}{// referenced as the "underscore" module}
    define(\textcolor{keyword}{function}() \{
      \textcolor{keywordflow}{return} lodash;
    \});
  \}
  \textcolor{comment}{// check for `exports` after `define` in case a build optimizer adds an `exports` object}
  \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (freeExports && freeModule) \{
    \textcolor{comment}{// in Node.js or RingoJS}
    \textcolor{keywordflow}{if} (moduleExports) \{
      (freeModule.exports = lodash).\_ = lodash;
    \}
    \textcolor{comment}{// in Narwhal or Rhino -require}
    \textcolor{keywordflow}{else} \{
      freeExports.\_ = lodash;
    \}
  \}
  \textcolor{keywordflow}{else} \{
    \textcolor{comment}{// in a browser or Rhino}
    root.\_ = lodash;
  \}
\}.call(\textcolor{keyword}{this}));
\end{DoxyCodeInclude}
 