\label{_type-check}%


{\ttfamily type-\/check} is a library which allows you to check the types of Java\+Script values at runtime with a Haskell like type syntax. It is great for checking external input, for testing, or even for adding a bit of safety to your internal code. It is a major component of \href{https://github.com/gkz/levn}{\tt levn}. M\+I\+T license. Version 0.\+3.\+1. Check out the \href{http://gkz.github.io/type-check/}{\tt demo}.

For updates on {\ttfamily type-\/check}, \href{https://twitter.com/gkzahariev}{\tt follow me on twitter}. \begin{DoxyVerb}npm install type-check
\end{DoxyVerb}


\subsection*{Quick Examples}


\begin{DoxyCode}
\textcolor{comment}{// Basic types:}
var typeCheck = require(\textcolor{stringliteral}{'type-check'}).typeCheck;
typeCheck(\textcolor{stringliteral}{'Number'}, 1);               \textcolor{comment}{// true}
typeCheck(\textcolor{stringliteral}{'Number'}, \textcolor{stringliteral}{'str'});           \textcolor{comment}{// false}
typeCheck(\textcolor{stringliteral}{'Error'}, \textcolor{keyword}{new} Error);        \textcolor{comment}{// true}
typeCheck(\textcolor{stringliteral}{'Undefined'}, undefined);    \textcolor{comment}{// true}

\textcolor{comment}{// Comment}
typeCheck(\textcolor{stringliteral}{'count::Number'}, 1);        \textcolor{comment}{// true}

\textcolor{comment}{// One type OR another type:}
typeCheck(\textcolor{stringliteral}{'Number | String'}, 2);      \textcolor{comment}{// true}
typeCheck(\textcolor{stringliteral}{'Number | String'}, \textcolor{stringliteral}{'str'});  \textcolor{comment}{// true}

\textcolor{comment}{// Wildcard, matches all types:}
typeCheck(\textcolor{charliteral}{'*'}, 2) \textcolor{comment}{// true}

\textcolor{comment}{// Array, all elements of a single type:}
typeCheck('[Number]', [1, 2, 3]);                \textcolor{comment}{// true}
typeCheck('[Number]', [1, 'str', 3]);            \textcolor{comment}{// false}

\textcolor{comment}{// Tuples, or fixed length arrays with elements of different types:}
typeCheck('(String, Number)', ['str', 2]);       \textcolor{comment}{// true}
typeCheck('(String, Number)', ['str']);          \textcolor{comment}{// false}
typeCheck('(String, Number)', ['str', 2, 5]);    \textcolor{comment}{// false}

\textcolor{comment}{// Object properties:}
typeCheck('\{x: Number, y: Boolean\}\textcolor{stringliteral}{', \{x: 2, y: false\});             // true}
\textcolor{stringliteral}{typeCheck('}\{x: Number, y: Boolean\}\textcolor{stringliteral}{',       \{x: 2\});                 // false}
\textcolor{stringliteral}{typeCheck('}\{x: Number, y: Maybe Boolean\}\textcolor{stringliteral}{', \{x: 2\});                 // true}
\textcolor{stringliteral}{typeCheck('}\{x: Number, y: Boolean\}\textcolor{stringliteral}{',      \{x: 2, y: false, z: 3\});  // false}
\textcolor{stringliteral}{typeCheck('}\{x: Number, y: Boolean, ...\}\textcolor{stringliteral}{', \{x: 2, y: false, z: 3\});  // true}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{// A particular type AND object properties:}
\textcolor{stringliteral}{typeCheck('}RegExp\{source: String, ...\}\textcolor{stringliteral}{', /re/i);          // true}
\textcolor{stringliteral}{typeCheck('}RegExp\{source: String, ...\}\textcolor{stringliteral}{', \{source: '}re\textcolor{stringliteral}{'\}); // false}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{// Custom types:}
\textcolor{stringliteral}{var opt = \{customTypes:}
\textcolor{stringliteral}{  \{Even: \{ typeOf: '}Number\textcolor{stringliteral}{', validate: function(x) \{ return x % 2 === 0; \}\}\}\};}
\textcolor{stringliteral}{typeCheck('}Even\textcolor{stringliteral}{', 2, opt); // true}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{// Nested:}
\textcolor{stringliteral}{var type = '}\{a: (String, [Number], \{y: Array, ...\}), b: Error\{message: String, ...\}\}\textcolor{stringliteral}{'}
\textcolor{stringliteral}{typeCheck(type, \{a: ['}hi\textcolor{stringliteral}{', [1, 2, 3], \{y: [1, '}ms\textcolor{stringliteral}{']\}], b: new Error('}oh no\textcolor{stringliteral}{')\}); // true}
\end{DoxyCode}


Check out the \href{#syntax}{\tt type syntax format} and \href{#guide}{\tt guide}.

\subsection*{Usage}

`require(\textquotesingle{}type-\/check\textquotesingle{});{\ttfamily returns an object that exposes four properties.}V\+E\+R\+S\+I\+O\+N{\ttfamily is the current version of the library as a string.}type\+Check{\ttfamily ,}parse\+Type{\ttfamily , and}parsed\+Type\+Check` are functions.


\begin{DoxyCode}
\textcolor{comment}{// typeCheck(type, input, options);}
typeCheck(\textcolor{stringliteral}{'Number'}, 2);               \textcolor{comment}{// true}

\textcolor{comment}{// parseType(type);}
var parsedType = parseType(\textcolor{stringliteral}{'Number'}); \textcolor{comment}{// object}

\textcolor{comment}{// parsedTypeCheck(parsedType, input, options);}
parsedTypeCheck(parsedType, 2);       \textcolor{comment}{// true}
\end{DoxyCode}


\subsubsection*{type\+Check(type, input, options)}

{\ttfamily type\+Check} checks a Java\+Script value {\ttfamily input} against {\ttfamily type} written in the \href{#type-format}{\tt type format} (and taking account the optional {\ttfamily options}) and returns whether the {\ttfamily input} matches the {\ttfamily type}.

\subparagraph*{arguments}


\begin{DoxyItemize}
\item type -\/ {\ttfamily String} -\/ the type written in the \href{#type-format}{\tt type format} which to check against
\item input -\/ {\ttfamily $\ast$} -\/ any Java\+Script value, which is to be checked against the type
\item options -\/ {\ttfamily Maybe Object} -\/ an optional parameter specifying additional options, currently the only available option is specifying \href{#custom-types}{\tt custom types}
\end{DoxyItemize}

\subparagraph*{returns}

{\ttfamily Boolean} -\/ whether the input matches the type

\#\#\#\#\# example 
\begin{DoxyCode}
typeCheck(\textcolor{stringliteral}{'Number'}, 2); \textcolor{comment}{// true}
\end{DoxyCode}


\subsubsection*{parse\+Type(type)}

{\ttfamily parse\+Type} parses string {\ttfamily type} written in the \href{#type-format}{\tt type format} into an object representing the parsed type.

\subparagraph*{arguments}


\begin{DoxyItemize}
\item type -\/ {\ttfamily String} -\/ the type written in the \href{#type-format}{\tt type format} which to parse
\end{DoxyItemize}

\subparagraph*{returns}

{\ttfamily Object} -\/ an object in the parsed type format representing the parsed type

\#\#\#\#\# example 
\begin{DoxyCode}
parseType(\textcolor{stringliteral}{'Number'}); \textcolor{comment}{// [\{type: 'Number'\}]}
\end{DoxyCode}
 \subsubsection*{parsed\+Type\+Check(parsed\+Type, input, options)}

{\ttfamily parsed\+Type\+Check} checks a Java\+Script value {\ttfamily input} against parsed {\ttfamily type} in the parsed type format (and taking account the optional {\ttfamily options}) and returns whether the {\ttfamily input} matches the {\ttfamily type}. Use this in conjunction with {\ttfamily parse\+Type} if you are going to use a type more than once.

\subparagraph*{arguments}


\begin{DoxyItemize}
\item type -\/ {\ttfamily Object} -\/ the type in the parsed type format which to check against
\item input -\/ {\ttfamily $\ast$} -\/ any Java\+Script value, which is to be checked against the type
\item options -\/ {\ttfamily Maybe Object} -\/ an optional parameter specifying additional options, currently the only available option is specifying \href{#custom-types}{\tt custom types}
\end{DoxyItemize}

\subparagraph*{returns}

{\ttfamily Boolean} -\/ whether the input matches the type

\#\#\#\#\# example 
\begin{DoxyCode}
parsedTypeCheck([\{type: \textcolor{stringliteral}{'Number'}\}], 2); \textcolor{comment}{// true}
var parsedType = parseType(\textcolor{stringliteral}{'String'});
parsedTypeCheck(parsedType, \textcolor{stringliteral}{'str'});     \textcolor{comment}{// true}
\end{DoxyCode}


\label{_type-format}%
 \subsection*{Type Format}

\subsubsection*{Syntax}

White space is ignored. The root node is a {\bfseries Types}.


\begin{DoxyItemize}
\item {\bfseries Identifier} = {\ttfamily \mbox{[}\textbackslash{}\$\textbackslash{}w\mbox{]}+} -\/ a group of any lower or upper case letters, numbers, underscores, or dollar signs -\/ eg. {\ttfamily String}
\item {\bfseries Type} = an {\ttfamily Identifier}, an {\ttfamily Identifier} followed by a {\ttfamily Structure}, just a {\ttfamily Structure}, or a wildcard {\ttfamily $\ast$} -\/ eg. {\ttfamily String}, {\ttfamily Object\{x\+: Number\}}, {\ttfamily \{x\+: Number\}}, {\ttfamily Array\{0\+: String, 1\+: Boolean, length\+: Number\}}, {\ttfamily $\ast$}
\item {\bfseries Types} = optionally a comment (an {\ttfamily Indentifier} followed by a {\ttfamily \+:\+:}), optionally the identifier {\ttfamily Maybe}, one or more {\ttfamily Type}, separated by {\ttfamily $\vert$} -\/ eg. {\ttfamily Number}, {\ttfamily String $\vert$ Date}, {\ttfamily Maybe Number}, {\ttfamily Maybe Boolean $\vert$ String}
\item {\bfseries Structure} = {\ttfamily Fields}, or a {\ttfamily Tuple}, or an {\ttfamily Array} -\/ eg. {\ttfamily \{x\+: Number\}}, {\ttfamily (String, Number)}, {\ttfamily \mbox{[}Date\mbox{]}}
\item {\bfseries Fields} = a {\ttfamily \{}, followed one or more {\ttfamily Field} separated by a comma {\ttfamily ,} (trailing comma {\ttfamily ,} is permitted), optionally an {\ttfamily ...} (always preceded by a comma {\ttfamily ,}), followed by a {\ttfamily \}} -\/ eg. {\ttfamily \{x\+: Number, y\+: String\}}, {\ttfamily \{k\+: Function, ...\}}
\item {\bfseries Field} = an {\ttfamily Identifier}, followed by a colon {\ttfamily \+:}, followed by {\ttfamily Types} -\/ eg. {\ttfamily x\+: Date $\vert$ String}, {\ttfamily y\+: Boolean}
\item {\bfseries Tuple} = a {\ttfamily (}, followed by one or more {\ttfamily Types} separated by a comma {\ttfamily ,} (trailing comma {\ttfamily ,} is permitted), followed by a {\ttfamily )} -\/ eg {\ttfamily (Date)}, {\ttfamily (Number, Date)}
\item {\bfseries Array} = a {\ttfamily \mbox{[}} followed by exactly one {\ttfamily Types} followed by a {\ttfamily \mbox{]}} -\/ eg. {\ttfamily \mbox{[}Boolean\mbox{]}}, {\ttfamily \mbox{[}Boolean $\vert$ Null\mbox{]}}
\end{DoxyItemize}

\subsubsection*{Guide}

{\ttfamily type-\/check} uses {\ttfamily Object.\+to\+String} to find out the basic type of a value. Specifically,


\begin{DoxyCode}
\{\}.toString.call(VALUE).slice(8, -1)
\{\}.toString.call(\textcolor{keyword}{true}).slice(8, -1) \textcolor{comment}{// 'Boolean'}
\end{DoxyCode}
 A basic type, eg. {\ttfamily Number}, uses this check. This is much more versatile than using {\ttfamily typeof} -\/ for example, with {\ttfamily document}, {\ttfamily typeof} produces {\ttfamily \textquotesingle{}object\textquotesingle{}} which isn\textquotesingle{}t that useful, and our technique produces {\ttfamily \textquotesingle{}H\+T\+M\+L\+Document\textquotesingle{}}.

You may check for multiple types by separating types with a {\ttfamily $\vert$}. The checker proceeds from left to right, and passes if the value is any of the types -\/ eg. {\ttfamily String $\vert$ Boolean} first checks if the value is a string, and then if it is a boolean. If it is none of those, then it returns false.

Adding a {\ttfamily Maybe} in front of a list of multiple types is the same as also checking for {\ttfamily Null} and {\ttfamily Undefined} -\/ eg. {\ttfamily Maybe String} is equivalent to {\ttfamily Undefined $\vert$ Null $\vert$ String}.

You may add a comment to remind you of what the type is for by following an identifier with a {\ttfamily \+:\+:} before a type (or multiple types). The comment is simply thrown out.

The wildcard {\ttfamily $\ast$} matches all types.

There are three types of structures for checking the contents of a value\+: \textquotesingle{}fields\textquotesingle{}, \textquotesingle{}tuple\textquotesingle{}, and \textquotesingle{}array\textquotesingle{}.

If used by itself, a \textquotesingle{}fields\textquotesingle{} structure will pass with any type of object as long as it is an instance of {\ttfamily Object} and the properties pass -\/ this allows for duck typing -\/ eg. {\ttfamily \{x\+: Boolean\}}.

To check if the properties pass, and the value is of a certain type, you can specify the type -\/ eg. {\ttfamily Error\{message\+: String\}}.

If you want to make a field optional, you can simply use {\ttfamily Maybe} -\/ eg. {\ttfamily \{x\+: Boolean, y\+: Maybe String\}} will still pass if {\ttfamily y} is undefined (or null).

If you don\textquotesingle{}t care if the value has properties beyond what you have specified, you can use the \textquotesingle{}etc\textquotesingle{} operator {\ttfamily ...} -\/ eg. {\ttfamily \{x\+: Boolean, ...\}} will match an object with an {\ttfamily x} property that is a boolean, and with zero or more other properties.

For an array, you must specify one or more types (separated by {\ttfamily $\vert$}) -\/ it will pass for something of any length as long as each element passes the types provided -\/ eg. {\ttfamily \mbox{[}Number\mbox{]}}, {\ttfamily \mbox{[}Number $\vert$ String\mbox{]}}.

A tuple checks for a fixed number of elements, each of a potentially different type. Each element is separated by a comma -\/ eg. {\ttfamily (String, Number)}.

An array and tuple structure check that the value is of type {\ttfamily Array} by default, but if another type is specified, they will check for that instead -\/ eg. {\ttfamily Int32\+Array\mbox{[}Number\mbox{]}}. You can use the wildcard {\ttfamily $\ast$} to search for any type at all.

Check out the \href{https://github.com/zaboco/type-precedence}{\tt type precedence} library for type-\/check.

\subsection*{Options}

Options is an object. It is an optional parameter to the {\ttfamily type\+Check} and {\ttfamily parsed\+Type\+Check} functions. The only current option is {\ttfamily custom\+Types}.

\label{_custom-types}%
 \subsubsection*{Custom Types}

{\bfseries Example\+:}


\begin{DoxyCode}
var options = \{
  customTypes: \{
    Even: \{
      typeOf: \textcolor{stringliteral}{'Number'},
      validate: \textcolor{keyword}{function}(x) \{
        \textcolor{keywordflow}{return} x % 2 === 0;
      \}
    \}
  \}
\};
typeCheck(\textcolor{stringliteral}{'Even'}, 2, options); \textcolor{comment}{// true}
typeCheck(\textcolor{stringliteral}{'Even'}, 3, options); \textcolor{comment}{// false}
\end{DoxyCode}


{\ttfamily custom\+Types} allows you to set up custom types for validation. The value of this is an object. The keys of the object are the types you will be matching. Each value of the object will be an object having a {\ttfamily type\+Of} property -\/ a string, and {\ttfamily validate} property -\/ a function.

The {\ttfamily type\+Of} property is the type the value should be, and {\ttfamily validate} is a function which should return true if the value is of that type. {\ttfamily validate} receives one parameter, which is the value that we are checking.

\subsection*{Technical About}

{\ttfamily type-\/check} is written in \href{http://livescript.net/}{\tt Live\+Script} -\/ a language that compiles to Java\+Script. It also uses the \href{http://preludels.com/}{\tt prelude.\+ls} library. 