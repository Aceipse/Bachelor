Shell\+J\+S is a portable $\ast$$\ast$(Windows/\+Linux/\+O\+S X)$\ast$$\ast$ implementation of Unix shell commands on top of the Node.\+js A\+P\+I. You can use it to eliminate your shell script\textquotesingle{}s dependency on Unix while still keeping its familiar and powerful commands. You can also install it globally so you can run it from outside Node projects -\/ say goodbye to those gnarly Bash scripts!

The project is \href{http://travis-ci.org/arturadib/shelljs}{\tt unit-\/tested} and battled-\/tested in projects like\+:


\begin{DoxyItemize}
\item \href{http://github.com/mozilla/pdf.js}{\tt P\+D\+F.\+js} -\/ Firefox\textquotesingle{}s next-\/gen P\+D\+F reader
\item \href{http://getfirebug.com/}{\tt Firebug} -\/ Firefox\textquotesingle{}s infamous debugger
\item \href{http://jshint.com}{\tt J\+S\+Hint} -\/ Most popular Java\+Script linter
\item \href{http://zeptojs.com}{\tt Zepto} -\/ j\+Query-\/compatible Java\+Script library for modern browsers
\item \href{http://yeoman.io/}{\tt Yeoman} -\/ Web application stack and development tool
\item \href{http://deployd.com}{\tt Deployd.\+com} -\/ Open source Paa\+S for quick A\+P\+I backend generation
\end{DoxyItemize}

and \href{https://npmjs.org/browse/depended/shelljs}{\tt many more}.

\subsection*{Installing}

Via npm\+:


\begin{DoxyCode}
1 $ npm install [-g] shelljs
\end{DoxyCode}


If the global option {\ttfamily -\/g} is specified, the binary {\ttfamily shjs} will be installed. This makes it possible to run Shell\+J\+S scripts much like any shell script from the command line, i.\+e. without requiring a {\ttfamily node\+\_\+modules} folder\+:


\begin{DoxyCode}
1 $ shjs my\_script
\end{DoxyCode}


You can also just copy {\ttfamily shell.\+js} into your project\textquotesingle{}s directory, and {\ttfamily require()} accordingly.

\subsection*{Examples}

\subsubsection*{Java\+Script}


\begin{DoxyCode}
1 require('shelljs/global');
2 
3 if (!which('git')) \{
4   echo('Sorry, this script requires git');
5   exit(1);
6 \}
7 
8 // Copy files to release dir
9 mkdir('-p', 'out/Release');
10 cp('-R', 'stuff/*', 'out/Release');
11 
12 // Replace macros in each .js file
13 cd('lib');
14 ls('*.js').forEach(function(file) \{
15   sed('-i', 'BUILD\_VERSION', 'v0.1.2', file);
16   sed('-i', /.*REMOVE\_THIS\_LINE.*\(\backslash\)n/, '', file);
17   sed('-i', /.*REPLACE\_LINE\_WITH\_MACRO.*\(\backslash\)n/, cat('macro.js'), file);
18 \});
19 cd('..');
20 
21 // Run external tool synchronously
22 if (exec('git commit -am "Auto-commit"').code !== 0) \{
23   echo('Error: Git commit failed');
24   exit(1);
25 \}
\end{DoxyCode}


\subsubsection*{Coffee\+Script}


\begin{DoxyCode}
1 require 'shelljs/global'
2 
3 if not which 'git'
4   echo 'Sorry, this script requires git'
5   exit 1
6 
7 # Copy files to release dir
8 mkdir '-p', 'out/Release'
9 cp '-R', 'stuff/*', 'out/Release'
10 
11 # Replace macros in each .js file
12 cd 'lib'
13 for file in ls '*.js'
14   sed '-i', 'BUILD\_VERSION', 'v0.1.2', file
15   sed '-i', /.*REMOVE\_THIS\_LINE.*\(\backslash\)n/, '', file
16   sed '-i', /.*REPLACE\_LINE\_WITH\_MACRO.*\(\backslash\)n/, cat 'macro.js', file
17 cd '..'
18 
19 # Run external tool synchronously
20 if (exec 'git commit -am "Auto-commit"').code != 0
21   echo 'Error: Git commit failed'
22   exit 1
\end{DoxyCode}


\subsection*{Global vs. Local}

The example above uses the convenience script {\ttfamily shelljs/global} to reduce verbosity. If polluting your global namespace is not desirable, simply require {\ttfamily shelljs}.

Example\+:


\begin{DoxyCode}
1 var shell = require('shelljs');
2 shell.echo('hello world');
\end{DoxyCode}


\subsection*{Make tool}

A convenience script {\ttfamily shelljs/make} is also provided to mimic the behavior of a Unix Makefile. In this case all shell objects are global, and command line arguments will cause the script to execute only the corresponding function in the global {\ttfamily target} object. To avoid redundant calls, target functions are executed only once per script.

Example (Coffee\+Script)\+:


\begin{DoxyCode}
1 require 'shelljs/make'
2 
3 target.all = ->
4   target.bundle()
5   target.docs()
6 
7 target.bundle = ->
8   cd \_\_dirname
9   mkdir 'build'
10   cd 'lib'
11   (cat '*.js').to '../build/output.js'
12 
13 target.docs = ->
14   cd \_\_dirname
15   mkdir 'docs'
16   cd 'lib'
17   for file in ls '*.js'
18     text = grep '//@', file     # extract special comments
19     text.replace '//@', ''      # remove comment tags
20     text.to 'docs/my\_docs.md'
\end{DoxyCode}


To run the target {\ttfamily all}, call the above script without arguments\+: {\ttfamily \$ node make}. To run the target {\ttfamily docs}\+: {\ttfamily \$ node make docs}, and so on.

\subsection*{Command reference}

All commands run synchronously, unless otherwise stated.

\subsubsection*{cd(\textquotesingle{}dir\textquotesingle{})}

Changes to directory {\ttfamily dir} for the duration of the script

\subsubsection*{pwd()}

Returns the current directory.

\subsubsection*{ls(\mbox{[}options ,\mbox{]} path \mbox{[},path ...\mbox{]})}

\subsubsection*{ls(\mbox{[}options ,\mbox{]} path\+\_\+array)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/\+R}\+: recursive
\item {\ttfamily -\/\+A}\+: all files (include files beginning with {\ttfamily .}, except for {\ttfamily .} and {\ttfamily ..})
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 ls('projs/*.js');
2 ls('-R', '/users/me', '/tmp');
3 ls('-R', ['/users/me', '/tmp']); // same as above
\end{DoxyCode}


Returns array of files in the given path, or in current directory if no path provided.

\subsubsection*{find(path \mbox{[},path ...\mbox{]})}

\subsubsection*{find(path\+\_\+array)}

Examples\+:


\begin{DoxyCode}
1 find('src', 'lib');
2 find(['src', 'lib']); // same as above
3 find('.').filter(function(file) \{ return file.match(/\(\backslash\).js$/); \});
\end{DoxyCode}


Returns array of all files (however deep) in the given paths.

The main difference from `ls(\textquotesingle{}-\/\+R\textquotesingle{}, path){\ttfamily is that the resulting file names include the base directories, e.\+g.}lib/resources/file1{\ttfamily instead of just}file1`.

\subsubsection*{cp(\mbox{[}options ,\mbox{]} source \mbox{[},source ...\mbox{]}, dest)}

\subsubsection*{cp(\mbox{[}options ,\mbox{]} source\+\_\+array, dest)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/f}\+: force
\item {\ttfamily -\/r, -\/\+R}\+: recursive
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 cp('file1', 'dir1');
2 cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');
3 cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above
\end{DoxyCode}


Copies files. The wildcard {\ttfamily $\ast$} is accepted.

\subsubsection*{rm(\mbox{[}options ,\mbox{]} file \mbox{[}, file ...\mbox{]})}

\subsubsection*{rm(\mbox{[}options ,\mbox{]} file\+\_\+array)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/f}\+: force
\item {\ttfamily -\/r, -\/\+R}\+: recursive
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 rm('-rf', '/tmp/*');
2 rm('some\_file.txt', 'another\_file.txt');
3 rm(['some\_file.txt', 'another\_file.txt']); // same as above
\end{DoxyCode}


Removes files. The wildcard {\ttfamily $\ast$} is accepted.

\subsubsection*{mv(source \mbox{[}, source ...\mbox{]}, dest\textquotesingle{})}

\subsubsection*{mv(source\+\_\+array, dest\textquotesingle{})}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily f}\+: force
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 mv('-f', 'file', 'dir/');
2 mv('file1', 'file2', 'dir/');
3 mv(['file1', 'file2'], 'dir/'); // same as above
\end{DoxyCode}


Moves files. The wildcard {\ttfamily $\ast$} is accepted.

\subsubsection*{mkdir(\mbox{[}options ,\mbox{]} dir \mbox{[}, dir ...\mbox{]})}

\subsubsection*{mkdir(\mbox{[}options ,\mbox{]} dir\+\_\+array)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily p}\+: full path (will create intermediate dirs if necessary)
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 mkdir('-p', '/tmp/a/b/c/d', '/tmp/e/f/g');
2 mkdir('-p', ['/tmp/a/b/c/d', '/tmp/e/f/g']); // same as above
\end{DoxyCode}


Creates directories.

\subsubsection*{test(expression)}

Available expression primaries\+:


\begin{DoxyItemize}
\item `\textquotesingle{}-\/b\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a block device +}\textquotesingle{}-\/c\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a character device +}\textquotesingle{}-\/d\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a directory +}\textquotesingle{}-\/e\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path exists +}\textquotesingle{}-\/f\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a regular file +}\textquotesingle{}-\/\+L\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a symboilc link +}\textquotesingle{}-\/p\textquotesingle{}, \textquotesingle{}path\textquotesingle{}{\ttfamily \+: true if path is a pipe (F\+I\+F\+O) +}\textquotesingle{}-\/\+S\textquotesingle{}, \textquotesingle{}path\textquotesingle{}`\+: true if path is a socket
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 if (test('-d', path)) \{ /* do something with dir */ \};
2 if (!test('-f', path)) continue; // skip if it's a regular file
\end{DoxyCode}


Evaluates expression using the available primaries and returns corresponding value.

\subsubsection*{cat(file \mbox{[}, file ...\mbox{]})}

\subsubsection*{cat(file\+\_\+array)}

Examples\+:


\begin{DoxyCode}
1 var str = cat('file*.txt');
2 var str = cat('file1', 'file2');
3 var str = cat(['file1', 'file2']); // same as above
\end{DoxyCode}


Returns a string containing the given file, or a concatenated string containing the files if more than one file is given (a new line character is introduced between each file). Wildcard {\ttfamily $\ast$} accepted.

\subsubsection*{\textquotesingle{}string\textquotesingle{}.to(file)}

Examples\+:


\begin{DoxyCode}
1 cat('input.txt').to('output.txt');
\end{DoxyCode}


Analogous to the redirection operator {\ttfamily $>$} in Unix, but works with Java\+Script strings (such as those returned by {\ttfamily cat}, {\ttfamily grep}, etc). {\itshape Like Unix redirections, {\ttfamily to()} will overwrite any existing file!}

\subsubsection*{\textquotesingle{}string\textquotesingle{}.to\+End(file)}

Examples\+:


\begin{DoxyCode}
1 cat('input.txt').toEnd('output.txt');
\end{DoxyCode}


Analogous to the redirect-\/and-\/append operator {\ttfamily $>$$>$} in Unix, but works with Java\+Script strings (such as those returned by {\ttfamily cat}, {\ttfamily grep}, etc).

\subsubsection*{sed(\mbox{[}options ,\mbox{]} search\+\_\+regex, replacement, file)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/i}\+: Replace contents of \textquotesingle{}file\textquotesingle{} in-\/place. {\itshape Note that no backups will be created!}
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 sed('-i', 'PROGRAM\_VERSION', 'v0.1.3', 'source.js');
2 sed(/.*DELETE\_THIS\_LINE.*\(\backslash\)n/, '', 'source.js');
\end{DoxyCode}


Reads an input string from {\ttfamily file} and performs a Java\+Script {\ttfamily replace()} on the input using the given search regex and replacement string or function. Returns the new string after replacement.

\subsubsection*{grep(\mbox{[}options ,\mbox{]} regex\+\_\+filter, file \mbox{[}, file ...\mbox{]})}

\subsubsection*{grep(\mbox{[}options ,\mbox{]} regex\+\_\+filter, file\+\_\+array)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/v}\+: Inverse the sense of the regex and print the lines not matching the criteria.
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 grep('-v', 'GLOBAL\_VARIABLE', '*.js');
2 grep('GLOBAL\_VARIABLE', '*.js');
\end{DoxyCode}


Reads input string from given files and returns a string containing all lines of the file that match the given {\ttfamily regex\+\_\+filter}. Wildcard {\ttfamily $\ast$} accepted.

\subsubsection*{which(command)}

Examples\+:


\begin{DoxyCode}
1 var nodeExec = which('node');
\end{DoxyCode}


Searches for {\ttfamily command} in the system\textquotesingle{}s P\+A\+T\+H. On Windows looks for {\ttfamily .exe}, {\ttfamily .cmd}, and {\ttfamily .bat} extensions. Returns string containing the absolute path to the command.

\subsubsection*{echo(string \mbox{[},string ...\mbox{]})}

Examples\+:


\begin{DoxyCode}
1 echo('hello world');
2 var str = echo('hello world');
\end{DoxyCode}


Prints string to stdout, and returns string with additional utility methods like {\ttfamily .to()}.

\subsubsection*{pushd(\mbox{[}options,\mbox{]} \mbox{[}dir $\vert$ \textquotesingle{}-\/\+N\textquotesingle{} $\vert$ \textquotesingle{}+\+N\textquotesingle{}\mbox{]})}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/n}\+: Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.
\end{DoxyItemize}

Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily dir}\+: Makes the current working directory be the top of the stack, and then executes the equivalent of {\ttfamily cd dir}.
\item {\ttfamily +\+N}\+: Brings the Nth directory (counting from the left of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.
\item {\ttfamily -\/\+N}\+: Brings the Nth directory (counting from the right of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 // process.cwd() === '/usr'
2 pushd('/etc'); // Returns /etc /usr
3 pushd('+1');   // Returns /usr /etc
\end{DoxyCode}


Save the current directory on the top of the directory stack and then cd to {\ttfamily dir}. With no arguments, pushd exchanges the top two directories. Returns an array of paths in the stack.

\subsubsection*{popd(\mbox{[}options,\mbox{]} \mbox{[}\textquotesingle{}-\/\+N\textquotesingle{} $\vert$ \textquotesingle{}+\+N\textquotesingle{}\mbox{]})}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/n}\+: Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.
\end{DoxyItemize}

Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily +\+N}\+: Removes the Nth directory (counting from the left of the list printed by dirs), starting with zero.
\item {\ttfamily -\/\+N}\+: Removes the Nth directory (counting from the right of the list printed by dirs), starting with zero.
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 echo(process.cwd()); // '/usr'
2 pushd('/etc');       // '/etc /usr'
3 echo(process.cwd()); // '/etc'
4 popd();              // '/usr'
5 echo(process.cwd()); // '/usr'
\end{DoxyCode}


When no arguments are given, popd removes the top directory from the stack and performs a cd to the new top directory. The elements are numbered from 0 starting at the first directory listed with dirs; i.\+e., popd is equivalent to popd +0. Returns an array of paths in the stack.

\subsubsection*{dirs(\mbox{[}options $\vert$ \textquotesingle{}+\+N\textquotesingle{} $\vert$ \textquotesingle{}-\/\+N\textquotesingle{}\mbox{]})}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/c}\+: Clears the directory stack by deleting all of the elements.
\end{DoxyItemize}

Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily +\+N}\+: Displays the Nth directory (counting from the left of the list printed by dirs when invoked without options), starting with zero.
\item {\ttfamily -\/\+N}\+: Displays the Nth directory (counting from the right of the list printed by dirs when invoked without options), starting with zero.
\end{DoxyItemize}

Display the list of currently remembered directories. Returns an array of paths in the stack, or a single path if +\+N or -\/\+N was specified.

See also\+: pushd, popd

\subsubsection*{ln(options, source, dest)}

\subsubsection*{ln(source, dest)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily s}\+: symlink
\item {\ttfamily f}\+: force
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 ln('file', 'newlink');
2 ln('-sf', 'file', 'existing');
\end{DoxyCode}


Links source to dest. Use -\/f to force the link, should dest already exist.

\subsubsection*{exit(code)}

Exits the current process with the given exit code.

\subsubsection*{env\mbox{[}\textquotesingle{}V\+A\+R\+\_\+\+N\+A\+M\+E\textquotesingle{}\mbox{]}}

Object containing environment variables (both getter and setter). Shortcut to process.\+env.

\subsubsection*{exec(command \mbox{[}, options\mbox{]} \mbox{[}, callback\mbox{]})}

Available options (all {\ttfamily false} by default)\+:


\begin{DoxyItemize}
\item {\ttfamily async}\+: Asynchronous execution. Defaults to true if a callback is provided.
\item {\ttfamily silent}\+: Do not echo program output to console.
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 var version = exec('node --version', \{silent:true\}).output;
2 
3 var child = exec('some\_long\_running\_process', \{async:true\});
4 child.stdout.on('data', function(data) \{
5   /* ... do something with data ... */
6 \});
7 
8 exec('some\_long\_running\_process', function(code, output) \{
9   console.log('Exit code:', code);
10   console.log('Program output:', output);
11 \});
\end{DoxyCode}


Executes the given {\ttfamily command} {\itshape synchronously}, unless otherwise specified. When in synchronous mode returns the object {\ttfamily \{ code\+:..., output\+:... \}}, containing the program\textquotesingle{}s {\ttfamily output} (stdout + stderr) and its exit {\ttfamily code}. Otherwise returns the child process object, and the {\ttfamily callback} gets the arguments {\ttfamily (code, output)}.

{\bfseries Note\+:} For long-\/lived processes, it\textquotesingle{}s best to run {\ttfamily exec()} asynchronously as the current synchronous implementation uses a lot of C\+P\+U. This should be getting fixed soon.

\subsubsection*{chmod(octal\+\_\+mode $\vert$$\vert$ octal\+\_\+string, file)}

\subsubsection*{chmod(symbolic\+\_\+mode, file)}

Available options\+:


\begin{DoxyItemize}
\item {\ttfamily -\/v}\+: output a diagnostic for every file processed
\item {\ttfamily -\/c}\+: like verbose but report only when a change is made
\item {\ttfamily -\/\+R}\+: change files and directories recursively
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
1 chmod(755, '/Users/brandon');
2 chmod('755', '/Users/brandon'); // same as above
3 chmod('u+x', '/Users/brandon');
\end{DoxyCode}


Alters the permissions of a file or directory by either specifying the absolute permissions in octal form or expressing the changes in symbols. This command tries to mimic the P\+O\+S\+I\+X behavior as much as possible. Notable exceptions\+:


\begin{DoxyItemize}
\item In symbolic modes, \textquotesingle{}a-\/r\textquotesingle{} and \textquotesingle{}-\/r\textquotesingle{} are identical. No consideration is given to the umask.
\item There is no \char`\"{}quiet\char`\"{} option since default behavior is to run silent.
\end{DoxyItemize}

\subsection*{Non-\/\+Unix commands}

\subsubsection*{tempdir()}

Examples\+:


\begin{DoxyCode}
1 var tmp = tempdir(); // "/tmp" for most *nix platforms
\end{DoxyCode}


Searches and returns string containing a writeable, platform-\/dependent temporary directory. Follows Python\textquotesingle{}s \href{http://docs.python.org/library/tempfile.html#tempfile.tempdir}{\tt tempfile algorithm}.

\subsubsection*{error()}

Tests if error occurred in the last command. Returns {\ttfamily null} if no error occurred, otherwise returns string explaining the error

\subsection*{Configuration}

\subsubsection*{config.\+silent}

Example\+:


\begin{DoxyCode}
1 var silentState = config.silent; // save old silent state
2 config.silent = true;
3 /* ... */
4 config.silent = silentState; // restore old silent state
\end{DoxyCode}


Suppresses all command output if {\ttfamily true}, except for {\ttfamily echo()} calls. Default is {\ttfamily false}.

\subsubsection*{config.\+fatal}

Example\+:


\begin{DoxyCode}
1 config.fatal = true;
2 cp('this\_file\_does\_not\_exist', '/dev/null'); // dies here
3 /* more commands... */
\end{DoxyCode}


If {\ttfamily true} the script will die on errors. Default is {\ttfamily false}. 