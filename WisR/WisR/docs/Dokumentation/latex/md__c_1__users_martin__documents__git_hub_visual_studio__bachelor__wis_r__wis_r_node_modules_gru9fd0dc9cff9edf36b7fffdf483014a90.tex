\begin{quote}
A full-\/featured markdown parser and compiler, written in Java\+Script. Built for speed. \end{quote}


\href{http://badge.fury.io/js/marked}{\tt !\mbox{[}N\+P\+M version\mbox{]}(https\+://badge.\+fury.\+io/js/marked.\+png)}

\subsection*{Install}


\begin{DoxyCode}
1 npm install marked --save
\end{DoxyCode}


\subsection*{Usage}

Minimal usage\+:


\begin{DoxyCode}
var marked = require(\textcolor{stringliteral}{'marked'});
console.log(marked(\textcolor{stringliteral}{'I am using \_\_markdown\_\_.'}));
\textcolor{comment}{// Outputs: <p>I am using <strong>markdown</strong>.</p>}
\end{DoxyCode}


Example setting options with default values\+:


\begin{DoxyCode}
var marked = require(\textcolor{stringliteral}{'marked'});
marked.setOptions(\{
  renderer: \textcolor{keyword}{new} marked.Renderer(),
  gfm: \textcolor{keyword}{true},
  tables: \textcolor{keyword}{true},
  breaks: \textcolor{keyword}{false},
  pedantic: \textcolor{keyword}{false},
  sanitize: \textcolor{keyword}{true},
  smartLists: \textcolor{keyword}{true},
  smartypants: \textcolor{keyword}{false}
\});

console.log(marked(\textcolor{stringliteral}{'I am using \_\_markdown\_\_.'}));
\end{DoxyCode}


\subsubsection*{Browser}


\begin{DoxyCode}
1 <!doctype html>
2 <html>
3 <head>
4   <meta charset="utf-8"/>
5   <title>Marked in the browser</title>
6   <script src="lib/marked.js"></script>
7 </head>
8 <body>
9   <div id="content"></div>
10   <script>
11     document.getElementById('content').innerHTML =
12       marked('# Marked in browser\(\backslash\)n\(\backslash\)nRendered by **marked**.');
13   </script>
14 </body>
15 </html>
\end{DoxyCode}


\subsection*{marked(markdown\+String \mbox{[},options\mbox{]} \mbox{[},callback\mbox{]})}

\subsubsection*{markdown\+String}

Type\+: {\ttfamily string}

String of markdown source to be compiled.

\subsubsection*{options}

Type\+: {\ttfamily object}

Hash of options. Can also be set using the {\ttfamily marked.\+set\+Options} method as seen above.

\subsubsection*{callback}

Type\+: {\ttfamily function}

Function called when the {\ttfamily markdown\+String} has been fully parsed when using async highlighting. If the {\ttfamily options} argument is omitted, this can be used as the second argument.

\subsection*{Options}

\subsubsection*{highlight}

Type\+: {\ttfamily function}

A function to highlight code blocks. The first example below uses async highlighting with \href{https://github.com/rvagg/node-pygmentize-bundled}{\tt node-\/pygmentize-\/bundled}, and the second is a synchronous example using \href{https://github.com/isagalaev/highlight.js}{\tt highlight.\+js}\+:


\begin{DoxyCode}
var marked = require(\textcolor{stringliteral}{'marked'});

var markdownString = \textcolor{stringliteral}{'```js\(\backslash\)n console.log("hello"); \(\backslash\)n```'};

\textcolor{comment}{// Async highlighting with pygmentize-bundled}
marked.setOptions(\{
  highlight: \textcolor{keyword}{function} (code, lang, callback) \{
    require(\textcolor{stringliteral}{'pygmentize-bundled'})(\{ lang: lang, format: \textcolor{stringliteral}{'html'} \}, code, \textcolor{keyword}{function} (err, result) \{
      callback(err, result.toString());
    \});
  \}
\});

\textcolor{comment}{// Using async version of marked}
marked(markdownString, \textcolor{keyword}{function} (err, content) \{
  \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{throw} err;
  console.log(content);
\});

\textcolor{comment}{// Synchronous highlighting with highlight.js}
marked.setOptions(\{
  highlight: \textcolor{keyword}{function} (code) \{
    \textcolor{keywordflow}{return} require(\textcolor{stringliteral}{'highlight.js'}).highlightAuto(code).value;
  \}
\});

console.log(marked(markdownString));
\end{DoxyCode}


\paragraph*{highlight arguments}

{\ttfamily code}

Type\+: {\ttfamily string}

The section of code to pass to the highlighter.

{\ttfamily lang}

Type\+: {\ttfamily string}

The programming language specified in the code block.

{\ttfamily callback}

Type\+: {\ttfamily function}

The callback function to call when using an async highlighter.

\subsubsection*{renderer}

Type\+: {\ttfamily object} Default\+: {\ttfamily new Renderer()}

An object containing functions to render tokens to H\+T\+M\+L.

\paragraph*{Overriding renderer methods}

The renderer option allows you to render tokens in a custom manner. Here is an example of overriding the default heading token rendering by adding an embedded anchor tag like on Git\+Hub\+:


\begin{DoxyCode}
1 var marked = require('marked');
2 var renderer = new marked.Renderer();
3 
4 renderer.heading = function (text, level) \{
5   var escapedText = text.toLowerCase().replace(/[^\(\backslash\)w]+/g, '-');
6 
7   return '<h' + level + '><a name="' +
8                 escapedText +
9                  '" class="anchor" href="#' +
10                  escapedText +
11                  '"><span class="header-link"></span></a>' +
12                   text + '</h' + level + '>';
13 \},
14 
15 console.log(marked('# heading+', \{ renderer: renderer \}));
\end{DoxyCode}
 This code will output the following H\+T\+M\+L\+: 
\begin{DoxyCode}
1 <h1>
2   <a name="heading-" class="anchor" href="#heading-">
3     <span class="header-link"></span>
4   </a>
5   heading+
6 </h1>
\end{DoxyCode}


\paragraph*{Block level renderer methods}


\begin{DoxyItemize}
\item code({\itshape string} code, {\itshape string} language)
\item blockquote({\itshape string} quote)
\item html({\itshape string} html)
\item heading({\itshape string} text, {\itshape number} level)
\item hr()
\item list({\itshape string} body, {\itshape boolean} ordered)
\item listitem({\itshape string} text)
\item paragraph({\itshape string} text)
\item table({\itshape string} header, {\itshape string} body)
\item tablerow({\itshape string} content)
\item tablecell({\itshape string} content, {\itshape object} flags)
\end{DoxyItemize}

{\ttfamily flags} has the following properties\+:


\begin{DoxyCode}
\{
    header: \textcolor{keyword}{true} || \textcolor{keyword}{false},
    align: \textcolor{stringliteral}{'center'} || \textcolor{stringliteral}{'left'} || \textcolor{stringliteral}{'right'}
\}
\end{DoxyCode}


\paragraph*{Inline level renderer methods}


\begin{DoxyItemize}
\item strong({\itshape string} text)
\item em({\itshape string} text)
\item codespan({\itshape string} code)
\item br()
\item del({\itshape string} text)
\item link({\itshape string} href, {\itshape string} title, {\itshape string} text)
\item image({\itshape string} href, {\itshape string} title, {\itshape string} text)
\end{DoxyItemize}

\subsubsection*{gfm}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily true}

Enable \href{https://help.github.com/articles/github-flavored-markdown}{\tt Git\+Hub flavored markdown}.

\subsubsection*{tables}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily true}

Enable G\+F\+M \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#wiki-tables}{\tt tables}. This option requires the {\ttfamily gfm} option to be true.

\subsubsection*{breaks}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily false}

Enable G\+F\+M \href{https://help.github.com/articles/github-flavored-markdown#newlines}{\tt line breaks}. This option requires the {\ttfamily gfm} option to be true.

\subsubsection*{pedantic}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily false}

Conform to obscure parts of {\ttfamily markdown.\+pl} as much as possible. Don\textquotesingle{}t fix any of the original markdown bugs or poor behavior.

\subsubsection*{sanitize}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily false}

Sanitize the output. Ignore any H\+T\+M\+L that has been input.

\subsubsection*{smart\+Lists}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily true}

Use smarter list behavior than the original markdown. May eventually be default with the old behavior moved into {\ttfamily pedantic}.

\subsubsection*{smartypants}

Type\+: {\ttfamily boolean} Default\+: {\ttfamily false}

Use \char`\"{}smart\char`\"{} typograhic punctuation for things like quotes and dashes.

\subsection*{Access to lexer and parser}

You also have direct access to the lexer and parser if you so desire.


\begin{DoxyCode}
1 var tokens = marked.lexer(text, options);
2 console.log(marked.parser(tokens));
\end{DoxyCode}



\begin{DoxyCode}
1 var lexer = new marked.Lexer(options);
2 var tokens = lexer.lex(text);
3 console.log(tokens);
4 console.log(lexer.rules);
\end{DoxyCode}


\subsection*{C\+L\+I}


\begin{DoxyCode}
1 $ marked -o hello.html
2 hello world
3 ^D
4 $ cat hello.html
5 <p>hello world</p>
\end{DoxyCode}


\subsection*{Philosophy behind marked}

The point of marked was to create a markdown compiler where it was possible to frequently parse huge chunks of markdown without having to worry about caching the compiled output somehow...or blocking for an unnecesarily long time.

marked is very concise and still implements all markdown features. It is also now fully compatible with the client-\/side.

marked more or less passes the official markdown test suite in its entirety. This is important because a surprising number of markdown compilers cannot pass more than a few tests. It was very difficult to get marked as compliant as it is. It could have cut corners in several areas for the sake of performance, but did not in order to be exactly what you expect in terms of a markdown rendering. In fact, this is why marked could be considered at a disadvantage in the benchmarks above.

Along with implementing every markdown feature, marked also implements \href{http://github.github.com/github-flavored-markdown/}{\tt G\+F\+M features}.

\subsection*{Benchmarks}

node v0.\+8.\+x


\begin{DoxyCode}
1 $ node test --bench
2 marked completed in 3411ms.
3 marked (gfm) completed in 3727ms.
4 marked (pedantic) completed in 3201ms.
5 robotskirt completed in 808ms.
6 showdown (reuse converter) completed in 11954ms.
7 showdown (new converter) completed in 17774ms.
8 markdown-js completed in 17191ms.
\end{DoxyCode}


{\bfseries Marked is now faster than Discount, which is written in C.}

For those feeling skeptical\+: These benchmarks run the entire markdown test suite 1000 times. The test suite tests every feature. It doesn\textquotesingle{}t cater to specific aspects.

\subsubsection*{Pro level}

You also have direct access to the lexer and parser if you so desire.


\begin{DoxyCode}
1 var tokens = marked.lexer(text, options);
2 console.log(marked.parser(tokens));
\end{DoxyCode}



\begin{DoxyCode}
1 var lexer = new marked.Lexer(options);
2 var tokens = lexer.lex(text);
3 console.log(tokens);
4 console.log(lexer.rules);
\end{DoxyCode}



\begin{DoxyCode}
1 $ node
2 > require('marked').lexer('> i am using marked.')
3 [ \{ type: 'blockquote\_start' \},
4   \{ type: 'paragraph',
5     text: 'i am using marked.' \},
6   \{ type: 'blockquote\_end' \},
7   links: \{\} ]
\end{DoxyCode}


\subsection*{Running Tests \& Contributing}

If you want to submit a pull request, make sure your changes pass the test suite. If you\textquotesingle{}re adding a new feature, be sure to add your own test.

The marked test suite is set up slightly strangely\+: {\ttfamily test/new} is for all tests that are not part of the original markdown.\+pl test suite (this is where your test should go if you make one). {\ttfamily test/original} is only for the original markdown.\+pl tests. {\ttfamily test/tests} houses both types of tests after they have been combined and moved/generated by running {\ttfamily node test -\/-\/fix} or {\ttfamily marked -\/-\/test -\/-\/fix}.

In other words, if you have a test to add, add it to {\ttfamily test/new/} and then regenerate the tests with {\ttfamily node test -\/-\/fix}. Commit the result. If your test uses a certain feature, for example, maybe it assumes G\+F\+M is {\itshape not} enabled, you can add {\ttfamily .nogfm} to the filename. So, {\ttfamily my-\/test.\+text} becomes {\ttfamily my-\/test.\+nogfm.\+text}. You can do this with any marked option. Say you want line breaks and smartypants enabled, your filename should be\+: {\ttfamily my-\/test.\+breaks.\+smartypants.\+text}.

To run the tests\+:


\begin{DoxyCode}
1 cd marked/
2 node test
\end{DoxyCode}


\subsubsection*{Contribution and License Agreement}

If you contribute code to this project, you are implicitly allowing your code to be distributed under the M\+I\+T license. You are also implicitly verifying that all code is your original work. {\ttfamily $<$/legalese$>$}

\subsection*{License}

Copyright (c) 2011-\/2014, Christopher Jeffrey. (M\+I\+T License)

See L\+I\+C\+E\+N\+S\+E for more info. 