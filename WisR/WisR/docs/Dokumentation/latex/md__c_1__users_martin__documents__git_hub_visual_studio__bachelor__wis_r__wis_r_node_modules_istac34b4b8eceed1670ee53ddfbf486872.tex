Yargs be a node.\+js library fer hearties tryin\textquotesingle{} ter parse optstrings.

With yargs, ye be havin\textquotesingle{} a map that leads straight to yer treasure! Treasure of course, being a simple option hash.

\href{https://travis-ci.org/bcoe/yargs}{\tt !\mbox{[}Build Status\mbox{]}(https\+://travis-\/ci.\+org/bcoe/yargs.\+png)} \href{https://gemnasium.com/bcoe/yargs}{\tt !\mbox{[}Dependency Status\mbox{]}(https\+://gemnasium.\+com/bcoe/yargs.\+png)} \href{https://coveralls.io/r/bcoe/yargs?branch=}{\tt !\mbox{[}Coverage Status\mbox{]}(https\+://coveralls.\+io/repos/bcoe/yargs/badge.\+svg?branch=)} \href{https://www.npmjs.com/package/yargs}{\tt !\mbox{[}N\+P\+M version\mbox{]}(https\+://img.\+shields.\+io/npm/v/yargs.\+svg)}

\begin{quote}
Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you\textquotesingle{}d like to contribute and don\textquotesingle{}t know where to start, have a look at \href{https://github.com/bcoe/yargs/issues}{\tt the issue list} \+:) \end{quote}


\section*{examples }

\subsection*{With yargs, the options be just a hash! }

xup.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs').argv;
3 
4 if (argv.rif - 5 * argv.xup > 7.138) \{
5     console.log('Plunder more riffiwobbles!');
6 \}
7 else \{
8     console.log('Drop the xupptumblers!');
9 \}
\end{DoxyCode}




 \begin{DoxyVerb}$ ./xup.js --rif=55 --xup=9.52
Plunder more riffiwobbles!

$ ./xup.js --rif 12 --xup 8.1
Drop the xupptumblers!
\end{DoxyVerb}




\subsection*{But don\textquotesingle{}t walk the plank just yet! There be more! You can do short options\+: }

short.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs').argv;
3 console.log('(%d,%d)', argv.x, argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./short.js -x 10 -y 21
(10,21)
\end{DoxyVerb}


\subsection*{And booleans, both long, short, and even grouped\+: }

bool.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var util = require('util');
3 var argv = require('yargs').argv;
4 
5 if (argv.s) \{
6     util.print(argv.fr ? 'Le perroquet dit: ' : 'The parrot says: ');
7 \}
8 console.log(
9     (argv.fr ? 'couac' : 'squawk') + (argv.p ? '!' : '')
10 );
\end{DoxyCode}




 \begin{DoxyVerb}$ ./bool.js -s
The parrot says: squawk

$ ./bool.js -sp
The parrot says: squawk!

$ ./bool.js -sp --fr
Le perroquet dit: couac!
\end{DoxyVerb}


\subsection*{And non-\/hyphenated options too! Just use {\ttfamily argv.\+\_\+}! }

nonopt.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs').argv;
3 console.log('(%d,%d)', argv.x, argv.y);
4 console.log(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./nonopt.js -x 6.82 -y 3.35 rum
(6.82,3.35)
[ 'rum' ]

$ ./nonopt.js "me hearties" -x 0.54 yo -y 1.12 ho
(0.54,1.12)
[ 'me hearties', 'yo', 'ho' ]
\end{DoxyVerb}


\subsection*{Yargs even counts your booleans! }

count.\+js


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .count('verbose')
4     .alias('v', 'verbose')
5     .argv;
6 
7 VERBOSE\_LEVEL = argv.verbose;
8 
9 function WARN()  \{ VERBOSE\_LEVEL >= 0 && console.log.apply(console, arguments); \}
10 function INFO()  \{ VERBOSE\_LEVEL >= 1 && console.log.apply(console, arguments); \}
11 function DEBUG() \{ VERBOSE\_LEVEL >= 2 && console.log.apply(console, arguments); \}
12 
13 WARN("Showing only important stuff");
14 INFO("Showing semi-mportant stuff too");
15 DEBUG("Extra chatty mode");
\end{DoxyCode}




 \$ node count.\+js Showing only important stuff

\$ node count.\+js -\/v Showing only important stuff Showing semi-\/important stuff too

\$ node count.\+js -\/vv Showing only important stuff Showing semi-\/important stuff too Extra chatty mode

\$ node count.\+js -\/v --verbose Showing only important stuff Showing semi-\/important stuff too Extra chatty mode

\subsection*{Tell users how to use yer options and make demands. }

divide.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .usage('Usage: $0 -x [num] -y [num]')
4     .demand(['x','y'])
5     .argv;
6 
7 console.log(argv.x / argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./divide.js -x 55 -y 11
5

$ node ./divide.js -x 4.91 -z 2.51
Usage: node ./divide.js -x [num] -y [num]

Options:
  -x  [required]
  -y  [required]

Missing required arguments: y
\end{DoxyVerb}


\subsection*{After yer demands have been met, demand more! Ask for non-\/hypenated arguments! }

demand\+\_\+count.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .demand(2)
4     .argv;
5 console.dir(argv)
\end{DoxyCode}




 \begin{DoxyVerb}$ ./demand_count.js a
Not enough arguments, expected 2, but only found 1
$ ./demand_count.js a b
{ _: [ 'a', 'b' ], '$0': 'node ./demand_count.js' }
$ ./demand_count.js a b c
{ _: [ 'a', 'b', 'c' ], '$0': 'node ./demand_count.js' }
\end{DoxyVerb}


\subsection*{E\+V\+E\+N M\+O\+R\+E S\+H\+I\+V\+E\+R M\+E T\+I\+M\+B\+E\+R\+S! }

default\+\_\+singles.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .default('x', 10)
4     .default('y', 10)
5     .argv
6 ;
7 console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_singles.js -x 5
15
\end{DoxyVerb}


default\+\_\+hash.\+js\+:


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .default(\{ x : 10, y : 10 \})
4     .argv
5 ;
6 console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_hash.js -y 7
17
\end{DoxyVerb}


\subsection*{And if you really want to get all descriptive about it... }

boolean\+\_\+single.\+js


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .boolean('v')
4     .argv
5 ;
6 console.dir(argv.v);
7 console.dir(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_single.js -v "me hearties" yo ho
true
[ 'me hearties', 'yo', 'ho' ]
\end{DoxyVerb}


boolean\+\_\+double.\+js


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .boolean(['x','y','z'])
4     .argv
5 ;
6 console.dir([ argv.x, argv.y, argv.z ]);
7 console.dir(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_double.js -x -z one two three
[ true, false, true ]
[ 'one', 'two', 'three' ]
\end{DoxyVerb}


\subsection*{Yargs is here to help you... }

Ye can describe parameters fer help messages and set aliases. Yargs figures out how ter format a handy help string automatically.

line\+\_\+count.\+js


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .usage('Usage: $0 <command> [options]')
4     .command('count', 'Count the lines in a file')
5     .demand(1)
6     .example('$0 count -f foo.js', 'count the lines in the given file')
7     .demand('f')
8     .alias('f', 'file')
9     .nargs('f', 1)
10     .describe('f', 'Load a file')
11     .help('h')
12     .alias('h', 'help')
13     .epilog('copyright 2015')
14     .argv;
15 
16 var fs = require('fs');
17 var s = fs.createReadStream(argv.file);
18 
19 var lines = 0;
20 s.on('data', function (buf) \{
21     lines += buf.toString().match(/\(\backslash\)n/g).length;
22 \});
23 
24 s.on('end', function () \{
25     console.log(lines);
26 \});
\end{DoxyCode}




 \$ node line\+\_\+count.\+js count Usage\+: node test.\+js $<$command$>$ \mbox{[}options\mbox{]}

Commands\+: count Count the lines in a file

Options\+: -\/f, --file Load a file \mbox{[}required\mbox{]} -\/h, --help Show help

Examples\+: node test.\+js count -\/f foo.\+js count the lines in the given file

copyright 2015

Missing required arguments\+: f

\$ node line\+\_\+count.\+js count --file line\+\_\+count.\+js 20

\$ node line\+\_\+count.\+js count -\/f line\+\_\+count.\+js 20

\section*{methods }

By itself,

````javascript require(\textquotesingle{}yargs\textquotesingle{}).argv `````

will use {\ttfamily process.\+argv} array to construct the {\ttfamily argv} object.

You can pass in the {\ttfamily process.\+argv} yourself\+:


\begin{DoxyCode}
1 require('yargs')([ '-x', '1', '-y', '2' ]).argv
\end{DoxyCode}


or use .parse() to do the same thing\+:


\begin{DoxyCode}
1 require('yargs').parse([ '-x', '1', '-y', '2' ])
\end{DoxyCode}


The rest of these methods below come in just before the terminating {\ttfamily .argv}.

\subsection*{.alias(key, alias) }

Set key names as equivalent such that updates to a key will propagate to aliases and vice-\/versa.

Optionally {\ttfamily .alias()} can take an object that maps keys to aliases. Each key of this object should be the canonical version of the option, and each value should be a string or an array of strings.

\subsection*{.default(key, value, \mbox{[}description\mbox{]}) }

Set {\ttfamily argv\mbox{[}key\mbox{]}} to {\ttfamily value} if no option was specified on {\ttfamily process.\+argv}.

Optionally {\ttfamily .default()} can take an object that maps keys to default values.

But wait, there\textquotesingle{}s more! the default value can be a {\ttfamily function} which returns a value. The name of the function will be used in the usage string\+:


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .default(\textcolor{stringliteral}{'random'}, \textcolor{keyword}{function} randomValue() \{
    \textcolor{keywordflow}{return} Math.random() * 256;
  \}).argv;
\end{DoxyCode}


Optionally, {\ttfamily description} can also be provided and will take precedence over displaying the value in the usage instructions\+:


\begin{DoxyCode}
.default(\textcolor{stringliteral}{'timeout'}, 60000, \textcolor{stringliteral}{'(one-minute)'});
\end{DoxyCode}


\subsection*{.demand(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

\subsection*{.require(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

\subsection*{.required(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

If {\ttfamily key} is a string, show the usage information and exit if {\ttfamily key} wasn\textquotesingle{}t specified in {\ttfamily process.\+argv}.

If {\ttfamily key} is a number, demand at least as many non-\/option arguments, which show up in {\ttfamily argv.\+\_\+}.

If {\ttfamily key} is an Array, demand each element.

If a {\ttfamily msg} string is given, it will be printed when the argument is missing, instead of the standard error message. This is especially helpful for the non-\/option arguments in {\ttfamily argv.\+\_\+}.

If a {\ttfamily boolean} value is given, it controls whether the option is demanded; this is useful when using {\ttfamily .options()} to specify command line parameters.

\subsection*{.requires\+Arg(key) }

Specifies either a single option key (string), or an array of options that must be followed by option values. If any option value is missing, show the usage information and exit.

The default behaviour is to set the value of any key not followed by an option value to {\ttfamily true}.

\subsection*{.implies(x, y) }

Given the key {\ttfamily x} is set, it is required that the key {\ttfamily y} is set.

implies can also accept an object specifying multiple implications.

\subsection*{.describe(key, desc) }

Describe a {\ttfamily key} for the generated usage information.

Optionally {\ttfamily .describe()} can take an object that maps keys to descriptions.

\subsection*{.option(key, opt) }

\subsection*{.options(key, opt) }

Instead of chaining together {\ttfamily .alias().demand().default().describe().string()}, you can specify keys in {\ttfamily opt} for each of the chainable methods.

For example\+:


\begin{DoxyCode}
1 var argv = require('yargs')
2     .option('f', \{
3         alias : 'file',
4         demand: true,
5         default: '/etc/passwd',
6         describe: 'x marks the spot',
7         type: 'string'
8     \})
9     .argv
10 ;
\end{DoxyCode}


is the same as


\begin{DoxyCode}
1 var argv = require('yargs')
2     .alias('f', 'file')
3     .default('f', '/etc/passwd')
4     .argv
5 ;
\end{DoxyCode}


Optionally {\ttfamily .options()} can take an object that maps keys to {\ttfamily opt} parameters.


\begin{DoxyCode}
1 var argv = require('yargs')
2     .options(\{
3       'f': \{
4         alias: 'file',
5         demand: true,
6         default: '/etc/passwd',
7         describe: 'x marks the spot',
8         type: 'string'
9       \}
10     \})
11     .argv
12 ;
\end{DoxyCode}


\subsection*{.usage(message, opts) }

Set a usage message to show which commands to use. Inside {\ttfamily message}, the string {\ttfamily \$0} will get interpolated to the current script name or node command for the present script similar to how {\ttfamily \$0} works in bash or perl.

{\ttfamily opts} is optional and acts like calling {\ttfamily .options(opts)}.

\subsection*{.command(cmd, desc) }

Document the commands exposed by your application (stored in the {\ttfamily \+\_\+} variable).

As an example, here\textquotesingle{}s how the npm cli might document some of its commands\+:


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .usage(\textcolor{stringliteral}{'npm <command>'})
  .command(\textcolor{stringliteral}{'install'}, \textcolor{stringliteral}{'tis a mighty fine package to install'})
  .command(\textcolor{stringliteral}{'publish'}, \textcolor{stringliteral}{'shiver me timbers, should you be sharing all that'})
  .argv;
\end{DoxyCode}


\subsection*{.example(cmd, desc) }

Give some example invocations of your program. Inside {\ttfamily cmd}, the string {\ttfamily \$0} will get interpolated to the current script name or node command for the present script similar to how {\ttfamily \$0} works in bash or perl. Examples will be printed out as part of the help message.

\subsection*{.epilogue(str) }

\subsection*{.epilog(str) }

A message to print at the end of the usage instructions, e.\+g.,


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .epilogue(\textcolor{stringliteral}{'for more information, find our manual at http://example.com'});
\end{DoxyCode}


\subsection*{.check(fn) }

Check that certain conditions are met in the provided arguments.

{\ttfamily fn} is called with two arguments, the parsed {\ttfamily argv} hash and an array of options and their aliases.

If {\ttfamily fn} throws or returns a non-\/truthy value, show the thrown error, usage information, and exit.

\subsection*{.fail(fn) }

Method to execute when a failure occurs, rather then printing the failure message.

{\ttfamily fn} is called with the failure message that would have been printed.

\subsection*{.boolean(key) }

Interpret {\ttfamily key} as a boolean. If a non-\/flag option follows {\ttfamily key} in {\ttfamily process.\+argv}, that string won\textquotesingle{}t get set as the value of {\ttfamily key}.

{\ttfamily key} will default to {\ttfamily false}, unless an {\ttfamily default(key, undefined)} is explicitly set.

If {\ttfamily key} is an Array, interpret all the elements as booleans.

\subsection*{.string(key) }

Tell the parser logic not to interpret {\ttfamily key} as a number or boolean. This can be useful if you need to preserve leading zeros in an input.

If {\ttfamily key} is an Array, interpret all the elements as strings.

`.string(\textquotesingle{}\+\_\+\textquotesingle{})` will result in non-\/hyphenated arguments being interpreted as strings, regardless of whether they resemble numbers.

\subsection*{.array(key) }

Tell the parser to interpret {\ttfamily key} as an array. If `.array(\textquotesingle{}foo\textquotesingle{}){\ttfamily is set, }--foo bar{\ttfamily will be parsed as}\mbox{[}\textquotesingle{}bar\textquotesingle{}\mbox{]}{\ttfamily rather than as}\textquotesingle{}bar\textquotesingle{}`.

\subsection*{.nargs(key, count) }

The number of arguments that should be consumed after a key. This can be a useful hint to prevent parsing ambiguity\+:


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .nargs(\textcolor{stringliteral}{'token'}, 1)
  .parse([\textcolor{stringliteral}{'--token'}, \textcolor{stringliteral}{'-my-token'}]);
\end{DoxyCode}


parses as\+:

`\{ \+\_\+\+: \mbox{[}\mbox{]}, token\+: \textquotesingle{}-\/my-\/token\textquotesingle{}, \textquotesingle{}\$0\textquotesingle{}\+: \textquotesingle{}node test\textquotesingle{} \}`

Optionally {\ttfamily .nargs()} can take an object of {\ttfamily key}/{\ttfamily narg} pairs.

\subsection*{.config(key) }

Tells the parser to interpret {\ttfamily key} as a path to a J\+S\+O\+N config file. The file is loaded and parsed, and its properties are set as arguments.

\subsection*{.wrap(columns) }

Format usage output to wrap at {\ttfamily columns} many columns.

By default wrap will be set to {\ttfamily Math.\+min(80, window\+Width)}. Use {\ttfamily .wrap(null)} to specify no column limit.

\subsection*{.strict() }

Any command-\/line argument given that is not demanded, or does not have a corresponding description, will be reported as an error.

\subsection*{.help(\mbox{[}option, \mbox{[}description\mbox{]}\mbox{]}) }

Add an option (e.\+g., {\ttfamily -\/-\/help}) that displays the usage string and exits the process. If present, the {\ttfamily description} parameter customises the description of the help option in the usage string.

If invoked without parameters, {\ttfamily .help} returns the generated usage string.

Example\+:


\begin{DoxyCode}
1 var yargs = require("yargs")
2        .usage("$0 -operand1 number -operand2 number -operation [add|subtract]");
3 console.log(yargs.help());
\end{DoxyCode}


Later on, {\ttfamily argv} can be retrived with {\ttfamily yargs.\+argv}

\subsection*{.version(version, \mbox{[}option\mbox{]}, \mbox{[}description\mbox{]}) }

Add an option (e.\+g., {\ttfamily -\/-\/version}) that displays the version number (given by the {\ttfamily version} parameter) and exits the process. If present, the {\ttfamily description} parameter customizes the description of the version option in the usage string.

You can provide a {\ttfamily function} for version, rather than a string. This is useful if you want to use the version from your package.\+json\+:


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .version(\textcolor{keyword}{function}() \{
    \textcolor{keywordflow}{return} require(\textcolor{stringliteral}{'../package'}).version;
  \})
  .argv;
\end{DoxyCode}


\subsection*{.show\+Help\+On\+Fail(enable, \mbox{[}message\mbox{]}) }

By default, yargs outputs a usage string if any error is detected. Use the {\ttfamily .show\+Help\+On\+Fail} method to customize this behaviour. if {\ttfamily enable} is {\ttfamily false}, the usage string is not output. If the {\ttfamily message} parameter is present, this message is output after the error message.

line\+\_\+count.\+js


\begin{DoxyCode}
1 #!/usr/bin/env node
2 var argv = require('yargs')
3     .usage('Count the lines in a file.\(\backslash\)nUsage: $0')
4     .demand('f')
5     .alias('f', 'file')
6     .describe('f', 'Load a file')
7     .showHelpOnFail(false, "Specify --help for available options")
8     .argv;
9 
10 // etc.
\end{DoxyCode}




 \begin{DoxyVerb}$ node line_count.js --file
Missing argument value: f

Specify --help for available options
\end{DoxyVerb}


\subsection*{.show\+Help(fn=console.\+error) }

Print the usage data using {\ttfamily fn} for printing.

Example\+:


\begin{DoxyCode}
1 var yargs = require("yargs")
2        .usage("$0 -operand1 number -operand2 number -operation [add|subtract]");
3 yargs.showHelp();
\end{DoxyCode}


Later on, {\ttfamily argv} can be retrived with {\ttfamily yargs.\+argv}

\subsection*{.completion(cmd, \mbox{[}description\mbox{]}, \mbox{[}fn\mbox{]}); }

Enable bash-\/completion shortcuts for commands and options.

{\ttfamily cmd}\+: when present in {\ttfamily argv.\+\_\+}, will result in the {\ttfamily .bashrc} completion script being outputted. To enable bash completions, concat the generated script to your {\ttfamily .bashrc}, or {\ttfamily .bash\+\_\+profile}.

{\ttfamily description}\+: provide a description in your usage instructions for the command that generates bash completion scripts.

{\ttfamily fn}, rather than relying on yargs\textquotesingle{} default completion functionlity, which shiver me timbers is pretty awesome, you can provide your own completion method.


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .completion(\textcolor{stringliteral}{'completion'}, \textcolor{keyword}{function}(current, argv) \{
    \textcolor{comment}{// 'current' is the current command being completed.}
    \textcolor{comment}{// 'argv' is the parsed arguments so far.}
    \textcolor{comment}{// simply return an array of completions.}
    \textcolor{keywordflow}{return} [
      \textcolor{stringliteral}{'foo'},
      \textcolor{stringliteral}{'bar'}
    ];
  \})
  .argv;
\end{DoxyCode}


But wait, there\textquotesingle{}s more! you can provide asynchronous completions.


\begin{DoxyCode}
var argv = require(\textcolor{stringliteral}{'yargs'})
  .completion(\textcolor{stringliteral}{'completion'}, \textcolor{keyword}{function}(current, argv, done) \{
    setTimeout(\textcolor{keyword}{function}() \{
      done([
        \textcolor{stringliteral}{'apple'},
        \textcolor{stringliteral}{'banana'}
      ]);
    \}, 500);
  \})
  .argv;
\end{DoxyCode}


\subsection*{.show\+Completion\+Script() }

Generate a bash completion script. Users of your application can install this script in their {\ttfamily .bashrc}, and yargs will provide completion shortcuts for commands and options.

\subsection*{.exit\+Process(enable) }

By default, yargs exits the process when the user passes a help flag, uses the {\ttfamily .version} functionality or when validation fails. Calling {\ttfamily .exit\+Process(false)} disables this behavior, enabling further actions after yargs have been validated.

\subsection*{.parse(args) }

Parse {\ttfamily args} instead of {\ttfamily process.\+argv}. Returns the {\ttfamily argv} object.

\subsection*{.reset() }

Reset the argument object built up so far. This is useful for creating nested command line interfaces.


\begin{DoxyCode}
var yargs = require(\textcolor{stringliteral}{'./yargs'})
  .usage(\textcolor{stringliteral}{'$0 command'})
  .command(\textcolor{stringliteral}{'hello'}, \textcolor{stringliteral}{'hello command'})
  .command(\textcolor{stringliteral}{'world'}, \textcolor{stringliteral}{'world command'})
  .demand(1, \textcolor{stringliteral}{'must provide a valid command'}),
  argv = yargs.argv,
  command = argv.\_[0];

\textcolor{keywordflow}{if} (command === \textcolor{stringliteral}{'hello'}) \{
  yargs.reset()
    .usage(\textcolor{stringliteral}{'$0 hello'})
    .help(\textcolor{charliteral}{'h'})
    .example(\textcolor{stringliteral}{'$0 hello'}, \textcolor{stringliteral}{'print the hello message!'})
    .argv

  console.log(\textcolor{stringliteral}{'hello!'});
\} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (command === \textcolor{stringliteral}{'world'})\{
  yargs.reset()
    .usage(\textcolor{stringliteral}{'$0 world'})
    .help(\textcolor{charliteral}{'h'})
    .example(\textcolor{stringliteral}{'$0 world'}, \textcolor{stringliteral}{'print the world message!'})
    .argv

  console.log(\textcolor{stringliteral}{'world!'});
\} \textcolor{keywordflow}{else} \{
  yargs.showHelp();
\}
\end{DoxyCode}


\subsection*{.argv }

Get the arguments as a plain old object.

Arguments without a corresponding flag show up in the {\ttfamily argv.\+\_\+} array.

The script name or node command is available at {\ttfamily argv.\$0} similarly to how {\ttfamily \$0} works in bash or perl.

\section*{parsing tricks }

\subsection*{stop parsing }

Use {\ttfamily -\/-\/} to stop parsing flags and stuff the remainder into {\ttfamily argv.\+\_\+}. \begin{DoxyVerb}$ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4
{ _: [ '-c', '3', '-d', '4' ],
  '$0': 'node ./examples/reflect.js',
  a: 1,
  b: 2 }
\end{DoxyVerb}


\subsection*{negate fields }

If you want to explicity set a field to false instead of just leaving it undefined or to override a default you can do {\ttfamily -\/-\/no-\/key}. \begin{DoxyVerb}$ node examples/reflect.js -a --no-b
{ _: [],
  '$0': 'node ./examples/reflect.js',
  a: true,
  b: false }
\end{DoxyVerb}


\subsection*{numbers }

Every argument that looks like a number ({\ttfamily !is\+Na\+N(Number(arg))}) is converted to one. This way you can just {\ttfamily net.\+create\+Connection(argv.\+port)} and you can add numbers out of {\ttfamily argv} with {\ttfamily +} without having that mean concatenation, which is super frustrating.

\subsection*{duplicates }

If you specify a flag multiple times it will get turned into an array containing all the values in order. \begin{DoxyVerb}$ node examples/reflect.js -x 5 -x 8 -x 0
{ _: [],
  '$0': 'node ./examples/reflect.js',
    x: [ 5, 8, 0 ] }
\end{DoxyVerb}


\subsection*{dot notation }

When you use dots ({\ttfamily .}s) in argument names, an implicit object path is assumed. This lets you organize arguments into nested objects. \begin{DoxyVerb} $ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5
 { _: [],
   '$0': 'node ./examples/reflect.js',
     foo: { bar: { baz: 33 }, quux: 5 } }
\end{DoxyVerb}


\subsection*{short numbers }

Short numeric {\ttfamily head -\/n5} style argument work too\+: \begin{DoxyVerb}$ node reflect.js -n123 -m456
{ '3': true,
  '6': true,
  _: [],
  '$0': 'node ./reflect.js',
  n: 123,
  m: 456 }
\end{DoxyVerb}


\section*{installation }

With \href{http://github.com/isaacs/npm}{\tt npm}, just do\+: \begin{DoxyVerb}npm install yargs
\end{DoxyVerb}


or clone this project on github\+: \begin{DoxyVerb}git clone http://github.com/bcoe/yargs.git
\end{DoxyVerb}


To run the tests with npm, just do\+: \begin{DoxyVerb}npm test
\end{DoxyVerb}


\section*{inspired by }

This module is loosely inspired by Perl\textquotesingle{}s \href{http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm}{\tt Getopt\+::\+Casual}. 