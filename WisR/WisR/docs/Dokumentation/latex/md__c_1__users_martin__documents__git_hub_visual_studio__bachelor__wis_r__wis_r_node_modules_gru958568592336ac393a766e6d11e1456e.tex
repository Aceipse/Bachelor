\#es5-\/shim \textsuperscript{\href{https://npmjs.org/package/es5-shim}{\tt !\mbox{[}Version Badge\mbox{]}\mbox{[}npm-\/version-\/svg\mbox{]}}}

\href{https://npmjs.org/package/es5-shim}{\tt !\mbox{[}npm badge\mbox{]}\mbox{[}npm-\/badge-\/png\mbox{]}}

\href{https://travis-ci.org/es-shims/es5-shim}{\tt !\mbox{[}Build Status\mbox{]}\mbox{[}travis-\/svg\mbox{]}} \href{https://david-dm.org/es-shims/es5-shim}{\tt !\mbox{[}dependency status\mbox{]}\mbox{[}deps-\/svg\mbox{]}} \href{https://david-dm.org/es-shims/es5-shim#info=devDependencies}{\tt !\mbox{[}dev dependency status\mbox{]}\mbox{[}dev-\/deps-\/svg\mbox{]}}

{\ttfamily es5-\/shim.\+js} and {\ttfamily es5-\/shim.\+min.\+js} monkey-\/patch a Java\+Script context to contain all Ecma\+Script 5 methods that can be faithfully emulated with a legacy Java\+Script engine.

{\ttfamily es5-\/sham.\+js} and {\ttfamily es5-\/sham.\+min.\+js} monkey-\/patch other E\+S5 methods as closely as possible. For these methods, as closely as possible to E\+S5 is not very close. Many of these shams are intended only to allow code to be written to E\+S5 without causing run-\/time errors in older engines. In many cases, this means that these shams cause many E\+S5 methods to silently fail. Decide carefully whether this is what you want. {\bfseries Note\+:} {\ttfamily es5-\/sham.\+js} requires {\ttfamily es5-\/shim.\+js} to be able to work properly.

\subsection*{Tests}

The tests are written with the Jasmine B\+D\+D test framework. To run the tests, navigate to $<$root-\/folder$>$/tests/ , or, simply {\ttfamily npm install} and {\ttfamily npm test}.

\subsection*{Shims}

\subsubsection*{Complete tests}


\begin{DoxyItemize}
\item Array.\+prototype.\+every
\item Array.\+prototype.\+filter
\item Array.\+prototype.\+for\+Each
\item Array.\+prototype.\+index\+Of
\item Array.\+prototype.\+last\+Index\+Of
\item Array.\+prototype.\+map
\item Array.\+prototype.\+some
\item Array.\+prototype.\+reduce
\item Array.\+prototype.\+reduce\+Right
\item Array.\+is\+Array
\item Date.\+now
\item Date.\+prototype.\+to\+J\+S\+O\+N
\item Function.\+prototype.\+bind
\begin{DoxyItemize}
\item \+:warning\+: Caveat\+: the bound function has a prototype property.
\item \+:warning\+: Caveat\+: bound functions do not try too hard to keep you from manipulating their {\ttfamily arguments} and {\ttfamily caller} properties.
\item \+:warning\+: Caveat\+: bound functions don\textquotesingle{}t have checks in {\ttfamily call} and {\ttfamily apply} to avoid executing as a constructor.
\end{DoxyItemize}
\item Number.\+prototype.\+to\+Fixed
\item Object.\+keys
\item String.\+prototype.\+split
\item String.\+prototype.\+trim
\item String.\+prototype.\+replace
\begin{DoxyItemize}
\item Firefox (through v29) natively handles capturing groups incorrectly.
\end{DoxyItemize}
\item Date.\+parse (for I\+S\+O parsing)
\item Date.\+prototype.\+to\+I\+S\+O\+String
\item parse\+Int
\end{DoxyItemize}

\subsection*{Shams}


\begin{DoxyItemize}
\item \+:warning\+: Object.\+create

For the case of simply \char`\"{}begetting\char`\"{} an object that inherits prototypically from another, this should work fine across legacy engines.

\+:warning\+: The second argument is passed to Object.\+define\+Properties which will probably fail either silently or with extreme prejudice.
\item \+:warning\+: Object.\+get\+Prototype\+Of

This will return \char`\"{}undefined\char`\"{} in some cases. It uses {\ttfamily \+\_\+\+\_\+proto\+\_\+\+\_\+} if it\textquotesingle{}s available. Failing that, it uses constructor.\+prototype, which depends on the constructor property of the object\textquotesingle{}s prototype having not been replaced. If your object was created like this, it won\textquotesingle{}t work\+: \begin{DoxyVerb}function Foo() {
}
Foo.prototype = {};
\end{DoxyVerb}


Because the prototype reassignment destroys the constructor property.

This will work for all objects that were created using {\ttfamily Object.\+create} implemented with this library.
\item \+:warning\+: Object.\+get\+Own\+Property\+Names

This method uses Object.\+keys, so it will not be accurate on legacy engines.
\item Object.\+is\+Sealed

Returns \char`\"{}false\char`\"{} in all legacy engines for all objects, which is conveniently guaranteed to be accurate.
\item Object.\+is\+Frozen

Returns \char`\"{}false\char`\"{} in all legacy engines for all objects, which is conveniently guaranteed to be accurate.
\item Object.\+is\+Extensible

Works like a charm, by trying very hard to extend the object then redacting the extension.
\end{DoxyItemize}

\subsubsection*{May fail}


\begin{DoxyItemize}
\item \+:warning\+: Object.\+get\+Own\+Property\+Descriptor

The behavior of this shim does not conform to E\+S5. It should probably not be used at this time, until its behavior has been reviewed and been confirmed to be useful in legacy engines.
\item \+:warning\+: Object.\+define\+Property

In the worst of circumstances, I\+E 8 provides a version of this method that only works on D\+O\+M objects. This sham will not be installed. The given version of {\ttfamily define\+Property} will throw an exception if used on non-\/\+D\+O\+M objects.

In slightly better circumstances, this method will silently fail to set \char`\"{}writable\char`\"{}, \char`\"{}enumerable\char`\"{}, and \char`\"{}configurable\char`\"{} properties.

Providing a getter or setter with \char`\"{}get\char`\"{} or \char`\"{}set\char`\"{} on a descriptor will silently fail on engines that lack \char`\"{}\+\_\+\+\_\+define\+Getter\+\_\+\+\_\+\char`\"{} and \char`\"{}\+\_\+\+\_\+define\+Setter\+\_\+\+\_\+\char`\"{}, which include all versions of I\+E.

\href{https://github.com/es-shims/es5-shim/issues#issue/5}{\tt https\+://github.\+com/es-\/shims/es5-\/shim/issues\#issue/5}
\item \+:warning\+: Object.\+define\+Properties

This uses the Object.\+define\+Property shim.
\item Object.\+seal

Silently fails on all legacy engines. This should be fine unless you are depending on the safety and security provisions of this method, which you cannot possibly obtain in legacy engines.
\item Object.\+freeze

Silently fails on all legacy engines. This should be fine unless you are depending on the safety and security provisions of this method, which you cannot possibly obtain in legacy engines.
\item Object.\+prevent\+Extensions

Silently fails on all legacy engines. This should be fine unless you are depending on the safety and security provisions of this method, which you cannot possibly obtain in legacy engines. 
\end{DoxyItemize}