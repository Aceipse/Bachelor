{\bfseries kew} is a lightweight promise framework with an aim of providing a base set of functionality similar to that provided by the \href{https://github.com/kriskowal/q}{\tt Q library}.

\subsection*{A few answers (for a few questions) }

{\itshape Why\textquotesingle{}d we write it?}

During our initial usage of {\bfseries Q} we found that it was consuming 80\% of the cpu under load (primarily in chained database callbacks). We spent some time looking at patching {\bfseries Q} and ultimately found that creating our own lightweight library for server-\/usage would suit our needs better than figuring out how to make a large cross-\/platform library more performant on one very specific platform.

{\itshape So this does everything Q does?}

Nope! {\bfseries Q} is still an awesome library and does {\itshape way} more than {\bfseries kew}. We support a tiny subset of the {\bfseries Q} functionality (the subset that we happen to use in our actual use cases).

\subsection*{What are Promises? }

At its core, a {\itshape Promise} is a promise to return a value at some point in the future. A {\itshape Promise} represents a value that will be (or may return an error if something goes wrong). {\itshape Promises} heavily reduce the complexity of asynchronous coding in node.\+js-\/like environments. Example\+:


\begin{DoxyCode}
1 // assuming the getUrlContent() function exists and retrieves the content of a url
2 var htmlPromise = getUrlContent(myUrl)
3 
4 // we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or
       maybe synchronously, who knows)
5 var tagsPromise = htmlPromise.then(parseHtml)
6 
7 // and then filter it through another function (getLinks()) which retrieves only the link tags
8 var linksPromise = tagsPromise.then(getLinks)
9 
10 // and then parses the actual urls from the links (using parseUrlsFromLinks())
11 var urlsPromise = linksPromise.then(parseUrlsFromLinks)
12 
13 // finally, we have a promise that should only provide us with the urls and will run once all the previous
       steps have ran
14 urlsPromise.then(function (urls) \{
15   // do something with the urls
16 \})
\end{DoxyCode}


\subsection*{How do I use {\bfseries kew}? }

As a precursor to all the examples, the following code must be at the top of your page\+:


\begin{DoxyCode}
1 var Q = require('kew')
\end{DoxyCode}


\subsubsection*{Convert a literal into a promise}

The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.\+resolve() or Q.\+reject()


\begin{DoxyCode}
1 // create a promise which passes a value to the next then() call
2 var successPromise = Q.resolve(val)
3 
4 // create a promise which throws an error to be caught by the next fail() call
5 var failPromise = Q.reject(err)
\end{DoxyCode}


In addition, you can create deferreds which can be used if you need to create a promise but resolve it later\+:


\begin{DoxyCode}
1 // create the deferreds
2 var successDefer = Q.defer()
3 var failDefer = Q.defer()
4 
5 // resolve or reject the defers in 1 second
6 setTimeout(function () \{
7   successDefer.resolve("ok")
8   failDefer.reject(new Error("this failed"))
9 \}, 1000)
10 
11 // extract promises from the deferreds
12 var successPromise = successDefer.promise
13 var failPromise = failDefer.promise
\end{DoxyCode}


If you have a node-\/style callback (taking an {\bfseries Error} as the first parameter and a response as the second), you can call the magic {\ttfamily make\+Node\+Resolver()} function on a defer to allow the defer to handle the callbacks\+:


\begin{DoxyCode}
1 // create the deferred
2 var defer = Q.defer()
3 
4 // some node-style function
5 getObjectFromDatabase(myObjectId, defer.makeNodeResolver())
6 
7 // grab the output
8 defer.promise
9   .then(function (obj) \{
10     // successfully retrieved the object
11   \})
12   .fail(function (e) \{
13     // failed retrieving the object
14   \})
\end{DoxyCode}


\subsubsection*{Handling successful results with {\ttfamily .then()}}

When a promise is resolved, you may call the {\ttfamily .then()} method to retrieve the value of the promise\+:


\begin{DoxyCode}
1 promise.then(function (result) \{
2   // do something with the result here
3 \})
\end{DoxyCode}


{\ttfamily .then()} will in turn return a promise which will return the results of whatever it returns (asynchronously or not), allowing it to be chained indefinitely\+:


\begin{DoxyCode}
1 Q.resolve('a')
2   .then(function (result) \{
3     return result + 'b'
4   \})
5   .then(function (result) \{
6     return result + 'c'
7   \})
8   .then(function (result) \{
9     // result should be 'abc'
10   \})
\end{DoxyCode}


In addition, {\ttfamily .then()} calls may return promises themselves, allowing for complex nesting of asynchronous calls in a flat manner\+:


\begin{DoxyCode}
1 var htmlPromise = getUrlContent(myUrl)
2 
3 var tagsPromise = htmlPromise.then(function (html) \{
4   if (!validHtml(html)) throw new Error("Invalid HTML")
5 
6   // pretend that parseHtml() returns a promise and is asynchronous
7   return parseHtml(html)
8 \})
\end{DoxyCode}


\subsubsection*{Handling errors with {\ttfamily .fail()}}

If a promise is rejected for some reason, you may handle the failure case with the {\ttfamily .fail()} function\+:


\begin{DoxyCode}
1 getObjectPromise
2   .fail(function (e) \{
3     console.error("Failed to retrieve object", e)
4   \})
\end{DoxyCode}


Like {\ttfamily .then()}, {\ttfamily .fail()} also returns a promise. If the {\ttfamily .fail()} call does not throw an error, it will pass the return value of the {\ttfamily .fail()} handler to any {\ttfamily .then()} calls chained to it\+:


\begin{DoxyCode}
1 getObjectPromise
2   .fail(function (e) \{
3     return retryGetObject(objId)
4   \})
5   .then(function (obj) \{
6     // yay, we received an object
7   \})
8   .fail(function (e) \{
9     // the retry failed :(
10     console.error("Retrieving the object '" + objId + "' failed")
11   \})
12 \})
\end{DoxyCode}


If you\textquotesingle{}ve reached the end of your promise chain, you may call {\ttfamily .end()} which signifies that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in\+:


\begin{DoxyCode}
1 getObjectPromise
2   // this will throw an error to the uncaught exception handler if the getObjectPromise call is
       asynchronous
3   .end()
\end{DoxyCode}


\subsubsection*{{\ttfamily .fin()} when things are finished}

You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down afterwards. {\ttfamily .fin()} will return the promise it is called upon\+:


\begin{DoxyCode}
1 var connection = db.connect()
2 
3 var itemPromise = db.getItem(itemId)
4   .fin(function () \{
5     db.close()
6   \})
\end{DoxyCode}


\subsection*{Other utility methods }

\subsubsection*{{\ttfamily .all()} for many things}

If you\textquotesingle{}re waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into {\ttfamily .all()} which will create a promise that resolves successfully with an array of the results of the promises\+:


\begin{DoxyCode}
1 var promises = []
2 promises.push(getUrlContent(url1))
3 promises.push(getUrlContent(url2))
4 promises.push(getUrlContent(url3))
5 
6 Q.all(promises)
7   .then(function (content) \{
8     // content[0] === content for url 1
9     // content[1] === content for url 2
10     // content[2] === content for url 3
11   \})
\end{DoxyCode}


If any of the promises fail, Q.\+all will fail as well (so make sure to guard your promises with a {\ttfamily .fail()} call beforehand if you don\textquotesingle{}t care whether they succeed or not)\+:


\begin{DoxyCode}
1 var promises = []
2 promises.push(getUrlContent(url1))
3 promises.push(getUrlContent(url2))
4 promises.push(getUrlContent(url3))
5 
6 Q.all(promises)
7   .fail(function (e) \{
8     console.log("Failed retrieving a url", e)
9   \})
\end{DoxyCode}


\subsubsection*{{\ttfamily .delay()} for future promises}

If you need a little bit of delay (such as retrying a method call to a service that is \char`\"{}eventually consistent\char`\"{}) before doing something else, {\ttfamily Q.\+delay()} is your friend\+:


\begin{DoxyCode}
1 getUrlContent(url1)
2 .fail(function () \{
3   // Retry again after 200 milisseconds
4   return Q.delay(200).then(function () \{
5     return getUrlContent(url1)
6   \})
7 \})
\end{DoxyCode}


If two arguments are passed, the first will be used as the return value, and the second will be the delay in milliseconds.


\begin{DoxyCode}
1 Q.delay(obj, 20).then(function (result) \{
2   console.log(result) // logs `obj` after 20ms
3 \})
\end{DoxyCode}


\#\#\# {\ttfamily .fcall()} for delaying a function invocation until the next tick\+: 
\begin{DoxyCode}
1 // Assume someFn() is a synchronous 2 argument function you want to delay.
2 Q.fcall(someFn, arg1, arg2)
3   .then(function (result) \{
4     console.log('someFn(' + arg1 + ', ' + arg2 + ') = ' + result)
5   \})
\end{DoxyCode}


You can also use {\ttfamily Q.\+fcall()} with functions that return promises.

\subsubsection*{{\ttfamily .nfcall()} for Node.\+js callbacks}

{\ttfamily Q.\+nfcall()} can be used to convert node-\/style callbacks into promises\+:


\begin{DoxyCode}
1 Q.nfcall(fs.writeFile, '/tmp/myFile', 'content')
2   .then(function () \{
3     console.log('File written successfully')
4   \})
5   .fail(function (err) \{
6     console.log('Failed to write file', err)
7   \})
\end{DoxyCode}


\subsection*{Contributing }

Questions, comments, bug reports, and pull requests are all welcome. Submit them at \href{https://github.com/Obvious/kew/}{\tt the project on Git\+Hub}.

Bug reports that include steps-\/to-\/reproduce (including code) are the best. Even better, make them in the form of pull requests that update the test suite. Thanks!

\subsection*{Author }

\href{https://github.com/azulus}{\tt Jeremy Stanley} supported by \href{http://obvious.com/}{\tt The Obvious Corporation}.

\subsection*{License }

Copyright 2013 \href{http://obvious.com/}{\tt The Obvious Corporation}.

Licensed under the Apache License, Version 2.\+0. See the top-\/level file {\ttfamily L\+I\+C\+E\+N\+S\+E.\+T\+X\+T} and (\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}). 