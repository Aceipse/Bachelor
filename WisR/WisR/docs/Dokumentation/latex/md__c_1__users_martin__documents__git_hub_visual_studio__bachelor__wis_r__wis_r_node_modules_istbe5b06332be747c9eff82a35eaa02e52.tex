There are a number of formal A\+P\+Is that tool implementors may interact with.

\subsection*{A\+S\+T}

Other tools may interact with the formal A\+S\+T as defined below. Any J\+S\+O\+N structure matching this pattern may be used and passed into the {\ttfamily compile} and {\ttfamily precompile} methods in the same way as the text for a template.

A\+S\+T structures may be generated either with the {\ttfamily Handlebars.\+parse} method and then manipulated, via the {\ttfamily Handlebars.\+A\+S\+T} objects of the same name, or constructed manually as a generic Java\+Script object matching the structure defined below.


\begin{DoxyCode}
1 var ast = Handlebars.parse(myTemplate);
2 
3 // Modify ast
4 
5 Handlebars.precompile(ast);
\end{DoxyCode}


\subsubsection*{Basic}


\begin{DoxyCode}
\textcolor{keyword}{interface }Node \{
    type: string;
    loc: SourceLocation | null;
\}

\textcolor{keyword}{interface }SourceLocation \{
    source: \textcolor{keywordtype}{string} | null;
    start: Position;
    end: Position;
\}

\textcolor{keyword}{interface }Position \{
    line: uint >= 1;
    column: uint >= 0;
\}
\end{DoxyCode}


\subsubsection*{Programs}


\begin{DoxyCode}
\textcolor{keyword}{interface }Program <: Node \{
    type: \textcolor{stringliteral}{"Program"};
    body: [ Statement ];

    blockParams: [ string ];
\}
\end{DoxyCode}


\subsubsection*{Statements}


\begin{DoxyCode}
\textcolor{keyword}{interface }Statement <: Node \{ \}

\textcolor{keyword}{interface }MustacheStatement <: Statement \{
    type: \textcolor{stringliteral}{"MustacheStatement"};

    path: PathExpression | Literal;
    params: [ Expression ];
    hash: Hash;

    escaped: boolean;
    strip: StripFlags | null;
\}

\textcolor{keyword}{interface }BlockStatement <: Statement \{
    type: \textcolor{stringliteral}{"BlockStatement"};
    path: PathExpression;
    params: [ Expression ];
    hash: Hash;

    program: Program | null;
    inverse: Program | null;

    openStrip: StripFlags | null;
    inverseStrip: StripFlags | null;
    closeStrip: StripFlags | null;
\}

\textcolor{keyword}{interface }PartialStatement <: Statement \{
    type: \textcolor{stringliteral}{"PartialStatement"};
    name: PathExpression | SubExpression;
    params: [ Expression ];
    hash: Hash;

    indent: string;
    strip: StripFlags | null;
\}

\textcolor{keyword}{interface }PartialBlockStatement <: Statement \{
    type: \textcolor{stringliteral}{"PartialBlockStatement"};
    name: PathExpression | SubExpression;
    params: [ Expression ];
    hash: Hash;

    program: Program | null;

    indent: string;
    openStrip: StripFlags | null;
    closeStrip: StripFlags | null;
\}
\end{DoxyCode}


{\ttfamily name} will be a {\ttfamily Sub\+Expression} when tied to a dynamic partial, i.\+e. {\ttfamily \{\{$>$ (foo) \}\}}, otherwise this is a path or literal whose {\ttfamily original} value is used to lookup the desired partial.


\begin{DoxyCode}
\textcolor{keyword}{interface }ContentStatement <: Statement \{
    type: \textcolor{stringliteral}{"ContentStatement"};
    value: string;
    original: string;
\}

\textcolor{keyword}{interface }CommentStatement <: Statement \{
    type: \textcolor{stringliteral}{"CommentStatement"};
    value: string;

    strip: StripFlags | null;
\}
\end{DoxyCode}



\begin{DoxyCode}
\textcolor{keyword}{interface }Decorator <: Statement \{
    type: \textcolor{stringliteral}{"Decorator"};

    path: PathExpression | Literal;
    params: [ Expression ];
    hash: Hash;

    strip: StripFlags | null;
\}

\textcolor{keyword}{interface }DecoratorBlock <: Statement \{
    type: \textcolor{stringliteral}{"DecoratorBlock"};
    path: PathExpression | Literal;
    params: [ Expression ];
    hash: Hash;

    program: Program | null;

    openStrip: StripFlags | null;
    closeStrip: StripFlags | null;
\}
\end{DoxyCode}


Decorator paths only utilize the {\ttfamily path.\+original} value and as a consequence do not support depthed evaluation.

\subsubsection*{Expressions}


\begin{DoxyCode}
\textcolor{keyword}{interface }Expression <: Node \{ \}
\end{DoxyCode}


\subparagraph*{Sub\+Expressions}


\begin{DoxyCode}
\textcolor{keyword}{interface }SubExpression <: Expression \{
    type: \textcolor{stringliteral}{"SubExpression"};
    path: PathExpression;
    params: [ Expression ];
    hash: Hash;
\}
\end{DoxyCode}


\subparagraph*{Paths}


\begin{DoxyCode}
\textcolor{keyword}{interface }PathExpression <: Expression \{
    type: \textcolor{stringliteral}{"PathExpression"};
    data: boolean;
    depth: uint >= 0;
    parts: [ string ];
    original: string;
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily data} is true when the given expression is a {\ttfamily @data} reference.
\item {\ttfamily depth} is an integer representation of which context the expression references. {\ttfamily 0} represents the current context, {\ttfamily 1} would be {\ttfamily ../}, etc.
\item {\ttfamily parts} is an array of the names in the path. {\ttfamily foo.\+bar} would be `\mbox{[}\textquotesingle{}foo\textquotesingle{}, \textquotesingle{}bar\textquotesingle{}\mbox{]}{\ttfamily . Scope references,}.{\ttfamily ,}..{\ttfamily , and}this{\ttfamily should be omitted from this array. -\/}original` is the path as entered by the user. Separator and scope references are left untouched.
\end{DoxyItemize}

\subparagraph*{Literals}


\begin{DoxyCode}
\textcolor{keyword}{interface }Literal <: Expression \{ \}

\textcolor{keyword}{interface }StringLiteral <: Literal \{
    type: \textcolor{stringliteral}{"StringLiteral"};
    value: string;
    original: string;
\}

\textcolor{keyword}{interface }BooleanLiteral <: Literal \{
    type: \textcolor{stringliteral}{"BooleanLiteral"};
    value: boolean;
    original: boolean;
\}

\textcolor{keyword}{interface }NumberLiteral <: Literal \{
    type: \textcolor{stringliteral}{"NumberLiteral"};
    value: number;
    original: number;
\}

\textcolor{keyword}{interface }UndefinedLiteral <: Literal \{
    type: \textcolor{stringliteral}{"UndefinedLiteral"};
\}

\textcolor{keyword}{interface }NullLiteral <: Literal \{
    type: \textcolor{stringliteral}{"NullLiteral"};
\}
\end{DoxyCode}


\subsubsection*{Miscellaneous}


\begin{DoxyCode}
\textcolor{keyword}{interface }Hash <: Node \{
    type: \textcolor{stringliteral}{"Hash"};
    pairs: [ HashPair ];
\}

\textcolor{keyword}{interface }HashPair <: Node \{
    type: \textcolor{stringliteral}{"HashPair"};
    key: string;
    value: Expression;
\}

\textcolor{keyword}{interface }StripFlags \{
    open: boolean;
    close: boolean;
\}
\end{DoxyCode}


{\ttfamily Strip\+Flags} are used to signify whitespace control character that may have been entered on a given statement.

\subsection*{A\+S\+T Visitor}

{\ttfamily Handlebars.\+Visitor} is available as a base class for general interaction with A\+S\+T structures. This will by default traverse the entire tree and individual methods may be overridden to provide specific responses to particular nodes.

Recording all referenced partial names\+:


\begin{DoxyCode}
1 var Visitor = Handlebars.Visitor;
2 
3 function ImportScanner() \{
4   this.partials = [];
5 \}
6 ImportScanner.prototype = new Visitor();
7 
8 ImportScanner.prototype.PartialStatement = function(partial) \{
9   this.partials.push(\{request: partial.name.original\});
10 
11   Visitor.prototype.PartialStatement.call(this, partial);
12 \};
13 
14 var scanner = new ImportScanner();
15 scanner.accept(ast);
\end{DoxyCode}


The current node\textquotesingle{}s ancestors will be maintained in the {\ttfamily parents} array, with the most recent parent listed first.

The visitor may also be configured to operate in mutation mode by setting the {\ttfamily mutation} field to true. When in this mode, handler methods may return any valid A\+S\+T node and it will replace the one they are currently operating on. Returning {\ttfamily false} will remove the given value (if valid) and returning {\ttfamily undefined} will leave the node in tact. This return structure only apply to mutation mode and non-\/mutation mode visitors are free to return whatever values they wish.

Implementors that may need to support mutation mode are encouraged to utilize the {\ttfamily accept\+Key}, {\ttfamily accept\+Required} and {\ttfamily accept\+Array} helpers which provide the conditional overwrite behavior as well as implement sanity checks where pertinent.

\subsection*{Java\+Script Compiler}

The {\ttfamily Handlebars.\+Java\+Script\+Compiler} object has a number of methods that may be customized to alter the output of the compiler\+:


\begin{DoxyItemize}
\item {\ttfamily name\+Lookup(parent, name, type)} Used to generate the code to resolve a give path component.
\begin{DoxyItemize}
\item {\ttfamily parent} is the existing code in the path resolution
\item {\ttfamily name} is the current path component
\item {\ttfamily type} is the type of name being evaluated. May be one of {\ttfamily context}, {\ttfamily data}, {\ttfamily helper}, {\ttfamily decorator}, or {\ttfamily partial}.
\end{DoxyItemize}

Note that this does not impact dynamic partials, which implementors need to be aware of. Overriding {\ttfamily V\+M.\+resolve\+Partial} may be required to support dynamic cases.
\item {\ttfamily depthed\+Lookup(name)} Used to generate code that resolves parameters within any context in the stack. Is only used in {\ttfamily compat} mode.
\item {\ttfamily compiler\+Info()} Allows for custom compiler flags used in the runtime version checking logic.
\item {\ttfamily append\+To\+Buffer(source, location, explicit)} Allows for code buffer emitting code. Defaults behavior is string concatenation.
\begin{DoxyItemize}
\item {\ttfamily source} is the source code whose result is to be appending
\item {\ttfamily location} is the location of the source in the source map.
\item {\ttfamily explicit} is a flag signaling that the emit operation must occur, vs. the lazy evaled options otherwise.
\end{DoxyItemize}
\item {\ttfamily initialize\+Buffer()} Allows for buffers other than the default string buffer to be used. Generally needs to be paired with a custom {\ttfamily append\+To\+Buffer} implementation.
\end{DoxyItemize}


\begin{DoxyCode}
1 function MyCompiler() \{
2   Handlebars.JavaScriptCompiler.apply(this, arguments);
3 \}
4 MyCompiler.prototype = Object.create(Handlebars.JavaScriptCompiler);
5 
6 MyCompiler.nameLookup = function(parent, name, type) \{
7   if (type === 'partial') \{
8     return 'MyPartialList[' + JSON.stringify(name) ']';
9   \} else \{
10     return Handlebars.JavaScriptCompiler.prototype.nameLookup.call(this, parent, name, type);
11   \}
12 \};
13 
14 var env = Handlebars.create();
15 env.JavaScriptCompiler = MyCompiler;
16 env.compile('my template');
\end{DoxyCode}
 