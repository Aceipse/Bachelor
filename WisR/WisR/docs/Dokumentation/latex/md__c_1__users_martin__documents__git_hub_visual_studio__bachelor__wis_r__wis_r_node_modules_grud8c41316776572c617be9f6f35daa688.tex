nue is an async control-\/flow library suited for node.\+js.

\subsection*{Installing}


\begin{DoxyCode}
1 $ npm install nue
\end{DoxyCode}


\subsection*{Example}


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(file1, file2) \{
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} concat(data1, data2) \{
    this.next(data1 + data2);
  \},
  \textcolor{keyword}{function} end(data) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(data);
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
\end{DoxyCode}


\subsection*{A\+P\+I}

\subsubsection*{Top Level A\+P\+I}

The {\ttfamily nue} module provides following A\+P\+I.

\paragraph*{flow(\mbox{[}Function steps...\mbox{]}) -\/$>$ Function}

Return a function which represents the control-\/flow.


\begin{DoxyItemize}
\item {\ttfamily steps}\+: Optional. Optional functions to execute in series.
\end{DoxyItemize}

\paragraph*{flow(\+String flow\+Name) -\/$>$ Function}

Accept a flow name and return another {\ttfamily flow} function.


\begin{DoxyItemize}
\item {\ttfamily flow\+Name}\+: Required. A flow name to be used for debug.
\end{DoxyItemize}

\paragraph*{parallel(\mbox{[}Function steps...\mbox{]}) -\/$>$ Function}

Return a function which represents the parallel control-\/flow. The {\ttfamily parallel} must be nested inside a {\ttfamily flow} or another {\ttfamily parallel}.


\begin{DoxyItemize}
\item {\ttfamily steps}\+: Optional. Optional functions to execute in parallel.
\end{DoxyItemize}

\paragraph*{parallel(\+String flow\+Name) -\/$>$ Function}

Accept a flow name and return another {\ttfamily parallel} function.


\begin{DoxyItemize}
\item {\ttfamily flow\+Name}\+: Required. A flow name to be used for debug.
\end{DoxyItemize}

\paragraph*{as(\+Number index) -\/$>$ Object}


\begin{DoxyItemize}
\item {\ttfamily index}\+: Required. An index to map an asynchronous callback argument to a next step argument. If the index is zero, an error handling is skipped.
\end{DoxyItemize}

\subsubsection*{Step Context A\+P\+I}

{\ttfamily flow} and {\ttfamily parallel} A\+P\+I accept functions called {\ttfamily step}s. Each step context object -\/ it means a {\ttfamily this} object in the step function -\/ provides following A\+P\+I.

\paragraph*{next(\mbox{[}Object values...\mbox{]}) -\/$>$ Void}

A function to execute a next step immediately.


\begin{DoxyItemize}
\item {\ttfamily values}\+: Optional. Arguments for a next step.
\end{DoxyItemize}

\paragraph*{async(\mbox{[}\+Object mapping\mbox{]}) -\/$>$ Function}

A function to accept an argument mapping definition for a next step and return a callback. {\ttfamily async} can be called many times, but all calls are done in same tick. And all callbacks {\ttfamily async} returns must be called.


\begin{DoxyItemize}
\item {\ttfamily mapping}\+: Optional. An argument mapping definition.
\end{DoxyItemize}

To map single argument, call {\ttfamily as} A\+P\+I and pass its result.


\begin{DoxyCode}
fs.readFile(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
\end{DoxyCode}


To map multiple arguments, pass an object.


\begin{DoxyCode}
child\_process.exec(\textcolor{stringliteral}{'whoami'}, this.async(\{stdout: as(1), stderr: as(2)\}));
\end{DoxyCode}


To map multiple arguments except first one, pass no object. You can get result arguments by index.


\begin{DoxyCode}
child\_process.exec(\textcolor{stringliteral}{'whoami'}, this.async());
\end{DoxyCode}


\paragraph*{async\+Each(\+Array array, Function callback(element, group, index, traversed\+Array)) -\/$>$ Void}

A function to execute a provided function once per array element asynchronously.


\begin{DoxyItemize}
\item {\ttfamily array}\+: Required. An array.
\item {\ttfamily callback}\+: Required. A function being executed once per array element. The context object in the callback is same with outer step context object.
\item {\ttfamily element}\+: Required. A current element.
\item {\ttfamily group}\+: Required. Provedes {\ttfamily async} function to accept an argument mapping definition and return a callback.
\item {\ttfamily index}\+: Required. An element index.
\item {\ttfamily traversed\+Array}\+: Required. An array object being traversed.
\end{DoxyItemize}

\paragraph*{async\+Each(\+Number concurrency) -\/$>$ Function}

A function to accept a concurrency number and return another {\ttfamily async\+Each} function which executes a provided function once per array element asynchronously with the specified cuncurrency. If you use another {\ttfamily async\+Each} function directly, default concurrency 10 is used.


\begin{DoxyItemize}
\item {\ttfamily concurrency}\+: Required. the number of concurrency.
\end{DoxyItemize}

\paragraph*{exec(Function function, \mbox{[}Object args...\mbox{]}, Function callback(err, \mbox{[}values...\mbox{]})) -\/$>$ Void}

A function to execute a specified {\ttfamily function} with {\ttfamily args} asynchronously.


\begin{DoxyItemize}
\item {\ttfamily function}\+: Required. A function to be executed asynchronously.
\item {\ttfamily args}\+: Optional. Arguments for the {\ttfamily function}.
\item {\ttfamily callback}\+: Required. A function to be executed when the {\ttfamily function} is completed.
\item {\ttfamily err}\+: Required. An error in an async call.
\item {\ttfamily values}\+: Required. Results from the {\ttfamily function}.
\end{DoxyItemize}

\paragraph*{end(\mbox{[}Object values...\mbox{]}) -\/$>$ Void}

A function to execute a last step immediately to end a control-\/flow.


\begin{DoxyItemize}
\item {\ttfamily values}\+: Optional. Arguments for a last step.
\end{DoxyItemize}

\paragraph*{end\+With(\+Error err) -\/$>$ Void}

A function to execute a last step immediately with an error to end a control-\/flow.


\begin{DoxyItemize}
\item {\ttfamily err}\+: Required. An error object. This object can be referred as {\ttfamily this.\+err} in a last step.
\end{DoxyItemize}

\paragraph*{data \+: Object}

A object to share arbitrary data between steps in a control-\/flow.

\paragraph*{flow\+Name \+: String}

A flow name.

\paragraph*{step\+Name \+: String}

A step name.

\paragraph*{err \+: Object}

An error object, which is thrown with {\ttfamily throw}, passed to {\ttfamily this.\+end\+With} or passed to an async callback as first argument. This property is accessible in only last steps.

\subsection*{More Examples}

\subsubsection*{Arguments Passing Between Functions}

Arguments are passed with {\ttfamily this.\+next} or {\ttfamily this.\+async}.

\paragraph*{Synchronously}


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} concat(s1, s2) \{
    var length = s1.length + s2.length
    this.next(s1, s2, length);
  \},
  \textcolor{keyword}{function} end(s1, s2, length) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(s1 + \textcolor{stringliteral}{'.length + '} + s2 + \textcolor{stringliteral}{'.length -> '} + length); \textcolor{comment}{// file1.length + file2.length -> 10}
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
\end{DoxyCode}


\paragraph*{Asynchronously}

To pass asynchronous call results to a next function, arguments mapping definition is necessary. The function {\ttfamily as} accepts an index to specify a callback argument and returns arguments mapping definition. The function {\ttfamily this.\+async} accepts the mapping definition and return a callback. When all callbacks are completed, the next function is called with specific arguments.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(file1, file2) \{
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} end(data1, data2) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(data1 + data2); \textcolor{comment}{// FILE1FILE2}
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
\end{DoxyCode}


Arguments mapping definition can contain arbitrary values.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(file1, file2) \{
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(\{name: file1, data: as(1)\}));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(\{name: file2, data: as(1)\}));
  \},
  \textcolor{keyword}{function} end(f1, f2) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(f1.name + \textcolor{stringliteral}{' and '} + f2.name + \textcolor{stringliteral}{' have been read.'}); \textcolor{comment}{// file1 and file2 have been read.}
    console.log(f1.data + f2.data); \textcolor{comment}{// FILE1FILE2}
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
\end{DoxyCode}


\subsubsection*{Asynchronous Loop}

{\ttfamily this.\+async\+Each} executes a provided function once per array element asynchronously. By default, the number of concurrency is 10.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(files) \{
    this.asyncEach(files, \textcolor{keyword}{function} (file, group) \{
      fs.readFile(file, \textcolor{stringliteral}{'utf8'}, group.async(\{name: file, data: as(1)\}));
    \});
  \},
  \textcolor{keyword}{function} end(files) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    var names = files.map(\textcolor{keyword}{function} (f) \{ \textcolor{keywordflow}{return} f.name; \});
    var contents = files.map(\textcolor{keyword}{function} (f) \{ \textcolor{keywordflow}{return} f.data\});
    console.log(names.join(\textcolor{stringliteral}{' and '}) + \textcolor{stringliteral}{' have been read.'}); \textcolor{comment}{// file1 and file2 have been read.}
    console.log(contents.join(\textcolor{stringliteral}{''})); \textcolor{comment}{// FILE1FILE2}
    this.next();
  \}
);

myFlow([\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'}]);
\end{DoxyCode}


To change the number of concurrency, specify the number as below.


\begin{DoxyCode}
\textcolor{keyword}{function} readFiles(files) \{
  this.asyncEach(5)(files, \textcolor{keyword}{function} (file, group) \{
     ...
  \});
\},
\end{DoxyCode}


\subsubsection*{Flow Nesting}

A flow is composable. So it can be nested.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var subFlow = flow(\textcolor{stringliteral}{'subFlow'})(
  \textcolor{keyword}{function} readFile(file) \{
    fs.readFile(file, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \}
);

var mainFlow = flow(\textcolor{stringliteral}{'mainFlow'})(
  \textcolor{keyword}{function} start() \{
    this.next(\textcolor{stringliteral}{'file1'});
  \},
  subFlow,
  \textcolor{keyword}{function} end(result) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(result);
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

mainFlow();
\end{DoxyCode}


\subsubsection*{Asynchronous Flow Execution}

A flow can be executed asynchronously.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var subFlow = flow(\textcolor{stringliteral}{'subFlow'})(
  \textcolor{keyword}{function} readFile(file) \{
    fs.readFile(file, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \}
);

var mainFlow = flow(\textcolor{stringliteral}{'mainFlow'})(
  \textcolor{keyword}{function} start() \{
    this.exec(subFlow, \textcolor{stringliteral}{'file1'}, this.async(as(1)));
    this.exec(subFlow, \textcolor{stringliteral}{'file2'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} end(data1, data2) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(data1 + data2);
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

mainFlow();
\end{DoxyCode}


\subsubsection*{Parallel Flow}

In following example, the flow {\ttfamily par1-\/1} and {\ttfamily par1-\/2} are executed in parallel.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var parallel = require(\textcolor{stringliteral}{'nue'}).parallel;

var myFlow = flow(\textcolor{stringliteral}{'main'})(
  \textcolor{keyword}{function} one() \{
    console.log(this.stepName);
    this.next(); 
  \},
  \textcolor{keyword}{function} two() \{
    console.log(this.stepName);
    this.next(); 
  \},
  parallel(\textcolor{stringliteral}{'par1'})(
    flow(\textcolor{stringliteral}{'par1-1'})(
      \textcolor{keyword}{function} three() \{
        console.log(this.stepName);
        this.next(); 
      \},
      \textcolor{keyword}{function} four() \{
        console.log(this.stepName);
        this.next(); 
      \}
    ),
    flow(\textcolor{stringliteral}{'par1-2'})(
      \textcolor{keyword}{function} five() \{
        console.log(this.stepName);
        this.next(); 
      \},
      \textcolor{keyword}{function} six() \{
        console.log(this.stepName);
        this.next(); 
      \}
    )
  ),
  \textcolor{keyword}{function} seven() \{
    console.log(this.stepName);
    this.next(); 
  \},
  \textcolor{keyword}{function} eight() \{
    console.log(this.stepName);
    this.next(); 
  \},
  \textcolor{keyword}{function} allDone() \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(this.stepName);
    this.next();
  \}
);

myFlow();
\end{DoxyCode}


Arguments to a parallel flow are passed to every forked functions. Parallel flow results are passed to a next funtion as an array. The array contains the results of forked functions.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var parallel = require(\textcolor{stringliteral}{'nue'}).parallel;

var myFlow = flow(\textcolor{stringliteral}{'main'})(
  \textcolor{keyword}{function} start() \{ 
    this.next(10, 20); 
  \},
  parallel(\textcolor{stringliteral}{'parallel'})(
    \textcolor{keyword}{function} add(x, y) \{ 
      this.next(x + y); 
    \},
    \textcolor{keyword}{function} sub(x, y) \{ 
      this.next(x - y);
    \}
  ),
  \textcolor{keyword}{function} end(results) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(\textcolor{stringliteral}{'add result: '} + results[0]); \textcolor{comment}{// add result: 30 }
    console.log(\textcolor{stringliteral}{'sub result: '} + results[1]); \textcolor{comment}{// sub result: -10}
    this.next();
  \}
);

myFlow();
\end{DoxyCode}


\subsubsection*{Data Sharing Between Functions}

Each step in a flow can share data through {\ttfamily this.\+data}. {\ttfamily this.\+data} is shared in a same flow. A nesting flow and any nested flows can\textquotesingle{}t share {\ttfamily this.\+data}.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(file1, file2) \{
    this.data.file1 = file1;
    this.data.file2 = file2;
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} concat(data1, data2) \{
    this.next(data1 + data2);
  \},
  \textcolor{keyword}{function} end(data) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(data);
    console.log(this.data.file1 + \textcolor{stringliteral}{' and '} + \textcolor{keyword}{this}.data.file2 + \textcolor{stringliteral}{' are concatenated.'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
\end{DoxyCode}


\subsubsection*{Error Handling}

In a last step in a flow, {\ttfamily this.\+err} represents an error which is thrown with {\ttfamily throw}, passed to {\ttfamily this.\+end\+With} or passed to an async callback as first argument. To indicate error handling is completed, you must assign {\ttfamily null} to {\ttfamily this.\+err}.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var myFlow = flow(\textcolor{stringliteral}{'myFlow'})(
  \textcolor{keyword}{function} readFiles(file1, file2) \{
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} concat(data1, data2) \{
    this.next(data1 + data2);
  \},
  \textcolor{keyword}{function} end(data) \{
    \textcolor{keywordflow}{if} (this.err) \{
      \textcolor{comment}{// handle error}
      console.log(this.err.message);
      \textcolor{comment}{// indicate error handling completion}
      this.err = null;
    \} \textcolor{keywordflow}{else} \{
      console.log(data);
    \}
    console.log(\textcolor{stringliteral}{'done'});
    this.next();
  \}
);

myFlow(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'non-existent-file'});
\end{DoxyCode}


\subsubsection*{Unit Test with Mocha}

Following example shows how to test a flow and a function with \href{http://visionmedia.github.com/mocha/}{\tt Mocha}.


\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;
var as = require(\textcolor{stringliteral}{'nue'}).as;
var fs = require(\textcolor{stringliteral}{'fs'});

var concatFiles = flow(
  \textcolor{keyword}{function} (file1, file2) \{
    fs.readFile(file1, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
    fs.readFile(file2, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
  \},
  \textcolor{keyword}{function} (data1, data2) \{
    this.next(data1 + data2);
  \}
);

\textcolor{keyword}{function} read(file) \{
  fs.readFile(file, \textcolor{stringliteral}{'utf8'}, this.async(as(1)));
\}

var assert = require(\textcolor{stringliteral}{'assert'});

describe(\textcolor{stringliteral}{'flow `concatFiles`'}, \textcolor{keyword}{function} () \{
  it(\textcolor{stringliteral}{'can be tested'}, \textcolor{keyword}{function} (done) \{
    flow(
      concatFiles,
      \textcolor{keyword}{function} (data) \{
        \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
        assert.strictEqual(data, \textcolor{stringliteral}{'FILE1FILE2'});
        done();
      \}
    )(\textcolor{stringliteral}{'file1'}, \textcolor{stringliteral}{'file2'});
  \});
\});

describe(\textcolor{stringliteral}{'function `read`'}, \textcolor{keyword}{function} () \{
  it(\textcolor{stringliteral}{'can be tested'}, \textcolor{keyword}{function} (done) \{
    flow(
      read,
      \textcolor{keyword}{function} (data) \{
        \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
        assert.strictEqual(data, \textcolor{stringliteral}{'FILE1'});
        done();
      \}
    )(\textcolor{stringliteral}{'file1'});
  \});
\});
\end{DoxyCode}


\subsection*{Debugging}

Use {\ttfamily N\+O\+D\+E\+\_\+\+D\+E\+B\+U\+G=nue}.

\subsubsection*{Example}

\begin{quote}
hoge.\+js \end{quote}



\begin{DoxyCode}
var flow = require(\textcolor{stringliteral}{'nue'}).flow;

flow(\textcolor{stringliteral}{'hoge'})(
  \textcolor{keyword}{function} add(x, y) \{
    this.next(x + y);
  \},
  \textcolor{keyword}{function} done(result) \{
    \textcolor{keywordflow}{if} (this.err) \textcolor{keywordflow}{throw} this.err;
    console.log(result);
  \}
)(10, 20);
\end{DoxyCode}


\begin{quote}
Run and Output \end{quote}



\begin{DoxyCode}
1 $ NODE\_DEBUG=nue node hoge.js
2 NUE: begin TOP\_LEVEL\_FLOW. flow: hoge(0), calledAt: /private/tmp/hoge.js:11:1, args: [ 10, 20 ]
3 NUE: begin STEP. flow: hoge(0), step: add(0), args: [ 10, 20 ]
4 NUE: begin STEP. flow: hoge(0), step: done(1), args: [ 30 ]
5 30
\end{DoxyCode}
 