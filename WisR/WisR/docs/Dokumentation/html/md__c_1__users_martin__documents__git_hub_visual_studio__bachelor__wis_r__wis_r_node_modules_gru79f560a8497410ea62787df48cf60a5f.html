<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>WisR web applikation: kew: a lightweight (and super fast) promise/deferred framework for node.js</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WisR web applikation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">kew: a lightweight (and super fast) promise/deferred framework for node.js </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>kew</b> is a lightweight promise framework with an aim of providing a base set of functionality similar to that provided by the <a href="https://github.com/kriskowal/q" title="Q">Q library</a>.</p>
<h2>A few answers (for a few questions) </h2>
<p><em>Why'd we write it?</em></p>
<p>During our initial usage of <b>Q</b> we found that it was consuming 80% of the cpu under load (primarily in chained database callbacks). We spent some time looking at patching <b>Q</b> and ultimately found that creating our own lightweight library for server-usage would suit our needs better than figuring out how to make a large cross-platform library more performant on one very specific platform.</p>
<p><em>So this does everything Q does?</em></p>
<p>Nope! <b>Q</b> is still an awesome library and does <em>way</em> more than <b>kew</b>. We support a tiny subset of the <b>Q</b> functionality (the subset that we happen to use in our actual use cases).</p>
<h2>What are Promises? </h2>
<p>At its core, a <em>Promise</em> is a promise to return a value at some point in the future. A <em>Promise</em> represents a value that will be (or may return an error if something goes wrong). <em>Promises</em> heavily reduce the complexity of asynchronous coding in node.js-like environments. Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// assuming the getUrlContent() function exists and retrieves the content of a url</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;var htmlPromise = getUrlContent(myUrl)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// we can then filter that through an http parser (our imaginary parseHtml() function) asynchronously (or maybe synchronously, who knows)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;var tagsPromise = htmlPromise.then(parseHtml)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// and then filter it through another function (getLinks()) which retrieves only the link tags</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;var linksPromise = tagsPromise.then(getLinks)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// and then parses the actual urls from the links (using parseUrlsFromLinks())</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;var urlsPromise = linksPromise.then(parseUrlsFromLinks)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// finally, we have a promise that should only provide us with the urls and will run once all the previous steps have ran</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;urlsPromise.then(function (urls) {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  // do something with the urls</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;})</div>
</div><!-- fragment --><h2>How do I use <b>kew</b>? </h2>
<p>As a precursor to all the examples, the following code must be at the top of your page:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var Q = require(&#39;kew&#39;)</div>
</div><!-- fragment --><h3>Convert a literal into a promise</h3>
<p>The easiest way to start a promise chain is by creating a new promise with a specified literal using Q.resolve() or Q.reject()</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// create a promise which passes a value to the next then() call</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;var successPromise = Q.resolve(val)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// create a promise which throws an error to be caught by the next fail() call</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;var failPromise = Q.reject(err)</div>
</div><!-- fragment --><p>In addition, you can create deferreds which can be used if you need to create a promise but resolve it later:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// create the deferreds</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;var successDefer = Q.defer()</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;var failDefer = Q.defer()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// resolve or reject the defers in 1 second</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;setTimeout(function () {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  successDefer.resolve(&quot;ok&quot;)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  failDefer.reject(new Error(&quot;this failed&quot;))</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}, 1000)</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// extract promises from the deferreds</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;var successPromise = successDefer.promise</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;var failPromise = failDefer.promise</div>
</div><!-- fragment --><p>If you have a node-style callback (taking an <b>Error</b> as the first parameter and a response as the second), you can call the magic <code>makeNodeResolver()</code> function on a defer to allow the defer to handle the callbacks:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// create the deferred</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;var defer = Q.defer()</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// some node-style function</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;getObjectFromDatabase(myObjectId, defer.makeNodeResolver())</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// grab the output</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;defer.promise</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  .then(function (obj) {</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // successfully retrieved the object</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  })</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  .fail(function (e) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    // failed retrieving the object</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  })</div>
</div><!-- fragment --><h3>Handling successful results with <code>.then()</code></h3>
<p>When a promise is resolved, you may call the <code>.then()</code> method to retrieve the value of the promise:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;promise.then(function (result) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // do something with the result here</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;})</div>
</div><!-- fragment --><p><code>.then()</code> will in turn return a promise which will return the results of whatever it returns (asynchronously or not), allowing it to be chained indefinitely:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Q.resolve(&#39;a&#39;)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  .then(function (result) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return result + &#39;b&#39;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  })</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  .then(function (result) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    return result + &#39;c&#39;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  })</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  .then(function (result) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // result should be &#39;abc&#39;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  })</div>
</div><!-- fragment --><p>In addition, <code>.then()</code> calls may return promises themselves, allowing for complex nesting of asynchronous calls in a flat manner:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var htmlPromise = getUrlContent(myUrl)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;var tagsPromise = htmlPromise.then(function (html) {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  if (!validHtml(html)) throw new Error(&quot;Invalid HTML&quot;)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // pretend that parseHtml() returns a promise and is asynchronous</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  return parseHtml(html)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;})</div>
</div><!-- fragment --><h3>Handling errors with <code>.fail()</code></h3>
<p>If a promise is rejected for some reason, you may handle the failure case with the <code>.fail()</code> function:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;getObjectPromise</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  .fail(function (e) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    console.error(&quot;Failed to retrieve object&quot;, e)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  })</div>
</div><!-- fragment --><p>Like <code>.then()</code>, <code>.fail()</code> also returns a promise. If the <code>.fail()</code> call does not throw an error, it will pass the return value of the <code>.fail()</code> handler to any <code>.then()</code> calls chained to it:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;getObjectPromise</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  .fail(function (e) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return retryGetObject(objId)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  })</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  .then(function (obj) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // yay, we received an object</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  })</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  .fail(function (e) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // the retry failed :(</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    console.error(&quot;Retrieving the object &#39;&quot; + objId + &quot;&#39; failed&quot;)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  })</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;})</div>
</div><!-- fragment --><p>If you've reached the end of your promise chain, you may call <code>.end()</code> which signifies that the promise chain is ended and any errors should be thrown in whatever scope the code is currently in:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;getObjectPromise</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // this will throw an error to the uncaught exception handler if the getObjectPromise call is asynchronous</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  .end()</div>
</div><!-- fragment --><h3><code>.fin()</code> when things are finished</h3>
<p>You may attach a handler to a promise which will be ran regardless of whether the promise was resolved or rejected (but will only run upon completion). This is useful in the cases where you may have set up resources to run a request and wish to tear them down afterwards. <code>.fin()</code> will return the promise it is called upon:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var connection = db.connect()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;var itemPromise = db.getItem(itemId)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  .fin(function () {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    db.close()</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  })</div>
</div><!-- fragment --><h2>Other utility methods </h2>
<h3><code>.all()</code> for many things</h3>
<p>If you're waiting for multiple promises to return, you may pass them (mixed in with literals if you desire) into <code>.all()</code> which will create a promise that resolves successfully with an array of the results of the promises:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var promises = []</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;promises.push(getUrlContent(url1))</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;promises.push(getUrlContent(url2))</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;promises.push(getUrlContent(url3))</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Q.all(promises)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  .then(function (content) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    // content[0] === content for url 1</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // content[1] === content for url 2</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // content[2] === content for url 3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  })</div>
</div><!-- fragment --><p>If any of the promises fail, Q.all will fail as well (so make sure to guard your promises with a <code>.fail()</code> call beforehand if you don't care whether they succeed or not):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var promises = []</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;promises.push(getUrlContent(url1))</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;promises.push(getUrlContent(url2))</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;promises.push(getUrlContent(url3))</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Q.all(promises)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  .fail(function (e) {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    console.log(&quot;Failed retrieving a url&quot;, e)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  })</div>
</div><!-- fragment --><h3><code>.delay()</code> for future promises</h3>
<p>If you need a little bit of delay (such as retrying a method call to a service that is "eventually consistent") before doing something else, <code>Q.delay()</code> is your friend:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;getUrlContent(url1)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;.fail(function () {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  // Retry again after 200 milisseconds</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  return Q.delay(200).then(function () {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    return getUrlContent(url1)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  })</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;})</div>
</div><!-- fragment --><p>If two arguments are passed, the first will be used as the return value, and the second will be the delay in milliseconds.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Q.delay(obj, 20).then(function (result) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  console.log(result) // logs `obj` after 20ms</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;})</div>
</div><!-- fragment --><p>### <code>.fcall()</code> for delaying a function invocation until the next tick: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Assume someFn() is a synchronous 2 argument function you want to delay.</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Q.fcall(someFn, arg1, arg2)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  .then(function (result) {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    console.log(&#39;someFn(&#39; + arg1 + &#39;, &#39; + arg2 + &#39;) = &#39; + result)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  })</div>
</div><!-- fragment --><p>You can also use <code>Q.fcall()</code> with functions that return promises.</p>
<h3><code>.nfcall()</code> for Node.js callbacks</h3>
<p><code>Q.nfcall()</code> can be used to convert node-style callbacks into promises:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Q.nfcall(fs.writeFile, &#39;/tmp/myFile&#39;, &#39;content&#39;)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  .then(function () {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    console.log(&#39;File written successfully&#39;)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  })</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  .fail(function (err) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    console.log(&#39;Failed to write file&#39;, err)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  })</div>
</div><!-- fragment --><h2>Contributing </h2>
<p>Questions, comments, bug reports, and pull requests are all welcome. Submit them at <a href="https://github.com/Obvious/kew/">the project on GitHub</a>.</p>
<p>Bug reports that include steps-to-reproduce (including code) are the best. Even better, make them in the form of pull requests that update the test suite. Thanks!</p>
<h2>Author </h2>
<p><a href="https://github.com/azulus">Jeremy Stanley</a> supported by <a href="http://obvious.com/">The Obvious Corporation</a>.</p>
<h2>License </h2>
<p>Copyright 2013 <a href="http://obvious.com/">The Obvious Corporation</a>.</p>
<p>Licensed under the Apache License, Version 2.0. See the top-level file <code>LICENSE.TXT</code> and (<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
