<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>WisR web applikation: C:/Users/martin/Documents/GitHubVisualStudio/Bachelor/WisR/WisR/docs/grunt-scripts/angular.js</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WisR web applikation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/martin/Documents/GitHubVisualStudio/Bachelor/WisR/WisR/docs/grunt-scripts/angular.js</div>  </div>
</div><!--header-->
<div class="contents">
<p>&lt;file name="index.html"&gt; </p><div ng-controller="ExampleController"> &lt;form novalidate="" class="simple-form"&gt; Name: &lt;input type="text" ng-model="user.name"&gt;<br />
 E-mail: &lt;input type="email" ng-model="user.email"&gt;<br />
 Gender: &lt;input type="radio" ng-model="user.gender" value="male"&gt;male &lt;input type="radio" ng-model="user.gender" value="female"&gt;female<br />
 &lt;button ng-click="reset()"&gt;RESET&lt;/button&gt; &lt;button ng-click="update(user)"&gt;SAVE&lt;/button&gt; &lt;/form&gt; </p><pre>form = {{user | json}}</pre> <pre>master = {{master | json}}</pre> </div><p>&lt;script&gt; angular.module('copyExample', []) .controller('ExampleController', ['$scope', function($scope) { $scope.master= {};</p>
<p>$scope.update = function(user) { // Example with 1 argument $scope.master= angular.copy(user); };</p>
<p>$scope.reset = function() { // Example with 2 arguments angular.copy($scope.master, $scope.user); };</p>
<p>$scope.reset(); }]); &lt;/script&gt; &lt;/file&gt; </p>
<p>*/ function copy(source, destination, stackSource, stackDest) { if (isWindow(source) || isScope(source)) { throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported."); } if (isTypedArray(destination)) { throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated."); }</p>
<p>if (!destination) { destination = source; if (isObject(source)) { var index; if (stackSource &amp;&amp; (index = stackSource.indexOf(source)) !== -1) { return stackDest[index]; }</p>
<p>// TypedArray, Date and RegExp have specific copy functionality and must be // pushed onto the stack before returning. // Array and other objects create the base object and recurse to copy child // objects. The array/object will be pushed onto the stack when recursed. if (isArray(source)) { return copy(source, [], stackSource, stackDest); } else if (isTypedArray(source)) { destination = new source.constructor(source); } else if (isDate(source)) { destination = new Date(source.getTime()); } else if (isRegExp(source)) { destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]); destination.lastIndex = source.lastIndex; } else { var emptyObject = Object.create(getPrototypeOf(source)); return copy(source, emptyObject, stackSource, stackDest); }</p>
<p>if (stackDest) { stackSource.push(source); stackDest.push(destination); } } } else { if (source === destination) throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");</p>
<p>stackSource = stackSource || []; stackDest = stackDest || [];</p>
<p>if (isObject(source)) { stackSource.push(source); stackDest.push(destination); }</p>
<p>var result, key; if (isArray(source)) { destination.length = 0; for (var i = 0; i &lt; source.length; i++) { destination.push(copy(source[i], null, stackSource, stackDest)); } } else { var h = destination.$$hashKey; if (isArray(destination)) { destination.length = 0; } else { forEach(destination, function(value, key) { delete destination[key]; }); } if (isBlankObject(source)) { // createMap() fast path &mdash; Safe to avoid hasOwnProperty check because prototype chain is empty for (key in source) { destination[key] = copy(source[key], null, stackSource, stackDest); } } else if (source &amp;&amp; typeof source.hasOwnProperty === 'function') { // Slow path, which must rely on hasOwnProperty for (key in source) { if (source.hasOwnProperty(key)) { destination[key] = copy(source[key], null, stackSource, stackDest); } } } else { // Slowest path &mdash; hasOwnProperty can't be called as a method for (key in source) { if (hasOwnProperty.call(source, key)) { destination[key] = copy(source[key], null, stackSource, stackDest); } } } setHashKey(destination,h); } } return destination; }</p>
<p>/** Creates a shallow copy of an object, an array or a primitive.</p>
<p>Assumes that there are no proto properties for objects. */ function shallowCopy(src, dst) { if (isArray(src)) { dst = dst || [];</p>
<p>for (var i = 0, ii = src.length; i &lt; ii; i++) { dst[i] = src[i]; } } else if (isObject(src)) { dst = dst || {};</p>
<p>for (var key in src) { if (!(key.charAt(0) === '$' &amp;&amp; key.charAt(1) === '$')) { dst[key] = src[key]; } } }</p>
<p>return dst || src; }</p>
<p>/**  function</p>
<div class="fragment"><div class="line"></div>
<div class="line">(<span class="keyword">function</span>(window, document, undefined) {<span class="stringliteral">&#39;use strict&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> minErr(module, ErrorConstructor) {</div>
<div class="line">  ErrorConstructor = ErrorConstructor || Error;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    var SKIP_INDEXES = 2;</div>
<div class="line"></div>
<div class="line">    var templateArgs = arguments,</div>
<div class="line">      code = templateArgs[0],</div>
<div class="line">      message = <span class="charliteral">&#39;[&#39;</span> + (module ? module + <span class="charliteral">&#39;:&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + code + <span class="stringliteral">&#39;] &#39;</span>,</div>
<div class="line">      <span class="keyword">template</span> = templateArgs[1],</div>
<div class="line">      paramPrefix, i;</div>
<div class="line"></div>
<div class="line">    message += <span class="keyword">template</span>.replace(/\{\d+\}/g, <span class="keyword">function</span>(match) {</div>
<div class="line">      var index = +match.slice(1, -1),</div>
<div class="line">        shiftedIndex = index + SKIP_INDEXES;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (shiftedIndex &lt; templateArgs.length) {</div>
<div class="line">        <span class="keywordflow">return</span> toDebugString(templateArgs[shiftedIndex]);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> match;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    message += <span class="stringliteral">&#39;\nhttp://errors.angularjs.org/1.4.4/&#39;</span> +</div>
<div class="line">      (module ? module + <span class="charliteral">&#39;/&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + code;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = SKIP_INDEXES, paramPrefix = <span class="charliteral">&#39;?&#39;</span>; i &lt; templateArgs.length; i++, paramPrefix = <span class="charliteral">&#39;&amp;&#39;</span>) {</div>
<div class="line">      message += paramPrefix + <span class="charliteral">&#39;p&#39;</span> + (i - SKIP_INDEXES) + <span class="charliteral">&#39;=&#39;</span> +</div>
<div class="line">        encodeURIComponent(toDebugString(templateArgs[i]));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ErrorConstructor(message);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* We need to tell jshint what variables are being exported */</span></div>
<div class="line"><span class="comment">/* global angular: true,</span></div>
<div class="line"><span class="comment">  msie: true,</span></div>
<div class="line"><span class="comment">  jqLite: true,</span></div>
<div class="line"><span class="comment">  jQuery: true,</span></div>
<div class="line"><span class="comment">  slice: true,</span></div>
<div class="line"><span class="comment">  splice: true,</span></div>
<div class="line"><span class="comment">  push: true,</span></div>
<div class="line"><span class="comment">  toString: true,</span></div>
<div class="line"><span class="comment">  ngMinErr: true,</span></div>
<div class="line"><span class="comment">  angularModule: true,</span></div>
<div class="line"><span class="comment">  uid: true,</span></div>
<div class="line"><span class="comment">  REGEX_STRING_REGEXP: true,</span></div>
<div class="line"><span class="comment">  VALIDITY_STATE_PROPERTY: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  lowercase: true,</span></div>
<div class="line"><span class="comment">  uppercase: true,</span></div>
<div class="line"><span class="comment">  manualLowercase: true,</span></div>
<div class="line"><span class="comment">  manualUppercase: true,</span></div>
<div class="line"><span class="comment">  nodeName_: true,</span></div>
<div class="line"><span class="comment">  isArrayLike: true,</span></div>
<div class="line"><span class="comment">  forEach: true,</span></div>
<div class="line"><span class="comment">  forEachSorted: true,</span></div>
<div class="line"><span class="comment">  reverseParams: true,</span></div>
<div class="line"><span class="comment">  nextUid: true,</span></div>
<div class="line"><span class="comment">  setHashKey: true,</span></div>
<div class="line"><span class="comment">  extend: true,</span></div>
<div class="line"><span class="comment">  toInt: true,</span></div>
<div class="line"><span class="comment">  inherit: true,</span></div>
<div class="line"><span class="comment">  merge: true,</span></div>
<div class="line"><span class="comment">  noop: true,</span></div>
<div class="line"><span class="comment">  identity: true,</span></div>
<div class="line"><span class="comment">  valueFn: true,</span></div>
<div class="line"><span class="comment">  isUndefined: true,</span></div>
<div class="line"><span class="comment">  isDefined: true,</span></div>
<div class="line"><span class="comment">  isObject: true,</span></div>
<div class="line"><span class="comment">  isBlankObject: true,</span></div>
<div class="line"><span class="comment">  isString: true,</span></div>
<div class="line"><span class="comment">  isNumber: true,</span></div>
<div class="line"><span class="comment">  isDate: true,</span></div>
<div class="line"><span class="comment">  isArray: true,</span></div>
<div class="line"><span class="comment">  isFunction: true,</span></div>
<div class="line"><span class="comment">  isRegExp: true,</span></div>
<div class="line"><span class="comment">  isWindow: true,</span></div>
<div class="line"><span class="comment">  isScope: true,</span></div>
<div class="line"><span class="comment">  isFile: true,</span></div>
<div class="line"><span class="comment">  isFormData: true,</span></div>
<div class="line"><span class="comment">  isBlob: true,</span></div>
<div class="line"><span class="comment">  isBoolean: true,</span></div>
<div class="line"><span class="comment">  isPromiseLike: true,</span></div>
<div class="line"><span class="comment">  trim: true,</span></div>
<div class="line"><span class="comment">  escapeForRegexp: true,</span></div>
<div class="line"><span class="comment">  isElement: true,</span></div>
<div class="line"><span class="comment">  makeMap: true,</span></div>
<div class="line"><span class="comment">  includes: true,</span></div>
<div class="line"><span class="comment">  arrayRemove: true,</span></div>
<div class="line"><span class="comment">  copy: true,</span></div>
<div class="line"><span class="comment">  shallowCopy: true,</span></div>
<div class="line"><span class="comment">  equals: true,</span></div>
<div class="line"><span class="comment">  csp: true,</span></div>
<div class="line"><span class="comment">  jq: true,</span></div>
<div class="line"><span class="comment">  concat: true,</span></div>
<div class="line"><span class="comment">  sliceArgs: true,</span></div>
<div class="line"><span class="comment">  bind: true,</span></div>
<div class="line"><span class="comment">  toJsonReplacer: true,</span></div>
<div class="line"><span class="comment">  toJson: true,</span></div>
<div class="line"><span class="comment">  fromJson: true,</span></div>
<div class="line"><span class="comment">  convertTimezoneToLocal: true,</span></div>
<div class="line"><span class="comment">  timezoneToOffset: true,</span></div>
<div class="line"><span class="comment">  startingTag: true,</span></div>
<div class="line"><span class="comment">  tryDecodeURIComponent: true,</span></div>
<div class="line"><span class="comment">  parseKeyValue: true,</span></div>
<div class="line"><span class="comment">  toKeyValue: true,</span></div>
<div class="line"><span class="comment">  encodeUriSegment: true,</span></div>
<div class="line"><span class="comment">  encodeUriQuery: true,</span></div>
<div class="line"><span class="comment">  angularInit: true,</span></div>
<div class="line"><span class="comment">  bootstrap: true,</span></div>
<div class="line"><span class="comment">  getTestability: true,</span></div>
<div class="line"><span class="comment">  snake_case: true,</span></div>
<div class="line"><span class="comment">  bindJQuery: true,</span></div>
<div class="line"><span class="comment">  assertArg: true,</span></div>
<div class="line"><span class="comment">  assertArgFn: true,</span></div>
<div class="line"><span class="comment">  assertNotHasOwnProperty: true,</span></div>
<div class="line"><span class="comment">  getter: true,</span></div>
<div class="line"><span class="comment">  getBlockNodes: true,</span></div>
<div class="line"><span class="comment">  hasOwnProperty: true,</span></div>
<div class="line"><span class="comment">  createMap: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  NODE_TYPE_ELEMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_ATTRIBUTE: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_TEXT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_COMMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_DOCUMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_DOCUMENT_FRAGMENT: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The name of a form control&#39;s ValidityState property.</span></div>
<div class="line"><span class="comment">// This is used so that it&#39;s possible for internal tests to create mock ValidityStates.</span></div>
<div class="line">var VALIDITY_STATE_PROPERTY = <span class="stringliteral">&#39;validity&#39;</span>;</div>
<div class="line"></div>
<div class="line">var lowercase = <span class="keyword">function</span>(string) {<span class="keywordflow">return</span> isString(<span class="keywordtype">string</span>) ? <span class="keywordtype">string</span>.toLowerCase() : string;};</div>
<div class="line">var hasOwnProperty = Object.prototype.hasOwnProperty;</div>
<div class="line"></div>
<div class="line">var uppercase = <span class="keyword">function</span>(string) {<span class="keywordflow">return</span> isString(<span class="keywordtype">string</span>) ? <span class="keywordtype">string</span>.toUpperCase() : string;};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var manualLowercase = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="comment">/* jshint bitwise: false */</span></div>
<div class="line">  <span class="keywordflow">return</span> isString(s)</div>
<div class="line">      ? s.replace(/[A-Z]/g, <span class="keyword">function</span>(ch) {<span class="keywordflow">return</span> String.fromCharCode(ch.charCodeAt(0) | 32);})</div>
<div class="line">      : s;</div>
<div class="line">};</div>
<div class="line">var manualUppercase = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="comment">/* jshint bitwise: false */</span></div>
<div class="line">  <span class="keywordflow">return</span> isString(s)</div>
<div class="line">      ? s.replace(/[a-z]/g, <span class="keyword">function</span>(ch) {<span class="keywordflow">return</span> String.fromCharCode(ch.charCodeAt(0) &amp; ~32);})</div>
<div class="line">      : s;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// String#toLowerCase and String#toUpperCase don&#39;t produce correct results in browsers with Turkish</span></div>
<div class="line"><span class="comment">// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods</span></div>
<div class="line"><span class="comment">// with correct but slower alternatives.</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="charliteral">&#39;i&#39;</span> !== <span class="charliteral">&#39;I&#39;</span>.toLowerCase()) {</div>
<div class="line">  lowercase = manualLowercase;</div>
<div class="line">  uppercase = manualUppercase;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    msie,             <span class="comment">// holds major version number for IE, or NaN if UA is not IE.</span></div>
<div class="line">    jqLite,           <span class="comment">// delay binding since jQuery could be loaded after us.</span></div>
<div class="line">    jQuery,           <span class="comment">// delay binding</span></div>
<div class="line">    slice             = [].slice,</div>
<div class="line">    splice            = [].splice,</div>
<div class="line">    push              = [].push,</div>
<div class="line">    toString          = Object.prototype.toString,</div>
<div class="line">    getPrototypeOf    = Object.getPrototypeOf,</div>
<div class="line">    ngMinErr          = minErr(<span class="stringliteral">&#39;ng&#39;</span>),</div>
<div class="line"></div>
<div class="line">    angular           = window.angular || (window.angular = {}),</div>
<div class="line">    angularModule,</div>
<div class="line">    uid               = 0;</div>
<div class="line"></div>
<div class="line">msie = document.documentMode;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isArrayLike(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj == null || isWindow(obj)) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Support: iOS 8.2 (not reproducible in simulator)</span></div>
<div class="line">  <span class="comment">// &quot;length&quot; in obj used to prevent JIT error (gh-11508)</span></div>
<div class="line">  var length = <span class="stringliteral">&quot;length&quot;</span> in Object(obj) &amp;&amp; obj.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (obj.nodeType === NODE_TYPE_ELEMENT &amp;&amp; length) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> isString(obj) || isArray(obj) || length === 0 ||</div>
<div class="line">         typeof length === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> forEach(obj, iterator, context) {</div>
<div class="line">  var key, length;</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (isFunction(obj)) {</div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="comment">// Need to check if hasOwnProperty exists,</span></div>
<div class="line">        <span class="comment">// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function</span></div>
<div class="line">        <span class="keywordflow">if</span> (key != <span class="stringliteral">&#39;prototype&#39;</span> &amp;&amp; key != <span class="stringliteral">&#39;length&#39;</span> &amp;&amp; key != <span class="stringliteral">&#39;name&#39;</span> &amp;&amp; (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(obj) || isArrayLike(obj)) {</div>
<div class="line">      var isPrimitive = typeof obj !== <span class="stringliteral">&#39;object&#39;</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (key = 0, length = obj.length; key &lt; length; key++) {</div>
<div class="line">        <span class="keywordflow">if</span> (isPrimitive || key in obj) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj.forEach &amp;&amp; obj.forEach !== forEach) {</div>
<div class="line">        obj.forEach(iterator, context, obj);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isBlankObject(obj)) {</div>
<div class="line">      <span class="comment">// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        iterator.call(context, obj[key], key, obj);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj.hasOwnProperty === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      <span class="comment">// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="keywordflow">if</span> (obj.hasOwnProperty(key)) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Slow path for objects which do not have a method `hasOwnProperty`</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="keywordflow">if</span> (hasOwnProperty.call(obj, key)) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> forEachSorted(obj, iterator, context) {</div>
<div class="line">  var keys = Object.keys(obj).sort();</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; keys.length; i++) {</div>
<div class="line">    iterator.call(context, obj[keys[i]], keys[i]);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> keys;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> reverseParams(iteratorFn) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(value, key) { iteratorFn(key, value); };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nextUid() {</div>
<div class="line">  <span class="keywordflow">return</span> ++uid;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setHashKey(obj, h) {</div>
<div class="line">  <span class="keywordflow">if</span> (h) {</div>
<div class="line">    obj.$$hashKey = h;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keyword">delete</span> obj.$$hashKey;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> baseExtend(dst, objs, deep) {</div>
<div class="line">  var h = dst.$$hashKey;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0, ii = objs.length; i &lt; ii; ++i) {</div>
<div class="line">    var obj = objs[i];</div>
<div class="line">    <span class="keywordflow">if</span> (!isObject(obj) &amp;&amp; !isFunction(obj)) <span class="keywordflow">continue</span>;</div>
<div class="line">    var keys = Object.keys(obj);</div>
<div class="line">    <span class="keywordflow">for</span> (var j = 0, jj = keys.length; j &lt; jj; j++) {</div>
<div class="line">      var key = keys[j];</div>
<div class="line">      var src = obj[key];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (deep &amp;&amp; isObject(src)) {</div>
<div class="line">        <span class="keywordflow">if</span> (isDate(src)) {</div>
<div class="line">          dst[key] = <span class="keyword">new</span> Date(src.valueOf());</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(src)) {</div>
<div class="line">          dst[key] = <span class="keyword">new</span> RegExp(src);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};</div>
<div class="line">          baseExtend(dst[key], [src], <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        dst[key] = src;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  setHashKey(dst, h);</div>
<div class="line">  <span class="keywordflow">return</span> dst;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> extend(dst) {</div>
<div class="line">  <span class="keywordflow">return</span> baseExtend(dst, slice.call(arguments, 1), <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> merge(dst) {</div>
<div class="line">  <span class="keywordflow">return</span> baseExtend(dst, slice.call(arguments, 1), <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toInt(str) {</div>
<div class="line">  <span class="keywordflow">return</span> parseInt(str, 10);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> inherit(parent, extra) {</div>
<div class="line">  <span class="keywordflow">return</span> extend(Object.create(parent), extra);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> noop() {}</div>
<div class="line">noop.$inject = [];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> identity($) {<span class="keywordflow">return</span> $;}</div>
<div class="line">identity.$inject = [];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> valueFn(value) {<span class="keywordflow">return</span> <span class="keyword">function</span>() {<span class="keywordflow">return</span> value;};}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> hasCustomToString(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> isFunction(obj.toString) &amp;&amp; obj.toString !== Object.prototype.toString;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isUndefined(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;undefined&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isDefined(value) {<span class="keywordflow">return</span> typeof value !== <span class="stringliteral">&#39;undefined&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isObject(value) {</div>
<div class="line">  <span class="comment">// http://jsperf.com/isobject4</span></div>
<div class="line">  <span class="keywordflow">return</span> value !== null &amp;&amp; typeof value === <span class="stringliteral">&#39;object&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBlankObject(value) {</div>
<div class="line">  <span class="keywordflow">return</span> value !== null &amp;&amp; typeof value === <span class="stringliteral">&#39;object&#39;</span> &amp;&amp; !getPrototypeOf(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isString(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;string&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isNumber(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;number&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isDate(value) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(value) === <span class="stringliteral">&#39;[object Date]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var isArray = Array.isArray;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFunction(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;function&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isRegExp(value) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(value) === <span class="stringliteral">&#39;[object RegExp]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isWindow(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; obj.window === obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isScope(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFile(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object File]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFormData(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object FormData]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBlob(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object Blob]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBoolean(value) {</div>
<div class="line">  <span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;boolean&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isPromiseLike(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; isFunction(obj.then);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;</div>
<div class="line"><span class="keyword">function</span> isTypedArray(value) {</div>
<div class="line">  <span class="keywordflow">return</span> TYPED_ARRAY_REGEXP.test(toString.call(value));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var trim = <span class="keyword">function</span>(value) {</div>
<div class="line">  <span class="keywordflow">return</span> isString(value) ? value.trim() : value;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copied from:</span></div>
<div class="line"><span class="comment">// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021</span></div>
<div class="line"><span class="comment">// Prereq: s is a string.</span></div>
<div class="line">var escapeForRegexp = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="keywordflow">return</span> s.replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, <span class="stringliteral">&#39;\\$1&#39;</span>).</div>
<div class="line">           replace(/\x08/g, <span class="stringliteral">&#39;\\x08&#39;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isElement(node) {</div>
<div class="line">  <span class="keywordflow">return</span> !!(node &amp;&amp;</div>
<div class="line">    (node.nodeName  <span class="comment">// we are a direct element</span></div>
<div class="line">    || (node.prop &amp;&amp; node.attr &amp;&amp; node.find)));  <span class="comment">// we have an on and find method part of jQuery API</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> makeMap(str) {</div>
<div class="line">  var obj = {}, items = str.split(<span class="stringliteral">&quot;,&quot;</span>), i;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; items.length; i++) {</div>
<div class="line">    obj[items[i]] = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nodeName_(element) {</div>
<div class="line">  <span class="keywordflow">return</span> lowercase(element.nodeName || (element[0] &amp;&amp; element[0].nodeName));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> includes(array, obj) {</div>
<div class="line">  <span class="keywordflow">return</span> Array.prototype.indexOf.call(array, obj) != -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> arrayRemove(array, value) {</div>
<div class="line">  var index = array.indexOf(value);</div>
<div class="line">  <span class="keywordflow">if</span> (index &gt;= 0) {</div>
<div class="line">    array.splice(index, 1);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> index;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> copy(source, destination, stackSource, stackDest) {</div>
<div class="line">  <span class="keywordflow">if</span> (isWindow(source) || isScope(source)) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpws&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! Making copies of Window or Scope instances is not supported.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (isTypedArray(destination)) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpta&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! TypedArray destination cannot be mutated.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!destination) {</div>
<div class="line">    destination = source;</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(source)) {</div>
<div class="line">      var index;</div>
<div class="line">      <span class="keywordflow">if</span> (stackSource &amp;&amp; (index = stackSource.indexOf(source)) !== -1) {</div>
<div class="line">        <span class="keywordflow">return</span> stackDest[index];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// TypedArray, Date and RegExp have specific copy functionality and must be</span></div>
<div class="line">      <span class="comment">// pushed onto the stack before returning.</span></div>
<div class="line">      <span class="comment">// Array and other objects create the base object and recurse to copy child</span></div>
<div class="line">      <span class="comment">// objects. The array/object will be pushed onto the stack when recursed.</span></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(source)) {</div>
<div class="line">        <span class="keywordflow">return</span> copy(source, [], stackSource, stackDest);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isTypedArray(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> source.constructor(source);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDate(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> Date(source.getTime());</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);</div>
<div class="line">        destination.lastIndex = source.lastIndex;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var emptyObject = Object.create(getPrototypeOf(source));</div>
<div class="line">        <span class="keywordflow">return</span> copy(source, emptyObject, stackSource, stackDest);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (stackDest) {</div>
<div class="line">        stackSource.push(source);</div>
<div class="line">        stackDest.push(destination);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (source === destination) <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpi&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! Source and destination are identical.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    stackSource = stackSource || [];</div>
<div class="line">    stackDest = stackDest || [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isObject(source)) {</div>
<div class="line">      stackSource.push(source);</div>
<div class="line">      stackDest.push(destination);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var result, key;</div>
<div class="line">    <span class="keywordflow">if</span> (isArray(source)) {</div>
<div class="line">      destination.length = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; source.length; i++) {</div>
<div class="line">        destination.push(copy(source[i], null, stackSource, stackDest));</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var h = destination.$$hashKey;</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(destination)) {</div>
<div class="line">        destination.length = 0;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        forEach(destination, <span class="keyword">function</span>(value, key) {</div>
<div class="line">          <span class="keyword">delete</span> destination[key];</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isBlankObject(source)) {</div>
<div class="line">        <span class="comment">// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (source &amp;&amp; typeof source.hasOwnProperty === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">        <span class="comment">// Slow path, which must rely on hasOwnProperty</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          <span class="keywordflow">if</span> (source.hasOwnProperty(key)) {</div>
<div class="line">            destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Slowest path --- hasOwnProperty can&#39;t be called as a method</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          <span class="keywordflow">if</span> (hasOwnProperty.call(source, key)) {</div>
<div class="line">            destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      setHashKey(destination,h);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> destination;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> shallowCopy(src, dst) {</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(src)) {</div>
<div class="line">    dst = dst || [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = src.length; i &lt; ii; i++) {</div>
<div class="line">      dst[i] = src[i];</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(src)) {</div>
<div class="line">    dst = dst || {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var key in src) {</div>
<div class="line">      <span class="keywordflow">if</span> (!(key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> &amp;&amp; key.charAt(1) === <span class="charliteral">&#39;$&#39;</span>)) {</div>
<div class="line">        dst[key] = src[key];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> dst || src;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> equals(o1, o2) {</div>
<div class="line">  <span class="keywordflow">if</span> (o1 === o2) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (o1 === null || o2 === null) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (o1 !== o1 &amp;&amp; o2 !== o2) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// NaN === NaN</span></div>
<div class="line">  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;</div>
<div class="line">  <span class="keywordflow">if</span> (t1 == t2) {</div>
<div class="line">    <span class="keywordflow">if</span> (t1 == <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(o1)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!isArray(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> ((length = o1.length) == o2.length) {</div>
<div class="line">          <span class="keywordflow">for</span> (key = 0; key &lt; length; key++) {</div>
<div class="line">            <span class="keywordflow">if</span> (!equals(o1[key], o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDate(o1)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!isDate(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">return</span> equals(o1.getTime(), o2.getTime());</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(o1)) {</div>
<div class="line">        <span class="keywordflow">return</span> isRegExp(o2) ? o1.toString() == o2.toString() : <span class="keyword">false</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||</div>
<div class="line">          isArray(o2) || isDate(o2) || isRegExp(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        keySet = createMap();</div>
<div class="line">        <span class="keywordflow">for</span> (key in o1) {</div>
<div class="line">          <span class="keywordflow">if</span> (key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> || isFunction(o1[key])) <span class="keywordflow">continue</span>;</div>
<div class="line">          <span class="keywordflow">if</span> (!equals(o1[key], o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          keySet[key] = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (key in o2) {</div>
<div class="line">          <span class="keywordflow">if</span> (!(key in keySet) &amp;&amp;</div>
<div class="line">              key.charAt(0) !== <span class="charliteral">&#39;$&#39;</span> &amp;&amp;</div>
<div class="line">              o2[key] !== undefined &amp;&amp;</div>
<div class="line">              !isFunction(o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var csp = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">if</span> (!isDefined(csp.rules)) {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    var ngCspElement = (document.querySelector(<span class="stringliteral">&#39;[ng-csp]&#39;</span>) ||</div>
<div class="line">                    document.querySelector(<span class="stringliteral">&#39;[data-ng-csp]&#39;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (ngCspElement) {</div>
<div class="line">      var ngCspAttribute = ngCspElement.getAttribute(<span class="stringliteral">&#39;ng-csp&#39;</span>) ||</div>
<div class="line">                    ngCspElement.getAttribute(<span class="stringliteral">&#39;data-ng-csp&#39;</span>);</div>
<div class="line">      csp.rules = {</div>
<div class="line">        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf(<span class="stringliteral">&#39;no-unsafe-eval&#39;</span>) !== -1),</div>
<div class="line">        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf(<span class="stringliteral">&#39;no-inline-style&#39;</span>) !== -1)</div>
<div class="line">      };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      csp.rules = {</div>
<div class="line">        noUnsafeEval: noUnsafeEval(),</div>
<div class="line">        noInlineStyle: <span class="keyword">false</span></div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> csp.rules;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> noUnsafeEval() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">/* jshint -W031, -W054 */</span></div>
<div class="line">      <span class="keyword">new</span> Function(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      <span class="comment">/* jshint +W031, +W054 */</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var jq = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(jq.name_)) <span class="keywordflow">return</span> jq.name_;</div>
<div class="line">  var el;</div>
<div class="line">  var i, ii = ngAttrPrefixes.length, prefix, name;</div>
<div class="line">  for (i = 0; i &lt; ii; ++i) {</div>
<div class="line">    prefix = ngAttrPrefixes[i];</div>
<div class="line">    <span class="keywordflow">if</span> (el = document.querySelector(<span class="charliteral">&#39;[&#39;</span> + prefix.replace(<span class="charliteral">&#39;:&#39;</span>, <span class="stringliteral">&#39;\\:&#39;</span>) + <span class="stringliteral">&#39;jq]&#39;</span>)) {</div>
<div class="line">      name = el.getAttribute(prefix + <span class="stringliteral">&#39;jq&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> (jq.name_ = name);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> concat(array1, array2, index) {</div>
<div class="line">  <span class="keywordflow">return</span> array1.concat(slice.call(array2, index));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> sliceArgs(args, startIndex) {</div>
<div class="line">  <span class="keywordflow">return</span> slice.call(args, startIndex || 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint -W101 */</span></div>
<div class="line"><span class="comment">/* jshint +W101 */</span></div>
<div class="line"><span class="keyword">function</span> bind(<span class="keyword">self</span>, fn) {</div>
<div class="line">  var curryArgs = arguments.length &gt; 2 ? sliceArgs(arguments, 2) : [];</div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {</div>
<div class="line">    <span class="keywordflow">return</span> curryArgs.length</div>
<div class="line">      ? <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> arguments.length</div>
<div class="line">            ? fn.apply(<span class="keyword">self</span>, concat(curryArgs, arguments, 0))</div>
<div class="line">            : fn.apply(<span class="keyword">self</span>, curryArgs);</div>
<div class="line">        }</div>
<div class="line">      : <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> arguments.length</div>
<div class="line">            ? fn.apply(<span class="keyword">self</span>, arguments)</div>
<div class="line">            : fn.call(<span class="keyword">self</span>);</div>
<div class="line">        };</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// in IE, native methods are not functions so they cannot be bound (note: they don&#39;t need to be)</span></div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toJsonReplacer(key, value) {</div>
<div class="line">  var val = value;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (typeof key === <span class="stringliteral">&#39;string&#39;</span> &amp;&amp; key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> &amp;&amp; key.charAt(1) === <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">    val = undefined;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isWindow(value)) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$WINDOW&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &amp;&amp;  document === value) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$DOCUMENT&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isScope(value)) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$SCOPE&#39;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> val;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toJson(obj, pretty) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> undefined;</div>
<div class="line">  <span class="keywordflow">if</span> (!isNumber(pretty)) {</div>
<div class="line">    pretty = pretty ? 2 : null;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> JSON.stringify(obj, toJsonReplacer, pretty);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> fromJson(json) {</div>
<div class="line">  <span class="keywordflow">return</span> isString(json)</div>
<div class="line">      ? JSON.parse(json)</div>
<div class="line">      : json;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> timezoneToOffset(timezone, fallback) {</div>
<div class="line">  var requestedTimezoneOffset = Date.parse(<span class="stringliteral">&#39;Jan 01, 1970 00:00:00 &#39;</span> + timezone) / 60000;</div>
<div class="line">  <span class="keywordflow">return</span> isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> addDateMinutes(date, minutes) {</div>
<div class="line">  date = <span class="keyword">new</span> Date(date.getTime());</div>
<div class="line">  date.setMinutes(date.getMinutes() + minutes);</div>
<div class="line">  <span class="keywordflow">return</span> date;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> convertTimezoneToLocal(date, timezone, reverse) {</div>
<div class="line">  reverse = reverse ? -1 : 1;</div>
<div class="line">  var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());</div>
<div class="line">  <span class="keywordflow">return</span> addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> startingTag(element) {</div>
<div class="line">  element = jqLite(element).clone();</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// turns out IE does not let you set .html() on elements which</span></div>
<div class="line">    <span class="comment">// are not allowed to have children. So we just ignore it.</span></div>
<div class="line">    element.empty();</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {}</div>
<div class="line">  var elemHtml = jqLite(<span class="stringliteral">&#39;&lt;div&gt;&#39;</span>).append(element).html();</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">return</span> element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :</div>
<div class="line">        elemHtml.</div>
<div class="line">          match(/^(&lt;[^&gt;]+&gt;)/)[1].</div>
<div class="line">          replace(/^&lt;([\w\-]+)/, <span class="keyword">function</span>(match, nodeName) { <span class="keywordflow">return</span> <span class="charliteral">&#39;&lt;&#39;</span> + lowercase(nodeName); });</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">    <span class="keywordflow">return</span> lowercase(elemHtml);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> tryDecodeURIComponent(value) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">return</span> decodeURIComponent(value);</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">    <span class="comment">// Ignore any invalid uri component</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> parseKeyValue(keyValue) {</div>
<div class="line">  var obj = {};</div>
<div class="line">  forEach((keyValue || <span class="stringliteral">&quot;&quot;</span>).split(<span class="charliteral">&#39;&amp;&#39;</span>), <span class="keyword">function</span>(keyValue) {</div>
<div class="line">    var splitPoint, key, val;</div>
<div class="line">    <span class="keywordflow">if</span> (keyValue) {</div>
<div class="line">      key = keyValue = keyValue.replace(/\+/g,<span class="stringliteral">&#39;%20&#39;</span>);</div>
<div class="line">      splitPoint = keyValue.indexOf(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (splitPoint !== -1) {</div>
<div class="line">        key = keyValue.substring(0, splitPoint);</div>
<div class="line">        val = keyValue.substring(splitPoint + 1);</div>
<div class="line">      }</div>
<div class="line">      key = tryDecodeURIComponent(key);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(key)) {</div>
<div class="line">        val = isDefined(val) ? tryDecodeURIComponent(val) : <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (!hasOwnProperty.call(obj, key)) {</div>
<div class="line">          obj[key] = val;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(obj[key])) {</div>
<div class="line">          obj[key].push(val);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          obj[key] = [obj[key],val];</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toKeyValue(obj) {</div>
<div class="line">  var parts = [];</div>
<div class="line">  forEach(obj, <span class="keyword">function</span>(value, key) {</div>
<div class="line">    <span class="keywordflow">if</span> (isArray(value)) {</div>
<div class="line">      forEach(value, <span class="keyword">function</span>(arrayValue) {</div>
<div class="line">        parts.push(encodeUriQuery(key, <span class="keyword">true</span>) +</div>
<div class="line">                   (arrayValue === <span class="keyword">true</span> ? <span class="stringliteral">&#39;&#39;</span> : <span class="charliteral">&#39;=&#39;</span> + encodeUriQuery(arrayValue, <span class="keyword">true</span>)));</div>
<div class="line">      });</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">    parts.push(encodeUriQuery(key, <span class="keyword">true</span>) +</div>
<div class="line">               (value === <span class="keyword">true</span> ? <span class="stringliteral">&#39;&#39;</span> : <span class="charliteral">&#39;=&#39;</span> + encodeUriQuery(value, <span class="keyword">true</span>)));</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> parts.length ? parts.join(<span class="charliteral">&#39;&amp;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> encodeUriSegment(val) {</div>
<div class="line">  <span class="keywordflow">return</span> encodeUriQuery(val, <span class="keyword">true</span>).</div>
<div class="line">             replace(/%26/gi, <span class="charliteral">&#39;&amp;&#39;</span>).</div>
<div class="line">             replace(/%3D/gi, <span class="charliteral">&#39;=&#39;</span>).</div>
<div class="line">             replace(/%2B/gi, <span class="charliteral">&#39;+&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> encodeUriQuery(val, pctEncodeSpaces) {</div>
<div class="line">  <span class="keywordflow">return</span> encodeURIComponent(val).</div>
<div class="line">             replace(/%40/gi, <span class="charliteral">&#39;@&#39;</span>).</div>
<div class="line">             replace(/%3A/gi, <span class="charliteral">&#39;:&#39;</span>).</div>
<div class="line">             replace(/%24/g, <span class="charliteral">&#39;$&#39;</span>).</div>
<div class="line">             replace(/%2C/gi, <span class="charliteral">&#39;,&#39;</span>).</div>
<div class="line">             replace(/%3B/gi, <span class="charliteral">&#39;;&#39;</span>).</div>
<div class="line">             replace(/%20/g, (pctEncodeSpaces ? <span class="stringliteral">&#39;%20&#39;</span> : <span class="charliteral">&#39;+&#39;</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngAttrPrefixes = [<span class="stringliteral">&#39;ng-&#39;</span>, <span class="stringliteral">&#39;data-ng-&#39;</span>, <span class="stringliteral">&#39;ng:&#39;</span>, <span class="stringliteral">&#39;x-ng-&#39;</span>];</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getNgAttribute(element, ngAttr) {</div>
<div class="line">  var attr, i, ii = ngAttrPrefixes.length;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; ii; ++i) {</div>
<div class="line">    attr = ngAttrPrefixes[i] + ngAttr;</div>
<div class="line">    <span class="keywordflow">if</span> (isString(attr = element.getAttribute(attr))) {</div>
<div class="line">      <span class="keywordflow">return</span> attr;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> null;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> angularInit(element, bootstrap) {</div>
<div class="line">  var appElement,</div>
<div class="line">      module,</div>
<div class="line">      config = {};</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The element `element` has priority over any other element</span></div>
<div class="line">  forEach(ngAttrPrefixes, <span class="keyword">function</span>(prefix) {</div>
<div class="line">    var name = prefix + <span class="stringliteral">&#39;app&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name)) {</div>
<div class="line">      appElement = element;</div>
<div class="line">      module = element.getAttribute(name);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  forEach(ngAttrPrefixes, <span class="keyword">function</span>(prefix) {</div>
<div class="line">    var name = prefix + <span class="stringliteral">&#39;app&#39;</span>;</div>
<div class="line">    var candidate;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!appElement &amp;&amp; (candidate = element.querySelector(<span class="charliteral">&#39;[&#39;</span> + name.replace(<span class="charliteral">&#39;:&#39;</span>, <span class="stringliteral">&#39;\\:&#39;</span>) + <span class="charliteral">&#39;]&#39;</span>))) {</div>
<div class="line">      appElement = candidate;</div>
<div class="line">      module = candidate.getAttribute(name);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">if</span> (appElement) {</div>
<div class="line">    config.strictDi = getNgAttribute(appElement, <span class="stringliteral">&quot;strict-di&quot;</span>) !== null;</div>
<div class="line">    bootstrap(appElement, module ? [module] : [], config);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> bootstrap(element, modules, config) {</div>
<div class="line">  <span class="keywordflow">if</span> (!isObject(config)) config = {};</div>
<div class="line">  var defaultConfig = {</div>
<div class="line">    strictDi: <span class="keyword">false</span></div>
<div class="line">  };</div>
<div class="line">  config = extend(defaultConfig, config);</div>
<div class="line">  var doBootstrap = <span class="keyword">function</span>() {</div>
<div class="line">    element = jqLite(element);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (element.injector()) {</div>
<div class="line">      var tag = (element[0] === document) ? <span class="stringliteral">&#39;document&#39;</span> : startingTag(element);</div>
<div class="line">      <span class="comment">//Encode angle brackets to prevent input from being sanitized to empty string #8683</span></div>
<div class="line">      <span class="keywordflow">throw</span> ngMinErr(</div>
<div class="line">          <span class="stringliteral">&#39;btstrpd&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;App Already Bootstrapped with this Element &#39;{0}&#39;&quot;</span>,</div>
<div class="line">          tag.replace(/&lt;/,<span class="stringliteral">&#39;&amp;lt;&#39;</span>).replace(/&gt;/,<span class="stringliteral">&#39;&amp;gt;&#39;</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    modules = modules || [];</div>
<div class="line">    modules.unshift([<span class="stringliteral">&#39;$provide&#39;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">      $provide.value(<span class="stringliteral">&#39;$rootElement&#39;</span>, element);</div>
<div class="line">    }]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (config.debugInfoEnabled) {</div>
<div class="line">      <span class="comment">// Pushing so that this overrides `debugInfoEnabled` setting defined in user&#39;s `modules`.</span></div>
<div class="line">      modules.push([<span class="stringliteral">&#39;$compileProvider&#39;</span>, <span class="keyword">function</span>($compileProvider) {</div>
<div class="line">        $compileProvider.debugInfoEnabled(<span class="keyword">true</span>);</div>
<div class="line">      }]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    modules.unshift(<span class="stringliteral">&#39;ng&#39;</span>);</div>
<div class="line">    var injector = createInjector(modules, config.strictDi);</div>
<div class="line">    injector.invoke([<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$rootElement&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="stringliteral">&#39;$injector&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span> bootstrapApply(scope, element, compile, injector) {</div>
<div class="line">        scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">          element.data(<span class="stringliteral">&#39;$injector&#39;</span>, injector);</div>
<div class="line">          compile(element)(scope);</div>
<div class="line">        });</div>
<div class="line">      }]</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> injector;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;</div>
<div class="line">  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (window &amp;&amp; NG_ENABLE_DEBUG_INFO.test(window.name)) {</div>
<div class="line">    config.debugInfoEnabled = <span class="keyword">true</span>;</div>
<div class="line">    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {</div>
<div class="line">    <span class="keywordflow">return</span> doBootstrap();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  angular.resumeBootstrap = <span class="keyword">function</span>(extraModules) {</div>
<div class="line">    forEach(extraModules, <span class="keyword">function</span>(module) {</div>
<div class="line">      modules.push(module);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> doBootstrap();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(angular.resumeDeferredBootstrap)) {</div>
<div class="line">    angular.resumeDeferredBootstrap();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> reloadWithDebugInfo() {</div>
<div class="line">  window.name = <span class="stringliteral">&#39;NG_ENABLE_DEBUG_INFO!&#39;</span> + window.name;</div>
<div class="line">  window.location.reload();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getTestability(rootElement) {</div>
<div class="line">  var injector = angular.element(rootElement).injector();</div>
<div class="line">  <span class="keywordflow">if</span> (!injector) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;test&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&#39;no injector found for element argument to getTestability&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> injector.get(<span class="stringliteral">&#39;$$testability&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var SNAKE_CASE_REGEXP = /[A-Z]/g;</div>
<div class="line"><span class="keyword">function</span> snake_case(name, separator) {</div>
<div class="line">  separator = separator || <span class="charliteral">&#39;_&#39;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> name.replace(SNAKE_CASE_REGEXP, <span class="keyword">function</span>(letter, pos) {</div>
<div class="line">    <span class="keywordflow">return</span> (pos ? separator : <span class="stringliteral">&#39;&#39;</span>) + letter.toLowerCase();</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var bindJQueryFired = <span class="keyword">false</span>;</div>
<div class="line">var skipDestroyOnNextJQueryCleanData;</div>
<div class="line"><span class="keyword">function</span> bindJQuery() {</div>
<div class="line">  var originalCleanData;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (bindJQueryFired) {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// bind to jQuery if present;</span></div>
<div class="line">  var jqName = jq();</div>
<div class="line">  jQuery = window.jQuery; <span class="comment">// use default jQuery.</span></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(jqName)) { <span class="comment">// `ngJq` present</span></div>
<div class="line">    jQuery = jqName === null ? undefined : window[jqName]; <span class="comment">// if empty; use jqLite. if not empty, use jQuery specified by `ngJq`.</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Use jQuery if it exists with proper functionality, otherwise default to us.</span></div>
<div class="line">  <span class="comment">// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.</span></div>
<div class="line">  <span class="comment">// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older</span></div>
<div class="line">  <span class="comment">// versions. It will not work for sure with jQuery &lt;1.7, though.</span></div>
<div class="line">  <span class="keywordflow">if</span> (jQuery &amp;&amp; jQuery.fn.on) {</div>
<div class="line">    jqLite = jQuery;</div>
<div class="line">    extend(jQuery.fn, {</div>
<div class="line">      scope: JQLitePrototype.scope,</div>
<div class="line">      isolateScope: JQLitePrototype.isolateScope,</div>
<div class="line">      controller: JQLitePrototype.controller,</div>
<div class="line">      injector: JQLitePrototype.injector,</div>
<div class="line">      inheritedData: JQLitePrototype.inheritedData</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// All nodes removed from the DOM via various jQuery APIs like .remove()</span></div>
<div class="line">    <span class="comment">// are passed through jQuery.cleanData. Monkey-patch this method to fire</span></div>
<div class="line">    <span class="comment">// the $destroy event on all removed nodes.</span></div>
<div class="line">    originalCleanData = jQuery.cleanData;</div>
<div class="line">    jQuery.cleanData = <span class="keyword">function</span>(elems) {</div>
<div class="line">      var events;</div>
<div class="line">      <span class="keywordflow">if</span> (!skipDestroyOnNextJQueryCleanData) {</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, elem; (elem = elems[i]) != null; i++) {</div>
<div class="line">          events = jQuery._data(elem, <span class="stringliteral">&quot;events&quot;</span>);</div>
<div class="line">          <span class="keywordflow">if</span> (events &amp;&amp; events.$destroy) {</div>
<div class="line">            jQuery(elem).triggerHandler(<span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        skipDestroyOnNextJQueryCleanData = <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      originalCleanData(elems);</div>
<div class="line">    };</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    jqLite = JQLite;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  angular.element = jqLite;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Prevent double-proxying.</span></div>
<div class="line">  bindJQueryFired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertArg(arg, name, reason) {</div>
<div class="line">  <span class="keywordflow">if</span> (!arg) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;areq&#39;</span>, <span class="stringliteral">&quot;Argument &#39;{0}&#39; is {1}&quot;</span>, (name || <span class="charliteral">&#39;?&#39;</span>), (reason || <span class="stringliteral">&quot;required&quot;</span>));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> arg;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertArgFn(arg, name, acceptArrayAnnotation) {</div>
<div class="line">  <span class="keywordflow">if</span> (acceptArrayAnnotation &amp;&amp; isArray(arg)) {</div>
<div class="line">      arg = arg[arg.length - 1];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  assertArg(isFunction(arg), name, <span class="stringliteral">&#39;not a function, got &#39;</span> +</div>
<div class="line">      (arg &amp;&amp; typeof arg === <span class="stringliteral">&#39;object&#39;</span> ? arg.constructor.name || <span class="stringliteral">&#39;Object&#39;</span> : typeof arg));</div>
<div class="line">  <span class="keywordflow">return</span> arg;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertNotHasOwnProperty(name, context) {</div>
<div class="line">  <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;hasOwnProperty&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;badname&#39;</span>, <span class="stringliteral">&quot;hasOwnProperty is not a valid {0} name&quot;</span>, context);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//TODO(misko): this function needs to be removed</span></div>
<div class="line"><span class="keyword">function</span> getter(obj, path, bindFnToScope) {</div>
<div class="line">  <span class="keywordflow">if</span> (!path) <span class="keywordflow">return</span> obj;</div>
<div class="line">  var keys = path.split(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">  var key;</div>
<div class="line">  var lastInstance = obj;</div>
<div class="line">  var len = keys.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; len; i++) {</div>
<div class="line">    key = keys[i];</div>
<div class="line">    <span class="keywordflow">if</span> (obj) {</div>
<div class="line">      obj = (lastInstance = obj)[key];</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!bindFnToScope &amp;&amp; isFunction(obj)) {</div>
<div class="line">    <span class="keywordflow">return</span> bind(lastInstance, obj);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getBlockNodes(nodes) {</div>
<div class="line">  <span class="comment">// TODO(perf): just check if all items in `nodes` are siblings and if they are return the original</span></div>
<div class="line">  <span class="comment">//             collection, otherwise update the original collection.</span></div>
<div class="line">  var node = nodes[0];</div>
<div class="line">  var endNode = nodes[nodes.length - 1];</div>
<div class="line">  var blockNodes = [node];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    node = node.nextSibling;</div>
<div class="line">    <span class="keywordflow">if</span> (!node) <span class="keywordflow">break</span>;</div>
<div class="line">    blockNodes.push(node);</div>
<div class="line">  } <span class="keywordflow">while</span> (node !== endNode);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> jqLite(blockNodes);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createMap() {</div>
<div class="line">  <span class="keywordflow">return</span> Object.create(null);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var NODE_TYPE_ELEMENT = 1;</div>
<div class="line">var NODE_TYPE_ATTRIBUTE = 2;</div>
<div class="line">var NODE_TYPE_TEXT = 3;</div>
<div class="line">var NODE_TYPE_COMMENT = 8;</div>
<div class="line">var NODE_TYPE_DOCUMENT = 9;</div>
<div class="line">var NODE_TYPE_DOCUMENT_FRAGMENT = 11;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setupModuleLoader(window) {</div>
<div class="line"></div>
<div class="line">  var $injectorMinErr = minErr(<span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line">  var ngMinErr = minErr(<span class="stringliteral">&#39;ng&#39;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> ensure(obj, name, factory) {</div>
<div class="line">    <span class="keywordflow">return</span> obj[name] || (obj[name] = factory());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var angular = ensure(window, <span class="stringliteral">&#39;angular&#39;</span>, Object);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap</span></div>
<div class="line">  angular.$$minErr = angular.$$minErr || minErr;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> ensure(angular, <span class="stringliteral">&#39;module&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    var modules = {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> module(name, requires, configFn) {</div>
<div class="line">      var assertNotHasOwnProperty = <span class="keyword">function</span>(name, context) {</div>
<div class="line">        <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;hasOwnProperty&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;badname&#39;</span>, <span class="stringliteral">&#39;hasOwnProperty is not a valid {0} name&#39;</span>, context);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      assertNotHasOwnProperty(name, <span class="stringliteral">&#39;module&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (requires &amp;&amp; modules.hasOwnProperty(name)) {</div>
<div class="line">        modules[name] = null;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> ensure(modules, name, <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!requires) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;nomod&#39;</span>, <span class="stringliteral">&quot;Module &#39;{0}&#39; is not available! You either misspelled &quot;</span> +</div>
<div class="line">             <span class="stringliteral">&quot;the module name or forgot to load it. If registering a module ensure that you &quot;</span> +</div>
<div class="line">             <span class="stringliteral">&quot;specify the dependencies as the second argument.&quot;</span>, name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var invokeQueue = [];</div>
<div class="line"></div>
<div class="line">        var configBlocks = [];</div>
<div class="line"></div>
<div class="line">        var runBlocks = [];</div>
<div class="line"></div>
<div class="line">        var config = invokeLater(<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;invoke&#39;</span>, <span class="stringliteral">&#39;push&#39;</span>, configBlocks);</div>
<div class="line"></div>
<div class="line">        var moduleInstance = {</div>
<div class="line">          <span class="comment">// Private state</span></div>
<div class="line">          _invokeQueue: invokeQueue,</div>
<div class="line">          _configBlocks: configBlocks,</div>
<div class="line">          _runBlocks: runBlocks,</div>
<div class="line"></div>
<div class="line">          requires: requires,</div>
<div class="line"></div>
<div class="line">          name: name,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">          provider: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;provider&#39;</span>),</div>
<div class="line"></div>
<div class="line">          factory: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;factory&#39;</span>),</div>
<div class="line"></div>
<div class="line">          service: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;service&#39;</span>),</div>
<div class="line"></div>
<div class="line">          value: invokeLater(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;value&#39;</span>),</div>
<div class="line"></div>
<div class="line">          constant: invokeLater(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;constant&#39;</span>, <span class="stringliteral">&#39;unshift&#39;</span>),</div>
<div class="line"></div>
<div class="line">          decorator: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;decorator&#39;</span>),</div>
<div class="line"></div>
<div class="line">          animation: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$animateProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          filter: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$filterProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          controller: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$controllerProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          directive: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$compileProvider&#39;</span>, <span class="stringliteral">&#39;directive&#39;</span>),</div>
<div class="line"></div>
<div class="line">          config: config,</div>
<div class="line"></div>
<div class="line">          run: <span class="keyword">function</span>(block) {</div>
<div class="line">            runBlocks.push(block);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (configFn) {</div>
<div class="line">          config(configFn);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> invokeLater(provider, method, insertMethod, queue) {</div>
<div class="line">          <span class="keywordflow">if</span> (!queue) queue = invokeQueue;</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            queue[insertMethod || <span class="stringliteral">&#39;push&#39;</span>]([provider, method, arguments]);</div>
<div class="line">            <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> invokeLaterAndSetModuleName(provider, method) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>(recipeName, factoryFunction) {</div>
<div class="line">            <span class="keywordflow">if</span> (factoryFunction &amp;&amp; isFunction(factoryFunction)) factoryFunction.$$moduleName = name;</div>
<div class="line">            invokeQueue.push([provider, method, arguments]);</div>
<div class="line">            <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global: toDebugString: true */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> serializeObject(obj) {</div>
<div class="line">  var seen = [];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> JSON.stringify(obj, <span class="keyword">function</span>(key, val) {</div>
<div class="line">    val = toJsonReplacer(key, val);</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(val)) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (seen.indexOf(val) &gt;= 0) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&lt;&lt;already seen&gt;&gt;&#39;</span>;</div>
<div class="line"></div>
<div class="line">      seen.push(val);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toDebugString(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> obj.toString().replace(/ \{[\s\S]*$/, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;undefined&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;undefined&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> serializeObject(obj);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global angularModule: true,</span></div>
<div class="line"><span class="comment">  version: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  $CompileProvider,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  htmlAnchorDirective,</span></div>
<div class="line"><span class="comment">  inputDirective,</span></div>
<div class="line"><span class="comment">  inputDirective,</span></div>
<div class="line"><span class="comment">  formDirective,</span></div>
<div class="line"><span class="comment">  scriptDirective,</span></div>
<div class="line"><span class="comment">  selectDirective,</span></div>
<div class="line"><span class="comment">  styleDirective,</span></div>
<div class="line"><span class="comment">  optionDirective,</span></div>
<div class="line"><span class="comment">  ngBindDirective,</span></div>
<div class="line"><span class="comment">  ngBindHtmlDirective,</span></div>
<div class="line"><span class="comment">  ngBindTemplateDirective,</span></div>
<div class="line"><span class="comment">  ngClassDirective,</span></div>
<div class="line"><span class="comment">  ngClassEvenDirective,</span></div>
<div class="line"><span class="comment">  ngClassOddDirective,</span></div>
<div class="line"><span class="comment">  ngCloakDirective,</span></div>
<div class="line"><span class="comment">  ngControllerDirective,</span></div>
<div class="line"><span class="comment">  ngFormDirective,</span></div>
<div class="line"><span class="comment">  ngHideDirective,</span></div>
<div class="line"><span class="comment">  ngIfDirective,</span></div>
<div class="line"><span class="comment">  ngIncludeDirective,</span></div>
<div class="line"><span class="comment">  ngIncludeFillContentDirective,</span></div>
<div class="line"><span class="comment">  ngInitDirective,</span></div>
<div class="line"><span class="comment">  ngNonBindableDirective,</span></div>
<div class="line"><span class="comment">  ngPluralizeDirective,</span></div>
<div class="line"><span class="comment">  ngRepeatDirective,</span></div>
<div class="line"><span class="comment">  ngShowDirective,</span></div>
<div class="line"><span class="comment">  ngStyleDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchWhenDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchDefaultDirective,</span></div>
<div class="line"><span class="comment">  ngOptionsDirective,</span></div>
<div class="line"><span class="comment">  ngTranscludeDirective,</span></div>
<div class="line"><span class="comment">  ngModelDirective,</span></div>
<div class="line"><span class="comment">  ngListDirective,</span></div>
<div class="line"><span class="comment">  ngChangeDirective,</span></div>
<div class="line"><span class="comment">  patternDirective,</span></div>
<div class="line"><span class="comment">  patternDirective,</span></div>
<div class="line"><span class="comment">  requiredDirective,</span></div>
<div class="line"><span class="comment">  requiredDirective,</span></div>
<div class="line"><span class="comment">  minlengthDirective,</span></div>
<div class="line"><span class="comment">  minlengthDirective,</span></div>
<div class="line"><span class="comment">  maxlengthDirective,</span></div>
<div class="line"><span class="comment">  maxlengthDirective,</span></div>
<div class="line"><span class="comment">  ngValueDirective,</span></div>
<div class="line"><span class="comment">  ngModelOptionsDirective,</span></div>
<div class="line"><span class="comment">  ngAttributeAliasDirectives,</span></div>
<div class="line"><span class="comment">  ngEventDirectives,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  $AnchorScrollProvider,</span></div>
<div class="line"><span class="comment">  $AnimateProvider,</span></div>
<div class="line"><span class="comment">  $CoreAnimateCssProvider,</span></div>
<div class="line"><span class="comment">  $$CoreAnimateQueueProvider,</span></div>
<div class="line"><span class="comment">  $$CoreAnimateRunnerProvider,</span></div>
<div class="line"><span class="comment">  $BrowserProvider,</span></div>
<div class="line"><span class="comment">  $CacheFactoryProvider,</span></div>
<div class="line"><span class="comment">  $ControllerProvider,</span></div>
<div class="line"><span class="comment">  $DocumentProvider,</span></div>
<div class="line"><span class="comment">  $ExceptionHandlerProvider,</span></div>
<div class="line"><span class="comment">  $FilterProvider,</span></div>
<div class="line"><span class="comment">  $$ForceReflowProvider,</span></div>
<div class="line"><span class="comment">  $InterpolateProvider,</span></div>
<div class="line"><span class="comment">  $IntervalProvider,</span></div>
<div class="line"><span class="comment">  $$HashMapProvider,</span></div>
<div class="line"><span class="comment">  $HttpProvider,</span></div>
<div class="line"><span class="comment">  $HttpParamSerializerProvider,</span></div>
<div class="line"><span class="comment">  $HttpParamSerializerJQLikeProvider,</span></div>
<div class="line"><span class="comment">  $HttpBackendProvider,</span></div>
<div class="line"><span class="comment">  $LocationProvider,</span></div>
<div class="line"><span class="comment">  $LogProvider,</span></div>
<div class="line"><span class="comment">  $ParseProvider,</span></div>
<div class="line"><span class="comment">  $RootScopeProvider,</span></div>
<div class="line"><span class="comment">  $QProvider,</span></div>
<div class="line"><span class="comment">  $$QProvider,</span></div>
<div class="line"><span class="comment">  $$SanitizeUriProvider,</span></div>
<div class="line"><span class="comment">  $SceProvider,</span></div>
<div class="line"><span class="comment">  $SceDelegateProvider,</span></div>
<div class="line"><span class="comment">  $SnifferProvider,</span></div>
<div class="line"><span class="comment">  $TemplateCacheProvider,</span></div>
<div class="line"><span class="comment">  $TemplateRequestProvider,</span></div>
<div class="line"><span class="comment">  $$TestabilityProvider,</span></div>
<div class="line"><span class="comment">  $TimeoutProvider,</span></div>
<div class="line"><span class="comment">  $$RAFProvider,</span></div>
<div class="line"><span class="comment">  $WindowProvider,</span></div>
<div class="line"><span class="comment">  $$jqLiteProvider,</span></div>
<div class="line"><span class="comment">  $$CookieReaderProvider</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var version = {</div>
<div class="line">  full: <span class="stringliteral">&#39;1.4.4&#39;</span>,    <span class="comment">// all of these placeholder strings will be replaced by grunt&#39;s</span></div>
<div class="line">  major: 1,    <span class="comment">// package task</span></div>
<div class="line">  minor: 4,</div>
<div class="line">  dot: 4,</div>
<div class="line">  codeName: <span class="stringliteral">&#39;pylon-requirement&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> publishExternalAPI(angular) {</div>
<div class="line">  extend(angular, {</div>
<div class="line">    <span class="stringliteral">&#39;bootstrap&#39;</span>: bootstrap,</div>
<div class="line">    <span class="stringliteral">&#39;copy&#39;</span>: copy,</div>
<div class="line">    <span class="stringliteral">&#39;extend&#39;</span>: extend,</div>
<div class="line">    <span class="stringliteral">&#39;merge&#39;</span>: merge,</div>
<div class="line">    <span class="stringliteral">&#39;equals&#39;</span>: equals,</div>
<div class="line">    <span class="stringliteral">&#39;element&#39;</span>: jqLite,</div>
<div class="line">    <span class="stringliteral">&#39;forEach&#39;</span>: forEach,</div>
<div class="line">    <span class="stringliteral">&#39;injector&#39;</span>: createInjector,</div>
<div class="line">    <span class="stringliteral">&#39;noop&#39;</span>: noop,</div>
<div class="line">    <span class="stringliteral">&#39;bind&#39;</span>: bind,</div>
<div class="line">    <span class="stringliteral">&#39;toJson&#39;</span>: toJson,</div>
<div class="line">    <span class="stringliteral">&#39;fromJson&#39;</span>: fromJson,</div>
<div class="line">    <span class="stringliteral">&#39;identity&#39;</span>: identity,</div>
<div class="line">    <span class="stringliteral">&#39;isUndefined&#39;</span>: isUndefined,</div>
<div class="line">    <span class="stringliteral">&#39;isDefined&#39;</span>: isDefined,</div>
<div class="line">    <span class="stringliteral">&#39;isString&#39;</span>: isString,</div>
<div class="line">    <span class="stringliteral">&#39;isFunction&#39;</span>: isFunction,</div>
<div class="line">    <span class="stringliteral">&#39;isObject&#39;</span>: isObject,</div>
<div class="line">    <span class="stringliteral">&#39;isNumber&#39;</span>: isNumber,</div>
<div class="line">    <span class="stringliteral">&#39;isElement&#39;</span>: isElement,</div>
<div class="line">    <span class="stringliteral">&#39;isArray&#39;</span>: isArray,</div>
<div class="line">    <span class="stringliteral">&#39;version&#39;</span>: version,</div>
<div class="line">    <span class="stringliteral">&#39;isDate&#39;</span>: isDate,</div>
<div class="line">    <span class="stringliteral">&#39;lowercase&#39;</span>: lowercase,</div>
<div class="line">    <span class="stringliteral">&#39;uppercase&#39;</span>: uppercase,</div>
<div class="line">    <span class="stringliteral">&#39;callbacks&#39;</span>: {counter: 0},</div>
<div class="line">    <span class="stringliteral">&#39;getTestability&#39;</span>: getTestability,</div>
<div class="line">    <span class="stringliteral">&#39;$$minErr&#39;</span>: minErr,</div>
<div class="line">    <span class="stringliteral">&#39;$$csp&#39;</span>: csp,</div>
<div class="line">    <span class="stringliteral">&#39;reloadWithDebugInfo&#39;</span>: reloadWithDebugInfo</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  angularModule = setupModuleLoader(window);</div>
<div class="line"></div>
<div class="line">  angularModule(<span class="stringliteral">&#39;ng&#39;</span>, [<span class="stringliteral">&#39;ngLocale&#39;</span>], [<span class="stringliteral">&#39;$provide&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span> ngModule($provide) {</div>
<div class="line">      <span class="comment">// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.</span></div>
<div class="line">      $provide.provider({</div>
<div class="line">        $$sanitizeUri: $$SanitizeUriProvider</div>
<div class="line">      });</div>
<div class="line">      $provide.provider(<span class="stringliteral">&#39;$compile&#39;</span>, $CompileProvider).</div>
<div class="line">        directive({</div>
<div class="line">            a: htmlAnchorDirective,</div>
<div class="line">            input: inputDirective,</div>
<div class="line">            textarea: inputDirective,</div>
<div class="line">            form: formDirective,</div>
<div class="line">            script: scriptDirective,</div>
<div class="line">            select: selectDirective,</div>
<div class="line">            style: styleDirective,</div>
<div class="line">            option: optionDirective,</div>
<div class="line">            ngBind: ngBindDirective,</div>
<div class="line">            ngBindHtml: ngBindHtmlDirective,</div>
<div class="line">            ngBindTemplate: ngBindTemplateDirective,</div>
<div class="line">            ngClass: ngClassDirective,</div>
<div class="line">            ngClassEven: ngClassEvenDirective,</div>
<div class="line">            ngClassOdd: ngClassOddDirective,</div>
<div class="line">            ngCloak: ngCloakDirective,</div>
<div class="line">            ngController: ngControllerDirective,</div>
<div class="line">            ngForm: ngFormDirective,</div>
<div class="line">            ngHide: ngHideDirective,</div>
<div class="line">            ngIf: ngIfDirective,</div>
<div class="line">            ngInclude: ngIncludeDirective,</div>
<div class="line">            ngInit: ngInitDirective,</div>
<div class="line">            ngNonBindable: ngNonBindableDirective,</div>
<div class="line">            ngPluralize: ngPluralizeDirective,</div>
<div class="line">            ngRepeat: ngRepeatDirective,</div>
<div class="line">            ngShow: ngShowDirective,</div>
<div class="line">            ngStyle: ngStyleDirective,</div>
<div class="line">            ngSwitch: ngSwitchDirective,</div>
<div class="line">            ngSwitchWhen: ngSwitchWhenDirective,</div>
<div class="line">            ngSwitchDefault: ngSwitchDefaultDirective,</div>
<div class="line">            ngOptions: ngOptionsDirective,</div>
<div class="line">            ngTransclude: ngTranscludeDirective,</div>
<div class="line">            ngModel: ngModelDirective,</div>
<div class="line">            ngList: ngListDirective,</div>
<div class="line">            ngChange: ngChangeDirective,</div>
<div class="line">            pattern: patternDirective,</div>
<div class="line">            ngPattern: patternDirective,</div>
<div class="line">            required: requiredDirective,</div>
<div class="line">            ngRequired: requiredDirective,</div>
<div class="line">            minlength: minlengthDirective,</div>
<div class="line">            ngMinlength: minlengthDirective,</div>
<div class="line">            maxlength: maxlengthDirective,</div>
<div class="line">            ngMaxlength: maxlengthDirective,</div>
<div class="line">            ngValue: ngValueDirective,</div>
<div class="line">            ngModelOptions: ngModelOptionsDirective</div>
<div class="line">        }).</div>
<div class="line">        directive({</div>
<div class="line">          ngInclude: ngIncludeFillContentDirective</div>
<div class="line">        }).</div>
<div class="line">        directive(ngAttributeAliasDirectives).</div>
<div class="line">        directive(ngEventDirectives);</div>
<div class="line">      $provide.provider({</div>
<div class="line">        $anchorScroll: $AnchorScrollProvider,</div>
<div class="line">        $animate: $AnimateProvider,</div>
<div class="line">        $animateCss: $CoreAnimateCssProvider,</div>
<div class="line">        $$animateQueue: $$CoreAnimateQueueProvider,</div>
<div class="line">        $$AnimateRunner: $$CoreAnimateRunnerProvider,</div>
<div class="line">        $browser: $BrowserProvider,</div>
<div class="line">        $cacheFactory: $CacheFactoryProvider,</div>
<div class="line">        $controller: $ControllerProvider,</div>
<div class="line">        $document: $DocumentProvider,</div>
<div class="line">        $exceptionHandler: $ExceptionHandlerProvider,</div>
<div class="line">        $filter: $FilterProvider,</div>
<div class="line">        $$forceReflow: $$ForceReflowProvider,</div>
<div class="line">        $interpolate: $InterpolateProvider,</div>
<div class="line">        $interval: $IntervalProvider,</div>
<div class="line">        $http: $HttpProvider,</div>
<div class="line">        $httpParamSerializer: $HttpParamSerializerProvider,</div>
<div class="line">        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,</div>
<div class="line">        $httpBackend: $HttpBackendProvider,</div>
<div class="line">        $location: $LocationProvider,</div>
<div class="line">        $log: $LogProvider,</div>
<div class="line">        $parse: $ParseProvider,</div>
<div class="line">        $rootScope: $RootScopeProvider,</div>
<div class="line">        $q: $QProvider,</div>
<div class="line">        $$q: $$QProvider,</div>
<div class="line">        $sce: $SceProvider,</div>
<div class="line">        $sceDelegate: $SceDelegateProvider,</div>
<div class="line">        $sniffer: $SnifferProvider,</div>
<div class="line">        $templateCache: $TemplateCacheProvider,</div>
<div class="line">        $templateRequest: $TemplateRequestProvider,</div>
<div class="line">        $$testability: $$TestabilityProvider,</div>
<div class="line">        $timeout: $TimeoutProvider,</div>
<div class="line">        $window: $WindowProvider,</div>
<div class="line">        $$rAF: $$RAFProvider,</div>
<div class="line">        $$jqLite: $$jqLiteProvider,</div>
<div class="line">        $$HashMap: $$HashMapProvider,</div>
<div class="line">        $$cookieReader: $$CookieReaderProvider</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  ]);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* global JQLitePrototype: true,</span></div>
<div class="line"><span class="comment">  addEventListenerFn: true,</span></div>
<div class="line"><span class="comment">  removeEventListenerFn: true,</span></div>
<div class="line"><span class="comment">  BOOLEAN_ATTR: true,</span></div>
<div class="line"><span class="comment">  ALIASED_ATTR: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//JQLite</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">JQLite.expando = <span class="stringliteral">&#39;ng339&#39;</span>;</div>
<div class="line"></div>
<div class="line">var jqCache = JQLite.cache = {},</div>
<div class="line">    jqId = 1,</div>
<div class="line">    addEventListenerFn = <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">      element.addEventListener(type, fn, <span class="keyword">false</span>);</div>
<div class="line">    },</div>
<div class="line">    removeEventListenerFn = <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">      element.removeEventListener(type, fn, <span class="keyword">false</span>);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * !!! This is an undocumented &quot;private&quot; function !!!</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">JQLite._data = <span class="keyword">function</span>(node) {</div>
<div class="line">  <span class="comment">//jQuery always returns an object on cache miss</span></div>
<div class="line">  <span class="keywordflow">return</span> this.cache[node[this.expando]] || {};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqNextId() { <span class="keywordflow">return</span> ++jqId; }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;</div>
<div class="line">var MOZ_HACK_REGEXP = /^moz([A-Z])/;</div>
<div class="line">var MOUSE_EVENT_MAP= { mouseleave: <span class="stringliteral">&quot;mouseout&quot;</span>, mouseenter: <span class="stringliteral">&quot;mouseover&quot;</span>};</div>
<div class="line">var jqLiteMinErr = minErr(<span class="stringliteral">&#39;jqLite&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> camelCase(name) {</div>
<div class="line">  <span class="keywordflow">return</span> name.</div>
<div class="line">    replace(SPECIAL_CHARS_REGEXP, <span class="keyword">function</span>(_, separator, letter, offset) {</div>
<div class="line">      <span class="keywordflow">return</span> offset ? letter.toUpperCase() : letter;</div>
<div class="line">    }).</div>
<div class="line">    replace(MOZ_HACK_REGEXP, <span class="stringliteral">&#39;Moz$1&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var SINGLE_TAG_REGEXP = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/;</div>
<div class="line">var HTML_REGEXP = /&lt;|&amp;#?\w+;/;</div>
<div class="line">var TAG_NAME_REGEXP = /&lt;([\w:]+)/;</div>
<div class="line">var XHTML_TAG_REGEXP = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi;</div>
<div class="line"></div>
<div class="line">var wrapMap = {</div>
<div class="line">  <span class="stringliteral">&#39;option&#39;</span>: [1, <span class="stringliteral">&#39;&lt;select multiple=&quot;multiple&quot;&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/select&gt;&#39;</span>],</div>
<div class="line"></div>
<div class="line">  <span class="stringliteral">&#39;thead&#39;</span>: [1, <span class="stringliteral">&#39;&lt;table&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;col&#39;</span>: [2, <span class="stringliteral">&#39;&lt;table&gt;&lt;colgroup&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/colgroup&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;tr&#39;</span>: [2, <span class="stringliteral">&#39;&lt;table&gt;&lt;tbody&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/tbody&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;td&#39;</span>: [3, <span class="stringliteral">&#39;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;_default&#39;</span>: [0, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>]</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">wrapMap.optgroup = wrapMap.option;</div>
<div class="line">wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;</div>
<div class="line">wrapMap.th = wrapMap.td;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteIsTextNode(html) {</div>
<div class="line">  <span class="keywordflow">return</span> !HTML_REGEXP.test(html);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAcceptsData(node) {</div>
<div class="line">  <span class="comment">// The window object can accept data but has no nodeType</span></div>
<div class="line">  <span class="comment">// Otherwise we are only interested in elements (1) and documents (9)</span></div>
<div class="line">  var nodeType = node.nodeType;</div>
<div class="line">  <span class="keywordflow">return</span> nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteHasData(node) {</div>
<div class="line">  <span class="keywordflow">for</span> (var key in jqCache[node.ng339]) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteBuildFragment(html, context) {</div>
<div class="line">  var tmp, tag, wrap,</div>
<div class="line">      fragment = context.createDocumentFragment(),</div>
<div class="line">      nodes = [], i;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (jqLiteIsTextNode(html)) {</div>
<div class="line">    <span class="comment">// Convert non-html into a text node</span></div>
<div class="line">    nodes.push(context.createTextNode(html));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Convert html into DOM nodes</span></div>
<div class="line">    tmp = tmp || fragment.appendChild(context.createElement(<span class="stringliteral">&quot;div&quot;</span>));</div>
<div class="line">    tag = (TAG_NAME_REGEXP.exec(html) || [<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>])[1].toLowerCase();</div>
<div class="line">    wrap = wrapMap[tag] || wrapMap._default;</div>
<div class="line">    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, <span class="stringliteral">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span>) + wrap[2];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Descend through wrappers to the right content</span></div>
<div class="line">    i = wrap[0];</div>
<div class="line">    <span class="keywordflow">while</span> (i--) {</div>
<div class="line">      tmp = tmp.lastChild;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    nodes = concat(nodes, tmp.childNodes);</div>
<div class="line"></div>
<div class="line">    tmp = fragment.firstChild;</div>
<div class="line">    tmp.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Remove wrapper from fragment</span></div>
<div class="line">  fragment.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">  fragment.innerHTML = <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// Clear inner HTML</span></div>
<div class="line">  forEach(nodes, <span class="keyword">function</span>(node) {</div>
<div class="line">    fragment.appendChild(node);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> fragment;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteParseHTML(html, context) {</div>
<div class="line">  context = context || document;</div>
<div class="line">  var parsed;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((parsed = SINGLE_TAG_REGEXP.exec(html))) {</div>
<div class="line">    <span class="keywordflow">return</span> [context.createElement(parsed[1])];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((parsed = jqLiteBuildFragment(html, context))) {</div>
<div class="line">    <span class="keywordflow">return</span> parsed.childNodes;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> [];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> JQLite(element) {</div>
<div class="line">  <span class="keywordflow">if</span> (element instanceof JQLite) {</div>
<div class="line">    <span class="keywordflow">return</span> element;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var argIsString;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isString(element)) {</div>
<div class="line">    element = trim(element);</div>
<div class="line">    argIsString = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!(<span class="keyword">this</span> instanceof JQLite)) {</div>
<div class="line">    <span class="keywordflow">if</span> (argIsString &amp;&amp; element.charAt(0) != <span class="charliteral">&#39;&lt;&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;nosel&#39;</span>, <span class="stringliteral">&#39;Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> JQLite(element);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (argIsString) {</div>
<div class="line">    jqLiteAddNodes(<span class="keyword">this</span>, jqLiteParseHTML(element));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    jqLiteAddNodes(<span class="keyword">this</span>, element);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteClone(element) {</div>
<div class="line">  <span class="keywordflow">return</span> element.cloneNode(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteDealoc(element, onlyDescendants) {</div>
<div class="line">  <span class="keywordflow">if</span> (!onlyDescendants) jqLiteRemoveData(element);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (element.querySelectorAll) {</div>
<div class="line">    var descendants = element.querySelectorAll(<span class="charliteral">&#39;*&#39;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, l = descendants.length; i &lt; l; i++) {</div>
<div class="line">      jqLiteRemoveData(descendants[i]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteOff(element, type, fn, unsupported) {</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(unsupported)) <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;offargs&#39;</span>, <span class="stringliteral">&#39;jqLite#off() does not support the `selector` argument&#39;</span>);</div>
<div class="line"></div>
<div class="line">  var expandoStore = jqLiteExpandoStore(element);</div>
<div class="line">  var events = expandoStore &amp;&amp; expandoStore.events;</div>
<div class="line">  var handle = expandoStore &amp;&amp; expandoStore.handle;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!handle) <span class="keywordflow">return</span>; <span class="comment">//no listeners registered</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!type) {</div>
<div class="line">    <span class="keywordflow">for</span> (type in events) {</div>
<div class="line">      <span class="keywordflow">if</span> (type !== <span class="stringliteral">&#39;$destroy&#39;</span>) {</div>
<div class="line">        removeEventListenerFn(element, type, handle);</div>
<div class="line">      }</div>
<div class="line">      <span class="keyword">delete</span> events[type];</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    forEach(type.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(type) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(fn)) {</div>
<div class="line">        var listenerFns = events[type];</div>
<div class="line">        arrayRemove(listenerFns || [], fn);</div>
<div class="line">        <span class="keywordflow">if</span> (listenerFns &amp;&amp; listenerFns.length &gt; 0) {</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      removeEventListenerFn(element, type, handle);</div>
<div class="line">      <span class="keyword">delete</span> events[type];</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemoveData(element, name) {</div>
<div class="line">  var expandoId = element.ng339;</div>
<div class="line">  var expandoStore = expandoId &amp;&amp; jqCache[expandoId];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (expandoStore) {</div>
<div class="line">    <span class="keywordflow">if</span> (name) {</div>
<div class="line">      <span class="keyword">delete</span> expandoStore.data[name];</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (expandoStore.handle) {</div>
<div class="line">      <span class="keywordflow">if</span> (expandoStore.events.$destroy) {</div>
<div class="line">        expandoStore.handle({}, <span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">      jqLiteOff(element);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span> jqCache[expandoId];</div>
<div class="line">    element.ng339 = undefined; <span class="comment">// don&#39;t delete DOM expandos. IE and Chrome don&#39;t like it</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteExpandoStore(element, createIfNecessary) {</div>
<div class="line">  var expandoId = element.ng339,</div>
<div class="line">      expandoStore = expandoId &amp;&amp; jqCache[expandoId];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (createIfNecessary &amp;&amp; !expandoStore) {</div>
<div class="line">    element.ng339 = expandoId = jqNextId();</div>
<div class="line">    expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined};</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> expandoStore;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteData(element, key, value) {</div>
<div class="line">  <span class="keywordflow">if</span> (jqLiteAcceptsData(element)) {</div>
<div class="line"></div>
<div class="line">    var isSimpleSetter = isDefined(value);</div>
<div class="line">    var isSimpleGetter = !isSimpleSetter &amp;&amp; key &amp;&amp; !isObject(key);</div>
<div class="line">    var massGetter = !key;</div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);</div>
<div class="line">    var data = expandoStore &amp;&amp; expandoStore.data;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isSimpleSetter) { <span class="comment">// data(&#39;key&#39;, value)</span></div>
<div class="line">      data[key] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (massGetter) {  <span class="comment">// data()</span></div>
<div class="line">        <span class="keywordflow">return</span> data;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isSimpleGetter) { <span class="comment">// data(&#39;key&#39;)</span></div>
<div class="line">          <span class="comment">// don&#39;t force creation of expandoStore if it doesn&#39;t exist yet</span></div>
<div class="line">          <span class="keywordflow">return</span> data &amp;&amp; data[key];</div>
<div class="line">        } <span class="keywordflow">else</span> { <span class="comment">// mass-setter: data({key1: val1, key2: val2})</span></div>
<div class="line">          extend(data, key);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteHasClass(element, selector) {</div>
<div class="line">  <span class="keywordflow">if</span> (!element.getAttribute) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> ((<span class="stringliteral">&quot; &quot;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="stringliteral">&quot; &quot;</span>).replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>).</div>
<div class="line">      indexOf(<span class="stringliteral">&quot; &quot;</span> + selector + <span class="stringliteral">&quot; &quot;</span>) &gt; -1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemoveClass(element, cssClasses) {</div>
<div class="line">  <span class="keywordflow">if</span> (cssClasses &amp;&amp; element.setAttribute) {</div>
<div class="line">    forEach(cssClasses.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(cssClass) {</div>
<div class="line">      element.setAttribute(<span class="stringliteral">&#39;class&#39;</span>, trim(</div>
<div class="line">          (<span class="stringliteral">&quot; &quot;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">          .replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">          .replace(<span class="stringliteral">&quot; &quot;</span> + trim(cssClass) + <span class="stringliteral">&quot; &quot;</span>, <span class="stringliteral">&quot; &quot;</span>))</div>
<div class="line">      );</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAddClass(element, cssClasses) {</div>
<div class="line">  <span class="keywordflow">if</span> (cssClasses &amp;&amp; element.setAttribute) {</div>
<div class="line">    var existingClasses = (<span class="charliteral">&#39; &#39;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="charliteral">&#39; &#39;</span>)</div>
<div class="line">                            .replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"></div>
<div class="line">    forEach(cssClasses.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(cssClass) {</div>
<div class="line">      cssClass = trim(cssClass);</div>
<div class="line">      <span class="keywordflow">if</span> (existingClasses.indexOf(<span class="charliteral">&#39; &#39;</span> + cssClass + <span class="charliteral">&#39; &#39;</span>) === -1) {</div>
<div class="line">        existingClasses += cssClass + <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    element.setAttribute(<span class="stringliteral">&#39;class&#39;</span>, trim(existingClasses));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAddNodes(root, elements) {</div>
<div class="line">  <span class="comment">// THIS CODE IS VERY HOT. Don&#39;t make changes without benchmarking.</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (elements) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if a Node (the most common case)</span></div>
<div class="line">    <span class="keywordflow">if</span> (elements.nodeType) {</div>
<div class="line">      root[root.length++] = elements;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var length = elements.length;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if an Array or NodeList and not a Window</span></div>
<div class="line">      <span class="keywordflow">if</span> (typeof length === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; elements.window !== elements) {</div>
<div class="line">        <span class="keywordflow">if</span> (length) {</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; length; i++) {</div>
<div class="line">            root[root.length++] = elements[i];</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        root[root.length++] = elements;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteController(element, name) {</div>
<div class="line">  <span class="keywordflow">return</span> jqLiteInheritedData(element, <span class="charliteral">&#39;$&#39;</span> + (name || <span class="stringliteral">&#39;ngController&#39;</span>) + <span class="stringliteral">&#39;Controller&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteInheritedData(element, name, value) {</div>
<div class="line">  <span class="comment">// if element is the document object work with the html element instead</span></div>
<div class="line">  <span class="comment">// this makes $(document).scope() possible</span></div>
<div class="line">  <span class="keywordflow">if</span> (element.nodeType == NODE_TYPE_DOCUMENT) {</div>
<div class="line">    element = element.documentElement;</div>
<div class="line">  }</div>
<div class="line">  var names = isArray(name) ? name : [name];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span> (element) {</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = names.length; i &lt; ii; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((value = jqLite.data(element, names[i])) !== undefined) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If dealing with a document fragment node with a host element, and no parent, use the host</span></div>
<div class="line">    <span class="comment">// element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM</span></div>
<div class="line">    <span class="comment">// to lookup parent controllers.</span></div>
<div class="line">    element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT &amp;&amp; element.host);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteEmpty(element) {</div>
<div class="line">  jqLiteDealoc(element, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">while</span> (element.firstChild) {</div>
<div class="line">    element.removeChild(element.firstChild);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemove(element, keepData) {</div>
<div class="line">  <span class="keywordflow">if</span> (!keepData) jqLiteDealoc(element);</div>
<div class="line">  var parent = element.parentNode;</div>
<div class="line">  <span class="keywordflow">if</span> (parent) parent.removeChild(element);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteDocumentLoaded(action, win) {</div>
<div class="line">  win = win || window;</div>
<div class="line">  <span class="keywordflow">if</span> (win.document.readyState === <span class="stringliteral">&#39;complete&#39;</span>) {</div>
<div class="line">    <span class="comment">// Force the action to be run async for consistent behaviour</span></div>
<div class="line">    <span class="comment">// from the action&#39;s point of view</span></div>
<div class="line">    <span class="comment">// i.e. it will definitely not be in a $apply</span></div>
<div class="line">    win.setTimeout(action);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// No need to unbind this handler as load is only ever called once</span></div>
<div class="line">    jqLite(win).on(<span class="stringliteral">&#39;load&#39;</span>, action);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions which are declared directly.</span></div>
<div class="line"><span class="comment"></span>var JQLitePrototype = JQLite.prototype = {</div>
<div class="line">  ready: <span class="keyword">function</span>(fn) {</div>
<div class="line">    var fired = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> trigger() {</div>
<div class="line">      <span class="keywordflow">if</span> (fired) <span class="keywordflow">return</span>;</div>
<div class="line">      fired = <span class="keyword">true</span>;</div>
<div class="line">      fn();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check if document is already loaded</span></div>
<div class="line">    <span class="keywordflow">if</span> (document.readyState === <span class="stringliteral">&#39;complete&#39;</span>) {</div>
<div class="line">      setTimeout(trigger);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      this.on(<span class="stringliteral">&#39;DOMContentLoaded&#39;</span>, trigger); <span class="comment">// works for modern browsers and IE9</span></div>
<div class="line">      <span class="comment">// we can not use jqLite since we are not done loading and jQuery could be loaded later.</span></div>
<div class="line">      <span class="comment">// jshint -W064</span></div>
<div class="line">      JQLite(window).on(<span class="stringliteral">&#39;load&#39;</span>, trigger); <span class="comment">// fallback to window.onload for others</span></div>
<div class="line">      <span class="comment">// jshint +W064</span></div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  toString: <span class="keyword">function</span>() {</div>
<div class="line">    var value = [];</div>
<div class="line">    forEach(<span class="keyword">this</span>, <span class="keyword">function</span>(e) { value.push(<span class="stringliteral">&#39;&#39;</span> + e);});</div>
<div class="line">    <span class="keywordflow">return</span> <span class="charliteral">&#39;[&#39;</span> + value.join(<span class="stringliteral">&#39;, &#39;</span>) + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  eq: <span class="keyword">function</span>(index) {</div>
<div class="line">      <span class="keywordflow">return</span> (index &gt;= 0) ? jqLite(<span class="keyword">this</span>[index]) : jqLite(<span class="keyword">this</span>[this.length + index]);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  length: 0,</div>
<div class="line">  push: push,</div>
<div class="line">  sort: [].sort,</div>
<div class="line">  splice: [].splice</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions iterating getter/setters.</span></div>
<div class="line"><span class="comment">// these functions return self on setter and</span></div>
<div class="line"><span class="comment">// value on get.</span></div>
<div class="line"><span class="comment"></span>var BOOLEAN_ATTR = {};</div>
<div class="line">forEach(<span class="stringliteral">&#39;multiple,selected,checked,disabled,readOnly,required,open&#39;</span>.split(<span class="charliteral">&#39;,&#39;</span>), <span class="keyword">function</span>(value) {</div>
<div class="line">  BOOLEAN_ATTR[lowercase(value)] = value;</div>
<div class="line">});</div>
<div class="line">var BOOLEAN_ELEMENTS = {};</div>
<div class="line">forEach(<span class="stringliteral">&#39;input,select,option,textarea,button,form,details&#39;</span>.split(<span class="charliteral">&#39;,&#39;</span>), <span class="keyword">function</span>(value) {</div>
<div class="line">  BOOLEAN_ELEMENTS[value] = <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line">var ALIASED_ATTR = {</div>
<div class="line">  <span class="stringliteral">&#39;ngMinlength&#39;</span>: <span class="stringliteral">&#39;minlength&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMaxlength&#39;</span>: <span class="stringliteral">&#39;maxlength&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMin&#39;</span>: <span class="stringliteral">&#39;min&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMax&#39;</span>: <span class="stringliteral">&#39;max&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngPattern&#39;</span>: <span class="stringliteral">&#39;pattern&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getBooleanAttrName(element, name) {</div>
<div class="line">  <span class="comment">// check dom last since we will most likely fail on name</span></div>
<div class="line">  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// booleanAttr is here twice to minimize DOM access</span></div>
<div class="line">  <span class="keywordflow">return</span> booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[nodeName_(element)] &amp;&amp; booleanAttr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getAliasedAttrName(element, name) {</div>
<div class="line">  var nodeName = element.nodeName;</div>
<div class="line">  <span class="keywordflow">return</span> (nodeName === <span class="stringliteral">&#39;INPUT&#39;</span> || nodeName === <span class="stringliteral">&#39;TEXTAREA&#39;</span>) &amp;&amp; ALIASED_ATTR[name];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">forEach({</div>
<div class="line">  data: jqLiteData,</div>
<div class="line">  removeData: jqLiteRemoveData,</div>
<div class="line">  hasData: jqLiteHasData</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite[name] = fn;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">forEach({</div>
<div class="line">  data: jqLiteData,</div>
<div class="line">  inheritedData: jqLiteInheritedData,</div>
<div class="line"></div>
<div class="line">  scope: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="comment">// Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!</span></div>
<div class="line">    <span class="keywordflow">return</span> jqLite.data(element, <span class="stringliteral">&#39;$scope&#39;</span>) || jqLiteInheritedData(element.parentNode || element, [<span class="stringliteral">&#39;$isolateScope&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>]);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isolateScope: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="comment">// Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!</span></div>
<div class="line">    <span class="keywordflow">return</span> jqLite.data(element, <span class="stringliteral">&#39;$isolateScope&#39;</span>) || jqLite.data(element, <span class="stringliteral">&#39;$isolateScopeNoTemplate&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  controller: jqLiteController,</div>
<div class="line"></div>
<div class="line">  injector: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> jqLiteInheritedData(element, <span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  removeAttr: <span class="keyword">function</span>(element, name) {</div>
<div class="line">    element.removeAttribute(name);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  hasClass: jqLiteHasClass,</div>
<div class="line"></div>
<div class="line">  css: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    name = camelCase(name);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element.style[name] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> element.style[name];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  attr: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    var nodeType = element.nodeType;</div>
<div class="line">    <span class="keywordflow">if</span> (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    var lowercasedName = lowercase(name);</div>
<div class="line">    <span class="keywordflow">if</span> (BOOLEAN_ATTR[lowercasedName]) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!!value) {</div>
<div class="line">          element[name] = <span class="keyword">true</span>;</div>
<div class="line">          element.setAttribute(name, lowercasedName);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          element[name] = <span class="keyword">false</span>;</div>
<div class="line">          element.removeAttribute(lowercasedName);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> (element[name] ||</div>
<div class="line">                 (element.attributes.getNamedItem(name) || noop).specified)</div>
<div class="line">               ? lowercasedName</div>
<div class="line">               : undefined;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element.setAttribute(name, value);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (element.getAttribute) {</div>
<div class="line">      <span class="comment">// the extra argument &quot;2&quot; is to get the right thing for a.href in IE, see jQuery code</span></div>
<div class="line">      <span class="comment">// some elements (e.g. Document) don&#39;t have get attribute, so return undefined</span></div>
<div class="line">      var ret = element.getAttribute(name, 2);</div>
<div class="line">      <span class="comment">// normalize non-existing attributes to undefined (as jQuery)</span></div>
<div class="line">      <span class="keywordflow">return</span> ret === null ? undefined : ret;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  prop: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element[name] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> element[name];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  text: (<span class="keyword">function</span>() {</div>
<div class="line">    getText.$dv = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> getText;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getText(element, value) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">        var nodeType = element.nodeType;</div>
<div class="line">        <span class="keywordflow">return</span> (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">      element.textContent = value;</div>
<div class="line">    }</div>
<div class="line">  })(),</div>
<div class="line"></div>
<div class="line">  val: <span class="keyword">function</span>(element, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">if</span> (element.multiple &amp;&amp; nodeName_(element) === <span class="stringliteral">&#39;select&#39;</span>) {</div>
<div class="line">        var result = [];</div>
<div class="line">        forEach(element.options, <span class="keyword">function</span>(option) {</div>
<div class="line">          if (option.selected) {</div>
<div class="line">            result.push(option.value || option.text);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> result.length === 0 ? null : result;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> element.value;</div>
<div class="line">    }</div>
<div class="line">    element.value = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  html: <span class="keyword">function</span>(element, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">return</span> element.innerHTML;</div>
<div class="line">    }</div>
<div class="line">    jqLiteDealoc(element, <span class="keyword">true</span>);</div>
<div class="line">    element.innerHTML = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  empty: jqLiteEmpty</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite.prototype[name] = <span class="keyword">function</span>(arg1, arg2) {</div>
<div class="line">    var i, key;</div>
<div class="line">    var nodeCount = this.length;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it</span></div>
<div class="line">    <span class="comment">// in a way that survives minification.</span></div>
<div class="line">    <span class="comment">// jqLiteEmpty takes no arguments but is a setter.</span></div>
<div class="line">    <span class="keywordflow">if</span> (fn !== jqLiteEmpty &amp;&amp;</div>
<div class="line">        (((fn.length == 2 &amp;&amp; (fn !== jqLiteHasClass &amp;&amp; fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(arg1)) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we are a write, but the object properties are the key/values</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; nodeCount; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> (fn === jqLiteData) {</div>
<div class="line">            <span class="comment">// data() takes the whole object in jQuery</span></div>
<div class="line">            fn(<span class="keyword">this</span>[i], arg1);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">for</span> (key in arg1) {</div>
<div class="line">              fn(<span class="keyword">this</span>[i], key, arg1[key]);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// return self for chaining</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// we are a read, so read the first child.</span></div>
<div class="line">        <span class="comment">// TODO: do we still need this?</span></div>
<div class="line">        var value = fn.$dv;</div>
<div class="line">        <span class="comment">// Only if we have $dv do we iterate over all, otherwise it is just the first element.</span></div>
<div class="line">        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;</div>
<div class="line">        <span class="keywordflow">for</span> (var j = 0; j &lt; jj; j++) {</div>
<div class="line">          var nodeValue = fn(<span class="keyword">this</span>[j], arg1, arg2);</div>
<div class="line">          value = value ? value + nodeValue : nodeValue;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// we are a write, so apply to all children</span></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; nodeCount; i++) {</div>
<div class="line">        fn(<span class="keyword">this</span>[i], arg1, arg2);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// return self for chaining</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createEventHandler(element, events) {</div>
<div class="line">  var eventHandler = <span class="keyword">function</span>(event, type) {</div>
<div class="line">    <span class="comment">// jQuery specific api</span></div>
<div class="line">    <span class="keyword">event</span>.isDefaultPrevented = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">event</span>.defaultPrevented;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var eventFns = events[type || <span class="keyword">event</span>.type];</div>
<div class="line">    var eventFnsLength = eventFns ? eventFns.length : 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!eventFnsLength) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(event.immediatePropagationStopped)) {</div>
<div class="line">      var originalStopImmediatePropagation = <span class="keyword">event</span>.stopImmediatePropagation;</div>
<div class="line">      <span class="keyword">event</span>.stopImmediatePropagation = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keyword">event</span>.immediatePropagationStopped = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (event.stopPropagation) {</div>
<div class="line">          <span class="keyword">event</span>.stopPropagation();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (originalStopImmediatePropagation) {</div>
<div class="line">          originalStopImmediatePropagation.call(event);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">event</span>.isImmediatePropagationStopped = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">event</span>.immediatePropagationStopped === <span class="keyword">true</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy event handlers in case event handlers array is modified during execution.</span></div>
<div class="line">    <span class="keywordflow">if</span> ((eventFnsLength &gt; 1)) {</div>
<div class="line">      eventFns = shallowCopy(eventFns);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0; i &lt; eventFnsLength; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> (!event.isImmediatePropagationStopped()) {</div>
<div class="line">        eventFns[i].call(element, event);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all</span></div>
<div class="line">  <span class="comment">//       events on `element`</span></div>
<div class="line">  eventHandler.elem = element;</div>
<div class="line">  <span class="keywordflow">return</span> eventHandler;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions iterating traversal.</span></div>
<div class="line"><span class="comment">// These functions chain results into a single</span></div>
<div class="line"><span class="comment">// selector.</span></div>
<div class="line"><span class="comment"></span>forEach({</div>
<div class="line">  removeData: jqLiteRemoveData,</div>
<div class="line"></div>
<div class="line">  on: <span class="keyword">function</span> jqLiteOn(element, type, fn, unsupported) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(unsupported)) <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;onargs&#39;</span>, <span class="stringliteral">&#39;jqLite#on() does not support the `selector` or `eventData` parameters&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do not add event handlers to non-elements because they will not be cleaned up.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!jqLiteAcceptsData(element)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element, <span class="keyword">true</span>);</div>
<div class="line">    var events = expandoStore.events;</div>
<div class="line">    var handle = expandoStore.handle;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!handle) {</div>
<div class="line">      handle = expandoStore.handle = createEventHandler(element, events);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// http://jsperf.com/string-indexof-vs-split</span></div>
<div class="line">    var types = type.indexOf(<span class="charliteral">&#39; &#39;</span>) &gt;= 0 ? type.split(<span class="charliteral">&#39; &#39;</span>) : [type];</div>
<div class="line">    var i = types.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (i--) {</div>
<div class="line">      type = types[i];</div>
<div class="line">      var eventFns = events[type];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!eventFns) {</div>
<div class="line">        events[type] = [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;mouseenter&#39;</span> || type === <span class="stringliteral">&#39;mouseleave&#39;</span>) {</div>
<div class="line">          <span class="comment">// Refer to jQuery&#39;s implementation of mouseenter &amp; mouseleave</span></div>
<div class="line">          <span class="comment">// Read about mouseenter and mouseleave:</span></div>
<div class="line">          <span class="comment">// http://www.quirksmode.org/js/events_mouse.html#link8</span></div>
<div class="line"></div>
<div class="line">          jqLiteOn(element, MOUSE_EVENT_MAP[type], <span class="keyword">function</span>(event) {</div>
<div class="line">            var target = <span class="keyword">this</span>, related = <span class="keyword">event</span>.relatedTarget;</div>
<div class="line">            <span class="comment">// For mousenter/leave call the handler if related is outside the target.</span></div>
<div class="line">            <span class="comment">// NB: No relatedTarget if the mouse left/entered the browser window</span></div>
<div class="line">            <span class="keywordflow">if</span> (!related || (related !== target &amp;&amp; !target.contains(related))) {</div>
<div class="line">              handle(event, type);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (type !== <span class="stringliteral">&#39;$destroy&#39;</span>) {</div>
<div class="line">            addEventListenerFn(element, type, handle);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        eventFns = events[type];</div>
<div class="line">      }</div>
<div class="line">      eventFns.push(fn);</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  off: jqLiteOff,</div>
<div class="line"></div>
<div class="line">  one: <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">    element = jqLite(element);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//add the listener twice so that when it is called</span></div>
<div class="line">    <span class="comment">//you can remove the original function and still be</span></div>
<div class="line">    <span class="comment">//able to call element.off(ev, fn) normally</span></div>
<div class="line">    element.on(type, <span class="keyword">function</span> onFn() {</div>
<div class="line">      element.off(type, fn);</div>
<div class="line">      element.off(type, onFn);</div>
<div class="line">    });</div>
<div class="line">    element.on(type, fn);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  replaceWith: <span class="keyword">function</span>(element, replaceNode) {</div>
<div class="line">    var index, parent = element.parentNode;</div>
<div class="line">    jqLiteDealoc(element);</div>
<div class="line">    forEach(<span class="keyword">new</span> JQLite(replaceNode), <span class="keyword">function</span>(node) {</div>
<div class="line">      <span class="keywordflow">if</span> (index) {</div>
<div class="line">        parent.insertBefore(node, index.nextSibling);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        parent.replaceChild(node, element);</div>
<div class="line">      }</div>
<div class="line">      index = node;</div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  children: <span class="keyword">function</span>(element) {</div>
<div class="line">    var children = [];</div>
<div class="line">    forEach(element.childNodes, <span class="keyword">function</span>(element) {</div>
<div class="line">      if (element.nodeType === NODE_TYPE_ELEMENT) {</div>
<div class="line">        children.push(element);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> children;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  contents: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> element.contentDocument || element.childNodes || [];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  append: <span class="keyword">function</span>(element, node) {</div>
<div class="line">    var nodeType = element.nodeType;</div>
<div class="line">    <span class="keywordflow">if</span> (nodeType !== NODE_TYPE_ELEMENT &amp;&amp; nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    node = <span class="keyword">new</span> JQLite(node);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = node.length; i &lt; ii; i++) {</div>
<div class="line">      var child = node[i];</div>
<div class="line">      element.appendChild(child);</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  prepend: <span class="keyword">function</span>(element, node) {</div>
<div class="line">    <span class="keywordflow">if</span> (element.nodeType === NODE_TYPE_ELEMENT) {</div>
<div class="line">      var index = element.firstChild;</div>
<div class="line">      forEach(<span class="keyword">new</span> JQLite(node), <span class="keyword">function</span>(child) {</div>
<div class="line">        element.insertBefore(child, index);</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  wrap: <span class="keyword">function</span>(element, wrapNode) {</div>
<div class="line">    wrapNode = jqLite(wrapNode).eq(0).clone()[0];</div>
<div class="line">    var parent = element.parentNode;</div>
<div class="line">    <span class="keywordflow">if</span> (parent) {</div>
<div class="line">      parent.replaceChild(wrapNode, element);</div>
<div class="line">    }</div>
<div class="line">    wrapNode.appendChild(element);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">remove</span>: jqLiteRemove,</div>
<div class="line"></div>
<div class="line">  detach: <span class="keyword">function</span>(element) {</div>
<div class="line">    jqLiteRemove(element, <span class="keyword">true</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  after: <span class="keyword">function</span>(element, newElement) {</div>
<div class="line">    var index = element, parent = element.parentNode;</div>
<div class="line">    newElement = <span class="keyword">new</span> JQLite(newElement);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = newElement.length; i &lt; ii; i++) {</div>
<div class="line">      var node = newElement[i];</div>
<div class="line">      parent.insertBefore(node, index.nextSibling);</div>
<div class="line">      index = node;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addClass: jqLiteAddClass,</div>
<div class="line">  removeClass: jqLiteRemoveClass,</div>
<div class="line"></div>
<div class="line">  toggleClass: <span class="keyword">function</span>(element, selector, condition) {</div>
<div class="line">    <span class="keywordflow">if</span> (selector) {</div>
<div class="line">      forEach(selector.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(className) {</div>
<div class="line">        var classCondition = condition;</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(classCondition)) {</div>
<div class="line">          classCondition = !jqLiteHasClass(element, className);</div>
<div class="line">        }</div>
<div class="line">        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  parent: <span class="keyword">function</span>(element) {</div>
<div class="line">    var parent = element.parentNode;</div>
<div class="line">    <span class="keywordflow">return</span> parent &amp;&amp; parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  next: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> element.nextElementSibling;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  find: <span class="keyword">function</span>(element, selector) {</div>
<div class="line">    <span class="keywordflow">if</span> (element.getElementsByTagName) {</div>
<div class="line">      <span class="keywordflow">return</span> element.getElementsByTagName(selector);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> [];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  clone: jqLiteClone,</div>
<div class="line"></div>
<div class="line">  triggerHandler: <span class="keyword">function</span>(element, event, extraParameters) {</div>
<div class="line"></div>
<div class="line">    var dummyEvent, eventFnsCopy, handlerArgs;</div>
<div class="line">    var eventName = <span class="keyword">event</span>.type || event;</div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element);</div>
<div class="line">    var events = expandoStore &amp;&amp; expandoStore.events;</div>
<div class="line">    var eventFns = events &amp;&amp; events[eventName];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (eventFns) {</div>
<div class="line">      <span class="comment">// Create a dummy event to pass to the handlers</span></div>
<div class="line">      dummyEvent = {</div>
<div class="line">        preventDefault: <span class="keyword">function</span>() { this.defaultPrevented = <span class="keyword">true</span>; },</div>
<div class="line">        isDefaultPrevented: <span class="keyword">function</span>() { <span class="keywordflow">return</span> this.defaultPrevented === <span class="keyword">true</span>; },</div>
<div class="line">        stopImmediatePropagation: <span class="keyword">function</span>() { this.immediatePropagationStopped = <span class="keyword">true</span>; },</div>
<div class="line">        isImmediatePropagationStopped: <span class="keyword">function</span>() { <span class="keywordflow">return</span> this.immediatePropagationStopped === <span class="keyword">true</span>; },</div>
<div class="line">        stopPropagation: noop,</div>
<div class="line">        type: eventName,</div>
<div class="line">        target: element</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If a custom event was provided then extend our dummy event with it</span></div>
<div class="line">      <span class="keywordflow">if</span> (event.type) {</div>
<div class="line">        dummyEvent = extend(dummyEvent, event);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Copy event handlers in case event handlers array is modified during execution.</span></div>
<div class="line">      eventFnsCopy = shallowCopy(eventFns);</div>
<div class="line">      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];</div>
<div class="line"></div>
<div class="line">      forEach(eventFnsCopy, <span class="keyword">function</span>(fn) {</div>
<div class="line">        <span class="keywordflow">if</span> (!dummyEvent.isImmediatePropagationStopped()) {</div>
<div class="line">          fn.apply(element, handlerArgs);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite.prototype[name] = <span class="keyword">function</span>(arg1, arg2, arg3) {</div>
<div class="line">    var value;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = this.length; i &lt; ii; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">        value = fn(<span class="keyword">this</span>[i], arg1, arg2, arg3);</div>
<div class="line">        <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">          <span class="comment">// any function which returns a value needs to be wrapped</span></div>
<div class="line">          value = jqLite(value);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        jqLiteAddNodes(value, fn(<span class="keyword">this</span>[i], arg1, arg2, arg3));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> isDefined(value) ? value : <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// bind legacy bind/unbind to on/off</span></div>
<div class="line">  JQLite.prototype.bind = JQLite.prototype.on;</div>
<div class="line">  JQLite.prototype.unbind = JQLite.prototype.off;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Provider for private $$jqLite service</span></div>
<div class="line"><span class="keyword">function</span> $$jqLiteProvider() {</div>
<div class="line">  this.$get = <span class="keyword">function</span> $$jqLite() {</div>
<div class="line">    <span class="keywordflow">return</span> extend(JQLite, {</div>
<div class="line">      hasClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteHasClass(node, classes);</div>
<div class="line">      },</div>
<div class="line">      addClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteAddClass(node, classes);</div>
<div class="line">      },</div>
<div class="line">      removeClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteRemoveClass(node, classes);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> hashKey(obj, nextUidFn) {</div>
<div class="line">  var key = obj &amp;&amp; obj.$$hashKey;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (key) {</div>
<div class="line">    <span class="keywordflow">if</span> (typeof key === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      key = obj.$$hashKey();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> key;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var objType = typeof obj;</div>
<div class="line">  <span class="keywordflow">if</span> (objType == <span class="stringliteral">&#39;function&#39;</span> || (objType == <span class="stringliteral">&#39;object&#39;</span> &amp;&amp; obj !== null)) {</div>
<div class="line">    key = obj.$$hashKey = objType + <span class="charliteral">&#39;:&#39;</span> + (nextUidFn || nextUid)();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    key = objType + <span class="charliteral">&#39;:&#39;</span> + obj;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> key;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> HashMap(array, isolatedUid) {</div>
<div class="line">  <span class="keywordflow">if</span> (isolatedUid) {</div>
<div class="line">    var uid = 0;</div>
<div class="line">    this.nextUid = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> ++uid;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">  forEach(array, this.put, <span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line">HashMap.prototype = {</div>
<div class="line">  put: <span class="keyword">function</span>(key, value) {</div>
<div class="line">    <span class="keyword">this</span>[hashKey(key, this.nextUid)] = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">get</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>[hashKey(key, this.nextUid)];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">remove</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">    var value = <span class="keyword">this</span>[key = hashKey(key, this.nextUid)];</div>
<div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>[key];</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var $$HashMapProvider = [<span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> HashMap;</div>
<div class="line">  }];</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;</div>
<div class="line">var FN_ARG_SPLIT = /,/;</div>
<div class="line">var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;</div>
<div class="line">var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;</div>
<div class="line">var $injectorMinErr = minErr(<span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> anonFn(fn) {</div>
<div class="line">  <span class="comment">// For anonymous functions, showing at the very least the function signature can help in</span></div>
<div class="line">  <span class="comment">// debugging.</span></div>
<div class="line">  var fnText = fn.toString().replace(STRIP_COMMENTS, <span class="stringliteral">&#39;&#39;</span>),</div>
<div class="line">      args = fnText.match(FN_ARGS);</div>
<div class="line">  <span class="keywordflow">if</span> (args) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;function(&#39;</span> + (args[1] || <span class="stringliteral">&#39;&#39;</span>).replace(/[\s\r\n]+/, <span class="charliteral">&#39; &#39;</span>) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&#39;fn&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> annotate(fn, strictDi, name) {</div>
<div class="line">  var $inject,</div>
<div class="line">      fnText,</div>
<div class="line">      argDecl,</div>
<div class="line">      last;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (typeof fn === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (!($inject = fn.$inject)) {</div>
<div class="line">      $inject = [];</div>
<div class="line">      <span class="keywordflow">if</span> (fn.length) {</div>
<div class="line">        <span class="keywordflow">if</span> (strictDi) {</div>
<div class="line">          <span class="keywordflow">if</span> (!isString(name) || !name) {</div>
<div class="line">            name = fn.name || anonFn(fn);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;strictdi&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;{0} is not using explicit annotation and cannot be invoked in strict mode&#39;</span>, name);</div>
<div class="line">        }</div>
<div class="line">        fnText = fn.toString().replace(STRIP_COMMENTS, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        argDecl = fnText.match(FN_ARGS);</div>
<div class="line">        forEach(argDecl[1].split(FN_ARG_SPLIT), <span class="keyword">function</span>(arg) {</div>
<div class="line">          arg.replace(FN_ARG, <span class="keyword">function</span>(all, underscore, name) {</div>
<div class="line">            $inject.push(name);</div>
<div class="line">          });</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      fn.$inject = $inject;</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(fn)) {</div>
<div class="line">    last = fn.length - 1;</div>
<div class="line">    assertArgFn(fn[last], <span class="stringliteral">&#39;fn&#39;</span>);</div>
<div class="line">    $inject = fn.slice(0, last);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    assertArgFn(fn, <span class="stringliteral">&#39;fn&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> $inject;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createInjector(modulesToLoad, strictDi) {</div>
<div class="line">  strictDi = (strictDi === <span class="keyword">true</span>);</div>
<div class="line">  var INSTANTIATING = {},</div>
<div class="line">      providerSuffix = <span class="stringliteral">&#39;Provider&#39;</span>,</div>
<div class="line">      path = [],</div>
<div class="line">      loadedModules = <span class="keyword">new</span> HashMap([], <span class="keyword">true</span>),</div>
<div class="line">      providerCache = {</div>
<div class="line">        $provide: {</div>
<div class="line">            provider: supportObject(provider),</div>
<div class="line">            factory: supportObject(factory),</div>
<div class="line">            service: supportObject(service),</div>
<div class="line">            value: supportObject(value),</div>
<div class="line">            constant: supportObject(constant),</div>
<div class="line">            decorator: decorator</div>
<div class="line">          }</div>
<div class="line">      },</div>
<div class="line">      providerInjector = (providerCache.$injector =</div>
<div class="line">          createInternalInjector(providerCache, <span class="keyword">function</span>(serviceName, caller) {</div>
<div class="line">            <span class="keywordflow">if</span> (angular.isString(caller)) {</div>
<div class="line">              path.push(caller);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;unpr&#39;</span>, <span class="stringliteral">&quot;Unknown provider: {0}&quot;</span>, path.join(<span class="stringliteral">&#39; &lt;- &#39;</span>));</div>
<div class="line">          })),</div>
<div class="line">      instanceCache = {},</div>
<div class="line">      instanceInjector = (instanceCache.$injector =</div>
<div class="line">          createInternalInjector(instanceCache, <span class="keyword">function</span>(serviceName, caller) {</div>
<div class="line">            var provider = providerInjector.get(serviceName + providerSuffix, caller);</div>
<div class="line">            <span class="keywordflow">return</span> instanceInjector.invoke(provider.$get, provider, undefined, serviceName);</div>
<div class="line">          }));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  forEach(loadModules(modulesToLoad), <span class="keyword">function</span>(fn) { <span class="keywordflow">if</span> (fn) instanceInjector.invoke(fn); });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> instanceInjector;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// $provider</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">function</span> supportObject(delegate) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(key, value) {</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(key)) {</div>
<div class="line">        forEach(key, reverseParams(delegate));</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> delegate(key, value);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> provider(name, provider_) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;service&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isFunction(provider_) || isArray(provider_)) {</div>
<div class="line">      provider_ = providerInjector.instantiate(provider_);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!provider_.$get) {</div>
<div class="line">      <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;pget&#39;</span>, <span class="stringliteral">&quot;Provider &#39;{0}&#39; must define $get factory method.&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> providerCache[name + providerSuffix] = provider_;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> enforceReturnValue(name, factory) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> enforcedReturnValue() {</div>
<div class="line">      var result = instanceInjector.invoke(factory, <span class="keyword">this</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(result)) {</div>
<div class="line">        <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;undef&#39;</span>, <span class="stringliteral">&quot;Provider &#39;{0}&#39; must return a value from $get factory method.&quot;</span>, name);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> factory(name, factoryFn, enforce) {</div>
<div class="line">    <span class="keywordflow">return</span> provider(name, {</div>
<div class="line">      $get: enforce !== <span class="keyword">false</span> ? enforceReturnValue(name, factoryFn) : factoryFn</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> service(name, constructor) {</div>
<div class="line">    <span class="keywordflow">return</span> factory(name, [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line">      <span class="keywordflow">return</span> $injector.instantiate(constructor);</div>
<div class="line">    }]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> value(name, val) { <span class="keywordflow">return</span> factory(name, valueFn(val), <span class="keyword">false</span>); }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> constant(name, value) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;constant&#39;</span>);</div>
<div class="line">    providerCache[name] = value;</div>
<div class="line">    instanceCache[name] = value;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> decorator(serviceName, decorFn) {</div>
<div class="line">    var origProvider = providerInjector.get(serviceName + providerSuffix),</div>
<div class="line">        orig$get = origProvider.$get;</div>
<div class="line"></div>
<div class="line">    origProvider.$get = <span class="keyword">function</span>() {</div>
<div class="line">      var origInstance = instanceInjector.invoke(orig$get, origProvider);</div>
<div class="line">      <span class="keywordflow">return</span> instanceInjector.invoke(decorFn, null, {$delegate: origInstance});</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Module Loading</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">function</span> loadModules(modulesToLoad) {</div>
<div class="line">    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), <span class="stringliteral">&#39;modulesToLoad&#39;</span>, <span class="stringliteral">&#39;not an array&#39;</span>);</div>
<div class="line">    var runBlocks = [], moduleFn;</div>
<div class="line">    forEach(modulesToLoad, <span class="keyword">function</span>(module) {</div>
<div class="line">      <span class="keywordflow">if</span> (loadedModules.get(module)) <span class="keywordflow">return</span>;</div>
<div class="line">      loadedModules.put(module, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> runInvokeQueue(queue) {</div>
<div class="line">        var i, ii;</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = queue.length; i &lt; ii; i++) {</div>
<div class="line">          var invokeArgs = queue[i],</div>
<div class="line">              provider = providerInjector.get(invokeArgs[0]);</div>
<div class="line"></div>
<div class="line">          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isString(module)) {</div>
<div class="line">          moduleFn = angularModule(module);</div>
<div class="line">          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);</div>
<div class="line">          runInvokeQueue(moduleFn._invokeQueue);</div>
<div class="line">          runInvokeQueue(moduleFn._configBlocks);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isFunction(module)) {</div>
<div class="line">            runBlocks.push(providerInjector.invoke(module));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(module)) {</div>
<div class="line">            runBlocks.push(providerInjector.invoke(module));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          assertArgFn(module, <span class="stringliteral">&#39;module&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="keywordflow">if</span> (isArray(module)) {</div>
<div class="line">          module = module[module.length - 1];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (e.message &amp;&amp; e.stack &amp;&amp; e.stack.indexOf(e.message) == -1) {</div>
<div class="line">          <span class="comment">// Safari &amp; FF&#39;s stack traces don&#39;t contain error.message content</span></div>
<div class="line">          <span class="comment">// unlike those of Chrome and IE</span></div>
<div class="line">          <span class="comment">// So if stack doesn&#39;t contain message, we create a new string that contains both.</span></div>
<div class="line">          <span class="comment">// Since error.stack is read-only in Safari, I&#39;m overriding e and not e.stack here.</span></div>
<div class="line">          <span class="comment">/* jshint -W022 */</span></div>
<div class="line">          e = e.message + <span class="charliteral">&#39;\n&#39;</span> + e.stack;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;modulerr&#39;</span>, <span class="stringliteral">&quot;Failed to instantiate module {0} due to:\n{1}&quot;</span>,</div>
<div class="line">                  module, e.stack || e.message || e);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> runBlocks;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// internal Injector</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">function</span> createInternalInjector(cache, factory) {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getService(serviceName, caller) {</div>
<div class="line">      <span class="keywordflow">if</span> (cache.hasOwnProperty(serviceName)) {</div>
<div class="line">        <span class="keywordflow">if</span> (cache[serviceName] === INSTANTIATING) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;cdep&#39;</span>, <span class="stringliteral">&#39;Circular dependency found: {0}&#39;</span>,</div>
<div class="line">                    serviceName + <span class="stringliteral">&#39; &lt;- &#39;</span> + path.join(<span class="stringliteral">&#39; &lt;- &#39;</span>));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> cache[serviceName];</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          path.unshift(serviceName);</div>
<div class="line">          cache[serviceName] = INSTANTIATING;</div>
<div class="line">          <span class="keywordflow">return</span> cache[serviceName] = factory(serviceName, caller);</div>
<div class="line">        } <span class="keywordflow">catch</span> (err) {</div>
<div class="line">          <span class="keywordflow">if</span> (cache[serviceName] === INSTANTIATING) {</div>
<div class="line">            <span class="keyword">delete</span> cache[serviceName];</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">throw</span> err;</div>
<div class="line">        } <span class="keywordflow">finally</span> {</div>
<div class="line">          path.shift();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> invoke(fn, <span class="keyword">self</span>, locals, serviceName) {</div>
<div class="line">      <span class="keywordflow">if</span> (typeof locals === <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">        serviceName = locals;</div>
<div class="line">        locals = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var args = [],</div>
<div class="line">          $inject = createInjector.$$annotate(fn, strictDi, serviceName),</div>
<div class="line">          length, i,</div>
<div class="line">          key;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0, length = $inject.length; i &lt; length; i++) {</div>
<div class="line">        key = $inject[i];</div>
<div class="line">        <span class="keywordflow">if</span> (typeof key !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;itkn&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&#39;Incorrect injection token! Expected service name as string, got {0}&#39;</span>, key);</div>
<div class="line">        }</div>
<div class="line">        args.push(</div>
<div class="line">          locals &amp;&amp; locals.hasOwnProperty(key)</div>
<div class="line">          ? locals[key]</div>
<div class="line">          : getService(key, serviceName)</div>
<div class="line">        );</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(fn)) {</div>
<div class="line">        fn = fn[length];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// http://jsperf.com/angularjs-invoke-apply-vs-switch</span></div>
<div class="line">      <span class="comment">// #5388</span></div>
<div class="line">      <span class="keywordflow">return</span> fn.apply(<span class="keyword">self</span>, args);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> instantiate(Type, locals, serviceName) {</div>
<div class="line">      <span class="comment">// Check if Type is annotated and use just the given function at n-1 as parameter</span></div>
<div class="line">      <span class="comment">// e.g. someModule.factory(&#39;greeter&#39;, [&#39;$window&#39;, function(renamed$window) {}]);</span></div>
<div class="line">      <span class="comment">// Object creation: http://jsperf.com/create-constructor/2</span></div>
<div class="line">      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);</div>
<div class="line">      var returnedValue = invoke(Type, instance, locals, serviceName);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      invoke: invoke,</div>
<div class="line">      instantiate: instantiate,</div>
<div class="line">      <span class="keyword">get</span>: getService,</div>
<div class="line">      annotate: createInjector.$$annotate,</div>
<div class="line">      has: <span class="keyword">function</span>(name) {</div>
<div class="line">        <span class="keywordflow">return</span> providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">createInjector.$$annotate = annotate;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $AnchorScrollProvider() {</div>
<div class="line"></div>
<div class="line">  var autoScrollingEnabled = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">  this.disableAutoScrolling = <span class="keyword">function</span>() {</div>
<div class="line">    autoScrollingEnabled = <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$location&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($window, $location, $rootScope) {</div>
<div class="line">    var document = $window.document;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Helper function to get first anchor from a NodeList</span></div>
<div class="line">    <span class="comment">// (using `Array#some()` instead of `angular#forEach()` since it&#39;s more performant</span></div>
<div class="line">    <span class="comment">//  and working in all supported browsers.)</span></div>
<div class="line">    <span class="keyword">function</span> getFirstAnchor(list) {</div>
<div class="line">      var result = null;</div>
<div class="line">      Array.prototype.some.call(list, <span class="keyword">function</span>(element) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodeName_(element) === <span class="charliteral">&#39;a&#39;</span>) {</div>
<div class="line">          result = element;</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getYOffset() {</div>
<div class="line"></div>
<div class="line">      var offset = scroll.yOffset;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(offset)) {</div>
<div class="line">        offset = offset();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isElement(offset)) {</div>
<div class="line">        var elem = offset[0];</div>
<div class="line">        var style = $window.getComputedStyle(elem);</div>
<div class="line">        <span class="keywordflow">if</span> (style.position !== <span class="stringliteral">&#39;fixed&#39;</span>) {</div>
<div class="line">          offset = 0;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          offset = elem.getBoundingClientRect().bottom;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isNumber(offset)) {</div>
<div class="line">        offset = 0;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> offset;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scrollTo(elem) {</div>
<div class="line">      <span class="keywordflow">if</span> (elem) {</div>
<div class="line">        elem.scrollIntoView();</div>
<div class="line"></div>
<div class="line">        var offset = getYOffset();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (offset) {</div>
<div class="line">          <span class="comment">// `offset` is the number of pixels we should scroll UP in order to align `elem` properly.</span></div>
<div class="line">          <span class="comment">// This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the</span></div>
<div class="line">          <span class="comment">// top of the viewport.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// IF the number of pixels from the top of `elem` to the end of the page&#39;s content is less</span></div>
<div class="line">          <span class="comment">// than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some</span></div>
<div class="line">          <span class="comment">// way down the page.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// This is often the case for elements near the bottom of the page.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// In such cases we do not need to scroll the whole `offset` up, just the difference between</span></div>
<div class="line">          <span class="comment">// the top of the element and the offset, which is enough to align the top of `elem` at the</span></div>
<div class="line">          <span class="comment">// desired position.</span></div>
<div class="line">          var elemTop = elem.getBoundingClientRect().top;</div>
<div class="line">          $window.scrollBy(0, elemTop - offset);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        $window.scrollTo(0, 0);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scroll(hash) {</div>
<div class="line">      hash = isString(hash) ? hash : $location.hash();</div>
<div class="line">      var elm;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// empty hash, scroll to the top of the page</span></div>
<div class="line">      <span class="keywordflow">if</span> (!hash) scrollTo(null);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// element with given id</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((elm = document.getElementById(hash))) scrollTo(elm);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// first anchor with given name :-D</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// no element and hash == &#39;top&#39;, scroll to the top of the page</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hash === <span class="stringliteral">&#39;top&#39;</span>) scrollTo(null);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// does not scroll when user clicks on anchor link that is currently on</span></div>
<div class="line">    <span class="comment">// (no url change, no $location.hash() change), browser native does scroll</span></div>
<div class="line">    <span class="keywordflow">if</span> (autoScrollingEnabled) {</div>
<div class="line">      $rootScope.$watch(<span class="keyword">function</span> autoScrollWatch() {<span class="keywordflow">return</span> $location.hash();},</div>
<div class="line">        <span class="keyword">function</span> autoScrollWatchAction(newVal, oldVal) {</div>
<div class="line">          <span class="comment">// skip the initial scroll if $location.hash is empty</span></div>
<div class="line">          <span class="keywordflow">if</span> (newVal === oldVal &amp;&amp; newVal === <span class="stringliteral">&#39;&#39;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          jqLiteDocumentLoaded(<span class="keyword">function</span>() {</div>
<div class="line">            $rootScope.$evalAsync(scroll);</div>
<div class="line">          });</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> scroll;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $animateMinErr = minErr(<span class="stringliteral">&#39;$animate&#39;</span>);</div>
<div class="line">var ELEMENT_NODE = 1;</div>
<div class="line">var NG_ANIMATE_CLASSNAME = <span class="stringliteral">&#39;ng-animate&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> mergeClasses(a,b) {</div>
<div class="line">  <span class="keywordflow">if</span> (!a &amp;&amp; !b) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> b;</div>
<div class="line">  <span class="keywordflow">if</span> (!b) <span class="keywordflow">return</span> a;</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(a)) a = a.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(b)) b = b.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> a + <span class="charliteral">&#39; &#39;</span> + b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> extractElementNode(element) {</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; element.length; i++) {</div>
<div class="line">    var elm = element[i];</div>
<div class="line">    <span class="keywordflow">if</span> (elm.nodeType === ELEMENT_NODE) {</div>
<div class="line">      <span class="keywordflow">return</span> elm;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> splitClasses(classes) {</div>
<div class="line">  <span class="keywordflow">if</span> (isString(classes)) {</div>
<div class="line">    classes = classes.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Use createMap() to prevent class assumptions involving property names in</span></div>
<div class="line">  <span class="comment">// Object.prototype</span></div>
<div class="line">  var obj = createMap();</div>
<div class="line">  forEach(classes, <span class="keyword">function</span>(klass) {</div>
<div class="line">    <span class="comment">// sometimes the split leaves empty string values</span></div>
<div class="line">    <span class="comment">// incase extra spaces were applied to the options</span></div>
<div class="line">    <span class="keywordflow">if</span> (klass.length) {</div>
<div class="line">      obj[klass] = true;</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// if any other type of options value besides an Object value is</span></div>
<div class="line"><span class="comment">// passed into the $animate.method() animation then this helper code</span></div>
<div class="line"><span class="comment">// will be run which will ignore it. While this patch is not the</span></div>
<div class="line"><span class="comment">// greatest solution to this, a lot of existing plugins depend on</span></div>
<div class="line"><span class="comment">// $animate to either call the callback (&lt; 1.2) or return a promise</span></div>
<div class="line"><span class="comment">// that can be changed. This helper function ensures that the options</span></div>
<div class="line"><span class="comment">// are wiped clean incase a callback function is provided.</span></div>
<div class="line"><span class="keyword">function</span> prepareAnimateOptions(options) {</div>
<div class="line">  <span class="keywordflow">return</span> isObject(options)</div>
<div class="line">      ? options</div>
<div class="line">      : {};</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $$CoreAnimateRunnerProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$$rAF&#39;</span>, <span class="keyword">function</span>($q, $$rAF) {</div>
<div class="line">    <span class="keyword">function</span> AnimateRunner() {}</div>
<div class="line">    AnimateRunner.all = noop;</div>
<div class="line">    AnimateRunner.chain = noop;</div>
<div class="line">    AnimateRunner.prototype = {</div>
<div class="line">      end: noop,</div>
<div class="line">      cancel: noop,</div>
<div class="line">      resume: noop,</div>
<div class="line">      pause: noop,</div>
<div class="line">      complete: noop,</div>
<div class="line">      then: <span class="keyword">function</span>(pass, fail) {</div>
<div class="line">        <span class="keywordflow">return</span> $q(<span class="keyword">function</span>(resolve) {</div>
<div class="line">          $$rAF(<span class="keyword">function</span>() {</div>
<div class="line">            resolve();</div>
<div class="line">          });</div>
<div class="line">        }).then(pass, fail);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">return</span> AnimateRunner;</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// this is prefixed with Core since it conflicts with</span></div>
<div class="line"><span class="comment">// the animateQueueProvider defined in ngAnimate/animateQueue.js</span></div>
<div class="line">var $$CoreAnimateQueueProvider = <span class="keyword">function</span>() {</div>
<div class="line">  var postDigestQueue = <span class="keyword">new</span> HashMap();</div>
<div class="line">  var postDigestElements = [];</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$AnimateRunner&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($$AnimateRunner,   $rootScope) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      enabled: noop,</div>
<div class="line">      on: noop,</div>
<div class="line">      off: noop,</div>
<div class="line">      pin: noop,</div>
<div class="line"></div>
<div class="line">      push: <span class="keyword">function</span>(element, event, options, domOperation) {</div>
<div class="line">        domOperation        &amp;&amp; domOperation();</div>
<div class="line"></div>
<div class="line">        options = options || {};</div>
<div class="line">        options.from        &amp;&amp; element.css(options.from);</div>
<div class="line">        options.to          &amp;&amp; element.css(options.to);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (options.addClass || options.removeClass) {</div>
<div class="line">          addRemoveClassesPostDigest(element, options.addClass, options.removeClass);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> $$AnimateRunner(); <span class="comment">// jshint ignore:line</span></div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addRemoveClassesPostDigest(element, add, <span class="keyword">remove</span>) {</div>
<div class="line">      var classVal, data = postDigestQueue.get(element);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!data) {</div>
<div class="line">        postDigestQueue.put(element, data = {});</div>
<div class="line">        postDigestElements.push(element);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var updateData = <span class="keyword">function</span>(classes, value) {</div>
<div class="line">        var changed = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (classes) {</div>
<div class="line">          classes = isString(classes) ? classes.split(<span class="charliteral">&#39; &#39;</span>) :</div>
<div class="line">                    isArray(classes) ? classes : [];</div>
<div class="line">          forEach(classes, <span class="keyword">function</span>(className) {</div>
<div class="line">            <span class="keywordflow">if</span> (className) {</div>
<div class="line">              changed = <span class="keyword">true</span>;</div>
<div class="line">              data[className] = value;</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> changed;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var classesAdded = updateData(add, <span class="keyword">true</span>);</div>
<div class="line">      var classesRemoved = updateData(<span class="keyword">remove</span>, <span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">if</span> ((!classesAdded &amp;&amp; !classesRemoved) || postDigestElements.length &gt; 1) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      $rootScope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">        forEach(postDigestElements, <span class="keyword">function</span>(element) {</div>
<div class="line">          var data = postDigestQueue.get(element);</div>
<div class="line">          <span class="keywordflow">if</span> (data) {</div>
<div class="line">            var existing = splitClasses(element.attr(<span class="stringliteral">&#39;class&#39;</span>));</div>
<div class="line">            var toAdd = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">            var toRemove = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">            forEach(data, <span class="keyword">function</span>(status, className) {</div>
<div class="line">              var hasClass = !!existing[className];</div>
<div class="line">              <span class="keywordflow">if</span> (status !== hasClass) {</div>
<div class="line">                <span class="keywordflow">if</span> (status) {</div>
<div class="line">                  toAdd += (toAdd.length ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + className;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  toRemove += (toRemove.length ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + className;</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line"></div>
<div class="line">            forEach(element, <span class="keyword">function</span>(elm) {</div>
<div class="line">              toAdd    &amp;&amp; jqLiteAddClass(elm, toAdd);</div>
<div class="line">              toRemove &amp;&amp; jqLiteRemoveClass(elm, toRemove);</div>
<div class="line">            });</div>
<div class="line">            postDigestQueue.remove(element);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        postDigestElements.length = 0;</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var $AnimateProvider = [<span class="stringliteral">&#39;$provide&#39;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">  var provider = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.$$registeredAnimations = Object.create(null);</div>
<div class="line"></div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">function</span>(name, factory) {</div>
<div class="line">    <span class="keywordflow">if</span> (name &amp;&amp; name.charAt(0) !== <span class="charliteral">&#39;.&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">throw</span> $animateMinErr(<span class="stringliteral">&#39;notcsel&#39;</span>, <span class="stringliteral">&quot;Expecting class selector starting with &#39;.&#39; got &#39;{0}&#39;.&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var key = name + <span class="stringliteral">&#39;-animation&#39;</span>;</div>
<div class="line">    provider.$$registeredAnimations[name.substr(1)] = key;</div>
<div class="line">    $provide.factory(key, factory);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.classNameFilter = <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length === 1) {</div>
<div class="line">      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;</div>
<div class="line">      <span class="keywordflow">if</span> (this.$$classNameFilter) {</div>
<div class="line">        var reservedRegex = <span class="keyword">new</span> RegExp(<span class="stringliteral">&quot;(\\s+|\\/)&quot;</span> + NG_ANIMATE_CLASSNAME + <span class="stringliteral">&quot;(\\s+|\\/)&quot;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (reservedRegex.test(<span class="keyword">this</span>.$$classNameFilter.toString())) {</div>
<div class="line">          <span class="keywordflow">throw</span> $animateMinErr(<span class="stringliteral">&#39;nongcls&#39;</span>,<span class="stringliteral">&#39;$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the &quot;{0}&quot; CSS class.&#39;</span>, NG_ANIMATE_CLASSNAME);</div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.$$classNameFilter;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$animateQueue&#39;</span>, <span class="keyword">function</span>($$animateQueue) {</div>
<div class="line">    <span class="keyword">function</span> domInsert(element, parentElement, afterElement) {</div>
<div class="line">      <span class="comment">// if for some reason the previous element was removed</span></div>
<div class="line">      <span class="comment">// from the dom sometime before this code runs then let&#39;s</span></div>
<div class="line">      <span class="comment">// just stick to using the parent element as the anchor</span></div>
<div class="line">      <span class="keywordflow">if</span> (afterElement) {</div>
<div class="line">        var afterNode = extractElementNode(afterElement);</div>
<div class="line">        <span class="keywordflow">if</span> (afterNode &amp;&amp; !afterNode.parentNode &amp;&amp; !afterNode.previousElementSibling) {</div>
<div class="line">          afterElement = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      afterElement ? afterElement.after(element) : parentElement.prepend(element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      <span class="comment">// we don&#39;t call it directly since non-existant arguments may</span></div>
<div class="line">      <span class="comment">// be interpreted as null within the sub enabled function</span></div>
<div class="line"></div>
<div class="line">      on: $$animateQueue.on,</div>
<div class="line"></div>
<div class="line">      off: $$animateQueue.off,</div>
<div class="line"></div>
<div class="line">      pin: $$animateQueue.pin,</div>
<div class="line"></div>
<div class="line">      enabled: $$animateQueue.enabled,</div>
<div class="line"></div>
<div class="line">      cancel: <span class="keyword">function</span>(runner) {</div>
<div class="line">        runner.end &amp;&amp; runner.end();</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      enter: <span class="keyword">function</span>(element, parent, after, options) {</div>
<div class="line">        parent = parent &amp;&amp; jqLite(parent);</div>
<div class="line">        after = after &amp;&amp; jqLite(after);</div>
<div class="line">        parent = parent || after.parent();</div>
<div class="line">        domInsert(element, parent, after);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;enter&#39;</span>, prepareAnimateOptions(options));</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      move: <span class="keyword">function</span>(element, parent, after, options) {</div>
<div class="line">        parent = parent &amp;&amp; jqLite(parent);</div>
<div class="line">        after = after &amp;&amp; jqLite(after);</div>
<div class="line">        parent = parent || after.parent();</div>
<div class="line">        domInsert(element, parent, after);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;move&#39;</span>, prepareAnimateOptions(options));</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      leave: <span class="keyword">function</span>(element, options) {</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;leave&#39;</span>, prepareAnimateOptions(options), <span class="keyword">function</span>() {</div>
<div class="line">          element.remove();</div>
<div class="line">        });</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      addClass: <span class="keyword">function</span>(element, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.addClass = mergeClasses(options.addclass, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;addClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      removeClass: <span class="keyword">function</span>(element, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.removeClass = mergeClasses(options.removeClass, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;removeClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      setClass: <span class="keyword">function</span>(element, add, <span class="keyword">remove</span>, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.addClass = mergeClasses(options.addClass, add);</div>
<div class="line">        options.removeClass = mergeClasses(options.removeClass, <span class="keyword">remove</span>);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;setClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      animate: <span class="keyword">function</span>(element, from, to, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.from = options.from ? extend(options.from, from) : from;</div>
<div class="line">        options.to   = options.to   ? extend(options.to, to)     : to;</div>
<div class="line"></div>
<div class="line">        className = className || <span class="stringliteral">&#39;ng-inline-animate&#39;</span>;</div>
<div class="line">        options.tempClasses = mergeClasses(options.tempClasses, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;animate&#39;</span>, options);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var $CoreAnimateCssProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$rAF&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="keyword">function</span>($$rAF, $q) {</div>
<div class="line"></div>
<div class="line">    var RAFPromise = <span class="keyword">function</span>() {};</div>
<div class="line">    RAFPromise.prototype = {</div>
<div class="line">      done: <span class="keyword">function</span>(cancel) {</div>
<div class="line">        this.defer &amp;&amp; this.defer[cancel === <span class="keyword">true</span> ? <span class="stringliteral">&#39;reject&#39;</span> : <span class="stringliteral">&#39;resolve&#39;</span>]();</div>
<div class="line">      },</div>
<div class="line">      end: <span class="keyword">function</span>() {</div>
<div class="line">        this.done();</div>
<div class="line">      },</div>
<div class="line">      cancel: <span class="keyword">function</span>() {</div>
<div class="line">        this.done(<span class="keyword">true</span>);</div>
<div class="line">      },</div>
<div class="line">      getPromise: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!this.defer) {</div>
<div class="line">          this.defer = $q.defer();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> this.defer.promise;</div>
<div class="line">      },</div>
<div class="line">      then: <span class="keyword">function</span>(f1,f2) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().then(f1,f2);</div>
<div class="line">      },</div>
<div class="line">      <span class="stringliteral">&#39;catch&#39;</span>: <span class="keyword">function</span>(f1) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().catch(f1);</div>
<div class="line">      },</div>
<div class="line">      <span class="stringliteral">&#39;finally&#39;</span>: <span class="keyword">function</span>(f1) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().finally(f1);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(element, options) {</div>
<div class="line">      <span class="keywordflow">if</span> (options.from) {</div>
<div class="line">        element.css(options.from);</div>
<div class="line">        options.from = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var closed, runner = <span class="keyword">new</span> RAFPromise();</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        start: run,</div>
<div class="line">        end: run</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> run() {</div>
<div class="line">        $$rAF(<span class="keyword">function</span>() {</div>
<div class="line">          close();</div>
<div class="line">          <span class="keywordflow">if</span> (!closed) {</div>
<div class="line">            runner.done();</div>
<div class="line">          }</div>
<div class="line">          closed = <span class="keyword">true</span>;</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> runner;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> close() {</div>
<div class="line">        <span class="keywordflow">if</span> (options.addClass) {</div>
<div class="line">          element.addClass(options.addClass);</div>
<div class="line">          options.addClass = null;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (options.removeClass) {</div>
<div class="line">          element.removeClass(options.removeClass);</div>
<div class="line">          options.removeClass = null;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (options.to) {</div>
<div class="line">          element.css(options.to);</div>
<div class="line">          options.to = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global stripHash: true */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Browser(window, document, $log, $sniffer) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">      rawDocument = document[0],</div>
<div class="line">      location = window.location,</div>
<div class="line">      history = window.history,</div>
<div class="line">      setTimeout = window.setTimeout,</div>
<div class="line">      clearTimeout = window.clearTimeout,</div>
<div class="line">      pendingDeferIds = {};</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.isMock = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  var outstandingRequestCount = 0;</div>
<div class="line">  var outstandingRequestCallbacks = [];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// TODO(vojta): remove this temporary api</span></div>
<div class="line">  <span class="keyword">self</span>.$$completeOutstandingRequest = completeOutstandingRequest;</div>
<div class="line">  <span class="keyword">self</span>.$$incOutstandingRequestCount = <span class="keyword">function</span>() { outstandingRequestCount++; };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> completeOutstandingRequest(fn) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      fn.apply(null, sliceArgs(arguments, 1));</div>
<div class="line">    } <span class="keywordflow">finally</span> {</div>
<div class="line">      outstandingRequestCount--;</div>
<div class="line">      <span class="keywordflow">if</span> (outstandingRequestCount === 0) {</div>
<div class="line">        <span class="keywordflow">while</span> (outstandingRequestCallbacks.length) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            outstandingRequestCallbacks.pop()();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $log.error(e);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getHash(url) {</div>
<div class="line">    var index = url.indexOf(<span class="charliteral">&#39;#&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> index === -1 ? <span class="stringliteral">&#39;&#39;</span> : url.substr(index);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.notifyWhenNoOutstandingRequests = <span class="keyword">function</span>(callback) {</div>
<div class="line">    <span class="keywordflow">if</span> (outstandingRequestCount === 0) {</div>
<div class="line">      callback();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      outstandingRequestCallbacks.push(callback);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// URL API</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  var cachedState, lastHistoryState,</div>
<div class="line">      lastBrowserUrl = location.href,</div>
<div class="line">      baseElement = document.find(<span class="stringliteral">&#39;base&#39;</span>),</div>
<div class="line">      reloadLocation = null;</div>
<div class="line"></div>
<div class="line">  cacheState();</div>
<div class="line">  lastHistoryState = cachedState;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.url = <span class="keyword">function</span>(url, replace, state) {</div>
<div class="line">    <span class="comment">// In modern browsers `history.state` is `null` by default; treating it separately</span></div>
<div class="line">    <span class="comment">// from `undefined` would cause `$browser.url(&#39;/foo&#39;)` to change `history.state`</span></div>
<div class="line">    <span class="comment">// to undefined via `pushState`. Instead, let&#39;s change `undefined` to `null` here.</span></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(state)) {</div>
<div class="line">      state = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Android Browser BFCache causes location, history reference to become stale.</span></div>
<div class="line">    <span class="keywordflow">if</span> (location !== window.location) location = window.location;</div>
<div class="line">    <span class="keywordflow">if</span> (history !== window.history) history = window.history;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// setter</span></div>
<div class="line">    <span class="keywordflow">if</span> (url) {</div>
<div class="line">      var sameState = lastHistoryState === state;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Don&#39;t change anything if previous and current URLs and states match. This also prevents</span></div>
<div class="line">      <span class="comment">// IE&lt;10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.</span></div>
<div class="line">      <span class="comment">// See https://github.com/angular/angular.js/commit/ffb2701</span></div>
<div class="line">      <span class="keywordflow">if</span> (lastBrowserUrl === url &amp;&amp; (!$sniffer.history || sameState)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">self</span>;</div>
<div class="line">      }</div>
<div class="line">      var sameBase = lastBrowserUrl &amp;&amp; stripHash(lastBrowserUrl) === stripHash(url);</div>
<div class="line">      lastBrowserUrl = url;</div>
<div class="line">      lastHistoryState = state;</div>
<div class="line">      <span class="comment">// Don&#39;t use history API if only the hash changed</span></div>
<div class="line">      <span class="comment">// due to a bug in IE10/IE11 which leads</span></div>
<div class="line">      <span class="comment">// to not firing a `hashchange` nor `popstate` event</span></div>
<div class="line">      <span class="comment">// in some cases (see #9143).</span></div>
<div class="line">      <span class="keywordflow">if</span> ($sniffer.history &amp;&amp; (!sameBase || !sameState)) {</div>
<div class="line">        history[replace ? <span class="stringliteral">&#39;replaceState&#39;</span> : <span class="stringliteral">&#39;pushState&#39;</span>](state, <span class="stringliteral">&#39;&#39;</span>, url);</div>
<div class="line">        cacheState();</div>
<div class="line">        <span class="comment">// Do the assignment again so that those two variables are referentially identical.</span></div>
<div class="line">        lastHistoryState = cachedState;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (!sameBase || reloadLocation) {</div>
<div class="line">          reloadLocation = url;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (replace) {</div>
<div class="line">          location.replace(url);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sameBase) {</div>
<div class="line">          location.href = url;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          location.hash = getHash(url);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">self</span>;</div>
<div class="line">    <span class="comment">// getter</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// - reloadLocation is needed as browsers don&#39;t allow to read out</span></div>
<div class="line">      <span class="comment">//   the new location.href if a reload happened.</span></div>
<div class="line">      <span class="comment">// - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172</span></div>
<div class="line">      <span class="keywordflow">return</span> reloadLocation || location.href.replace(/%27/g,<span class="stringliteral">&quot;&#39;&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.state = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> cachedState;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var urlChangeListeners = [],</div>
<div class="line">      urlChangeInit = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> cacheStateAndFireUrlChange() {</div>
<div class="line">    cacheState();</div>
<div class="line">    fireUrlChange();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getCurrentState() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">return</span> history.state;</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="comment">// MSIE can reportedly throw when there is no state (UNCONFIRMED).</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// This variable should be used *only* inside the cacheState function.</span></div>
<div class="line">  var lastCachedState = null;</div>
<div class="line">  <span class="keyword">function</span> cacheState() {</div>
<div class="line">    <span class="comment">// This should be the only place in $browser where `history.state` is read.</span></div>
<div class="line">    cachedState = getCurrentState();</div>
<div class="line">    cachedState = isUndefined(cachedState) ? null : cachedState;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prevent callbacks fo fire twice if both hashchange &amp; popstate were fired.</span></div>
<div class="line">    <span class="keywordflow">if</span> (equals(cachedState, lastCachedState)) {</div>
<div class="line">      cachedState = lastCachedState;</div>
<div class="line">    }</div>
<div class="line">    lastCachedState = cachedState;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> fireUrlChange() {</div>
<div class="line">    <span class="keywordflow">if</span> (lastBrowserUrl === <span class="keyword">self</span>.url() &amp;&amp; lastHistoryState === cachedState) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    lastBrowserUrl = <span class="keyword">self</span>.url();</div>
<div class="line">    lastHistoryState = cachedState;</div>
<div class="line">    forEach(urlChangeListeners, <span class="keyword">function</span>(listener) {</div>
<div class="line">      listener(<span class="keyword">self</span>.url(), cachedState);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.onUrlChange = <span class="keyword">function</span>(callback) {</div>
<div class="line">    <span class="comment">// TODO(vojta): refactor to use node&#39;s syntax for events</span></div>
<div class="line">    <span class="keywordflow">if</span> (!urlChangeInit) {</div>
<div class="line">      <span class="comment">// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)</span></div>
<div class="line">      <span class="comment">// don&#39;t fire popstate when user change the address bar and don&#39;t fire hashchange when url</span></div>
<div class="line">      <span class="comment">// changed by push/replaceState</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// html5 history api - popstate event</span></div>
<div class="line">      <span class="keywordflow">if</span> ($sniffer.history) jqLite(window).on(<span class="stringliteral">&#39;popstate&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line">      <span class="comment">// hashchange event</span></div>
<div class="line">      jqLite(window).on(<span class="stringliteral">&#39;hashchange&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line"></div>
<div class="line">      urlChangeInit = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    urlChangeListeners.push(callback);</div>
<div class="line">    <span class="keywordflow">return</span> callback;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.$$applicationDestroyed = <span class="keyword">function</span>() {</div>
<div class="line">    jqLite(window).off(<span class="stringliteral">&#39;hashchange popstate&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.$$checkUrlChange = fireUrlChange;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Misc API</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">self</span>.baseHref = <span class="keyword">function</span>() {</div>
<div class="line">    var href = baseElement.attr(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> href ? href.replace(/^(https?\:)?\/\/[^\/]*/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.defer = <span class="keyword">function</span>(fn, delay) {</div>
<div class="line">    var timeoutId;</div>
<div class="line">    outstandingRequestCount++;</div>
<div class="line">    timeoutId = setTimeout(<span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">delete</span> pendingDeferIds[timeoutId];</div>
<div class="line">      completeOutstandingRequest(fn);</div>
<div class="line">    }, delay || 0);</div>
<div class="line">    pendingDeferIds[timeoutId] = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> timeoutId;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.defer.cancel = <span class="keyword">function</span>(deferId) {</div>
<div class="line">    <span class="keywordflow">if</span> (pendingDeferIds[deferId]) {</div>
<div class="line">      <span class="keyword">delete</span> pendingDeferIds[deferId];</div>
<div class="line">      clearTimeout(deferId);</div>
<div class="line">      completeOutstandingRequest(noop);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $BrowserProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$log&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $log, $sniffer, $document) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Browser($window, $document, $log, $sniffer);</div>
<div class="line">      }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $CacheFactoryProvider() {</div>
<div class="line"></div>
<div class="line">  this.$get = <span class="keyword">function</span>() {</div>
<div class="line">    var caches = {};</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> cacheFactory(cacheId, options) {</div>
<div class="line">      <span class="keywordflow">if</span> (cacheId in caches) {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;$cacheFactory&#39;</span>)(<span class="stringliteral">&#39;iid&#39;</span>, <span class="stringliteral">&quot;CacheId &#39;{0}&#39; is already taken!&quot;</span>, cacheId);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var size = 0,</div>
<div class="line">          stats = extend({}, options, {<span class="keywordtype">id</span>: cacheId}),</div>
<div class="line">          data = {},</div>
<div class="line">          capacity = (options &amp;&amp; options.capacity) || Number.MAX_VALUE,</div>
<div class="line">          lruHash = {},</div>
<div class="line">          freshEnd = null,</div>
<div class="line">          staleEnd = null;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> caches[cacheId] = {</div>
<div class="line"></div>
<div class="line">        put: <span class="keyword">function</span>(key, value) {</div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(value)) <span class="keywordflow">return</span>;</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key] || (lruHash[key] = {key: key});</div>
<div class="line"></div>
<div class="line">            refresh(lruEntry);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!(key in data)) size++;</div>
<div class="line">          data[key] = value;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (size &gt; capacity) {</div>
<div class="line">            this.<span class="keyword">remove</span>(staleEnd.key);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> value;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!lruEntry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            refresh(lruEntry);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> data[key];</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keyword">remove</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!lruEntry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (lruEntry == freshEnd) freshEnd = lruEntry.p;</div>
<div class="line">            <span class="keywordflow">if</span> (lruEntry == staleEnd) staleEnd = lruEntry.n;</div>
<div class="line">            link(lruEntry.n,lruEntry.p);</div>
<div class="line"></div>
<div class="line">            <span class="keyword">delete</span> lruHash[key];</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keyword">delete</span> data[key];</div>
<div class="line">          size--;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        removeAll: <span class="keyword">function</span>() {</div>
<div class="line">          data = {};</div>
<div class="line">          size = 0;</div>
<div class="line">          lruHash = {};</div>
<div class="line">          freshEnd = staleEnd = null;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        destroy: <span class="keyword">function</span>() {</div>
<div class="line">          data = null;</div>
<div class="line">          stats = null;</div>
<div class="line">          lruHash = null;</div>
<div class="line">          <span class="keyword">delete</span> caches[cacheId];</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        info: <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> extend({}, stats, {size: size});</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> refresh(entry) {</div>
<div class="line">        <span class="keywordflow">if</span> (entry != freshEnd) {</div>
<div class="line">          <span class="keywordflow">if</span> (!staleEnd) {</div>
<div class="line">            staleEnd = entry;</div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (staleEnd == entry) {</div>
<div class="line">            staleEnd = entry.n;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          link(entry.n, entry.p);</div>
<div class="line">          link(entry, freshEnd);</div>
<div class="line">          freshEnd = entry;</div>
<div class="line">          freshEnd.n = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> link(nextEntry, prevEntry) {</div>
<div class="line">        <span class="keywordflow">if</span> (nextEntry != prevEntry) {</div>
<div class="line">          <span class="keywordflow">if</span> (nextEntry) nextEntry.p = prevEntry; <span class="comment">//p stands for previous, &#39;prev&#39; didn&#39;t minify</span></div>
<div class="line">          <span class="keywordflow">if</span> (prevEntry) prevEntry.n = nextEntry; <span class="comment">//n stands for next, &#39;next&#39; didn&#39;t minify</span></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    cacheFactory.info = <span class="keyword">function</span>() {</div>
<div class="line">      var info = {};</div>
<div class="line">      forEach(caches, <span class="keyword">function</span>(cache, cacheId) {</div>
<div class="line">        info[cacheId] = cache.info();</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> info;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    cacheFactory.get = <span class="keyword">function</span>(cacheId) {</div>
<div class="line">      <span class="keywordflow">return</span> caches[cacheId];</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cacheFactory;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TemplateCacheProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$cacheFactory&#39;</span>, <span class="keyword">function</span>($cacheFactory) {</div>
<div class="line">    <span class="keywordflow">return</span> $cacheFactory(<span class="stringliteral">&#39;templates&#39;</span>);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * DOM-related variables:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * - &quot;node&quot; - DOM Node</span></div>
<div class="line"><span class="comment"> * - &quot;element&quot; - DOM Element or Node</span></div>
<div class="line"><span class="comment"> * - &quot;$node&quot; or &quot;$element&quot; - jqLite-wrapped node or element</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Compiler related stuff:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * - &quot;linkFn&quot; - linking fn of a single directive</span></div>
<div class="line"><span class="comment"> * - &quot;nodeLinkFn&quot; - function that aggregates all linking fns for a particular node</span></div>
<div class="line"><span class="comment"> * - &quot;childLinkFn&quot; -  function that aggregates all linking fns for child nodes of a particular node</span></div>
<div class="line"><span class="comment"> * - &quot;compositeLinkFn&quot; - function that aggregates all linking fns for a compilation root (nodeList)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var $compileMinErr = minErr(<span class="stringliteral">&#39;$compile&#39;</span>);</div>
<div class="line"></div>
<div class="line">$CompileProvider.$inject = [<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;$$sanitizeUriProvider&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> $CompileProvider($provide, $$sanitizeUriProvider) {</div>
<div class="line">  var hasDirectives = {},</div>
<div class="line">      Suffix = <span class="stringliteral">&#39;Directive&#39;</span>,</div>
<div class="line">      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,</div>
<div class="line">      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,</div>
<div class="line">      ALL_OR_NOTHING_ATTRS = makeMap(<span class="stringliteral">&#39;ngSrc,ngSrcset,src,srcset&#39;</span>),</div>
<div class="line">      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes</span></div>
<div class="line">  <span class="comment">// The assumption is that future DOM event attribute names will begin with</span></div>
<div class="line">  <span class="comment">// &#39;on&#39; and be composed of only English letters.</span></div>
<div class="line">  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseIsolateBindings(scope, directiveName, isController) {</div>
<div class="line">    var LOCAL_REGEXP = /^\s*([@&amp;]|=(\*?))(\??)\s*(\w*)\s*$/;</div>
<div class="line"></div>
<div class="line">    var bindings = {};</div>
<div class="line"></div>
<div class="line">    forEach(scope, <span class="keyword">function</span>(definition, scopeName) {</div>
<div class="line">      var match = definition.match(LOCAL_REGEXP);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;iscp&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Invalid {3} for directive &#39;{0}&#39;.&quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot; Definition: {... {1}: &#39;{2}&#39; ...}&quot;</span>,</div>
<div class="line">            directiveName, scopeName, definition,</div>
<div class="line">            (isController ? <span class="stringliteral">&quot;controller bindings definition&quot;</span> :</div>
<div class="line">            <span class="stringliteral">&quot;isolate scope definition&quot;</span>));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      bindings[scopeName] = {</div>
<div class="line">        mode: match[1][0],</div>
<div class="line">        collection: match[2] === <span class="charliteral">&#39;*&#39;</span>,</div>
<div class="line">        optional: match[3] === <span class="charliteral">&#39;?&#39;</span>,</div>
<div class="line">        attrName: match[4] || scopeName</div>
<div class="line">      };</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bindings;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseDirectiveBindings(directive, directiveName) {</div>
<div class="line">    var bindings = {</div>
<div class="line">      isolateScope: null,</div>
<div class="line">      bindToController: null</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(directive.scope)) {</div>
<div class="line">      <span class="keywordflow">if</span> (directive.bindToController === <span class="keyword">true</span>) {</div>
<div class="line">        bindings.bindToController = parseIsolateBindings(directive.scope,</div>
<div class="line">                                                         directiveName, <span class="keyword">true</span>);</div>
<div class="line">        bindings.isolateScope = {};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        bindings.isolateScope = parseIsolateBindings(directive.scope,</div>
<div class="line">                                                     directiveName, <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(directive.bindToController)) {</div>
<div class="line">      bindings.bindToController =</div>
<div class="line">          parseIsolateBindings(directive.bindToController, directiveName, <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(bindings.bindToController)) {</div>
<div class="line">      var controller = directive.controller;</div>
<div class="line">      var controllerAs = directive.controllerAs;</div>
<div class="line">      <span class="keywordflow">if</span> (!controller) {</div>
<div class="line">        <span class="comment">// There is no controller, there may or may not be a controllerAs property</span></div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;noctrl&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&quot;Cannot bind to controller without directive &#39;{0}&#39;s controller.&quot;</span>,</div>
<div class="line">              directiveName);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!identifierForController(controller, controllerAs)) {</div>
<div class="line">        <span class="comment">// There is a controller, but no identifier or controllerAs property</span></div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;noident&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&quot;Cannot bind to controller without identifier for directive &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">              directiveName);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> bindings;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> assertValidDirectiveName(name) {</div>
<div class="line">    var letter = name.charAt(0);</div>
<div class="line">    <span class="keywordflow">if</span> (!letter || letter !== lowercase(letter)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;baddir&#39;</span>, <span class="stringliteral">&quot;Directive name &#39;{0}&#39; is invalid. The first character must be a lowercase letter&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (name !== name.trim()) {</div>
<div class="line">      <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;baddir&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Directive name &#39;{0}&#39; is invalid. The name should not contain leading or trailing whitespaces&quot;</span>,</div>
<div class="line">            name);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">   this.directive = <span class="keyword">function</span> registerDirective(name, directiveFactory) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;directive&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isString(name)) {</div>
<div class="line">      assertValidDirectiveName(name);</div>
<div class="line">      assertArg(directiveFactory, <span class="stringliteral">&#39;directiveFactory&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (!hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        hasDirectives[name] = [];</div>
<div class="line">        $provide.factory(name + Suffix, [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>,</div>
<div class="line">          <span class="keyword">function</span>($injector, $exceptionHandler) {</div>
<div class="line">            var directives = [];</div>
<div class="line">            forEach(hasDirectives[name], <span class="keyword">function</span>(directiveFactory, index) {</div>
<div class="line">              <span class="keywordflow">try</span> {</div>
<div class="line">                var directive = $injector.invoke(directiveFactory);</div>
<div class="line">                <span class="keywordflow">if</span> (isFunction(directive)) {</div>
<div class="line">                  directive = { compile: valueFn(directive) };</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!directive.compile &amp;&amp; directive.link) {</div>
<div class="line">                  directive.compile = valueFn(directive.link);</div>
<div class="line">                }</div>
<div class="line">                directive.priority = directive.priority || 0;</div>
<div class="line">                directive.index = index;</div>
<div class="line">                directive.name = directive.name || name;</div>
<div class="line">                directive.require = directive.require || (directive.controller &amp;&amp; directive.name);</div>
<div class="line">                directive.restrict = directive.restrict || <span class="stringliteral">&#39;EA&#39;</span>;</div>
<div class="line">                var bindings = directive.$$bindings =</div>
<div class="line">                    parseDirectiveBindings(directive, directive.name);</div>
<div class="line">                <span class="keywordflow">if</span> (isObject(bindings.isolateScope)) {</div>
<div class="line">                  directive.$$isolateBindings = bindings.isolateScope;</div>
<div class="line">                }</div>
<div class="line">                directive.$$moduleName = directiveFactory.$$moduleName;</div>
<div class="line">                directives.push(directive);</div>
<div class="line">              } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">                $exceptionHandler(e);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            <span class="keywordflow">return</span> directives;</div>
<div class="line">          }]);</div>
<div class="line">      }</div>
<div class="line">      hasDirectives[name].push(directiveFactory);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      forEach(name, reverseParams(registerDirective));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.aHrefSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $$sanitizeUriProvider.aHrefSanitizationWhitelist();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.imgSrcSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $$sanitizeUriProvider.imgSrcSanitizationWhitelist();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var debugInfoEnabled = <span class="keyword">true</span>;</div>
<div class="line">  this.debugInfoEnabled = <span class="keyword">function</span>(enabled) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(enabled)) {</div>
<div class="line">      debugInfoEnabled = enabled;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> debugInfoEnabled;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [</div>
<div class="line">            <span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$templateRequest&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;$controller&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>, <span class="stringliteral">&#39;$sce&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$$sanitizeUri&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,</div>
<div class="line">             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {</div>
<div class="line"></div>
<div class="line">    var Attributes = <span class="keyword">function</span>(element, attributesToCopy) {</div>
<div class="line">      <span class="keywordflow">if</span> (attributesToCopy) {</div>
<div class="line">        var keys = Object.keys(attributesToCopy);</div>
<div class="line">        var i, l, key;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, l = keys.length; i &lt; l; i++) {</div>
<div class="line">          key = keys[i];</div>
<div class="line">          <span class="keyword">this</span>[key] = attributesToCopy[key];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.$attr = {};</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      this.$$element = element;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    Attributes.prototype = {</div>
<div class="line">      $normalize: directiveNormalize,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $addClass: <span class="keyword">function</span>(classVal) {</div>
<div class="line">        <span class="keywordflow">if</span> (classVal &amp;&amp; classVal.length &gt; 0) {</div>
<div class="line">          $animate.addClass(this.$$element, classVal);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $removeClass: <span class="keyword">function</span>(classVal) {</div>
<div class="line">        <span class="keywordflow">if</span> (classVal &amp;&amp; classVal.length &gt; 0) {</div>
<div class="line">          $animate.removeClass(this.$$element, classVal);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $updateClass: <span class="keyword">function</span>(newClasses, oldClasses) {</div>
<div class="line">        var toAdd = tokenDifference(newClasses, oldClasses);</div>
<div class="line">        <span class="keywordflow">if</span> (toAdd &amp;&amp; toAdd.length) {</div>
<div class="line">          $animate.addClass(this.$$element, toAdd);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var toRemove = tokenDifference(oldClasses, newClasses);</div>
<div class="line">        <span class="keywordflow">if</span> (toRemove &amp;&amp; toRemove.length) {</div>
<div class="line">          $animate.removeClass(this.$$element, toRemove);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $set: <span class="keyword">function</span>(key, value, writeAttr, attrName) {</div>
<div class="line">        <span class="comment">// TODO: decide whether or not to throw an error if &quot;class&quot;</span></div>
<div class="line">        <span class="comment">//is set through this function since it may cause $updateClass to</span></div>
<div class="line">        <span class="comment">//become unstable.</span></div>
<div class="line"></div>
<div class="line">        var node = this.$$element[0],</div>
<div class="line">            booleanKey = getBooleanAttrName(node, key),</div>
<div class="line">            aliasedKey = getAliasedAttrName(node, key),</div>
<div class="line">            observer = key,</div>
<div class="line">            nodeName;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (booleanKey) {</div>
<div class="line">          this.$$element.prop(key, value);</div>
<div class="line">          attrName = booleanKey;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aliasedKey) {</div>
<div class="line">          <span class="keyword">this</span>[aliasedKey] = value;</div>
<div class="line">          observer = aliasedKey;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">this</span>[key] = value;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// translate normalized key to actual key</span></div>
<div class="line">        <span class="keywordflow">if</span> (attrName) {</div>
<div class="line">          this.$attr[key] = attrName;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          attrName = this.$attr[key];</div>
<div class="line">          <span class="keywordflow">if</span> (!attrName) {</div>
<div class="line">            this.$attr[key] = attrName = snake_case(key, <span class="charliteral">&#39;-&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        nodeName = nodeName_(this.$$element);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ((nodeName === <span class="charliteral">&#39;a&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;href&#39;</span>) ||</div>
<div class="line">            (nodeName === <span class="stringliteral">&#39;img&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;src&#39;</span>)) {</div>
<div class="line">          <span class="comment">// sanitize a[href] and img[src] values</span></div>
<div class="line">          <span class="keyword">this</span>[key] = value = $$sanitizeUri(value, key === <span class="stringliteral">&#39;src&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nodeName === <span class="stringliteral">&#39;img&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;srcset&#39;</span>) {</div>
<div class="line">          <span class="comment">// sanitize img[srcset] values</span></div>
<div class="line">          var result = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// first check if there are spaces because it&#39;s not the same pattern</span></div>
<div class="line">          var trimmedSrcset = trim(value);</div>
<div class="line">          <span class="comment">//                (   999x   ,|   999w   ,|   ,|,   )</span></div>
<div class="line">          var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;</div>
<div class="line">          var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// split srcset into tuple of uri and descriptor except for the last item</span></div>
<div class="line">          var rawUris = trimmedSrcset.split(pattern);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// for each tuples</span></div>
<div class="line">          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; nbrUrisWith2parts; i++) {</div>
<div class="line">            var innerIdx = i * 2;</div>
<div class="line">            <span class="comment">// sanitize the uri</span></div>
<div class="line">            result += $$sanitizeUri(trim(rawUris[innerIdx]), <span class="keyword">true</span>);</div>
<div class="line">            <span class="comment">// add the descriptor</span></div>
<div class="line">            result += (<span class="stringliteral">&quot; &quot;</span> + trim(rawUris[innerIdx + 1]));</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// split the last item into uri and descriptor</span></div>
<div class="line">          var lastTuple = trim(rawUris[i * 2]).split(/\s/);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// sanitize the last uri</span></div>
<div class="line">          result += $$sanitizeUri(trim(lastTuple[0]), <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// and add the last descriptor if any</span></div>
<div class="line">          <span class="keywordflow">if</span> (lastTuple.length === 2) {</div>
<div class="line">            result += (<span class="stringliteral">&quot; &quot;</span> + trim(lastTuple[1]));</div>
<div class="line">          }</div>
<div class="line">          <span class="keyword">this</span>[key] = value = result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (writeAttr !== <span class="keyword">false</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (value === null || value === undefined) {</div>
<div class="line">            this.$$element.removeAttr(attrName);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            this.$$element.attr(attrName, value);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fire observers</span></div>
<div class="line">        var $$observers = this.$$observers;</div>
<div class="line">        $$observers &amp;&amp; forEach($$observers[observer], <span class="keyword">function</span>(fn) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            fn(value);</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $observe: <span class="keyword">function</span>(key, fn) {</div>
<div class="line">        var attrs = <span class="keyword">this</span>,</div>
<div class="line">            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),</div>
<div class="line">            listeners = ($$observers[key] || ($$observers[key] = []));</div>
<div class="line"></div>
<div class="line">        listeners.push(fn);</div>
<div class="line">        $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (!listeners.$$inter &amp;&amp; attrs.hasOwnProperty(key) &amp;&amp; !isUndefined(attrs[key])) {</div>
<div class="line">            <span class="comment">// no one registered attribute interpolation function, so lets call it manually</span></div>
<div class="line">            fn(attrs[key]);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          arrayRemove(listeners, fn);</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> safeAddClass($element, className) {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        $element.addClass(className);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="comment">// ignore, since it means that we are trying to set class on</span></div>
<div class="line">        <span class="comment">// SVG element, where class name is read-only.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    var startSymbol = $interpolate.startSymbol(),</div>
<div class="line">        endSymbol = $interpolate.endSymbol(),</div>
<div class="line">        denormalizeTemplate = (startSymbol == <span class="stringliteral">&#39;{{&#39;</span> || endSymbol  == <span class="stringliteral">&#39;}}&#39;</span>)</div>
<div class="line">            ? identity</div>
<div class="line">            : <span class="keyword">function</span> denormalizeTemplate(<span class="keyword">template</span>) {</div>
<div class="line">              <span class="keywordflow">return</span> <span class="keyword">template</span>.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);</div>
<div class="line">        },</div>
<div class="line">        NG_ATTR_BINDING = /^ngAttr[A-Z]/;</div>
<div class="line"></div>
<div class="line">    compile.$$addBindingInfo = debugInfoEnabled ? <span class="keyword">function</span> $$addBindingInfo($element, binding) {</div>
<div class="line">      var bindings = $element.data(<span class="stringliteral">&#39;$binding&#39;</span>) || [];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(binding)) {</div>
<div class="line">        bindings = bindings.concat(binding);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        bindings.push(binding);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $element.data(<span class="stringliteral">&#39;$binding&#39;</span>, bindings);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addBindingClass = debugInfoEnabled ? <span class="keyword">function</span> $$addBindingClass($element) {</div>
<div class="line">      safeAddClass($element, <span class="stringliteral">&#39;ng-binding&#39;</span>);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addScopeInfo = debugInfoEnabled ? <span class="keyword">function</span> $$addScopeInfo($element, scope, isolated, noTemplate) {</div>
<div class="line">      var dataName = isolated ? (noTemplate ? <span class="stringliteral">&#39;$isolateScopeNoTemplate&#39;</span> : <span class="stringliteral">&#39;$isolateScope&#39;</span>) : <span class="stringliteral">&#39;$scope&#39;</span>;</div>
<div class="line">      $element.data(dataName, scope);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addScopeClass = debugInfoEnabled ? <span class="keyword">function</span> $$addScopeClass($element, isolated) {</div>
<div class="line">      safeAddClass($element, isolated ? <span class="stringliteral">&#39;ng-isolate-scope&#39;</span> : <span class="stringliteral">&#39;ng-scope&#39;</span>);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> compile;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,</div>
<div class="line">                        previousCompileContext) {</div>
<div class="line">      <span class="keywordflow">if</span> (!($compileNodes instanceof jqLite)) {</div>
<div class="line">        <span class="comment">// jquery always rewraps, whereas we need to preserve the original selector so that we can</span></div>
<div class="line">        <span class="comment">// modify it.</span></div>
<div class="line">        $compileNodes = jqLite($compileNodes);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// We can not compile top level text elements since text nodes can be merged and we will</span></div>
<div class="line">      <span class="comment">// not be able to attach scope data to them, so we will wrap them in &lt;span&gt;</span></div>
<div class="line">      forEach($compileNodes, <span class="keyword">function</span>(node, index) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.nodeType == NODE_TYPE_TEXT &amp;&amp; node.nodeValue.match(/\S+/) <span class="comment">/* non-empty */</span> ) {</div>
<div class="line">          $compileNodes[index] = jqLite(node).wrap(<span class="stringliteral">&#39;&lt;span&gt;&lt;/span&gt;&#39;</span>).parent()[0];</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      var compositeLinkFn =</div>
<div class="line">              compileNodes($compileNodes, transcludeFn, $compileNodes,</div>
<div class="line">                           maxPriority, ignoreDirective, previousCompileContext);</div>
<div class="line">      compile.$$addScopeClass($compileNodes);</div>
<div class="line">      var <span class="keyword">namespace </span>= null;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> publicLinkFn(scope, cloneConnectFn, options) {</div>
<div class="line">        assertArg(scope, <span class="stringliteral">&#39;scope&#39;</span>);</div>
<div class="line"></div>
<div class="line">        options = options || {};</div>
<div class="line">        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,</div>
<div class="line">          transcludeControllers = options.transcludeControllers,</div>
<div class="line">          futureParentElement = options.futureParentElement;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// When `parentBoundTranscludeFn` is passed, it is a</span></div>
<div class="line">        <span class="comment">// `controllersBoundTransclude` function (it was previously passed</span></div>
<div class="line">        <span class="comment">// as `transclude` to directive.link) so we must unwrap it to get</span></div>
<div class="line">        <span class="comment">// its `boundTranscludeFn`</span></div>
<div class="line">        <span class="keywordflow">if</span> (parentBoundTranscludeFn &amp;&amp; parentBoundTranscludeFn.$$boundTransclude) {</div>
<div class="line">          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!<span class="keyword">namespace</span>) {</div>
<div class="line">          <span class="keyword">namespace </span>= detectNamespaceForChildElements(futureParentElement);</div>
<div class="line">        }</div>
<div class="line">        var $linkNode;</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">namespace</span> !== <span class="stringliteral">&#39;html&#39;</span>) {</div>
<div class="line">          <span class="comment">// When using a directive with replace:true and templateUrl the $compileNodes</span></div>
<div class="line">          <span class="comment">// (or a child element inside of them)</span></div>
<div class="line">          <span class="comment">// might change, so we need to recreate the namespace adapted compileNodes</span></div>
<div class="line">          <span class="comment">// for call to the link function.</span></div>
<div class="line">          <span class="comment">// Note: This will already clone the nodes...</span></div>
<div class="line">          $linkNode = jqLite(</div>
<div class="line">            wrapTemplate(<span class="keyword">namespace</span>, jqLite(<span class="stringliteral">&#39;&lt;div&gt;&#39;</span>).append($compileNodes).html())</div>
<div class="line">          );</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cloneConnectFn) {</div>
<div class="line">          <span class="comment">// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart</span></div>
<div class="line">          <span class="comment">// and sometimes changes the structure of the DOM.</span></div>
<div class="line">          $linkNode = JQLitePrototype.clone.call($compileNodes);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          $linkNode = $compileNodes;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (transcludeControllers) {</div>
<div class="line">          <span class="keywordflow">for</span> (var controllerName in transcludeControllers) {</div>
<div class="line">            $linkNode.data(<span class="charliteral">&#39;$&#39;</span> + controllerName + <span class="stringliteral">&#39;Controller&#39;</span>, transcludeControllers[controllerName].instance);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        compile.$$addScopeInfo($linkNode, scope);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cloneConnectFn) cloneConnectFn($linkNode, scope);</div>
<div class="line">        <span class="keywordflow">if</span> (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);</div>
<div class="line">        <span class="keywordflow">return</span> $linkNode;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> detectNamespaceForChildElements(parentElement) {</div>
<div class="line">      <span class="comment">// TODO: Make this detect MathML as well...</span></div>
<div class="line">      var node = parentElement &amp;&amp; parentElement[0];</div>
<div class="line">      <span class="keywordflow">if</span> (!node) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;html&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> nodeName_(node) !== <span class="stringliteral">&#39;foreignobject&#39;</span> &amp;&amp; node.toString().match(/SVG/) ? <span class="stringliteral">&#39;svg&#39;</span> : <span class="stringliteral">&#39;html&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,</div>
<div class="line">                            previousCompileContext) {</div>
<div class="line">      var linkFns = [],</div>
<div class="line">          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; nodeList.length; i++) {</div>
<div class="line">        attrs = <span class="keyword">new</span> Attributes();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we must always refer to nodeList[i] since the nodes can be replaced underneath us.</span></div>
<div class="line">        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,</div>
<div class="line">                                        ignoreDirective);</div>
<div class="line"></div>
<div class="line">        nodeLinkFn = (directives.length)</div>
<div class="line">            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,</div>
<div class="line">                                      null, [], [], previousCompileContext)</div>
<div class="line">            : null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFn &amp;&amp; nodeLinkFn.scope) {</div>
<div class="line">          compile.$$addScopeClass(attrs.$$element);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        childLinkFn = (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||</div>
<div class="line">                      !(childNodes = nodeList[i].childNodes) ||</div>
<div class="line">                      !childNodes.length)</div>
<div class="line">            ? null</div>
<div class="line">            : compileNodes(childNodes,</div>
<div class="line">                 nodeLinkFn ? (</div>
<div class="line">                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)</div>
<div class="line">                     &amp;&amp; nodeLinkFn.transclude) : transcludeFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFn || childLinkFn) {</div>
<div class="line">          linkFns.push(i, nodeLinkFn, childLinkFn);</div>
<div class="line">          linkFnFound = <span class="keyword">true</span>;</div>
<div class="line">          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//use the previous context only for the first element in the virtual group</span></div>
<div class="line">        previousCompileContext = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// return a linking function if we have found anything, null otherwise</span></div>
<div class="line">      <span class="keywordflow">return</span> linkFnFound ? compositeLinkFn : null;</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {</div>
<div class="line">        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;</div>
<div class="line">        var stableNodeList;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFnFound) {</div>
<div class="line">          <span class="comment">// copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our</span></div>
<div class="line">          <span class="comment">// offsets don&#39;t get screwed up</span></div>
<div class="line">          var nodeListLength = nodeList.length;</div>
<div class="line">          stableNodeList = <span class="keyword">new</span> Array(nodeListLength);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// create a sparse array by only copying the elements which have a linkFn</span></div>
<div class="line">          <span class="keywordflow">for</span> (i = 0; i &lt; linkFns.length; i+=3) {</div>
<div class="line">            idx = linkFns[i];</div>
<div class="line">            stableNodeList[idx] = nodeList[idx];</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          stableNodeList = nodeList;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = linkFns.length; i &lt; ii;) {</div>
<div class="line">          node = stableNodeList[linkFns[i++]];</div>
<div class="line">          nodeLinkFn = linkFns[i++];</div>
<div class="line">          childLinkFn = linkFns[i++];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (nodeLinkFn) {</div>
<div class="line">            <span class="keywordflow">if</span> (nodeLinkFn.scope) {</div>
<div class="line">              childScope = scope.$new();</div>
<div class="line">              compile.$$addScopeInfo(jqLite(node), childScope);</div>
<div class="line">              var destroyBindings = nodeLinkFn.$$destroyBindings;</div>
<div class="line">              <span class="keywordflow">if</span> (destroyBindings) {</div>
<div class="line">                nodeLinkFn.$$destroyBindings = null;</div>
<div class="line">                childScope.$on(<span class="stringliteral">&#39;$destroyed&#39;</span>, destroyBindings);</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childScope = scope;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (nodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(</div>
<div class="line">                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!nodeLinkFn.templateOnThisElement &amp;&amp; parentBoundTranscludeFn) {</div>
<div class="line">              childBoundTranscludeFn = parentBoundTranscludeFn;</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!parentBoundTranscludeFn &amp;&amp; transcludeFn) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childBoundTranscludeFn = null;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn,</div>
<div class="line">                       nodeLinkFn);</div>
<div class="line"></div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (childLinkFn) {</div>
<div class="line">            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {</div>
<div class="line"></div>
<div class="line">      var boundTranscludeFn = <span class="keyword">function</span>(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!transcludedScope) {</div>
<div class="line">          transcludedScope = scope.$new(<span class="keyword">false</span>, containingScope);</div>
<div class="line">          transcludedScope.$$transcluded = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> transcludeFn(transcludedScope, cloneFn, {</div>
<div class="line">          parentBoundTranscludeFn: previousBoundTranscludeFn,</div>
<div class="line">          transcludeControllers: controllers,</div>
<div class="line">          futureParentElement: futureParentElement</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> boundTranscludeFn;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {</div>
<div class="line">      var nodeType = node.nodeType,</div>
<div class="line">          attrsMap = attrs.$attr,</div>
<div class="line">          match,</div>
<div class="line">          className;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">switch</span> (nodeType) {</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_ELEMENT: <span class="comment">/* Element */</span></div>
<div class="line">          <span class="comment">// use the node name: &lt;directive&gt;</span></div>
<div class="line">          addDirective(directives,</div>
<div class="line">              directiveNormalize(nodeName_(node)), <span class="charliteral">&#39;E&#39;</span>, maxPriority, ignoreDirective);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// iterate over the attributes</span></div>
<div class="line">          <span class="keywordflow">for</span> (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,</div>
<div class="line">                   j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {</div>
<div class="line">            var attrStartName = <span class="keyword">false</span>;</div>
<div class="line">            var attrEndName = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            attr = nAttrs[j];</div>
<div class="line">            name = attr.name;</div>
<div class="line">            value = trim(attr.value);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// support ngAttr attribute binding</span></div>
<div class="line">            ngAttrName = directiveNormalize(name);</div>
<div class="line">            <span class="keywordflow">if</span> (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {</div>
<div class="line">              name = name.replace(PREFIX_REGEXP, <span class="stringliteral">&#39;&#39;</span>)</div>
<div class="line">                .substr(8).replace(/_(.)/g, <span class="keyword">function</span>(match, letter) {</div>
<div class="line">                  <span class="keywordflow">return</span> letter.toUpperCase();</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            var directiveNName = ngAttrName.replace(/(Start|End)$/, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (directiveIsMultiElement(directiveNName)) {</div>
<div class="line">              <span class="keywordflow">if</span> (ngAttrName === directiveNName + <span class="stringliteral">&#39;Start&#39;</span>) {</div>
<div class="line">                attrStartName = name;</div>
<div class="line">                attrEndName = name.substr(0, name.length - 5) + <span class="stringliteral">&#39;end&#39;</span>;</div>
<div class="line">                name = name.substr(0, name.length - 6);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            nName = directiveNormalize(name.toLowerCase());</div>
<div class="line">            attrsMap[nName] = name;</div>
<div class="line">            <span class="keywordflow">if</span> (isNgAttr || !attrs.hasOwnProperty(nName)) {</div>
<div class="line">                attrs[nName] = value;</div>
<div class="line">                <span class="keywordflow">if</span> (getBooleanAttrName(node, nName)) {</div>
<div class="line">                  attrs[nName] = <span class="keyword">true</span>; <span class="comment">// presence means true</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);</div>
<div class="line">            addDirective(directives, nName, <span class="charliteral">&#39;A&#39;</span>, maxPriority, ignoreDirective, attrStartName,</div>
<div class="line">                          attrEndName);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// use class as directive</span></div>
<div class="line">          className = node.className;</div>
<div class="line">          <span class="keywordflow">if</span> (isObject(className)) {</div>
<div class="line">              <span class="comment">// Maybe SVGAnimatedString</span></div>
<div class="line">              className = className.animVal;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (isString(className) &amp;&amp; className !== <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">            <span class="keywordflow">while</span> (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {</div>
<div class="line">              nName = directiveNormalize(match[2]);</div>
<div class="line">              <span class="keywordflow">if</span> (addDirective(directives, nName, <span class="charliteral">&#39;C&#39;</span>, maxPriority, ignoreDirective)) {</div>
<div class="line">                attrs[nName] = trim(match[3]);</div>
<div class="line">              }</div>
<div class="line">              className = className.substr(match.index + match[0].length);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_TEXT: <span class="comment">/* Text Node */</span></div>
<div class="line">          <span class="keywordflow">if</span> (msie === 11) {</div>
<div class="line">            <span class="comment">// Workaround for #11781</span></div>
<div class="line">            <span class="keywordflow">while</span> (node.parentNode &amp;&amp; node.nextSibling &amp;&amp; node.nextSibling.nodeType === NODE_TYPE_TEXT) {</div>
<div class="line">              node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;</div>
<div class="line">              node.parentNode.removeChild(node.nextSibling);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          addTextInterpolateDirective(directives, node.nodeValue);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_COMMENT: <span class="comment">/* Comment */</span></div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);</div>
<div class="line">            <span class="keywordflow">if</span> (match) {</div>
<div class="line">              nName = directiveNormalize(match[1]);</div>
<div class="line">              <span class="keywordflow">if</span> (addDirective(directives, nName, <span class="charliteral">&#39;M&#39;</span>, maxPriority, ignoreDirective)) {</div>
<div class="line">                attrs[nName] = trim(match[2]);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            <span class="comment">// turns out that under some circumstances IE9 throws errors when one attempts to read</span></div>
<div class="line">            <span class="comment">// comment&#39;s node value.</span></div>
<div class="line">            <span class="comment">// Just ignore it and continue. (Can&#39;t seem to reproduce in test case.)</span></div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      directives.sort(byPriority);</div>
<div class="line">      <span class="keywordflow">return</span> directives;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> groupScan(node, attrStart, attrEnd) {</div>
<div class="line">      var nodes = [];</div>
<div class="line">      var depth = 0;</div>
<div class="line">      <span class="keywordflow">if</span> (attrStart &amp;&amp; node.hasAttribute &amp;&amp; node.hasAttribute(attrStart)) {</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!node) {</div>
<div class="line">            <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;uterdir&#39;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Unterminated attribute, found &#39;{0}&#39; but no matching &#39;{1}&#39; found.&quot;</span>,</div>
<div class="line">                      attrStart, attrEnd);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (node.nodeType == NODE_TYPE_ELEMENT) {</div>
<div class="line">            <span class="keywordflow">if</span> (node.hasAttribute(attrStart)) depth++;</div>
<div class="line">            <span class="keywordflow">if</span> (node.hasAttribute(attrEnd)) depth--;</div>
<div class="line">          }</div>
<div class="line">          nodes.push(node);</div>
<div class="line">          node = node.nextSibling;</div>
<div class="line">        } <span class="keywordflow">while</span> (depth &gt; 0);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        nodes.push(node);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> jqLite(nodes);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element, attrs, controllers, transcludeFn) {</div>
<div class="line">        element = groupScan(element[0], attrStart, attrEnd);</div>
<div class="line">        <span class="keywordflow">return</span> linkFn(scope, element, attrs, controllers, transcludeFn);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,</div>
<div class="line">                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,</div>
<div class="line">                                   previousCompileContext) {</div>
<div class="line">      previousCompileContext = previousCompileContext || {};</div>
<div class="line"></div>
<div class="line">      var terminalPriority = -Number.MAX_VALUE,</div>
<div class="line">          newScopeDirective = previousCompileContext.newScopeDirective,</div>
<div class="line">          controllerDirectives = previousCompileContext.controllerDirectives,</div>
<div class="line">          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,</div>
<div class="line">          templateDirective = previousCompileContext.templateDirective,</div>
<div class="line">          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,</div>
<div class="line">          hasTranscludeDirective = <span class="keyword">false</span>,</div>
<div class="line">          hasTemplate = <span class="keyword">false</span>,</div>
<div class="line">          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,</div>
<div class="line">          $compileNode = templateAttrs.$$element = jqLite(compileNode),</div>
<div class="line">          directive,</div>
<div class="line">          directiveName,</div>
<div class="line">          $template,</div>
<div class="line">          replaceDirective = originalReplaceDirective,</div>
<div class="line">          childTranscludeFn = transcludeFn,</div>
<div class="line">          linkFn,</div>
<div class="line">          directiveValue;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// executes all directives on the current element</span></div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">        directive = directives[i];</div>
<div class="line">        var attrStart = directive.$$start;</div>
<div class="line">        var attrEnd = directive.$$end;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// collect multiblock sections</span></div>
<div class="line">        <span class="keywordflow">if</span> (attrStart) {</div>
<div class="line">          $compileNode = groupScan(compileNode, attrStart, attrEnd);</div>
<div class="line">        }</div>
<div class="line">        $template = undefined;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (terminalPriority &gt; directive.priority) {</div>
<div class="line">          <span class="keywordflow">break</span>; <span class="comment">// prevent further processing of directives</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directiveValue = directive.scope) {</div>
<div class="line"></div>
<div class="line">          <span class="comment">// skip the check for directives with async templates, we&#39;ll check the derived sync</span></div>
<div class="line">          <span class="comment">// directive when the template arrives</span></div>
<div class="line">          <span class="keywordflow">if</span> (!directive.templateUrl) {</div>
<div class="line">            <span class="keywordflow">if</span> (isObject(directiveValue)) {</div>
<div class="line">              <span class="comment">// This directive is trying to add an isolated scope.</span></div>
<div class="line">              <span class="comment">// Check that there is no scope of any kind already</span></div>
<div class="line">              assertNoDuplicate(<span class="stringliteral">&#39;new/isolated scope&#39;</span>, newIsolateScopeDirective || newScopeDirective,</div>
<div class="line">                                directive, $compileNode);</div>
<div class="line">              newIsolateScopeDirective = directive;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// This directive is trying to add a child scope.</span></div>
<div class="line">              <span class="comment">// Check that there is no isolated scope already</span></div>
<div class="line">              assertNoDuplicate(<span class="stringliteral">&#39;new/isolated scope&#39;</span>, newIsolateScopeDirective, directive,</div>
<div class="line">                                $compileNode);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          newScopeDirective = newScopeDirective || directive;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        directiveName = directive.name;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!directive.templateUrl &amp;&amp; directive.controller) {</div>
<div class="line">          directiveValue = directive.controller;</div>
<div class="line">          controllerDirectives = controllerDirectives || createMap();</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&quot;&#39;&quot;</span> + directiveName + <span class="stringliteral">&quot;&#39; controller&quot;</span>,</div>
<div class="line">              controllerDirectives[directiveName], directive, $compileNode);</div>
<div class="line">          controllerDirectives[directiveName] = directive;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directiveValue = directive.transclude) {</div>
<div class="line">          hasTranscludeDirective = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Special case ngIf and ngRepeat so that we don&#39;t complain about duplicate transclusion.</span></div>
<div class="line">          <span class="comment">// This option should only be used by directives that know how to safely handle element transclusion,</span></div>
<div class="line">          <span class="comment">// where the transcluded nodes are added or replaced after linking.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!directive.$$tlb) {</div>
<div class="line">            assertNoDuplicate(<span class="stringliteral">&#39;transclusion&#39;</span>, nonTlbTranscludeDirective, directive, $compileNode);</div>
<div class="line">            nonTlbTranscludeDirective = directive;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directiveValue == <span class="stringliteral">&#39;element&#39;</span>) {</div>
<div class="line">            hasElementTranscludeDirective = <span class="keyword">true</span>;</div>
<div class="line">            terminalPriority = directive.priority;</div>
<div class="line">            $template = $compileNode;</div>
<div class="line">            $compileNode = templateAttrs.$$element =</div>
<div class="line">                jqLite(document.createComment(<span class="charliteral">&#39; &#39;</span> + directiveName + <span class="stringliteral">&#39;: &#39;</span> +</div>
<div class="line">                                              templateAttrs[directiveName] + <span class="charliteral">&#39; &#39;</span>));</div>
<div class="line">            compileNode = $compileNode[0];</div>
<div class="line">            replaceWith(jqCollection, sliceArgs($template), compileNode);</div>
<div class="line"></div>
<div class="line">            childTranscludeFn = compile($template, transcludeFn, terminalPriority,</div>
<div class="line">                                        replaceDirective &amp;&amp; replaceDirective.name, {</div>
<div class="line">                                          <span class="comment">// Don&#39;t pass in:</span></div>
<div class="line">                                          <span class="comment">// - controllerDirectives - otherwise we&#39;ll create duplicates controllers</span></div>
<div class="line">                                          <span class="comment">// - newIsolateScopeDirective or templateDirective - combining templates with</span></div>
<div class="line">                                          <span class="comment">//   element transclusion doesn&#39;t make sense.</span></div>
<div class="line">                                          <span class="comment">//</span></div>
<div class="line">                                          <span class="comment">// We need only nonTlbTranscludeDirective so that we prevent putting transclusion</span></div>
<div class="line">                                          <span class="comment">// on the same element more than once.</span></div>
<div class="line">                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective</div>
<div class="line">                                        });</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            $template = jqLite(jqLiteClone(compileNode)).contents();</div>
<div class="line">            $compileNode.empty(); <span class="comment">// clear contents</span></div>
<div class="line">            childTranscludeFn = compile($template, transcludeFn);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.template) {</div>
<div class="line">          hasTemplate = <span class="keyword">true</span>;</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&#39;template&#39;</span>, templateDirective, directive, $compileNode);</div>
<div class="line">          templateDirective = directive;</div>
<div class="line"></div>
<div class="line">          directiveValue = (isFunction(directive.template))</div>
<div class="line">              ? directive.template($compileNode, templateAttrs)</div>
<div class="line">              : directive.template;</div>
<div class="line"></div>
<div class="line">          directiveValue = denormalizeTemplate(directiveValue);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directive.replace) {</div>
<div class="line">            replaceDirective = directive;</div>
<div class="line">            <span class="keywordflow">if</span> (jqLiteIsTextNode(directiveValue)) {</div>
<div class="line">              $template = [];</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));</div>
<div class="line">            }</div>
<div class="line">            compileNode = $template[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tplrt&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Template for directive &#39;{0}&#39; must have exactly one root element. {1}&quot;</span>,</div>
<div class="line">                  directiveName, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            replaceWith(jqCollection, $compileNode, compileNode);</div>
<div class="line"></div>
<div class="line">            var newTemplateAttrs = {$attr: {}};</div>
<div class="line"></div>
<div class="line">            <span class="comment">// combine directives from the original node and from the template:</span></div>
<div class="line">            <span class="comment">// - take the array of directives for this element</span></div>
<div class="line">            <span class="comment">// - split it into two parts, those that already applied (processed) and those that weren&#39;t (unprocessed)</span></div>
<div class="line">            <span class="comment">// - collect directives from the template and sort them by priority</span></div>
<div class="line">            <span class="comment">// - combine directives as: processed + template + unprocessed</span></div>
<div class="line">            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);</div>
<div class="line">            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">              markDirectivesAsIsolate(templateDirectives);</div>
<div class="line">            }</div>
<div class="line">            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);</div>
<div class="line">            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);</div>
<div class="line"></div>
<div class="line">            ii = directives.length;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            $compileNode.html(directiveValue);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.templateUrl) {</div>
<div class="line">          hasTemplate = <span class="keyword">true</span>;</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&#39;template&#39;</span>, templateDirective, directive, $compileNode);</div>
<div class="line">          templateDirective = directive;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directive.replace) {</div>
<div class="line">            replaceDirective = directive;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,</div>
<div class="line">              templateAttrs, jqCollection, hasTranscludeDirective &amp;&amp; childTranscludeFn, preLinkFns, postLinkFns, {</div>
<div class="line">                controllerDirectives: controllerDirectives,</div>
<div class="line">                newScopeDirective: (newScopeDirective !== directive) &amp;&amp; newScopeDirective,</div>
<div class="line">                newIsolateScopeDirective: newIsolateScopeDirective,</div>
<div class="line">                templateDirective: templateDirective,</div>
<div class="line">                nonTlbTranscludeDirective: nonTlbTranscludeDirective</div>
<div class="line">              });</div>
<div class="line">          ii = directives.length;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (directive.compile) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);</div>
<div class="line">            <span class="keywordflow">if</span> (isFunction(linkFn)) {</div>
<div class="line">              addLinkFns(null, linkFn, attrStart, attrEnd);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (linkFn) {</div>
<div class="line">              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e, startingTag($compileNode));</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.terminal) {</div>
<div class="line">          nodeLinkFn.terminal = <span class="keyword">true</span>;</div>
<div class="line">          terminalPriority = Math.max(terminalPriority, directive.priority);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      nodeLinkFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope === <span class="keyword">true</span>;</div>
<div class="line">      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;</div>
<div class="line">      nodeLinkFn.templateOnThisElement = hasTemplate;</div>
<div class="line">      nodeLinkFn.transclude = childTranscludeFn;</div>
<div class="line"></div>
<div class="line">      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// might be normal or delayed nodeLinkFn depending on if templateUrl is present</span></div>
<div class="line">      <span class="keywordflow">return</span> nodeLinkFn;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> addLinkFns(pre, post, attrStart, attrEnd) {</div>
<div class="line">        <span class="keywordflow">if</span> (pre) {</div>
<div class="line">          <span class="keywordflow">if</span> (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);</div>
<div class="line">          pre.require = directive.require;</div>
<div class="line">          pre.directiveName = directiveName;</div>
<div class="line">          <span class="keywordflow">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) {</div>
<div class="line">            pre = cloneAndAnnotateFn(pre, {isolateScope: <span class="keyword">true</span>});</div>
<div class="line">          }</div>
<div class="line">          preLinkFns.push(pre);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (post) {</div>
<div class="line">          <span class="keywordflow">if</span> (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);</div>
<div class="line">          post.require = directive.require;</div>
<div class="line">          post.directiveName = directiveName;</div>
<div class="line">          <span class="keywordflow">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) {</div>
<div class="line">            post = cloneAndAnnotateFn(post, {isolateScope: <span class="keyword">true</span>});</div>
<div class="line">          }</div>
<div class="line">          postLinkFns.push(post);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> getControllers(directiveName, require, $element, elementControllers) {</div>
<div class="line">        var value;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isString(require)) {</div>
<div class="line">          var match = require.match(REQUIRE_PREFIX_REGEXP);</div>
<div class="line">          var name = require.substring(match[0].length);</div>
<div class="line">          var inheritType = match[1] || match[3];</div>
<div class="line">          var optional = match[2] === <span class="charliteral">&#39;?&#39;</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">//If only parents then start at the parent element</span></div>
<div class="line">          <span class="keywordflow">if</span> (inheritType === <span class="stringliteral">&#39;^^&#39;</span>) {</div>
<div class="line">            $element = $element.parent();</div>
<div class="line">          <span class="comment">//Otherwise attempt getting the controller from elementControllers in case</span></div>
<div class="line">          <span class="comment">//the element is transcluded (and has no data) and to avoid .data if possible</span></div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            value = elementControllers &amp;&amp; elementControllers[name];</div>
<div class="line">            value = value &amp;&amp; value.instance;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!value) {</div>
<div class="line">            var dataName = <span class="charliteral">&#39;$&#39;</span> + name + <span class="stringliteral">&#39;Controller&#39;</span>;</div>
<div class="line">            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!value &amp;&amp; !optional) {</div>
<div class="line">            <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;ctreq&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;Controller &#39;{0}&#39;, required by directive &#39;{1}&#39;, can&#39;t be found!&quot;</span>,</div>
<div class="line">                name, directiveName);</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(require)) {</div>
<div class="line">          value = [];</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0, ii = require.length; i &lt; ii; i++) {</div>
<div class="line">            value[i] = getControllers(directiveName, require[i], $element, elementControllers);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> value || null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {</div>
<div class="line">        var elementControllers = createMap();</div>
<div class="line">        <span class="keywordflow">for</span> (var controllerKey in controllerDirectives) {</div>
<div class="line">          var directive = controllerDirectives[controllerKey];</div>
<div class="line">          var locals = {</div>
<div class="line">            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,</div>
<div class="line">            $element: $element,</div>
<div class="line">            $attrs: attrs,</div>
<div class="line">            $transclude: transcludeFn</div>
<div class="line">          };</div>
<div class="line"></div>
<div class="line">          var controller = directive.controller;</div>
<div class="line">          <span class="keywordflow">if</span> (controller == <span class="charliteral">&#39;@&#39;</span>) {</div>
<div class="line">            controller = attrs[directive.name];</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          var controllerInstance = $controller(controller, locals, <span class="keyword">true</span>, directive.controllerAs);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// For directives with element transclusion the element is a comment,</span></div>
<div class="line">          <span class="comment">// but jQuery .data doesn&#39;t support attaching data to comment nodes as it&#39;s hard to</span></div>
<div class="line">          <span class="comment">// clean up (http://bugs.jquery.com/ticket/8335).</span></div>
<div class="line">          <span class="comment">// Instead, we save the controllers for the element in a local hash and attach to .data</span></div>
<div class="line">          <span class="comment">// later, once we have the actual element.</span></div>
<div class="line">          elementControllers[directive.name] = controllerInstance;</div>
<div class="line">          <span class="keywordflow">if</span> (!hasElementTranscludeDirective) {</div>
<div class="line">            $element.data(<span class="charliteral">&#39;$&#39;</span> + directive.name + <span class="stringliteral">&#39;Controller&#39;</span>, controllerInstance.instance);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> elementControllers;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn,</div>
<div class="line">                          thisLinkFn) {</div>
<div class="line">        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,</div>
<div class="line">            attrs;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (compileNode === linkNode) {</div>
<div class="line">          attrs = templateAttrs;</div>
<div class="line">          $element = templateAttrs.$$element;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          $element = jqLite(linkNode);</div>
<div class="line">          attrs = <span class="keyword">new</span> Attributes($element, templateAttrs);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">          isolateScope = scope.$new(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (boundTranscludeFn) {</div>
<div class="line">          <span class="comment">// track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`</span></div>
<div class="line">          <span class="comment">// is later passed as `parentBoundTranscludeFn` to `publicLinkFn`</span></div>
<div class="line">          transcludeFn = controllersBoundTransclude;</div>
<div class="line">          transcludeFn.$$boundTransclude = boundTranscludeFn;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (controllerDirectives) {</div>
<div class="line">          elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">          <span class="comment">// Initialize isolate scope bindings for new isolate scope directive.</span></div>
<div class="line">          compile.$$addScopeInfo($element, isolateScope, <span class="keyword">true</span>, !(templateDirective &amp;&amp; (templateDirective === newIsolateScopeDirective ||</div>
<div class="line">              templateDirective === newIsolateScopeDirective.$$originalDirective)));</div>
<div class="line">          compile.$$addScopeClass($element, <span class="keyword">true</span>);</div>
<div class="line">          isolateScope.$$isolateBindings =</div>
<div class="line">              newIsolateScopeDirective.$$isolateBindings;</div>
<div class="line">          initializeDirectiveBindings(scope, attrs, isolateScope,</div>
<div class="line">                                      isolateScope.$$isolateBindings,</div>
<div class="line">                                      newIsolateScopeDirective, isolateScope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (elementControllers) {</div>
<div class="line">          <span class="comment">// Initialize bindToController bindings for new/isolate scopes</span></div>
<div class="line">          var scopeDirective = newIsolateScopeDirective || newScopeDirective;</div>
<div class="line">          var bindings;</div>
<div class="line">          var controllerForBindings;</div>
<div class="line">          <span class="keywordflow">if</span> (scopeDirective &amp;&amp; elementControllers[scopeDirective.name]) {</div>
<div class="line">            bindings = scopeDirective.$$bindings.bindToController;</div>
<div class="line">            controller = elementControllers[scopeDirective.name];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (controller &amp;&amp; controller.identifier &amp;&amp; bindings) {</div>
<div class="line">              controllerForBindings = controller;</div>
<div class="line">              thisLinkFn.$$destroyBindings =</div>
<div class="line">                  initializeDirectiveBindings(scope, attrs, controller.instance,</div>
<div class="line">                                              bindings, scopeDirective);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">for</span> (i in elementControllers) {</div>
<div class="line">            controller = elementControllers[i];</div>
<div class="line">            var controllerResult = controller();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (controllerResult !== controller.instance) {</div>
<div class="line">              <span class="comment">// If the controller constructor has a return value, overwrite the instance</span></div>
<div class="line">              <span class="comment">// from setupControllers and update the element data</span></div>
<div class="line">              controller.instance = controllerResult;</div>
<div class="line">              $element.data(<span class="charliteral">&#39;$&#39;</span> + i + <span class="stringliteral">&#39;Controller&#39;</span>, controllerResult);</div>
<div class="line">              <span class="keywordflow">if</span> (controller === controllerForBindings) {</div>
<div class="line">                <span class="comment">// Remove and re-install bindToController bindings</span></div>
<div class="line">                thisLinkFn.$$destroyBindings();</div>
<div class="line">                thisLinkFn.$$destroyBindings =</div>
<div class="line">                  initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// PRELINKING</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = preLinkFns.length; i &lt; ii; i++) {</div>
<div class="line">          linkFn = preLinkFns[i];</div>
<div class="line">          invokeLinkFn(linkFn,</div>
<div class="line">              linkFn.isolateScope ? isolateScope : scope,</div>
<div class="line">              $element,</div>
<div class="line">              attrs,</div>
<div class="line">              linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),</div>
<div class="line">              transcludeFn</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// RECURSION</span></div>
<div class="line">        <span class="comment">// We only pass the isolate scope, if the isolate directive has a template,</span></div>
<div class="line">        <span class="comment">// otherwise the child elements do not belong to the isolate directive.</span></div>
<div class="line">        var scopeToChild = scope;</div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective &amp;&amp; (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {</div>
<div class="line">          scopeToChild = isolateScope;</div>
<div class="line">        }</div>
<div class="line">        childLinkFn &amp;&amp; childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// POSTLINKING</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = postLinkFns.length - 1; i &gt;= 0; i--) {</div>
<div class="line">          linkFn = postLinkFns[i];</div>
<div class="line">          invokeLinkFn(linkFn,</div>
<div class="line">              linkFn.isolateScope ? isolateScope : scope,</div>
<div class="line">              $element,</div>
<div class="line">              attrs,</div>
<div class="line">              linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),</div>
<div class="line">              transcludeFn</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This is the function that is injected as `$transclude`.</span></div>
<div class="line">        <span class="comment">// Note: all arguments are optional!</span></div>
<div class="line">        <span class="keyword">function</span> controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {</div>
<div class="line">          var transcludeControllers;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// No scope passed in:</span></div>
<div class="line">          <span class="keywordflow">if</span> (!isScope(scope)) {</div>
<div class="line">            futureParentElement = cloneAttachFn;</div>
<div class="line">            cloneAttachFn = scope;</div>
<div class="line">            scope = undefined;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (hasElementTranscludeDirective) {</div>
<div class="line">            transcludeControllers = elementControllers;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (!futureParentElement) {</div>
<div class="line">            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> markDirectivesAsIsolate(directives) {</div>
<div class="line">      <span class="comment">// mark all directives as needing isolate scope.</span></div>
<div class="line">      <span class="keywordflow">for</span> (var j = 0, jj = directives.length; j &lt; jj; j++) {</div>
<div class="line">        directives[j] = inherit(directives[j], {$$isolateScope: <span class="keyword">true</span>});</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,</div>
<div class="line">                          endAttrName) {</div>
<div class="line">      <span class="keywordflow">if</span> (name === ignoreDirective) <span class="keywordflow">return</span> null;</div>
<div class="line">      var match = null;</div>
<div class="line">      <span class="keywordflow">if</span> (hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        <span class="keywordflow">for</span> (var directive, directives = $injector.get(name + Suffix),</div>
<div class="line">            i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            directive = directives[i];</div>
<div class="line">            <span class="keywordflow">if</span> ((maxPriority === undefined || maxPriority &gt; directive.priority) &amp;&amp;</div>
<div class="line">                 directive.restrict.indexOf(location) != -1) {</div>
<div class="line">              <span class="keywordflow">if</span> (startAttrName) {</div>
<div class="line">                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});</div>
<div class="line">              }</div>
<div class="line">              tDirectives.push(directive);</div>
<div class="line">              match = directive;</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) { $exceptionHandler(e); }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> match;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> directiveIsMultiElement(name) {</div>
<div class="line">      <span class="keywordflow">if</span> (hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        <span class="keywordflow">for</span> (var directive, directives = $injector.get(name + Suffix),</div>
<div class="line">            i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">          directive = directives[i];</div>
<div class="line">          <span class="keywordflow">if</span> (directive.multiElement) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> mergeTemplateAttributes(dst, src) {</div>
<div class="line">      var srcAttr = src.$attr,</div>
<div class="line">          dstAttr = dst.$attr,</div>
<div class="line">          $element = dst.$$element;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// reapply the old attributes to the new element</span></div>
<div class="line">      forEach(dst, <span class="keyword">function</span>(value, key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key.charAt(0) != <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (src[key] &amp;&amp; src[key] !== value) {</div>
<div class="line">            value += (key === <span class="stringliteral">&#39;style&#39;</span> ? <span class="charliteral">&#39;;&#39;</span> : <span class="charliteral">&#39; &#39;</span>) + src[key];</div>
<div class="line">          }</div>
<div class="line">          dst.$set(key, value, <span class="keyword">true</span>, srcAttr[key]);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// copy the new attributes on the old attrs object</span></div>
<div class="line">      forEach(src, <span class="keyword">function</span>(value, key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key == <span class="stringliteral">&#39;class&#39;</span>) {</div>
<div class="line">          safeAddClass($element, value);</div>
<div class="line">          dst[<span class="stringliteral">&#39;class&#39;</span>] = (dst[<span class="stringliteral">&#39;class&#39;</span>] ? dst[<span class="stringliteral">&#39;class&#39;</span>] + <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + value;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key == <span class="stringliteral">&#39;style&#39;</span>) {</div>
<div class="line">          $element.attr(<span class="stringliteral">&#39;style&#39;</span>, $element.attr(<span class="stringliteral">&#39;style&#39;</span>) + <span class="charliteral">&#39;;&#39;</span> + value);</div>
<div class="line">          dst[<span class="stringliteral">&#39;style&#39;</span>] = (dst[<span class="stringliteral">&#39;style&#39;</span>] ? dst[<span class="stringliteral">&#39;style&#39;</span>] + <span class="charliteral">&#39;;&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + value;</div>
<div class="line">          <span class="comment">// `dst` will never contain hasOwnProperty as DOM parser won&#39;t let it.</span></div>
<div class="line">          <span class="comment">// You will get an &quot;InvalidCharacterError: DOM Exception 5&quot; error if you</span></div>
<div class="line">          <span class="comment">// have an attribute like &quot;has-own-property&quot; or &quot;data-has-own-property&quot;, etc.</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key.charAt(0) != <span class="charliteral">&#39;$&#39;</span> &amp;&amp; !dst.hasOwnProperty(key)) {</div>
<div class="line">          dst[key] = value;</div>
<div class="line">          dstAttr[key] = srcAttr[key];</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compileTemplateUrl(directives, $compileNode, tAttrs,</div>
<div class="line">        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {</div>
<div class="line">      var linkQueue = [],</div>
<div class="line">          afterTemplateNodeLinkFn,</div>
<div class="line">          afterTemplateChildLinkFn,</div>
<div class="line">          beforeTemplateCompileNode = $compileNode[0],</div>
<div class="line">          origAsyncDirective = directives.shift(),</div>
<div class="line">          derivedSyncDirective = inherit(origAsyncDirective, {</div>
<div class="line">            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective</div>
<div class="line">          }),</div>
<div class="line">          templateUrl = (isFunction(origAsyncDirective.templateUrl))</div>
<div class="line">              ? origAsyncDirective.templateUrl($compileNode, tAttrs)</div>
<div class="line">              : origAsyncDirective.templateUrl,</div>
<div class="line">          templateNamespace = origAsyncDirective.templateNamespace;</div>
<div class="line"></div>
<div class="line">      $compileNode.empty();</div>
<div class="line"></div>
<div class="line">      $templateRequest(templateUrl)</div>
<div class="line">        .then(<span class="keyword">function</span>(content) {</div>
<div class="line">          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;</div>
<div class="line"></div>
<div class="line">          content = denormalizeTemplate(content);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (origAsyncDirective.replace) {</div>
<div class="line">            <span class="keywordflow">if</span> (jqLiteIsTextNode(content)) {</div>
<div class="line">              $template = [];</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));</div>
<div class="line">            }</div>
<div class="line">            compileNode = $template[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tplrt&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Template for directive &#39;{0}&#39; must have exactly one root element. {1}&quot;</span>,</div>
<div class="line">                  origAsyncDirective.name, templateUrl);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            tempTemplateAttrs = {$attr: {}};</div>
<div class="line">            replaceWith($rootElement, $compileNode, compileNode);</div>
<div class="line">            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (isObject(origAsyncDirective.scope)) {</div>
<div class="line">              markDirectivesAsIsolate(templateDirectives);</div>
<div class="line">            }</div>
<div class="line">            directives = templateDirectives.concat(directives);</div>
<div class="line">            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            compileNode = beforeTemplateCompileNode;</div>
<div class="line">            $compileNode.html(content);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          directives.unshift(derivedSyncDirective);</div>
<div class="line"></div>
<div class="line">          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,</div>
<div class="line">              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,</div>
<div class="line">              previousCompileContext);</div>
<div class="line">          forEach($rootElement, <span class="keyword">function</span>(node, i) {</div>
<div class="line">            <span class="keywordflow">if</span> (node == compileNode) {</div>
<div class="line">              $rootElement[i] = $compileNode[0];</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">while</span> (linkQueue.length) {</div>
<div class="line">            var scope = linkQueue.shift(),</div>
<div class="line">                beforeTemplateLinkNode = linkQueue.shift(),</div>
<div class="line">                linkRootElement = linkQueue.shift(),</div>
<div class="line">                boundTranscludeFn = linkQueue.shift(),</div>
<div class="line">                linkNode = $compileNode[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (scope.$$destroyed) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (beforeTemplateLinkNode !== beforeTemplateCompileNode) {</div>
<div class="line">              var oldClasses = beforeTemplateLinkNode.className;</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">if</span> (!(previousCompileContext.hasElementTranscludeDirective &amp;&amp;</div>
<div class="line">                  origAsyncDirective.replace)) {</div>
<div class="line">                <span class="comment">// it was cloned therefore we have to clone as well.</span></div>
<div class="line">                linkNode = jqLiteClone(compileNode);</div>
<div class="line">              }</div>
<div class="line">              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Copy in CSS classes from original node</span></div>
<div class="line">              safeAddClass(jqLite(linkNode), oldClasses);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (afterTemplateNodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childBoundTranscludeFn = boundTranscludeFn;</div>
<div class="line">            }</div>
<div class="line">            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,</div>
<div class="line">              childBoundTranscludeFn, afterTemplateNodeLinkFn);</div>
<div class="line">          }</div>
<div class="line">          linkQueue = null;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {</div>
<div class="line">        var childBoundTranscludeFn = boundTranscludeFn;</div>
<div class="line">        <span class="keywordflow">if</span> (scope.$$destroyed) <span class="keywordflow">return</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (linkQueue) {</div>
<div class="line">          linkQueue.push(scope,</div>
<div class="line">                         node,</div>
<div class="line">                         rootElement,</div>
<div class="line">                         childBoundTranscludeFn);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (afterTemplateNodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);</div>
<div class="line">          }</div>
<div class="line">          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn,</div>
<div class="line">                                  afterTemplateNodeLinkFn);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> byPriority(a, b) {</div>
<div class="line">      var diff = b.priority - a.priority;</div>
<div class="line">      <span class="keywordflow">if</span> (diff !== 0) <span class="keywordflow">return</span> diff;</div>
<div class="line">      <span class="keywordflow">if</span> (a.name !== b.name) <span class="keywordflow">return</span> (a.name &lt; b.name) ? -1 : 1;</div>
<div class="line">      <span class="keywordflow">return</span> a.index - b.index;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> assertNoDuplicate(what, previousDirective, directive, element) {</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> wrapModuleNameIfDefined(moduleName) {</div>
<div class="line">        <span class="keywordflow">return</span> moduleName ?</div>
<div class="line">          (<span class="stringliteral">&#39; (module: &#39;</span> + moduleName + <span class="charliteral">&#39;)&#39;</span>) :</div>
<div class="line">          <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (previousDirective) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;multidir&#39;</span>, <span class="stringliteral">&#39;Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}&#39;</span>,</div>
<div class="line">            previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),</div>
<div class="line">            directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addTextInterpolateDirective(directives, text) {</div>
<div class="line">      var interpolateFn = $interpolate(text, <span class="keyword">true</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (interpolateFn) {</div>
<div class="line">        directives.push({</div>
<div class="line">          priority: 0,</div>
<div class="line">          compile: <span class="keyword">function</span> textInterpolateCompileFn(templateNode) {</div>
<div class="line">            var templateNodeParent = templateNode.parent(),</div>
<div class="line">                hasCompileParent = !!templateNodeParent.length;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// When transcluding a template that has bindings in the root</span></div>
<div class="line">            <span class="comment">// we don&#39;t have a parent and thus need to add the class during linking fn.</span></div>
<div class="line">            <span class="keywordflow">if</span> (hasCompileParent) compile.$$addBindingClass(templateNodeParent);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span> textInterpolateLinkFn(scope, node) {</div>
<div class="line">              var parent = node.parent();</div>
<div class="line">              <span class="keywordflow">if</span> (!hasCompileParent) compile.$$addBindingClass(parent);</div>
<div class="line">              compile.$$addBindingInfo(parent, interpolateFn.expressions);</div>
<div class="line">              scope.$watch(interpolateFn, <span class="keyword">function</span> interpolateFnWatchAction(value) {</div>
<div class="line">                node[0].nodeValue = value;</div>
<div class="line">              });</div>
<div class="line">            };</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> wrapTemplate(type, <span class="keyword">template</span>) {</div>
<div class="line">      type = lowercase(type || <span class="stringliteral">&#39;html&#39;</span>);</div>
<div class="line">      <span class="keywordflow">switch</span> (type) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;svg&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;math&#39;</span>:</div>
<div class="line">        var wrapper = document.createElement(<span class="stringliteral">&#39;div&#39;</span>);</div>
<div class="line">        wrapper.innerHTML = <span class="charliteral">&#39;&lt;&#39;</span> + type + <span class="charliteral">&#39;&gt;&#39;</span> + <span class="keyword">template</span> + <span class="stringliteral">&#39;&lt;/&#39;</span> + type + <span class="charliteral">&#39;&gt;&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> wrapper.childNodes[0].childNodes;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">template</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getTrustedContext(node, attrNormalizedName) {</div>
<div class="line">      <span class="keywordflow">if</span> (attrNormalizedName == <span class="stringliteral">&quot;srcdoc&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> $sce.HTML;</div>
<div class="line">      }</div>
<div class="line">      var tag = nodeName_(node);</div>
<div class="line">      <span class="comment">// maction[xlink:href] can source SVG.  It&#39;s not limited to &lt;maction&gt;.</span></div>
<div class="line">      <span class="keywordflow">if</span> (attrNormalizedName == <span class="stringliteral">&quot;xlinkHref&quot;</span> ||</div>
<div class="line">          (tag == <span class="stringliteral">&quot;form&quot;</span> &amp;&amp; attrNormalizedName == <span class="stringliteral">&quot;action&quot;</span>) ||</div>
<div class="line">          (tag != <span class="stringliteral">&quot;img&quot;</span> &amp;&amp; (attrNormalizedName == <span class="stringliteral">&quot;src&quot;</span> ||</div>
<div class="line">                            attrNormalizedName == <span class="stringliteral">&quot;ngSrc&quot;</span>))) {</div>
<div class="line">        <span class="keywordflow">return</span> $sce.RESOURCE_URL;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {</div>
<div class="line">      var trustedContext = getTrustedContext(node, name);</div>
<div class="line">      allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;</div>
<div class="line"></div>
<div class="line">      var interpolateFn = $interpolate(value, <span class="keyword">true</span>, trustedContext, allOrNothing);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// no interpolation found -&gt; ignore</span></div>
<div class="line">      <span class="keywordflow">if</span> (!interpolateFn) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (name === <span class="stringliteral">&quot;multiple&quot;</span> &amp;&amp; nodeName_(node) === <span class="stringliteral">&quot;select&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&quot;selmulti&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Binding to the &#39;multiple&#39; attribute is not supported. Element: {0}&quot;</span>,</div>
<div class="line">            startingTag(node));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      directives.push({</div>
<div class="line">        priority: 100,</div>
<div class="line">        compile: <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> {</div>
<div class="line">              pre: <span class="keyword">function</span> attrInterpolatePreLinkFn(scope, element, attr) {</div>
<div class="line">                var $$observers = (attr.$$observers || (attr.$$observers = {}));</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (EVENT_HANDLER_ATTR_REGEXP.test(name)) {</div>
<div class="line">                  <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;nodomevents&#39;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Interpolations for HTML DOM event attributes are disallowed.  Please use the &quot;</span> +</div>
<div class="line">                          <span class="stringliteral">&quot;ng- versions (such as ng-click instead of onclick) instead.&quot;</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If the attribute has changed since last $interpolate()ed</span></div>
<div class="line">                var newValue = attr[name];</div>
<div class="line">                <span class="keywordflow">if</span> (newValue !== value) {</div>
<div class="line">                  <span class="comment">// we need to interpolate again since the attribute value has been updated</span></div>
<div class="line">                  <span class="comment">// (e.g. by another directive&#39;s compile function)</span></div>
<div class="line">                  <span class="comment">// ensure unset/empty values make interpolateFn falsy</span></div>
<div class="line">                  interpolateFn = newValue &amp;&amp; $interpolate(newValue, <span class="keyword">true</span>, trustedContext, allOrNothing);</div>
<div class="line">                  value = newValue;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// if attribute was updated so that there is no interpolation going on we don&#39;t want to</span></div>
<div class="line">                <span class="comment">// register any observers</span></div>
<div class="line">                <span class="keywordflow">if</span> (!interpolateFn) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// initialize attr object so that it&#39;s ready in case we need the value for isolate</span></div>
<div class="line">                <span class="comment">// scope initialization, otherwise the value would not be available from isolate</span></div>
<div class="line">                <span class="comment">// directive&#39;s linking fn during linking phase</span></div>
<div class="line">                attr[name] = interpolateFn(scope);</div>
<div class="line"></div>
<div class="line">                ($$observers[name] || ($$observers[name] = [])).$$inter = <span class="keyword">true</span>;</div>
<div class="line">                (attr.$$observers &amp;&amp; attr.$$observers[name].$$scope || scope).</div>
<div class="line">                  $watch(interpolateFn, <span class="keyword">function</span> interpolateFnWatchAction(newValue, oldValue) {</div>
<div class="line">                    <span class="comment">//special case for class attribute addition + removal</span></div>
<div class="line">                    <span class="comment">//so that class changes can tap into the animation</span></div>
<div class="line">                    <span class="comment">//hooks provided by the $animate service. Be sure to</span></div>
<div class="line">                    <span class="comment">//skip animations when the first digest occurs (when</span></div>
<div class="line">                    <span class="comment">//both the new and the old values are the same) since</span></div>
<div class="line">                    <span class="comment">//the CSS classes are the non-interpolated values</span></div>
<div class="line">                    <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;class&#39;</span> &amp;&amp; newValue != oldValue) {</div>
<div class="line">                      attr.$updateClass(newValue, oldValue);</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                      attr.$set(name, newValue);</div>
<div class="line">                    }</div>
<div class="line">                  });</div>
<div class="line">              }</div>
<div class="line">            };</div>
<div class="line">          }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> replaceWith($rootElement, elementsToRemove, newNode) {</div>
<div class="line">      var firstElementToRemove = elementsToRemove[0],</div>
<div class="line">          removeCount = elementsToRemove.length,</div>
<div class="line">          parent = firstElementToRemove.parentNode,</div>
<div class="line">          i, ii;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> ($rootElement) {</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = $rootElement.length; i &lt; ii; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> ($rootElement[i] == firstElementToRemove) {</div>
<div class="line">            $rootElement[i++] = newNode;</div>
<div class="line">            <span class="keywordflow">for</span> (var j = i, j2 = j + removeCount - 1,</div>
<div class="line">                     jj = $rootElement.length;</div>
<div class="line">                 j &lt; jj; j++, j2++) {</div>
<div class="line">              <span class="keywordflow">if</span> (j2 &lt; jj) {</div>
<div class="line">                $rootElement[j] = $rootElement[j2];</div>
<div class="line">              } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keyword">delete</span> $rootElement[j];</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            $rootElement.length -= removeCount - 1;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If the replaced element is also the jQuery .context then replace it</span></div>
<div class="line">            <span class="comment">// .context is a deprecated jQuery api, so we should set it only when jQuery set it</span></div>
<div class="line">            <span class="comment">// http://api.jquery.com/context/</span></div>
<div class="line">            <span class="keywordflow">if</span> ($rootElement.context === firstElementToRemove) {</div>
<div class="line">              $rootElement.context = newNode;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (parent) {</div>
<div class="line">        parent.replaceChild(newNode, firstElementToRemove);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// TODO(perf): what&#39;s this document fragment for? is it needed? can we at least reuse it?</span></div>
<div class="line">      var fragment = document.createDocumentFragment();</div>
<div class="line">      fragment.appendChild(firstElementToRemove);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (jqLite.hasData(firstElementToRemove)) {</div>
<div class="line">        <span class="comment">// Copy over user data (that includes Angular&#39;s $scope etc.). Don&#39;t copy private</span></div>
<div class="line">        <span class="comment">// data here because there&#39;s no public interface in jQuery to do that and copying over</span></div>
<div class="line">        <span class="comment">// event listeners (which is the main use of private data) wouldn&#39;t work anyway.</span></div>
<div class="line">        jqLite(newNode).data(jqLite(firstElementToRemove).data());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove data of the replaced element. We cannot just call .remove()</span></div>
<div class="line">        <span class="comment">// on the element it since that would deallocate scope that is needed</span></div>
<div class="line">        <span class="comment">// for the new node. Instead, remove the data &quot;manually&quot;.</span></div>
<div class="line">        <span class="keywordflow">if</span> (!jQuery) {</div>
<div class="line">          <span class="keyword">delete</span> jqLite.cache[firstElementToRemove[jqLite.expando]];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// jQuery 2.x doesn&#39;t expose the data storage. Use jQuery.cleanData to clean up after</span></div>
<div class="line">          <span class="comment">// the replaced element. The cleanData version monkey-patched by Angular would cause</span></div>
<div class="line">          <span class="comment">// the scope to be trashed and we do need the very same scope to work with the new</span></div>
<div class="line">          <span class="comment">// element. However, we cannot just cache the non-patched version and use it here as</span></div>
<div class="line">          <span class="comment">// that would break if another library patches the method after Angular does (one</span></div>
<div class="line">          <span class="comment">// example is jQuery UI). Instead, set a flag indicating scope destroying should be</span></div>
<div class="line">          <span class="comment">// skipped this one time.</span></div>
<div class="line">          skipDestroyOnNextJQueryCleanData = <span class="keyword">true</span>;</div>
<div class="line">          jQuery.cleanData([firstElementToRemove]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (var k = 1, kk = elementsToRemove.length; k &lt; kk; k++) {</div>
<div class="line">        var element = elementsToRemove[k];</div>
<div class="line">        jqLite(element).remove(); <span class="comment">// must do this way to clean up expando</span></div>
<div class="line">        fragment.appendChild(element);</div>
<div class="line">        <span class="keyword">delete</span> elementsToRemove[k];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      elementsToRemove[0] = newNode;</div>
<div class="line">      elementsToRemove.length = 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> cloneAndAnnotateFn(fn, annotation) {</div>
<div class="line">      <span class="keywordflow">return</span> extend(<span class="keyword">function</span>() { <span class="keywordflow">return</span> fn.apply(null, arguments); }, fn, annotation);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        linkFn(scope, $element, attrs, controllers, transcludeFn);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        $exceptionHandler(e, startingTag($element));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set up $watches for isolate scope and controller bindings. This process</span></div>
<div class="line">    <span class="comment">// only occurs for isolate scopes and new scopes with controllerAs.</span></div>
<div class="line">    <span class="keyword">function</span> initializeDirectiveBindings(scope, attrs, destination, bindings,</div>
<div class="line">                                         directive, newScope) {</div>
<div class="line">      var onNewScopeDestroyed;</div>
<div class="line">      forEach(bindings, <span class="keyword">function</span>(definition, scopeName) {</div>
<div class="line">        var attrName = definition.attrName,</div>
<div class="line">        optional = definition.optional,</div>
<div class="line">        mode = definition.mode, <span class="comment">// @, =, or &amp;</span></div>
<div class="line">        lastValue,</div>
<div class="line">        parentGet, parentSet, compare;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">switch</span> (mode) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;@&#39;</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!optional &amp;&amp; !hasOwnProperty.call(attrs, attrName)) {</div>
<div class="line">              destination[scopeName] = attrs[attrName] = <span class="keywordtype">void</span> 0;</div>
<div class="line">            }</div>
<div class="line">            attrs.$observe(attrName, <span class="keyword">function</span>(value) {</div>
<div class="line">              <span class="keywordflow">if</span> (isString(value)) {</div>
<div class="line">                destination[scopeName] = value;</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            attrs.$$observers[attrName].$$scope = scope;</div>
<div class="line">            <span class="keywordflow">if</span> (isString(attrs[attrName])) {</div>
<div class="line">              <span class="comment">// If the attribute has been provided then we trigger an interpolation to ensure</span></div>
<div class="line">              <span class="comment">// the value is there for use in the link fn</span></div>
<div class="line">              destination[scopeName] = $interpolate(attrs[attrName])(scope);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;=&#39;</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!hasOwnProperty.call(attrs, attrName)) {</div>
<div class="line">              <span class="keywordflow">if</span> (optional) <span class="keywordflow">break</span>;</div>
<div class="line">              attrs[attrName] = <span class="keywordtype">void</span> 0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (optional &amp;&amp; !attrs[attrName]) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            parentGet = $parse(attrs[attrName]);</div>
<div class="line">            <span class="keywordflow">if</span> (parentGet.literal) {</div>
<div class="line">              compare = equals;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              compare = <span class="keyword">function</span>(a, b) { <span class="keywordflow">return</span> a === b || (a !== a &amp;&amp; b !== b); };</div>
<div class="line">            }</div>
<div class="line">            parentSet = parentGet.assign || <span class="keyword">function</span>() {</div>
<div class="line">              <span class="comment">// reset the change, or we will throw this exception on every $digest</span></div>
<div class="line">              lastValue = destination[scopeName] = parentGet(scope);</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;nonassign&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Expression &#39;{0}&#39; used with directive &#39;{1}&#39; is non-assignable!&quot;</span>,</div>
<div class="line">                  attrs[attrName], directive.name);</div>
<div class="line">            };</div>
<div class="line">            lastValue = destination[scopeName] = parentGet(scope);</div>
<div class="line">            var parentValueWatch = <span class="keyword">function</span> parentValueWatch(parentValue) {</div>
<div class="line">              <span class="keywordflow">if</span> (!compare(parentValue, destination[scopeName])) {</div>
<div class="line">                <span class="comment">// we are out of sync and need to copy</span></div>
<div class="line">                <span class="keywordflow">if</span> (!compare(parentValue, lastValue)) {</div>
<div class="line">                  <span class="comment">// parent changed and it has precedence</span></div>
<div class="line">                  destination[scopeName] = parentValue;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  <span class="comment">// if the parent can be assigned then do so</span></div>
<div class="line">                  parentSet(scope, parentValue = destination[scopeName]);</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">              <span class="keywordflow">return</span> lastValue = parentValue;</div>
<div class="line">            };</div>
<div class="line">            parentValueWatch.$stateful = <span class="keyword">true</span>;</div>
<div class="line">            var unwatch;</div>
<div class="line">            <span class="keywordflow">if</span> (definition.collection) {</div>
<div class="line">              unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);</div>
<div class="line">            }</div>
<div class="line">            onNewScopeDestroyed = (onNewScopeDestroyed || []);</div>
<div class="line">            onNewScopeDestroyed.push(unwatch);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>:</div>
<div class="line">            <span class="comment">// Don&#39;t assign Object.prototype method to scope</span></div>
<div class="line">            parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Don&#39;t assign noop to destination if expression is not valid</span></div>
<div class="line">            <span class="keywordflow">if</span> (parentGet === noop &amp;&amp; optional) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            destination[scopeName] = <span class="keyword">function</span>(locals) {</div>
<div class="line">              <span class="keywordflow">return</span> parentGet(scope, locals);</div>
<div class="line">            };</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      var destroyBindings = onNewScopeDestroyed ? <span class="keyword">function</span> destroyBindings() {</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, ii = onNewScopeDestroyed.length; i &lt; ii; ++i) {</div>
<div class="line">          onNewScopeDestroyed[i]();</div>
<div class="line">        }</div>
<div class="line">      } : noop;</div>
<div class="line">      <span class="keywordflow">if</span> (newScope &amp;&amp; destroyBindings !== noop) {</div>
<div class="line">        newScope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, destroyBindings);</div>
<div class="line">        <span class="keywordflow">return</span> noop;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> destroyBindings;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;</div>
<div class="line"><span class="keyword">function</span> directiveNormalize(name) {</div>
<div class="line">  <span class="keywordflow">return</span> camelCase(name.replace(PREFIX_REGEXP, <span class="stringliteral">&#39;&#39;</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nodesetLinkingFn(</div>
<div class="line">  <span class="comment">/* angular.Scope */</span> scope,</div>
<div class="line">  <span class="comment">/* NodeList */</span> nodeList,</div>
<div class="line">  <span class="comment">/* Element */</span> rootElement,</div>
<div class="line">  <span class="comment">/* function(Function) */</span> boundTranscludeFn</div>
<div class="line">) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> directiveLinkingFn(</div>
<div class="line">  <span class="comment">/* nodesetLinkingFn */</span> nodesetLinkingFn,</div>
<div class="line">  <span class="comment">/* angular.Scope */</span> scope,</div>
<div class="line">  <span class="comment">/* Node */</span> node,</div>
<div class="line">  <span class="comment">/* Element */</span> rootElement,</div>
<div class="line">  <span class="comment">/* function(Function) */</span> boundTranscludeFn</div>
<div class="line">) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> tokenDifference(str1, str2) {</div>
<div class="line">  var values = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      tokens1 = str1.split(/\s+/),</div>
<div class="line">      tokens2 = str2.split(/\s+/);</div>
<div class="line"></div>
<div class="line">  outer:</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; tokens1.length; i++) {</div>
<div class="line">    var token = tokens1[i];</div>
<div class="line">    <span class="keywordflow">for</span> (var j = 0; j &lt; tokens2.length; j++) {</div>
<div class="line">      <span class="keywordflow">if</span> (token == tokens2[j]) <span class="keywordflow">continue</span> outer;</div>
<div class="line">    }</div>
<div class="line">    values += (values.length &gt; 0 ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + token;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> values;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> removeComments(jqNodes) {</div>
<div class="line">  jqNodes = jqLite(jqNodes);</div>
<div class="line">  var i = jqNodes.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (i &lt;= 1) {</div>
<div class="line">    <span class="keywordflow">return</span> jqNodes;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span> (i--) {</div>
<div class="line">    var node = jqNodes[i];</div>
<div class="line">    <span class="keywordflow">if</span> (node.nodeType === NODE_TYPE_COMMENT) {</div>
<div class="line">      splice.call(jqNodes, i, 1);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> jqNodes;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $controllerMinErr = minErr(<span class="stringliteral">&#39;$controller&#39;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;</div>
<div class="line"><span class="keyword">function</span> identifierForController(controller, ident) {</div>
<div class="line">  <span class="keywordflow">if</span> (ident &amp;&amp; isString(ident)) <span class="keywordflow">return</span> ident;</div>
<div class="line">  <span class="keywordflow">if</span> (isString(controller)) {</div>
<div class="line">    var match = CNTRL_REG.exec(controller);</div>
<div class="line">    <span class="keywordflow">if</span> (match) <span class="keywordflow">return</span> match[3];</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ControllerProvider() {</div>
<div class="line">  var controllers = {},</div>
<div class="line">      globals = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">function</span>(name, constructor) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;controller&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(name)) {</div>
<div class="line">      extend(controllers, name);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      controllers[name] = constructor;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.allowGlobals = <span class="keyword">function</span>() {</div>
<div class="line">    globals = <span class="keyword">true</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>($injector, $window) {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(expression, locals, later, ident) {</div>
<div class="line">      <span class="comment">// PRIVATE API:</span></div>
<div class="line">      <span class="comment">//   param `later` --- indicates that the controller&#39;s constructor is invoked at a later time.</span></div>
<div class="line">      <span class="comment">//                     If true, $controller will allocate the object with the correct</span></div>
<div class="line">      <span class="comment">//                     prototype chain, but will not invoke the controller until a returned</span></div>
<div class="line">      <span class="comment">//                     callback is invoked.</span></div>
<div class="line">      <span class="comment">//   param `ident` --- An optional label which overrides the label parsed from the controller</span></div>
<div class="line">      <span class="comment">//                     expression, if any.</span></div>
<div class="line">      var instance, match, constructor, identifier;</div>
<div class="line">      later = later === <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (ident &amp;&amp; isString(ident)) {</div>
<div class="line">        identifier = ident;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isString(expression)) {</div>
<div class="line">        match = expression.match(CNTRL_REG);</div>
<div class="line">        <span class="keywordflow">if</span> (!match) {</div>
<div class="line">          <span class="keywordflow">throw</span> $controllerMinErr(<span class="stringliteral">&#39;ctrlfmt&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Badly formed controller string &#39;{0}&#39;. &quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot;Must match `__name__ as __id__` or `__name__`.&quot;</span>, expression);</div>
<div class="line">        }</div>
<div class="line">        constructor = match[1],</div>
<div class="line">        identifier = identifier || match[3];</div>
<div class="line">        expression = controllers.hasOwnProperty(constructor)</div>
<div class="line">            ? controllers[constructor]</div>
<div class="line">            : getter(locals.$scope, constructor, <span class="keyword">true</span>) ||</div>
<div class="line">                (globals ? getter($window, constructor, <span class="keyword">true</span>) : undefined);</div>
<div class="line"></div>
<div class="line">        assertArgFn(expression, constructor, <span class="keyword">true</span>);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (later) {</div>
<div class="line">        <span class="comment">// Instantiate controller later:</span></div>
<div class="line">        <span class="comment">// This machinery is used to create an instance of the object before calling the</span></div>
<div class="line">        <span class="comment">// controller&#39;s constructor itself.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This allows properties to be added to the controller before the constructor is</span></div>
<div class="line">        <span class="comment">// invoked. Primarily, this is used for isolate scope bindings in $compile.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This feature is not intended for use by applications, and is thus not documented</span></div>
<div class="line">        <span class="comment">// publicly.</span></div>
<div class="line">        <span class="comment">// Object creation: http://jsperf.com/create-constructor/2</span></div>
<div class="line">        var controllerPrototype = (isArray(expression) ?</div>
<div class="line">          expression[expression.length - 1] : expression).prototype;</div>
<div class="line">        instance = Object.create(controllerPrototype || null);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">          addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var instantiate;</div>
<div class="line">        <span class="keywordflow">return</span> instantiate = extend(<span class="keyword">function</span>() {</div>
<div class="line">          var result = $injector.invoke(expression, instance, locals, constructor);</div>
<div class="line">          <span class="keywordflow">if</span> (result !== instance &amp;&amp; (isObject(result) || isFunction(result))) {</div>
<div class="line">            instance = result;</div>
<div class="line">            <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">              <span class="comment">// If result changed, re-assign controllerAs value to scope.</span></div>
<div class="line">              addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> instance;</div>
<div class="line">        }, {</div>
<div class="line">          instance: instance,</div>
<div class="line">          identifier: identifier</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      instance = $injector.instantiate(expression, locals, constructor);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">        addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> instance;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addIdentifier(locals, identifier, instance, name) {</div>
<div class="line">      <span class="keywordflow">if</span> (!(locals &amp;&amp; isObject(locals.$scope))) {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;$controller&#39;</span>)(<span class="stringliteral">&#39;noscp&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;Cannot export controller &#39;{0}&#39; as &#39;{1}&#39;! No $scope object provided via `locals`.&quot;</span>,</div>
<div class="line">          name, identifier);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      locals.$scope[identifier] = instance;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $DocumentProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>(window) {</div>
<div class="line">    <span class="keywordflow">return</span> jqLite(window.document);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ExceptionHandlerProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$log&#39;</span>, <span class="keyword">function</span>($log) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(exception, cause) {</div>
<div class="line">      $log.error.apply($log, arguments);</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $$ForceReflowProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$document&#39;</span>, <span class="keyword">function</span>($document) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(domNode) {</div>
<div class="line">      <span class="comment">//the line below will force the browser to perform a repaint so</span></div>
<div class="line">      <span class="comment">//that all the animated elements within the animation frame will</span></div>
<div class="line">      <span class="comment">//be properly updated and drawn on screen. This is required to</span></div>
<div class="line">      <span class="comment">//ensure that the preparation animation is properly flushed so that</span></div>
<div class="line">      <span class="comment">//the active state picks up from there. DO NOT REMOVE THIS LINE.</span></div>
<div class="line">      <span class="comment">//DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH</span></div>
<div class="line">      <span class="comment">//WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND</span></div>
<div class="line">      <span class="comment">//WILL TAKE YEARS AWAY FROM YOUR LIFE.</span></div>
<div class="line">      <span class="keywordflow">if</span> (domNode) {</div>
<div class="line">        <span class="keywordflow">if</span> (!domNode.nodeType &amp;&amp; domNode instanceof jqLite) {</div>
<div class="line">          domNode = domNode[0];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        domNode = $document[0].body;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> domNode.offsetWidth + 1;</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var APPLICATION_JSON = <span class="stringliteral">&#39;application/json&#39;</span>;</div>
<div class="line">var CONTENT_TYPE_APPLICATION_JSON = {<span class="stringliteral">&#39;Content-Type&#39;</span>: APPLICATION_JSON + <span class="stringliteral">&#39;;charset=utf-8&#39;</span>};</div>
<div class="line">var JSON_START = /^\[|^\{(?!\{)/;</div>
<div class="line">var JSON_ENDS = {</div>
<div class="line">  <span class="charliteral">&#39;[&#39;</span>: /]$/,</div>
<div class="line">  <span class="charliteral">&#39;{&#39;</span>: /}$/</div>
<div class="line">};</div>
<div class="line">var JSON_PROTECTION_PREFIX = /^\)\]\}<span class="stringliteral">&#39;,?\n/;</span></div>
<div class="line"><span class="stringliteral">var $httpMinErr = minErr(&#39;</span>$http<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">var $httpMinErrLegacyFn = function(method) {</span></div>
<div class="line"><span class="stringliteral">  return function() {</span></div>
<div class="line"><span class="stringliteral">    throw $httpMinErr(&#39;</span>legacy<span class="stringliteral">&#39;, &#39;</span>The method `{0}` on the promise returned from `$http` has been disabled.<span class="stringliteral">&#39;, method);</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">};</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function serializeValue(v) {</span></div>
<div class="line"><span class="stringliteral">  if (isObject(v)) {</span></div>
<div class="line"><span class="stringliteral">    return isDate(v) ? v.toISOString() : toJson(v);</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral">  return v;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpParamSerializerProvider() {</span></div>
<div class="line"><span class="stringliteral">  this.$get = function() {</span></div>
<div class="line"><span class="stringliteral">    return function ngParamSerializer(params) {</span></div>
<div class="line"><span class="stringliteral">      if (!params) return &#39;</span><span class="stringliteral">&#39;;</span></div>
<div class="line"><span class="stringliteral">      var parts = [];</span></div>
<div class="line"><span class="stringliteral">      forEachSorted(params, function(value, key) {</span></div>
<div class="line"><span class="stringliteral">        if (value === null || isUndefined(value)) return;</span></div>
<div class="line"><span class="stringliteral">        if (isArray(value)) {</span></div>
<div class="line"><span class="stringliteral">          forEach(value, function(v, k) {</span></div>
<div class="line"><span class="stringliteral">            parts.push(encodeUriQuery(key)  + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(v)));</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else {</span></div>
<div class="line"><span class="stringliteral">          parts.push(encodeUriQuery(key) + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(value)));</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">      });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">      return parts.join(&#39;</span>&amp;<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">    };</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpParamSerializerJQLikeProvider() {</span></div>
<div class="line"><span class="stringliteral">  this.$get = function() {</span></div>
<div class="line"><span class="stringliteral">    return function jQueryLikeParamSerializer(params) {</span></div>
<div class="line"><span class="stringliteral">      if (!params) return &#39;</span><span class="stringliteral">&#39;;</span></div>
<div class="line"><span class="stringliteral">      var parts = [];</span></div>
<div class="line"><span class="stringliteral">      serialize(params, &#39;</span><span class="stringliteral">&#39;, true);</span></div>
<div class="line"><span class="stringliteral">      return parts.join(&#39;</span>&amp;<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">      function serialize(toSerialize, prefix, topLevel) {</span></div>
<div class="line"><span class="stringliteral">        if (toSerialize === null || isUndefined(toSerialize)) return;</span></div>
<div class="line"><span class="stringliteral">        if (isArray(toSerialize)) {</span></div>
<div class="line"><span class="stringliteral">          forEach(toSerialize, function(value, index) {</span></div>
<div class="line"><span class="stringliteral">            serialize(value, prefix + &#39;</span>[<span class="stringliteral">&#39; + (isObject(value) ? index : &#39;</span><span class="stringliteral">&#39;) + &#39;</span>]<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else if (isObject(toSerialize) &amp;&amp; !isDate(toSerialize)) {</span></div>
<div class="line"><span class="stringliteral">          forEachSorted(toSerialize, function(value, key) {</span></div>
<div class="line"><span class="stringliteral">            serialize(value, prefix +</span></div>
<div class="line"><span class="stringliteral">                (topLevel ? &#39;</span><span class="stringliteral">&#39; : &#39;</span>[<span class="stringliteral">&#39;) +</span></div>
<div class="line"><span class="stringliteral">                key +</span></div>
<div class="line"><span class="stringliteral">                (topLevel ? &#39;</span><span class="stringliteral">&#39; : &#39;</span>]<span class="stringliteral">&#39;));</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else {</span></div>
<div class="line"><span class="stringliteral">          parts.push(encodeUriQuery(prefix) + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(toSerialize)));</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">    };</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function defaultHttpResponseTransform(data, headers) {</span></div>
<div class="line"><span class="stringliteral">  if (isString(data)) {</span></div>
<div class="line"><span class="stringliteral">    // Strip json vulnerability protection prefix and trim whitespace</span></div>
<div class="line"><span class="stringliteral">    var tempData = data.replace(JSON_PROTECTION_PREFIX, &#39;</span><span class="stringliteral">&#39;).trim();</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    if (tempData) {</span></div>
<div class="line"><span class="stringliteral">      var contentType = headers(&#39;</span>Content-Type<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">      if ((contentType &amp;&amp; (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {</span></div>
<div class="line"><span class="stringliteral">        data = fromJson(tempData);</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return data;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function isJsonLike(str) {</span></div>
<div class="line"><span class="stringliteral">    var jsonStart = str.match(JSON_START);</span></div>
<div class="line"><span class="stringliteral">    return jsonStart &amp;&amp; JSON_ENDS[jsonStart[0]].test(str);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function parseHeaders(headers) {</span></div>
<div class="line"><span class="stringliteral">  var parsed = createMap(), i;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  function fillInParsed(key, val) {</span></div>
<div class="line"><span class="stringliteral">    if (key) {</span></div>
<div class="line"><span class="stringliteral">      parsed[key] = parsed[key] ? parsed[key] + &#39;</span>, <span class="stringliteral">&#39; + val : val;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  if (isString(headers)) {</span></div>
<div class="line"><span class="stringliteral">    forEach(headers.split(&#39;</span>\n<span class="stringliteral">&#39;), function(line) {</span></div>
<div class="line"><span class="stringliteral">      i = line.indexOf(&#39;</span>:<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">      fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  } else if (isObject(headers)) {</span></div>
<div class="line"><span class="stringliteral">    forEach(headers, function(headerVal, headerKey) {</span></div>
<div class="line"><span class="stringliteral">      fillInParsed(lowercase(headerKey), trim(headerVal));</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return parsed;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function headersGetter(headers) {</span></div>
<div class="line"><span class="stringliteral">  var headersObj;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return function(name) {</span></div>
<div class="line"><span class="stringliteral">    if (!headersObj) headersObj =  parseHeaders(headers);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    if (name) {</span></div>
<div class="line"><span class="stringliteral">      var value = headersObj[lowercase(name)];</span></div>
<div class="line"><span class="stringliteral">      if (value === void 0) {</span></div>
<div class="line"><span class="stringliteral">        value = null;</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">      return value;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    return headersObj;</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function transformData(data, headers, status, fns) {</span></div>
<div class="line"><span class="stringliteral">  if (isFunction(fns)) {</span></div>
<div class="line"><span class="stringliteral">    return fns(data, headers, status);</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  forEach(fns, function(fn) {</span></div>
<div class="line"><span class="stringliteral">    data = fn(data, headers, status);</span></div>
<div class="line"><span class="stringliteral">  });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return data;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function isSuccess(status) {</span></div>
<div class="line"><span class="stringliteral">  return 200 &lt;= status &amp;&amp; status &lt; 300;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpProvider() {</span></div>
<div class="line"><span class="stringliteral">  var defaults = this.defaults = {</span></div>
<div class="line"><span class="stringliteral">    // transform incoming response data</span></div>
<div class="line"><span class="stringliteral">    transformResponse: [defaultHttpResponseTransform],</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // transform outgoing request data</span></div>
<div class="line"><span class="stringliteral">    transformRequest: [function(d) {</span></div>
<div class="line"><span class="stringliteral">      return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) &amp;&amp; !isFormData(d) ? toJson(d) : d;</span></div>
<div class="line"><span class="stringliteral">    }],</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // default headers</span></div>
<div class="line"><span class="stringliteral">    headers: {</span></div>
<div class="line"><span class="stringliteral">      common: {</span></div>
<div class="line"><span class="stringliteral">        &#39;</span>Accept<span class="stringliteral">&#39;: &#39;</span>application/json, text/plain, *<span class="comment">/*&#39;</span></div>
<div class="line"><span class="comment">      },</span></div>
<div class="line"><span class="comment">      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),</span></div>
<div class="line"><span class="comment">      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),</span></div>
<div class="line"><span class="comment">      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)</span></div>
<div class="line"><span class="comment">    },</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    xsrfCookieName: &#39;XSRF-TOKEN&#39;,</span></div>
<div class="line"><span class="comment">    xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    paramSerializer: &#39;$httpParamSerializer&#39;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var useApplyAsync = false;</span></div>
<div class="line"><span class="comment">  this.useApplyAsync = function(value) {</span></div>
<div class="line"><span class="comment">    if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">      useApplyAsync = !!value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    return useApplyAsync;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var useLegacyPromise = true;</span></div>
<div class="line"><span class="comment">  this.useLegacyPromiseExtensions = function(value) {</span></div>
<div class="line"><span class="comment">    if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">      useLegacyPromise = !!value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    return useLegacyPromise;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var interceptorFactories = this.interceptors = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$httpBackend&#39;, &#39;$$cookieReader&#39;, &#39;$cacheFactory&#39;, &#39;$rootScope&#39;, &#39;$q&#39;, &#39;$injector&#39;,</span></div>
<div class="line"><span class="comment">      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    var defaultCache = $cacheFactory(&#39;$http&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    defaults.paramSerializer = isString(defaults.paramSerializer) ?</span></div>
<div class="line"><span class="comment">      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    var reversedInterceptors = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    forEach(interceptorFactories, function(interceptorFactory) {</span></div>
<div class="line"><span class="comment">      reversedInterceptors.unshift(isString(interceptorFactory)</span></div>
<div class="line"><span class="comment">          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));</span></div>
<div class="line"><span class="comment">    });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function $http(requestConfig) {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (!angular.isObject(requestConfig)) {</span></div>
<div class="line"><span class="comment">        throw minErr(&#39;$http&#39;)(&#39;badreq&#39;, &#39;Http request configuration must be an object.  Received: {0}&#39;, requestConfig);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var config = extend({</span></div>
<div class="line"><span class="comment">        method: &#39;get&#39;,</span></div>
<div class="line"><span class="comment">        transformRequest: defaults.transformRequest,</span></div>
<div class="line"><span class="comment">        transformResponse: defaults.transformResponse,</span></div>
<div class="line"><span class="comment">        paramSerializer: defaults.paramSerializer</span></div>
<div class="line"><span class="comment">      }, requestConfig);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      config.headers = mergeHeaders(requestConfig);</span></div>
<div class="line"><span class="comment">      config.method = uppercase(config.method);</span></div>
<div class="line"><span class="comment">      config.paramSerializer = isString(config.paramSerializer) ?</span></div>
<div class="line"><span class="comment">        $injector.get(config.paramSerializer) : config.paramSerializer;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var serverRequest = function(config) {</span></div>
<div class="line"><span class="comment">        var headers = config.headers;</span></div>
<div class="line"><span class="comment">        var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // strip content-type if data is undefined</span></div>
<div class="line"><span class="comment">        if (isUndefined(reqData)) {</span></div>
<div class="line"><span class="comment">          forEach(headers, function(value, header) {</span></div>
<div class="line"><span class="comment">            if (lowercase(header) === &#39;content-type&#39;) {</span></div>
<div class="line"><span class="comment">                delete headers[header];</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials)) {</span></div>
<div class="line"><span class="comment">          config.withCredentials = defaults.withCredentials;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // send request</span></div>
<div class="line"><span class="comment">        return sendReq(config, reqData).then(transformResponse, transformResponse);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var chain = [serverRequest, undefined];</span></div>
<div class="line"><span class="comment">      var promise = $q.when(config);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // apply interceptors</span></div>
<div class="line"><span class="comment">      forEach(reversedInterceptors, function(interceptor) {</span></div>
<div class="line"><span class="comment">        if (interceptor.request || interceptor.requestError) {</span></div>
<div class="line"><span class="comment">          chain.unshift(interceptor.request, interceptor.requestError);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        if (interceptor.response || interceptor.responseError) {</span></div>
<div class="line"><span class="comment">          chain.push(interceptor.response, interceptor.responseError);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      while (chain.length) {</span></div>
<div class="line"><span class="comment">        var thenFn = chain.shift();</span></div>
<div class="line"><span class="comment">        var rejectFn = chain.shift();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        promise = promise.then(thenFn, rejectFn);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (useLegacyPromise) {</span></div>
<div class="line"><span class="comment">        promise.success = function(fn) {</span></div>
<div class="line"><span class="comment">          assertArgFn(fn, &#39;fn&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          promise.then(function(response) {</span></div>
<div class="line"><span class="comment">            fn(response.data, response.status, response.headers, config);</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">          return promise;</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        promise.error = function(fn) {</span></div>
<div class="line"><span class="comment">          assertArgFn(fn, &#39;fn&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          promise.then(null, function(response) {</span></div>
<div class="line"><span class="comment">            fn(response.data, response.status, response.headers, config);</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">          return promise;</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      } else {</span></div>
<div class="line"><span class="comment">        promise.success = $httpMinErrLegacyFn(&#39;success&#39;);</span></div>
<div class="line"><span class="comment">        promise.error = $httpMinErrLegacyFn(&#39;error&#39;);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function transformResponse(response) {</span></div>
<div class="line"><span class="comment">        // make a copy since the response must be cacheable</span></div>
<div class="line"><span class="comment">        var resp = extend({}, response);</span></div>
<div class="line"><span class="comment">        if (!response.data) {</span></div>
<div class="line"><span class="comment">          resp.data = response.data;</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        return (isSuccess(response.status))</span></div>
<div class="line"><span class="comment">          ? resp</span></div>
<div class="line"><span class="comment">          : $q.reject(resp);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function executeHeaderFns(headers, config) {</span></div>
<div class="line"><span class="comment">        var headerContent, processedHeaders = {};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        forEach(headers, function(headerFn, header) {</span></div>
<div class="line"><span class="comment">          if (isFunction(headerFn)) {</span></div>
<div class="line"><span class="comment">            headerContent = headerFn(config);</span></div>
<div class="line"><span class="comment">            if (headerContent != null) {</span></div>
<div class="line"><span class="comment">              processedHeaders[header] = headerContent;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            processedHeaders[header] = headerFn;</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        return processedHeaders;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function mergeHeaders(config) {</span></div>
<div class="line"><span class="comment">        var defHeaders = defaults.headers,</span></div>
<div class="line"><span class="comment">            reqHeaders = extend({}, config.headers),</span></div>
<div class="line"><span class="comment">            defHeaderName, lowercaseDefHeaderName, reqHeaderName;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // using for-in instead of forEach to avoid unecessary iteration after header has been found</span></div>
<div class="line"><span class="comment">        defaultHeadersIteration:</span></div>
<div class="line"><span class="comment">        for (defHeaderName in defHeaders) {</span></div>
<div class="line"><span class="comment">          lowercaseDefHeaderName = lowercase(defHeaderName);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          for (reqHeaderName in reqHeaders) {</span></div>
<div class="line"><span class="comment">            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {</span></div>
<div class="line"><span class="comment">              continue defaultHeadersIteration;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          reqHeaders[defHeaderName] = defHeaders[defHeaderName];</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // execute if header value is a function for merged headers</span></div>
<div class="line"><span class="comment">        return executeHeaderFns(reqHeaders, shallowCopy(config));</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $http.pendingRequests = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    createShortMethods(&#39;get&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;jsonp&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    createShortMethodsWithData(&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $http.defaults = defaults;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return $http;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function createShortMethods(names) {</span></div>
<div class="line"><span class="comment">      forEach(arguments, function(name) {</span></div>
<div class="line"><span class="comment">        $http[name] = function(url, config) {</span></div>
<div class="line"><span class="comment">          return $http(extend({}, config || {}, {</span></div>
<div class="line"><span class="comment">            method: name,</span></div>
<div class="line"><span class="comment">            url: url</span></div>
<div class="line"><span class="comment">          }));</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function createShortMethodsWithData(name) {</span></div>
<div class="line"><span class="comment">      forEach(arguments, function(name) {</span></div>
<div class="line"><span class="comment">        $http[name] = function(url, data, config) {</span></div>
<div class="line"><span class="comment">          return $http(extend({}, config || {}, {</span></div>
<div class="line"><span class="comment">            method: name,</span></div>
<div class="line"><span class="comment">            url: url,</span></div>
<div class="line"><span class="comment">            data: data</span></div>
<div class="line"><span class="comment">          }));</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function sendReq(config, reqData) {</span></div>
<div class="line"><span class="comment">      var deferred = $q.defer(),</span></div>
<div class="line"><span class="comment">          promise = deferred.promise,</span></div>
<div class="line"><span class="comment">          cache,</span></div>
<div class="line"><span class="comment">          cachedResp,</span></div>
<div class="line"><span class="comment">          reqHeaders = config.headers,</span></div>
<div class="line"><span class="comment">          url = buildUrl(config.url, config.paramSerializer(config.params));</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      $http.pendingRequests.push(config);</span></div>
<div class="line"><span class="comment">      promise.then(removePendingReq, removePendingReq);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if ((config.cache || defaults.cache) &amp;&amp; config.cache !== false &amp;&amp;</span></div>
<div class="line"><span class="comment">          (config.method === &#39;GET&#39; || config.method === &#39;JSONP&#39;)) {</span></div>
<div class="line"><span class="comment">        cache = isObject(config.cache) ? config.cache</span></div>
<div class="line"><span class="comment">              : isObject(defaults.cache) ? defaults.cache</span></div>
<div class="line"><span class="comment">              : defaultCache;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (cache) {</span></div>
<div class="line"><span class="comment">        cachedResp = cache.get(url);</span></div>
<div class="line"><span class="comment">        if (isDefined(cachedResp)) {</span></div>
<div class="line"><span class="comment">          if (isPromiseLike(cachedResp)) {</span></div>
<div class="line"><span class="comment">            // cached request has already been sent, but there is no response yet</span></div>
<div class="line"><span class="comment">            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            // serving from cache</span></div>
<div class="line"><span class="comment">            if (isArray(cachedResp)) {</span></div>
<div class="line"><span class="comment">              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);</span></div>
<div class="line"><span class="comment">            } else {</span></div>
<div class="line"><span class="comment">              resolvePromise(cachedResp, 200, {}, &#39;OK&#39;);</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          // put the promise for the non-transformed response into cache as a placeholder</span></div>
<div class="line"><span class="comment">          cache.put(url, promise);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // if we won&#39;t have the response in cache, set the xsrf headers and</span></div>
<div class="line"><span class="comment">      // send the request to the backend</span></div>
<div class="line"><span class="comment">      if (isUndefined(cachedResp)) {</span></div>
<div class="line"><span class="comment">        var xsrfValue = urlIsSameOrigin(config.url)</span></div>
<div class="line"><span class="comment">            ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName]</span></div>
<div class="line"><span class="comment">            : undefined;</span></div>
<div class="line"><span class="comment">        if (xsrfValue) {</span></div>
<div class="line"><span class="comment">          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,</span></div>
<div class="line"><span class="comment">            config.withCredentials, config.responseType);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function done(status, response, headersString, statusText) {</span></div>
<div class="line"><span class="comment">        if (cache) {</span></div>
<div class="line"><span class="comment">          if (isSuccess(status)) {</span></div>
<div class="line"><span class="comment">            cache.put(url, [status, response, parseHeaders(headersString), statusText]);</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            // remove promise from the cache</span></div>
<div class="line"><span class="comment">            cache.remove(url);</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        function resolveHttpPromise() {</span></div>
<div class="line"><span class="comment">          resolvePromise(response, status, headersString, statusText);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (useApplyAsync) {</span></div>
<div class="line"><span class="comment">          $rootScope.$applyAsync(resolveHttpPromise);</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          resolveHttpPromise();</span></div>
<div class="line"><span class="comment">          if (!$rootScope.$$phase) $rootScope.$apply();</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function resolvePromise(response, status, headers, statusText) {</span></div>
<div class="line"><span class="comment">        // normalize internal statuses to 0</span></div>
<div class="line"><span class="comment">        status = Math.max(status, 0);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        (isSuccess(status) ? deferred.resolve : deferred.reject)({</span></div>
<div class="line"><span class="comment">          data: response,</span></div>
<div class="line"><span class="comment">          status: status,</span></div>
<div class="line"><span class="comment">          headers: headersGetter(headers),</span></div>
<div class="line"><span class="comment">          config: config,</span></div>
<div class="line"><span class="comment">          statusText: statusText</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function resolvePromiseWithResult(result) {</span></div>
<div class="line"><span class="comment">        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function removePendingReq() {</span></div>
<div class="line"><span class="comment">        var idx = $http.pendingRequests.indexOf(config);</span></div>
<div class="line"><span class="comment">        if (idx !== -1) $http.pendingRequests.splice(idx, 1);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function buildUrl(url, serializedParams) {</span></div>
<div class="line"><span class="comment">      if (serializedParams.length &gt; 0) {</span></div>
<div class="line"><span class="comment">        url += ((url.indexOf(&#39;?&#39;) == -1) ? &#39;?&#39; : &#39;&amp;&#39;) + serializedParams;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      return url;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function createXhr() {</span></div>
<div class="line"><span class="comment">    return new window.XMLHttpRequest();</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $HttpBackendProvider() {</span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$browser&#39;, &#39;$window&#39;, &#39;$document&#39;, function($browser, $window, $document) {</span></div>
<div class="line"><span class="comment">    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {</span></div>
<div class="line"><span class="comment">  // TODO(vojta): fix the signature</span></div>
<div class="line"><span class="comment">  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {</span></div>
<div class="line"><span class="comment">    $browser.$$incOutstandingRequestCount();</span></div>
<div class="line"><span class="comment">    url = url || $browser.url();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    if (lowercase(method) == &#39;jsonp&#39;) {</span></div>
<div class="line"><span class="comment">      var callbackId = &#39;_&#39; + (callbacks.counter++).toString(36);</span></div>
<div class="line"><span class="comment">      callbacks[callbackId] = function(data) {</span></div>
<div class="line"><span class="comment">        callbacks[callbackId].data = data;</span></div>
<div class="line"><span class="comment">        callbacks[callbackId].called = true;</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var jsonpDone = jsonpReq(url.replace(&#39;JSON_CALLBACK&#39;, &#39;angular.callbacks.&#39; + callbackId),</span></div>
<div class="line"><span class="comment">          callbackId, function(status, text) {</span></div>
<div class="line"><span class="comment">        completeRequest(callback, status, callbacks[callbackId].data, &quot;&quot;, text);</span></div>
<div class="line"><span class="comment">        callbacks[callbackId] = noop;</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var xhr = createXhr();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.open(method, url, true);</span></div>
<div class="line"><span class="comment">      forEach(headers, function(value, key) {</span></div>
<div class="line"><span class="comment">        if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">            xhr.setRequestHeader(key, value);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.onload = function requestLoaded() {</span></div>
<div class="line"><span class="comment">        var statusText = xhr.statusText || &#39;&#39;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // responseText is the old-school way of retrieving response (supported by IE9)</span></div>
<div class="line"><span class="comment">        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)</span></div>
<div class="line"><span class="comment">        var response = (&#39;response&#39; in xhr) ? xhr.response : xhr.responseText;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)</span></div>
<div class="line"><span class="comment">        var status = xhr.status === 1223 ? 204 : xhr.status;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // fix status code when it is 0 (0 status is undocumented).</span></div>
<div class="line"><span class="comment">        // Occurs when accessing file resources or on Android 4.1 stock browser</span></div>
<div class="line"><span class="comment">        // while retrieving files from application cache.</span></div>
<div class="line"><span class="comment">        if (status === 0) {</span></div>
<div class="line"><span class="comment">          status = response ? 200 : urlResolve(url).protocol == &#39;file&#39; ? 404 : 0;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        completeRequest(callback,</span></div>
<div class="line"><span class="comment">            status,</span></div>
<div class="line"><span class="comment">            response,</span></div>
<div class="line"><span class="comment">            xhr.getAllResponseHeaders(),</span></div>
<div class="line"><span class="comment">            statusText);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var requestError = function() {</span></div>
<div class="line"><span class="comment">        // The response is always empty</span></div>
<div class="line"><span class="comment">        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error</span></div>
<div class="line"><span class="comment">        completeRequest(callback, -1, null, null, &#39;&#39;);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.onerror = requestError;</span></div>
<div class="line"><span class="comment">      xhr.onabort = requestError;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (withCredentials) {</span></div>
<div class="line"><span class="comment">        xhr.withCredentials = true;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (responseType) {</span></div>
<div class="line"><span class="comment">        try {</span></div>
<div class="line"><span class="comment">          xhr.responseType = responseType;</span></div>
<div class="line"><span class="comment">        } catch (e) {</span></div>
<div class="line"><span class="comment">          // WebKit added support for the json responseType value on 09/03/2013</span></div>
<div class="line"><span class="comment">          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are</span></div>
<div class="line"><span class="comment">          // known to throw when setting the value &quot;json&quot; as the response type. Other older</span></div>
<div class="line"><span class="comment">          // browsers implementing the responseType</span></div>
<div class="line"><span class="comment">          //</span></div>
<div class="line"><span class="comment">          // The json response type can be ignored if not supported, because JSON payloads are</span></div>
<div class="line"><span class="comment">          // parsed on the client-side regardless.</span></div>
<div class="line"><span class="comment">          if (responseType !== &#39;json&#39;) {</span></div>
<div class="line"><span class="comment">            throw e;</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.send(post);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    if (timeout &gt; 0) {</span></div>
<div class="line"><span class="comment">      var timeoutId = $browserDefer(timeoutRequest, timeout);</span></div>
<div class="line"><span class="comment">    } else if (isPromiseLike(timeout)) {</span></div>
<div class="line"><span class="comment">      timeout.then(timeoutRequest);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function timeoutRequest() {</span></div>
<div class="line"><span class="comment">      jsonpDone &amp;&amp; jsonpDone();</span></div>
<div class="line"><span class="comment">      xhr &amp;&amp; xhr.abort();</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function completeRequest(callback, status, response, headersString, statusText) {</span></div>
<div class="line"><span class="comment">      // cancel timeout and subsequent timeout promise resolution</span></div>
<div class="line"><span class="comment">      if (timeoutId !== undefined) {</span></div>
<div class="line"><span class="comment">        $browserDefer.cancel(timeoutId);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      jsonpDone = xhr = null;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      callback(status, response, headersString, statusText);</span></div>
<div class="line"><span class="comment">      $browser.$$completeOutstandingRequest(noop);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  function jsonpReq(url, callbackId, done) {</span></div>
<div class="line"><span class="comment">    // we can&#39;t use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:</span></div>
<div class="line"><span class="comment">    // - fetches local scripts via XHR and evals them</span></div>
<div class="line"><span class="comment">    // - adds and immediately removes script elements from the document</span></div>
<div class="line"><span class="comment">    var script = rawDocument.createElement(&#39;script&#39;), callback = null;</span></div>
<div class="line"><span class="comment">    script.type = &quot;text/javascript&quot;;</span></div>
<div class="line"><span class="comment">    script.src = url;</span></div>
<div class="line"><span class="comment">    script.async = true;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    callback = function(event) {</span></div>
<div class="line"><span class="comment">      removeEventListenerFn(script, &quot;load&quot;, callback);</span></div>
<div class="line"><span class="comment">      removeEventListenerFn(script, &quot;error&quot;, callback);</span></div>
<div class="line"><span class="comment">      rawDocument.body.removeChild(script);</span></div>
<div class="line"><span class="comment">      script = null;</span></div>
<div class="line"><span class="comment">      var status = -1;</span></div>
<div class="line"><span class="comment">      var text = &quot;unknown&quot;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (event) {</span></div>
<div class="line"><span class="comment">        if (event.type === &quot;load&quot; &amp;&amp; !callbacks[callbackId].called) {</span></div>
<div class="line"><span class="comment">          event = { type: &quot;error&quot; };</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        text = event.type;</span></div>
<div class="line"><span class="comment">        status = event.type === &quot;error&quot; ? 404 : 200;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (done) {</span></div>
<div class="line"><span class="comment">        done(status, text);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    addEventListenerFn(script, &quot;load&quot;, callback);</span></div>
<div class="line"><span class="comment">    addEventListenerFn(script, &quot;error&quot;, callback);</span></div>
<div class="line"><span class="comment">    rawDocument.body.appendChild(script);</span></div>
<div class="line"><span class="comment">    return callback;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">var $interpolateMinErr = angular.$interpolateMinErr = minErr(&#39;$interpolate&#39;);</span></div>
<div class="line"><span class="comment">$interpolateMinErr.throwNoconcat = function(text) {</span></div>
<div class="line"><span class="comment">  throw $interpolateMinErr(&#39;noconcat&#39;,</span></div>
<div class="line"><span class="comment">      &quot;Error while interpolating: {0}\nStrict Contextual Escaping disallows &quot; +</span></div>
<div class="line"><span class="comment">      &quot;interpolations that concatenate multiple expressions when a trusted value is &quot; +</span></div>
<div class="line"><span class="comment">      &quot;required.  See http://docs.angularjs.org/api/ng.$sce&quot;, text);</span></div>
<div class="line"><span class="comment">};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">$interpolateMinErr.interr = function(text, err) {</span></div>
<div class="line"><span class="comment">  return $interpolateMinErr(&#39;interr&#39;, &quot;Can&#39;t interpolate: {0}\n{1}&quot;, text, err.toString());</span></div>
<div class="line"><span class="comment">};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $InterpolateProvider() {</span></div>
<div class="line"><span class="comment">  var startSymbol = &#39;{{&#39;;</span></div>
<div class="line"><span class="comment">  var endSymbol = &#39;}}&#39;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.startSymbol = function(value) {</span></div>
<div class="line"><span class="comment">    if (value) {</span></div>
<div class="line"><span class="comment">      startSymbol = value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment">      return startSymbol;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.endSymbol = function(value) {</span></div>
<div class="line"><span class="comment">    if (value) {</span></div>
<div class="line"><span class="comment">      endSymbol = value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment">      return endSymbol;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$parse&#39;, &#39;$exceptionHandler&#39;, &#39;$sce&#39;, function($parse, $exceptionHandler, $sce) {</span></div>
<div class="line"><span class="comment">    var startSymbolLength = startSymbol.length,</span></div>
<div class="line"><span class="comment">        endSymbolLength = endSymbol.length,</span></div>
<div class="line"><span class="comment">        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), &#39;g&#39;),</span></div>
<div class="line"><span class="comment">        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), &#39;g&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function escape(ch) {</span></div>
<div class="line"><span class="comment">      return &#39;\\\\\\&#39; + ch;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function unescapeText(text) {</span></div>
<div class="line"><span class="comment">      return text.replace(escapedStartRegexp, startSymbol).</span></div>
<div class="line"><span class="comment">        replace(escapedEndRegexp, endSymbol);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function stringify(value) {</span></div>
<div class="line"><span class="comment">      if (value == null) { // null || undefined</span></div>
<div class="line"><span class="comment">        return &#39;&#39;;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      switch (typeof value) {</span></div>
<div class="line"><span class="comment">        case &#39;string&#39;:</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        case &#39;number&#39;:</span></div>
<div class="line"><span class="comment">          value = &#39;&#39; + value;</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        default:</span></div>
<div class="line"><span class="comment">          value = toJson(value);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return value;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {</span></div>
<div class="line"><span class="comment">      allOrNothing = !!allOrNothing;</span></div>
<div class="line"><span class="comment">      var startIndex,</span></div>
<div class="line"><span class="comment">          endIndex,</span></div>
<div class="line"><span class="comment">          index = 0,</span></div>
<div class="line"><span class="comment">          expressions = [],</span></div>
<div class="line"><span class="comment">          parseFns = [],</span></div>
<div class="line"><span class="comment">          textLength = text.length,</span></div>
<div class="line"><span class="comment">          exp,</span></div>
<div class="line"><span class="comment">          concat = [],</span></div>
<div class="line"><span class="comment">          expressionPositions = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      while (index &lt; textLength) {</span></div>
<div class="line"><span class="comment">        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;</span></div>
<div class="line"><span class="comment">             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {</span></div>
<div class="line"><span class="comment">          if (index !== startIndex) {</span></div>
<div class="line"><span class="comment">            concat.push(unescapeText(text.substring(index, startIndex)));</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          exp = text.substring(startIndex + startSymbolLength, endIndex);</span></div>
<div class="line"><span class="comment">          expressions.push(exp);</span></div>
<div class="line"><span class="comment">          parseFns.push($parse(exp, parseStringifyInterceptor));</span></div>
<div class="line"><span class="comment">          index = endIndex + endSymbolLength;</span></div>
<div class="line"><span class="comment">          expressionPositions.push(concat.length);</span></div>
<div class="line"><span class="comment">          concat.push(&#39;&#39;);</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          // we did not find an interpolation, so we have to add the remainder to the separators array</span></div>
<div class="line"><span class="comment">          if (index !== textLength) {</span></div>
<div class="line"><span class="comment">            concat.push(unescapeText(text.substring(index)));</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // Concatenating expressions makes it hard to reason about whether some combination of</span></div>
<div class="line"><span class="comment">      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a</span></div>
<div class="line"><span class="comment">      // single expression be used for iframe[src], object[src], etc., we ensure that the value</span></div>
<div class="line"><span class="comment">      // that&#39;s used is assigned or constructed by some JS code somewhere that is more testable or</span></div>
<div class="line"><span class="comment">      // make it obvious that you bound the value to some user controlled value.  This helps reduce</span></div>
<div class="line"><span class="comment">      // the load when auditing for XSS issues.</span></div>
<div class="line"><span class="comment">      if (trustedContext &amp;&amp; concat.length &gt; 1) {</span></div>
<div class="line"><span class="comment">          $interpolateMinErr.throwNoconcat(text);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (!mustHaveExpression || expressions.length) {</span></div>
<div class="line"><span class="comment">        var compute = function(values) {</span></div>
<div class="line"><span class="comment">          for (var i = 0, ii = expressions.length; i &lt; ii; i++) {</span></div>
<div class="line"><span class="comment">            if (allOrNothing &amp;&amp; isUndefined(values[i])) return;</span></div>
<div class="line"><span class="comment">            concat[expressionPositions[i]] = values[i];</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          return concat.join(&#39;&#39;);</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        var getValue = function(value) {</span></div>
<div class="line"><span class="comment">          return trustedContext ?</span></div>
<div class="line"><span class="comment">            $sce.getTrusted(trustedContext, value) :</span></div>
<div class="line"><span class="comment">            $sce.valueOf(value);</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        return extend(function interpolationFn(context) {</span></div>
<div class="line"><span class="comment">            var i = 0;</span></div>
<div class="line"><span class="comment">            var ii = expressions.length;</span></div>
<div class="line"><span class="comment">            var values = new Array(ii);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            try {</span></div>
<div class="line"><span class="comment">              for (; i &lt; ii; i++) {</span></div>
<div class="line"><span class="comment">                values[i] = parseFns[i](context);</span></div>
<div class="line"><span class="comment">              }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">              return compute(values);</span></div>
<div class="line"><span class="comment">            } catch (err) {</span></div>
<div class="line"><span class="comment">              $exceptionHandler($interpolateMinErr.interr(text, err));</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          }, {</span></div>
<div class="line"><span class="comment">          // all of these properties are undocumented for now</span></div>
<div class="line"><span class="comment">          exp: text, //just for compatibility with regular watchers created via $watch</span></div>
<div class="line"><span class="comment">          expressions: expressions,</span></div>
<div class="line"><span class="comment">          $$watchDelegate: function(scope, listener) {</span></div>
<div class="line"><span class="comment">            var lastValue;</span></div>
<div class="line"><span class="comment">            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {</span></div>
<div class="line"><span class="comment">              var currValue = compute(values);</span></div>
<div class="line"><span class="comment">              if (isFunction(listener)) {</span></div>
<div class="line"><span class="comment">                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);</span></div>
<div class="line"><span class="comment">              }</span></div>
<div class="line"><span class="comment">              lastValue = currValue;</span></div>
<div class="line"><span class="comment">            });</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function parseStringifyInterceptor(value) {</span></div>
<div class="line"><span class="comment">        try {</span></div>
<div class="line"><span class="comment">          value = getValue(value);</span></div>
<div class="line"><span class="comment">          return allOrNothing &amp;&amp; !isDefined(value) ? value : stringify(value);</span></div>
<div class="line"><span class="comment">        } catch (err) {</span></div>
<div class="line"><span class="comment">          $exceptionHandler($interpolateMinErr.interr(text, err));</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $interpolate.startSymbol = function() {</span></div>
<div class="line"><span class="comment">      return startSymbol;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $interpolate.endSymbol = function() {</span></div>
<div class="line"><span class="comment">      return endSymbol;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return $interpolate;</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $IntervalProvider() {</span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$rootScope&#39;, &#39;$window&#39;, &#39;$q&#39;, &#39;$$q&#39;,</span></div>
<div class="line"><span class="comment">       function($rootScope,   $window,   $q,   $$q) {</span></div>
<div class="line"><span class="comment">    var intervals = {};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function interval(fn, delay, count, invokeApply) {</span></div>
<div class="line"><span class="comment">      var hasParams = arguments.length &gt; 4,</span></div>
<div class="line"><span class="comment">          args = hasParams ? sliceArgs(arguments, 4) : [],</span></div>
<div class="line"><span class="comment">          setInterval = $window.setInterval,</span></div>
<div class="line"><span class="comment">          clearInterval = $window.clearInterval,</span></div>
<div class="line"><span class="comment">          iteration = 0,</span></div>
<div class="line"><span class="comment">          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),</span></div>
<div class="line"><span class="comment">          deferred = (skipApply ? $$q : $q).defer(),</span></div>
<div class="line"><span class="comment">          promise = deferred.promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      count = isDefined(count) ? count : 0;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      promise.then(null, null, (!hasParams) ? fn : function() {</span></div>
<div class="line"><span class="comment">        fn.apply(null, args);</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      promise.$$intervalId = setInterval(function tick() {</span></div>
<div class="line"><span class="comment">        deferred.notify(iteration++);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (count &gt; 0 &amp;&amp; iteration &gt;= count) {</span></div>
<div class="line"><span class="comment">          deferred.resolve(iteration);</span></div>
<div class="line"><span class="comment">          clearInterval(promise.$$intervalId);</span></div>
<div class="line"><span class="comment">          delete intervals[promise.$$intervalId];</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (!skipApply) $rootScope.$apply();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      }, delay);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      intervals[promise.$$intervalId] = deferred;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    interval.cancel = function(promise) {</span></div>
<div class="line"><span class="comment">      if (promise &amp;&amp; promise.$$intervalId in intervals) {</span></div>
<div class="line"><span class="comment">        intervals[promise.$$intervalId].reject(&#39;canceled&#39;);</span></div>
<div class="line"><span class="comment">        $window.clearInterval(promise.$$intervalId);</span></div>
<div class="line"><span class="comment">        delete intervals[promise.$$intervalId];</span></div>
<div class="line"><span class="comment">        return true;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      return false;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return interval;</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,</span></div>
<div class="line"><span class="comment">    DEFAULT_PORTS = {&#39;http&#39;: 80, &#39;https&#39;: 443, &#39;ftp&#39;: 21};</span></div>
<div class="line"><span class="comment">var $locationMinErr = minErr(&#39;$location&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function encodePath(path) {</span></div>
<div class="line"><span class="comment">  var segments = path.split(&#39;/&#39;),</span></div>
<div class="line"><span class="comment">      i = segments.length;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  while (i--) {</span></div>
<div class="line"><span class="comment">    segments[i] = encodeUriSegment(segments[i]);</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  return segments.join(&#39;/&#39;);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function parseAbsoluteUrl(absoluteUrl, locationObj) {</span></div>
<div class="line"><span class="comment">  var parsedUrl = urlResolve(absoluteUrl);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  locationObj.$$protocol = parsedUrl.protocol;</span></div>
<div class="line"><span class="comment">  locationObj.$$host = parsedUrl.hostname;</span></div>
<div class="line"><span class="comment">  locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function parseAppUrl(relativeUrl, locationObj) {</span></div>
<div class="line"><span class="comment">  var prefixed = (relativeUrl.charAt(0) !== &#39;/&#39;);</span></div>
<div class="line"><span class="comment">  if (prefixed) {</span></div>
<div class="line"><span class="comment">    relativeUrl = &#39;/&#39; + relativeUrl;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">  var match = urlResolve(relativeUrl);</span></div>
<div class="line"><span class="comment">  locationObj.$$path = decodeURIComponent(prefixed &amp;&amp; match.pathname.charAt(0) === &#39;/&#39; ?</span></div>
<div class="line"><span class="comment">      match.pathname.substring(1) : match.pathname);</span></div>
<div class="line"><span class="comment">  locationObj.$$search = parseKeyValue(match.search);</span></div>
<div class="line"><span class="comment">  locationObj.$$hash = decodeURIComponent(match.hash);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  // make sure path starts with &#39;/&#39;;</span></div>
<div class="line"><span class="comment">  if (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) != &#39;/&#39;) {</span></div>
<div class="line"><span class="comment">    locationObj.$$path = &#39;/&#39; + locationObj.$$path;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function beginsWith(begin, whole) {</span></div>
<div class="line"><span class="comment">  if (whole.indexOf(begin) === 0) {</span></div>
<div class="line"><span class="comment">    return whole.substr(begin.length);</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function stripHash(url) {</span></div>
<div class="line"><span class="comment">  var index = url.indexOf(&#39;#&#39;);</span></div>
<div class="line"><span class="comment">  return index == -1 ? url : url.substr(0, index);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function trimEmptyHash(url) {</span></div>
<div class="line"><span class="comment">  return url.replace(/(#.+)|#$/, &#39;$1&#39;);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function stripFile(url) {</span></div>
<div class="line"><span class="comment">  return url.substr(0, stripHash(url).lastIndexOf(&#39;/&#39;) + 1);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/* return the server only (scheme://host:port) */</span></div>
<div class="line"><span class="keyword">function</span> serverBase(url) {</div>
<div class="line">  <span class="keywordflow">return</span> url.substring(0, url.indexOf(<span class="charliteral">&#39;/&#39;</span>, url.indexOf(<span class="stringliteral">&#39;//&#39;</span>) + 2));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {</div>
<div class="line">  this.$$html5 = <span class="keyword">true</span>;</div>
<div class="line">  basePrefix = basePrefix || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  parseAbsoluteUrl(appBase, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$$parse = <span class="keyword">function</span>(url) {</div>
<div class="line">    var pathUrl = beginsWith(appBaseNoFile, url);</div>
<div class="line">    <span class="keywordflow">if</span> (!isString(pathUrl)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;ipthprfx&#39;</span>, <span class="stringliteral">&#39;Invalid url &quot;{0}&quot;, missing path prefix &quot;{1}&quot;.&#39;</span>, url,</div>
<div class="line">          appBaseNoFile);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    parseAppUrl(pathUrl, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!this.$$path) {</div>
<div class="line">      this.$$path = <span class="charliteral">&#39;/&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); <span class="comment">// first char is always &#39;/&#39;</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (relHref &amp;&amp; relHref[0] === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">      <span class="comment">// special case for links to hash fragments:</span></div>
<div class="line">      <span class="comment">// keep the old url and only replace the hash fragment</span></div>
<div class="line">      this.hash(relHref.slice(1));</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    var appUrl, prevAppUrl;</div>
<div class="line">    var rewrittenUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ((appUrl = beginsWith(appBase, url)) !== undefined) {</div>
<div class="line">      prevAppUrl = appUrl;</div>
<div class="line">      <span class="keywordflow">if</span> ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {</div>
<div class="line">        rewrittenUrl = appBaseNoFile + (beginsWith(<span class="charliteral">&#39;/&#39;</span>, appUrl) || appUrl);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        rewrittenUrl = appBase + prevAppUrl;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile + appUrl;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (appBaseNoFile == url + <span class="charliteral">&#39;/&#39;</span>) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rewrittenUrl) {</div>
<div class="line">      this.$$parse(rewrittenUrl);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> !!rewrittenUrl;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {</div>
<div class="line"></div>
<div class="line">  parseAbsoluteUrl(appBase, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$$parse = <span class="keyword">function</span>(url) {</div>
<div class="line">    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);</div>
<div class="line">    var withoutHashUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isUndefined(withoutBaseUrl) &amp;&amp; withoutBaseUrl.charAt(0) === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The rest of the url starts with a hash so we have</span></div>
<div class="line">      <span class="comment">// got either a hashbang path or a plain hash fragment</span></div>
<div class="line">      withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(withoutHashUrl)) {</div>
<div class="line">        <span class="comment">// There was no hashbang prefix so we just have a hash fragment</span></div>
<div class="line">        withoutHashUrl = withoutBaseUrl;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// There was no hashbang path nor hash fragment:</span></div>
<div class="line">      <span class="comment">// If we are in HTML5 mode we use what is left as the path;</span></div>
<div class="line">      <span class="comment">// Otherwise we ignore what is left</span></div>
<div class="line">      <span class="keywordflow">if</span> (this.$$html5) {</div>
<div class="line">        withoutHashUrl = withoutBaseUrl;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        withoutHashUrl = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(withoutBaseUrl)) {</div>
<div class="line">          appBase = url;</div>
<div class="line">          this.replace();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    parseAppUrl(withoutHashUrl, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line"></div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * In Windows, on an anchor node on documents loaded from</span></div>
<div class="line"><span class="comment">     * the filesystem, the browser will return a pathname</span></div>
<div class="line"><span class="comment">     * prefixed with the drive name (&#39;/C:/path&#39;) when a</span></div>
<div class="line"><span class="comment">     * pathname without a drive is set:</span></div>
<div class="line"><span class="comment">     *  * a.setAttribute(&#39;href&#39;, &#39;/foo&#39;)</span></div>
<div class="line"><span class="comment">     *   * a.pathname === &#39;/C:/foo&#39; //true</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Inside of Angular, we&#39;re always using pathnames that</span></div>
<div class="line"><span class="comment">     * do not include drive names for routing.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">function</span> removeWindowsDriveName(path, url, base) {</div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">      Matches paths for file protocol on windows,</span></div>
<div class="line"><span class="comment">      such as /C:/foo/bar, and captures only /foo/bar.</span></div>
<div class="line"><span class="comment">      */</span></div>
<div class="line">      var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;</div>
<div class="line"></div>
<div class="line">      var firstPathSegmentMatch;</div>
<div class="line"></div>
<div class="line">      <span class="comment">//Get the relative path from the input URL.</span></div>
<div class="line">      <span class="keywordflow">if</span> (url.indexOf(base) === 0) {</div>
<div class="line">        url = url.replace(base, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The input URL intentionally contains a first path segment that ends with a colon.</span></div>
<div class="line">      <span class="keywordflow">if</span> (windowsFilePathExp.exec(url)) {</div>
<div class="line">        <span class="keywordflow">return</span> path;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      firstPathSegmentMatch = windowsFilePathExp.exec(path);</div>
<div class="line">      <span class="keywordflow">return</span> firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (stripHash(appBase) == stripHash(url)) {</div>
<div class="line">      this.$$parse(url);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {</div>
<div class="line">  this.$$html5 = <span class="keyword">true</span>;</div>
<div class="line">  LocationHashbangUrl.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (relHref &amp;&amp; relHref[0] === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">      <span class="comment">// special case for links to hash fragments:</span></div>
<div class="line">      <span class="comment">// keep the old url and only replace the hash fragment</span></div>
<div class="line">      this.hash(relHref.slice(1));</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var rewrittenUrl;</div>
<div class="line">    var appUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (appBase == stripHash(url)) {</div>
<div class="line">      rewrittenUrl = url;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((appUrl = beginsWith(appBaseNoFile, url))) {</div>
<div class="line">      rewrittenUrl = appBase + hashPrefix + appUrl;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (appBaseNoFile === url + <span class="charliteral">&#39;/&#39;</span>) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rewrittenUrl) {</div>
<div class="line">      this.$$parse(rewrittenUrl);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> !!rewrittenUrl;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    <span class="comment">// include hashPrefix in $$absUrl when $$url is empty so IE9 does not reload page because of removal of &#39;#&#39;</span></div>
<div class="line">    this.$$absUrl = appBase + hashPrefix + this.$$url;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var locationPrototype = {</div>
<div class="line"></div>
<div class="line">  $$html5: <span class="keyword">false</span>,</div>
<div class="line"></div>
<div class="line">  $$replace: <span class="keyword">false</span>,</div>
<div class="line"></div>
<div class="line">  absUrl: locationGetter(<span class="stringliteral">&#39;$$absUrl&#39;</span>),</div>
<div class="line"></div>
<div class="line">  url: <span class="keyword">function</span>(url) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(url)) {</div>
<div class="line">      <span class="keywordflow">return</span> this.$$url;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var match = PATH_MATCH.exec(url);</div>
<div class="line">    <span class="keywordflow">if</span> (match[1] || url === <span class="stringliteral">&#39;&#39;</span>) this.path(decodeURIComponent(match[1]));</div>
<div class="line">    <span class="keywordflow">if</span> (match[2] || match[1] || url === <span class="stringliteral">&#39;&#39;</span>) this.search(match[3] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    this.hash(match[5] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  protocol: locationGetter(<span class="stringliteral">&#39;$$protocol&#39;</span>),</div>
<div class="line"></div>
<div class="line">  host: locationGetter(<span class="stringliteral">&#39;$$host&#39;</span>),</div>
<div class="line"></div>
<div class="line">  port: locationGetter(<span class="stringliteral">&#39;$$port&#39;</span>),</div>
<div class="line"></div>
<div class="line">  path: locationGetterSetter(<span class="stringliteral">&#39;$$path&#39;</span>, <span class="keyword">function</span>(path) {</div>
<div class="line">    path = path !== null ? path.toString() : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> path.charAt(0) == <span class="charliteral">&#39;/&#39;</span> ? path : <span class="charliteral">&#39;/&#39;</span> + path;</div>
<div class="line">  }),</div>
<div class="line"></div>
<div class="line">  search: <span class="keyword">function</span>(search, paramValue) {</div>
<div class="line">    <span class="keywordflow">switch</span> (arguments.length) {</div>
<div class="line">      <span class="keywordflow">case</span> 0:</div>
<div class="line">        <span class="keywordflow">return</span> this.$$search;</div>
<div class="line">      <span class="keywordflow">case</span> 1:</div>
<div class="line">        <span class="keywordflow">if</span> (isString(search) || isNumber(search)) {</div>
<div class="line">          search = search.toString();</div>
<div class="line">          this.$$search = parseKeyValue(search);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(search)) {</div>
<div class="line">          search = copy(search, {});</div>
<div class="line">          <span class="comment">// remove object undefined or null properties</span></div>
<div class="line">          forEach(search, <span class="keyword">function</span>(value, key) {</div>
<div class="line">            <span class="keywordflow">if</span> (value == null) <span class="keyword">delete</span> search[key];</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          this.$$search = search;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;isrcharg&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&#39;The first argument of the `$location#search()` call must be a string or an object.&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(paramValue) || paramValue === null) {</div>
<div class="line">          <span class="keyword">delete</span> this.$$search[search];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.$$search[search] = paramValue;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  hash: locationGetterSetter(<span class="stringliteral">&#39;$$hash&#39;</span>, <span class="keyword">function</span>(hash) {</div>
<div class="line">    <span class="keywordflow">return</span> hash !== null ? hash.toString() : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  }),</div>
<div class="line"></div>
<div class="line">  replace: <span class="keyword">function</span>() {</div>
<div class="line">    this.$$replace = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], <span class="keyword">function</span>(Location) {</div>
<div class="line">  Location.prototype = Object.create(locationPrototype);</div>
<div class="line"></div>
<div class="line">  Location.prototype.state = <span class="keyword">function</span>(state) {</div>
<div class="line">    <span class="keywordflow">if</span> (!arguments.length) {</div>
<div class="line">      <span class="keywordflow">return</span> this.$$state;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (Location !== LocationHtml5Url || !this.$$html5) {</div>
<div class="line">      <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;nostate&#39;</span>, <span class="stringliteral">&#39;History API state support is available only &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;in HTML5 mode and only in browsers supporting HTML5 History API&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// The user might modify `stateObject` after invoking `$location.state(stateObject)`</span></div>
<div class="line">    <span class="comment">// but we&#39;re changing the $$state reference to $browser.state() during the $digest</span></div>
<div class="line">    <span class="comment">// so the modification window is narrow.</span></div>
<div class="line">    this.$$state = isUndefined(state) ? null : state;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> locationGetter(property) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>[property];</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> locationGetterSetter(property, preprocess) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[property];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">this</span>[property] = preprocess(value);</div>
<div class="line">    this.$$compose();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $LocationProvider() {</div>
<div class="line">  var hashPrefix = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      html5Mode = {</div>
<div class="line">        enabled: <span class="keyword">false</span>,</div>
<div class="line">        requireBase: <span class="keyword">true</span>,</div>
<div class="line">        rewriteLinks: <span class="keyword">true</span></div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">  this.hashPrefix = <span class="keyword">function</span>(prefix) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(prefix)) {</div>
<div class="line">      hashPrefix = prefix;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> hashPrefix;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.html5Mode = <span class="keyword">function</span>(mode) {</div>
<div class="line">    <span class="keywordflow">if</span> (isBoolean(mode)) {</div>
<div class="line">      html5Mode.enabled = mode;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(mode)) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.enabled)) {</div>
<div class="line">        html5Mode.enabled = mode.enabled;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.requireBase)) {</div>
<div class="line">        html5Mode.requireBase = mode.requireBase;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.rewriteLinks)) {</div>
<div class="line">        html5Mode.rewriteLinks = mode.rewriteLinks;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> html5Mode;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$rootElement&#39;</span>, <span class="stringliteral">&#39;$window&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($rootScope, $browser, $sniffer, $rootElement, $window) {</div>
<div class="line">    var $location,</div>
<div class="line">        LocationMode,</div>
<div class="line">        baseHref = $browser.baseHref(), <span class="comment">// if base[href] is undefined, it defaults to &#39;&#39;</span></div>
<div class="line">        initialUrl = $browser.url(),</div>
<div class="line">        appBase;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (html5Mode.enabled) {</div>
<div class="line">      <span class="keywordflow">if</span> (!baseHref &amp;&amp; html5Mode.requireBase) {</div>
<div class="line">        <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;nobase&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;$location in HTML5 mode requires a &lt;base&gt; tag to be present!&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      appBase = serverBase(initialUrl) + (baseHref || <span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line">      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      appBase = stripHash(initialUrl);</div>
<div class="line">      LocationMode = LocationHashbangUrl;</div>
<div class="line">    }</div>
<div class="line">    var appBaseNoFile = stripFile(appBase);</div>
<div class="line"></div>
<div class="line">    $location = <span class="keyword">new</span> LocationMode(appBase, appBaseNoFile, <span class="charliteral">&#39;#&#39;</span> + hashPrefix);</div>
<div class="line">    $location.$$parseLinkUrl(initialUrl, initialUrl);</div>
<div class="line"></div>
<div class="line">    $location.$$state = $browser.state();</div>
<div class="line"></div>
<div class="line">    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> setBrowserUrlWithFallback(url, replace, state) {</div>
<div class="line">      var oldUrl = $location.url();</div>
<div class="line">      var oldState = $location.$$state;</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        $browser.url(url, replace, state);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure $location.state() returns referentially identical (not just deeply equal)</span></div>
<div class="line">        <span class="comment">// state object; this makes possible quick checking if the state changed in the digest</span></div>
<div class="line">        <span class="comment">// loop. Checking deep equality would be too expensive.</span></div>
<div class="line">        $location.$$state = $browser.state();</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="comment">// Restore old values if pushState fails</span></div>
<div class="line">        $location.url(oldUrl);</div>
<div class="line">        $location.$$state = oldState;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">throw</span> e;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $rootElement.on(<span class="stringliteral">&#39;click&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">      <span class="comment">// TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)</span></div>
<div class="line">      <span class="comment">// currently we open nice url link and redirect then</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var elm = jqLite(event.target);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// traverse the DOM up to find first A tag</span></div>
<div class="line">      while (nodeName_(elm[0]) !== <span class="charliteral">&#39;a&#39;</span>) {</div>
<div class="line">        <span class="comment">// ignore rewriting if no A tag (reached root element, or no parent - removed from document)</span></div>
<div class="line">        <span class="keywordflow">if</span> (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var absHref = elm.prop(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">      <span class="comment">// get the actual href attribute - see</span></div>
<div class="line">      <span class="comment">// http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx</span></div>
<div class="line">      var relHref = elm.attr(<span class="stringliteral">&#39;href&#39;</span>) || elm.attr(<span class="stringliteral">&#39;xlink:href&#39;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isObject(absHref) &amp;&amp; absHref.toString() === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span>) {</div>
<div class="line">        <span class="comment">// SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during</span></div>
<div class="line">        <span class="comment">// an animation.</span></div>
<div class="line">        absHref = urlResolve(absHref.animVal).href;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Ignore when url is started with javascript: or mailto:</span></div>
<div class="line">      <span class="keywordflow">if</span> (IGNORE_URI_REGEXP.test(absHref)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (absHref &amp;&amp; !elm.attr(<span class="stringliteral">&#39;target&#39;</span>) &amp;&amp; !event.isDefaultPrevented()) {</div>
<div class="line">        <span class="keywordflow">if</span> ($location.$$parseLinkUrl(absHref, relHref)) {</div>
<div class="line">          <span class="comment">// We do a preventDefault for all urls that are part of the angular application,</span></div>
<div class="line">          <span class="comment">// in html5mode and also without, so that we are able to abort navigation without</span></div>
<div class="line">          <span class="comment">// getting double entries in the location history.</span></div>
<div class="line">          event.preventDefault();</div>
<div class="line">          <span class="comment">// update location manually</span></div>
<div class="line">          <span class="keywordflow">if</span> ($location.absUrl() != $browser.url()) {</div>
<div class="line">            $rootScope.$apply();</div>
<div class="line">            <span class="comment">// hack to work around FF6 bug 684208 when scenario runner clicks on links</span></div>
<div class="line">            $window.angular[<span class="stringliteral">&#39;ff-684208-preventDefault&#39;</span>] = <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// rewrite hashbang url &lt;&gt; html5 url</span></div>
<div class="line">    <span class="keywordflow">if</span> (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {</div>
<div class="line">      $browser.url($location.absUrl(), <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var initializing = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update $location when $browser url changes</span></div>
<div class="line">    $browser.onUrlChange(<span class="keyword">function</span>(newUrl, newState) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(beginsWith(appBaseNoFile, newUrl))) {</div>
<div class="line">        <span class="comment">// If we are navigating outside of the app then force a reload</span></div>
<div class="line">        $window.location.href = newUrl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">        var oldUrl = $location.absUrl();</div>
<div class="line">        var oldState = $location.$$state;</div>
<div class="line">        var defaultPrevented;</div>
<div class="line"></div>
<div class="line">        $location.$$parse(newUrl);</div>
<div class="line">        $location.$$state = newState;</div>
<div class="line"></div>
<div class="line">        defaultPrevented = $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeStart&#39;</span>, newUrl, oldUrl,</div>
<div class="line">            newState, oldState).defaultPrevented;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// if the location was changed by a `$locationChangeStart` handler then stop</span></div>
<div class="line">        <span class="comment">// processing this location change</span></div>
<div class="line">        <span class="keywordflow">if</span> ($location.absUrl() !== newUrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (defaultPrevented) {</div>
<div class="line">          $location.$$parse(oldUrl);</div>
<div class="line">          $location.$$state = oldState;</div>
<div class="line">          setBrowserUrlWithFallback(oldUrl, <span class="keyword">false</span>, oldState);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          initializing = <span class="keyword">false</span>;</div>
<div class="line">          afterLocationChange(oldUrl, oldState);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!$rootScope.$$phase) $rootScope.$digest();</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update browser</span></div>
<div class="line">    $rootScope.$watch(<span class="keyword">function</span> $locationWatch() {</div>
<div class="line">      var oldUrl = trimEmptyHash($browser.url());</div>
<div class="line">      var newUrl = trimEmptyHash($location.absUrl());</div>
<div class="line">      var oldState = $browser.state();</div>
<div class="line">      var currentReplace = $location.$$replace;</div>
<div class="line">      var urlOrStateChanged = oldUrl !== newUrl ||</div>
<div class="line">        ($location.$$html5 &amp;&amp; $sniffer.history &amp;&amp; oldState !== $location.$$state);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (initializing || urlOrStateChanged) {</div>
<div class="line">        initializing = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">          var newUrl = $location.absUrl();</div>
<div class="line">          var defaultPrevented = $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeStart&#39;</span>, newUrl, oldUrl,</div>
<div class="line">              $location.$$state, oldState).defaultPrevented;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// if the location was changed by a `$locationChangeStart` handler then stop</span></div>
<div class="line">          <span class="comment">// processing this location change</span></div>
<div class="line">          <span class="keywordflow">if</span> ($location.absUrl() !== newUrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (defaultPrevented) {</div>
<div class="line">            $location.$$parse(oldUrl);</div>
<div class="line">            $location.$$state = oldState;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (urlOrStateChanged) {</div>
<div class="line">              setBrowserUrlWithFallback(newUrl, currentReplace,</div>
<div class="line">                                        oldState === $location.$$state ? null : $location.$$state);</div>
<div class="line">            }</div>
<div class="line">            afterLocationChange(oldUrl, oldState);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $location.$$replace = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// we don&#39;t need to return anything because $evalAsync will make the digest loop dirty when</span></div>
<div class="line">      <span class="comment">// there is a change</span></div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> $location;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> afterLocationChange(oldUrl, oldState) {</div>
<div class="line">      $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeSuccess&#39;</span>, $location.absUrl(), oldUrl,</div>
<div class="line">        $location.$$state, oldState);</div>
<div class="line">    }</div>
<div class="line">}];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $LogProvider() {</div>
<div class="line">  var debug = <span class="keyword">true</span>,</div>
<div class="line">      <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.debugEnabled = <span class="keyword">function</span>(flag) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(flag)) {</div>
<div class="line">      debug = flag;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> debug;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>($window) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      log: consoleLog(<span class="stringliteral">&#39;log&#39;</span>),</div>
<div class="line"></div>
<div class="line">      info: consoleLog(<span class="stringliteral">&#39;info&#39;</span>),</div>
<div class="line"></div>
<div class="line">      warn: consoleLog(<span class="stringliteral">&#39;warn&#39;</span>),</div>
<div class="line"></div>
<div class="line">      error: consoleLog(<span class="stringliteral">&#39;error&#39;</span>),</div>
<div class="line"></div>
<div class="line">      debug: (<span class="keyword">function</span>() {</div>
<div class="line">        var fn = consoleLog(<span class="stringliteral">&#39;debug&#39;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (debug) {</div>
<div class="line">            fn.apply(<span class="keyword">self</span>, arguments);</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }())</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> formatError(arg) {</div>
<div class="line">      <span class="keywordflow">if</span> (arg instanceof Error) {</div>
<div class="line">        <span class="keywordflow">if</span> (arg.stack) {</div>
<div class="line">          arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1)</div>
<div class="line">              ? <span class="stringliteral">&#39;Error: &#39;</span> + arg.message + <span class="charliteral">&#39;\n&#39;</span> + arg.stack</div>
<div class="line">              : arg.stack;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg.sourceURL) {</div>
<div class="line">          arg = arg.message + <span class="charliteral">&#39;\n&#39;</span> + arg.sourceURL + <span class="charliteral">&#39;:&#39;</span> + arg.line;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> arg;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> consoleLog(type) {</div>
<div class="line">      var console = $window.console || {},</div>
<div class="line">          logFn = console[type] || console.log || noop,</div>
<div class="line">          hasApply = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Note: reading logFn.apply throws an error in IE11 in IE8 document mode.</span></div>
<div class="line">      <span class="comment">// The reason behind this is that console.log has type &quot;object&quot; in IE8...</span></div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        hasApply = !!logFn.apply;</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {}</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (hasApply) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          var args = [];</div>
<div class="line">          forEach(arguments, <span class="keyword">function</span>(arg) {</div>
<div class="line">            args.push(formatError(arg));</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> logFn.apply(console, args);</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// we are IE which either doesn&#39;t have window.console =&gt; this is noop and we do nothing,</span></div>
<div class="line">      <span class="comment">// or we are IE where console.log doesn&#39;t have apply so we log at least first 2 args</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(arg1, arg2) {</div>
<div class="line">        logFn(arg1, arg2 == null ? <span class="stringliteral">&#39;&#39;</span> : arg2);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line">var $parseMinErr = minErr(<span class="stringliteral">&#39;$parse&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sandboxing Angular Expressions</span></div>
<div class="line"><span class="comment">// ------------------------------</span></div>
<div class="line"><span class="comment">// Angular expressions are generally considered safe because these expressions only have direct</span></div>
<div class="line"><span class="comment">// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by</span></div>
<div class="line"><span class="comment">// obtaining a reference to native JS functions such as the Function constructor.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// As an example, consider the following Angular expression:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//   {}.toString.constructor(&#39;alert(&quot;evil JS code&quot;)&#39;)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This sandboxing technique is not perfect and doesn&#39;t aim to be. The goal is to prevent exploits</span></div>
<div class="line"><span class="comment">// against the expression language, but not to prevent exploits that were enabled by exposing</span></div>
<div class="line"><span class="comment">// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good</span></div>
<div class="line"><span class="comment">// practice and therefore we are not even trying to protect against interaction with an object</span></div>
<div class="line"><span class="comment">// explicitly exposed in this way.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// In general, it is not possible to access a Window object from an angular expression unless a</span></div>
<div class="line"><span class="comment">// window or some DOM object that has a reference to window is published onto a Scope.</span></div>
<div class="line"><span class="comment">// Similarly we prevent invocations of function known to be dangerous, as well as assignments to</span></div>
<div class="line"><span class="comment">// native objects.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// See https://docs.angularjs.org/guide/security</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeMemberName(name, fullExpression) {</div>
<div class="line">  <span class="keywordflow">if</span> (name === <span class="stringliteral">&quot;__defineGetter__&quot;</span> || name === <span class="stringliteral">&quot;__defineSetter__&quot;</span></div>
<div class="line">      || name === <span class="stringliteral">&quot;__lookupGetter__&quot;</span> || name === <span class="stringliteral">&quot;__lookupSetter__&quot;</span></div>
<div class="line">      || name === <span class="stringliteral">&quot;__proto__&quot;</span>) {</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfld&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Attempting to access a disallowed field in Angular expressions! &#39;</span></div>
<div class="line">        + <span class="stringliteral">&#39;Expression: {0}&#39;</span>, fullExpression);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> name;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeObject(obj, fullExpression) {</div>
<div class="line">  <span class="comment">// nifty check if obj is Function that is fast and works across iframes and other contexts</span></div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (obj.constructor === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfn&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing Function in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// isWindow(obj)</span></div>
<div class="line">        obj.window === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecwindow&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing the Window in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// isElement(obj)</span></div>
<div class="line">        obj.children &amp;&amp; (obj.nodeName || (obj.prop &amp;&amp; obj.attr &amp;&amp; obj.find))) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecdom&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// block Object so that we can&#39;t get hold of dangerous Object.* methods</span></div>
<div class="line">        obj === Object) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecobj&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing Object in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var CALL = Function.prototype.call;</div>
<div class="line">var APPLY = Function.prototype.apply;</div>
<div class="line">var BIND = Function.prototype.bind;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeFunction(obj, fullExpression) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (obj.constructor === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfn&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Referencing Function in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">        fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj === CALL || obj === APPLY || obj === BIND) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecff&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">        fullExpression);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var OPERATORS = createMap();</div>
<div class="line">forEach(<span class="stringliteral">&#39;+ - * / % === !== == != &lt; &gt; &lt;= &gt;= &amp;&amp; || ! = |&#39;</span>.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(<span class="keyword">operator</span>) { OPERATORS[<span class="keyword">operator</span>] = <span class="keyword">true</span>; });</div>
<div class="line">var ESCAPE = {<span class="stringliteral">&quot;n&quot;</span>:<span class="stringliteral">&quot;\n&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>:<span class="stringliteral">&quot;\f&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>:<span class="stringliteral">&quot;\r&quot;</span>, <span class="stringliteral">&quot;t&quot;</span>:<span class="stringliteral">&quot;\t&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>:<span class="stringliteral">&quot;\v&quot;</span>, <span class="stringliteral">&quot;&#39;&quot;</span>:<span class="stringliteral">&quot;&#39;&quot;</span>, <span class="charliteral">&#39;&quot;&#39;</span>:<span class="charliteral">&#39;&quot;&#39;</span>};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var Lexer = <span class="keyword">function</span>(options) {</div>
<div class="line">  this.options = options;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Lexer.prototype = {</div>
<div class="line">  constructor: Lexer,</div>
<div class="line"></div>
<div class="line">  lex: <span class="keyword">function</span>(text) {</div>
<div class="line">    this.text = text;</div>
<div class="line">    this.index = 0;</div>
<div class="line">    this.tokens = [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;&quot;&#39;</span> || ch === <span class="stringliteral">&quot;&#39;&quot;</span>) {</div>
<div class="line">        this.readString(ch);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isNumber(ch) || ch === <span class="charliteral">&#39;.&#39;</span> &amp;&amp; this.isNumber(this.peek())) {</div>
<div class="line">        this.readNumber();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isIdent(ch)) {</div>
<div class="line">        this.readIdent();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.is(ch, <span class="stringliteral">&#39;(){}[].,;:?&#39;</span>)) {</div>
<div class="line">        this.tokens.push({index: this.index, text: ch});</div>
<div class="line">        this.index++;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isWhitespace(ch)) {</div>
<div class="line">        this.index++;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var ch2 = ch + this.peek();</div>
<div class="line">        var ch3 = ch2 + this.peek(2);</div>
<div class="line">        var op1 = OPERATORS[ch];</div>
<div class="line">        var op2 = OPERATORS[ch2];</div>
<div class="line">        var op3 = OPERATORS[ch3];</div>
<div class="line">        <span class="keywordflow">if</span> (op1 || op2 || op3) {</div>
<div class="line">          var token = op3 ? ch3 : (op2 ? ch2 : ch);</div>
<div class="line">          this.tokens.push({index: this.index, text: token, <span class="keyword">operator</span>: <span class="keyword">true</span>});</div>
<div class="line">          this.index += token.length;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.throwError(<span class="stringliteral">&#39;Unexpected next character &#39;</span>, this.index, this.index + 1);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.tokens;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  is: <span class="keyword">function</span>(ch, chars) {</div>
<div class="line">    <span class="keywordflow">return</span> chars.indexOf(ch) !== -1;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peek: <span class="keyword">function</span>(i) {</div>
<div class="line">    var num = i || 1;</div>
<div class="line">    <span class="keywordflow">return</span> (this.index + num &lt; this.text.length) ? this.text.charAt(this.index + num) : <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isNumber: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="charliteral">&#39;0&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;9&#39;</span>) &amp;&amp; typeof ch === <span class="stringliteral">&quot;string&quot;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isWhitespace: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="comment">// IE treats non-breaking space as \u00A0</span></div>
<div class="line">    <span class="keywordflow">return</span> (ch === <span class="charliteral">&#39; &#39;</span> || ch === <span class="charliteral">&#39;\r&#39;</span> || ch === <span class="charliteral">&#39;\t&#39;</span> ||</div>
<div class="line">            ch === <span class="charliteral">&#39;\n&#39;</span> || ch === <span class="charliteral">&#39;\v&#39;</span> || ch === <span class="stringliteral">&#39;\u00A0&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isIdent: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="charliteral">&#39;a&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;z&#39;</span> ||</div>
<div class="line">            <span class="charliteral">&#39;A&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;Z&#39;</span> ||</div>
<div class="line">            <span class="charliteral">&#39;_&#39;</span> === ch || ch === <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isExpOperator: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (ch === <span class="charliteral">&#39;-&#39;</span> || ch === <span class="charliteral">&#39;+&#39;</span> || this.isNumber(ch));</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  throwError: <span class="keyword">function</span>(error, start, end) {</div>
<div class="line">    end = end || this.index;</div>
<div class="line">    var colStr = (isDefined(start)</div>
<div class="line">            ? <span class="stringliteral">&#39;s &#39;</span> + start +  <span class="charliteral">&#39;-&#39;</span> + this.index + <span class="stringliteral">&#39; [&#39;</span> + this.text.substring(start, end) + <span class="charliteral">&#39;]&#39;</span></div>
<div class="line">            : <span class="charliteral">&#39; &#39;</span> + end);</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;lexerr&#39;</span>, <span class="stringliteral">&#39;Lexer Error: {0} at column{1} in expression [{2}].&#39;</span>,</div>
<div class="line">        error, colStr, this.text);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readNumber: <span class="keyword">function</span>() {</div>
<div class="line">    var number = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var start = this.index;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = lowercase(this.text.charAt(<span class="keyword">this</span>.index));</div>
<div class="line">      <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;.&#39;</span> || this.isNumber(ch)) {</div>
<div class="line">        number += ch;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var peekCh = this.peek();</div>
<div class="line">        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;e&#39;</span> &amp;&amp; this.isExpOperator(peekCh)) {</div>
<div class="line">          number += ch;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isExpOperator(ch) &amp;&amp;</div>
<div class="line">            peekCh &amp;&amp; this.isNumber(peekCh) &amp;&amp;</div>
<div class="line">            number.charAt(number.length - 1) == <span class="charliteral">&#39;e&#39;</span>) {</div>
<div class="line">          number += ch;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isExpOperator(ch) &amp;&amp;</div>
<div class="line">            (!peekCh || !this.isNumber(peekCh)) &amp;&amp;</div>
<div class="line">            number.charAt(number.length - 1) == <span class="charliteral">&#39;e&#39;</span>) {</div>
<div class="line">          this.throwError(<span class="stringliteral">&#39;Invalid exponent&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.tokens.push({</div>
<div class="line">      index: start,</div>
<div class="line">      text: number,</div>
<div class="line">      constant: <span class="keyword">true</span>,</div>
<div class="line">      value: Number(number)</div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readIdent: <span class="keyword">function</span>() {</div>
<div class="line">    var start = this.index;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      <span class="keywordflow">if</span> (!(this.isIdent(ch) || this.isNumber(ch))) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.tokens.push({</div>
<div class="line">      index: start,</div>
<div class="line">      text: this.text.slice(start, this.index),</div>
<div class="line">      identifier: <span class="keyword">true</span></div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readString: <span class="keyword">function</span>(quote) {</div>
<div class="line">    var start = this.index;</div>
<div class="line">    this.index++;</div>
<div class="line">    var <span class="keywordtype">string</span> = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var rawString = quote;</div>
<div class="line">    var escape = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      rawString += ch;</div>
<div class="line">      <span class="keywordflow">if</span> (escape) {</div>
<div class="line">        <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;u&#39;</span>) {</div>
<div class="line">          var hex = this.text.substring(this.index + 1, this.index + 5);</div>
<div class="line">          <span class="keywordflow">if</span> (!hex.match(/[\da-f]{4}/i)) {</div>
<div class="line">            this.throwError(<span class="stringliteral">&#39;Invalid unicode escape [\\u&#39;</span> + hex + <span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">          this.index += 4;</div>
<div class="line">          <span class="keywordtype">string</span> += String.fromCharCode(parseInt(hex, 16));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          var rep = ESCAPE[ch];</div>
<div class="line">          <span class="keywordtype">string</span> = <span class="keywordtype">string</span> + (rep || ch);</div>
<div class="line">        }</div>
<div class="line">        escape = <span class="keyword">false</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;\\&#39;</span>) {</div>
<div class="line">        escape = <span class="keyword">true</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch === quote) {</div>
<div class="line">        this.index++;</div>
<div class="line">        this.tokens.push({</div>
<div class="line">          index: start,</div>
<div class="line">          text: rawString,</div>
<div class="line">          constant: <span class="keyword">true</span>,</div>
<div class="line">          value: <span class="keywordtype">string</span></div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordtype">string</span> += ch;</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.throwError(<span class="stringliteral">&#39;Unterminated quote&#39;</span>, start);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var AST = <span class="keyword">function</span>(lexer, options) {</div>
<div class="line">  this.lexer = lexer;</div>
<div class="line">  this.options = options;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">AST.Program = <span class="stringliteral">&#39;Program&#39;</span>;</div>
<div class="line">AST.ExpressionStatement = <span class="stringliteral">&#39;ExpressionStatement&#39;</span>;</div>
<div class="line">AST.AssignmentExpression = <span class="stringliteral">&#39;AssignmentExpression&#39;</span>;</div>
<div class="line">AST.ConditionalExpression = <span class="stringliteral">&#39;ConditionalExpression&#39;</span>;</div>
<div class="line">AST.LogicalExpression = <span class="stringliteral">&#39;LogicalExpression&#39;</span>;</div>
<div class="line">AST.BinaryExpression = <span class="stringliteral">&#39;BinaryExpression&#39;</span>;</div>
<div class="line">AST.UnaryExpression = <span class="stringliteral">&#39;UnaryExpression&#39;</span>;</div>
<div class="line">AST.CallExpression = <span class="stringliteral">&#39;CallExpression&#39;</span>;</div>
<div class="line">AST.MemberExpression = <span class="stringliteral">&#39;MemberExpression&#39;</span>;</div>
<div class="line">AST.Identifier = <span class="stringliteral">&#39;Identifier&#39;</span>;</div>
<div class="line">AST.Literal = <span class="stringliteral">&#39;Literal&#39;</span>;</div>
<div class="line">AST.ArrayExpression = <span class="stringliteral">&#39;ArrayExpression&#39;</span>;</div>
<div class="line">AST.Property = <span class="stringliteral">&#39;Property&#39;</span>;</div>
<div class="line">AST.ObjectExpression = <span class="stringliteral">&#39;ObjectExpression&#39;</span>;</div>
<div class="line">AST.ThisExpression = <span class="stringliteral">&#39;ThisExpression&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Internal use only</span></div>
<div class="line">AST.NGValueParameter = <span class="stringliteral">&#39;NGValueParameter&#39;</span>;</div>
<div class="line"></div>
<div class="line">AST.prototype = {</div>
<div class="line">  ast: <span class="keyword">function</span>(text) {</div>
<div class="line">    this.text = text;</div>
<div class="line">    this.tokens = this.lexer.lex(text);</div>
<div class="line"></div>
<div class="line">    var value = this.program();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length !== 0) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is an unexpected token&#39;</span>, this.tokens[0]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  program: <span class="keyword">function</span>() {</div>
<div class="line">    var body = [];</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">      <span class="keywordflow">if</span> (this.tokens.length &gt; 0 &amp;&amp; !<span class="keyword">this</span>.peek(<span class="charliteral">&#39;}&#39;</span>, <span class="charliteral">&#39;)&#39;</span>, <span class="charliteral">&#39;;&#39;</span>, <span class="charliteral">&#39;]&#39;</span>))</div>
<div class="line">        body.push(<span class="keyword">this</span>.expressionStatement());</div>
<div class="line">      <span class="keywordflow">if</span> (!this.expect(<span class="charliteral">&#39;;&#39;</span>)) {</div>
<div class="line">        <span class="keywordflow">return</span> { type: AST.Program, body: body};</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expressionStatement: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.ExpressionStatement, expression: this.filterChain() };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filterChain: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.expression();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;|&#39;</span>))) {</div>
<div class="line">      left = this.filter(left);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expression: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.assignment();</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  assignment: <span class="keyword">function</span>() {</div>
<div class="line">    var result = this.ternary();</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;=&#39;</span>)) {</div>
<div class="line">      result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), <span class="keyword">operator</span>: <span class="charliteral">&#39;=&#39;</span>};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ternary: <span class="keyword">function</span>() {</div>
<div class="line">    var test = this.logicalOR();</div>
<div class="line">    var alternate;</div>
<div class="line">    var consequent;</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;?&#39;</span>)) {</div>
<div class="line">      alternate = this.expression();</div>
<div class="line">      <span class="keywordflow">if</span> (this.consume(<span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line">        consequent = this.expression();</div>
<div class="line">        <span class="keywordflow">return</span> { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent};</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> test;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  logicalOR: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.logicalAND();</div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="stringliteral">&#39;||&#39;</span>)) {</div>
<div class="line">      left = { type: AST.LogicalExpression, <span class="keyword">operator</span>: <span class="stringliteral">&#39;||&#39;</span>, left: left, right: this.logicalAND() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  logicalAND: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.equality();</div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="stringliteral">&#39;&amp;&amp;&#39;</span>)) {</div>
<div class="line">      left = { type: AST.LogicalExpression, <span class="keyword">operator</span>: <span class="stringliteral">&#39;&amp;&amp;&#39;</span>, left: left, right: this.equality()};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  equality: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.relational();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="stringliteral">&#39;==&#39;</span>,<span class="stringliteral">&#39;!=&#39;</span>,<span class="stringliteral">&#39;===&#39;</span>,<span class="stringliteral">&#39;!==&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.relational() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  relational: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.additive();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;=&#39;</span>, <span class="stringliteral">&#39;&gt;=&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.additive() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  additive: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.multiplicative();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;+&#39;</span>,<span class="charliteral">&#39;-&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.multiplicative() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  multiplicative: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.unary();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;*&#39;</span>,<span class="charliteral">&#39;/&#39;</span>,<span class="charliteral">&#39;%&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.unary() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  unary: <span class="keyword">function</span>() {</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">if</span> ((token = this.expect(<span class="charliteral">&#39;+&#39;</span>, <span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;!&#39;</span>))) {</div>
<div class="line">      <span class="keywordflow">return</span> { type: AST.UnaryExpression, <span class="keyword">operator</span>: token.text, prefix: <span class="keyword">true</span>, argument: this.unary() };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> this.primary();</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  primary: <span class="keyword">function</span>() {</div>
<div class="line">    var primary;</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;(&#39;</span>)) {</div>
<div class="line">      primary = this.filterChain();</div>
<div class="line">      this.consume(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;[&#39;</span>)) {</div>
<div class="line">      primary = this.arrayDeclaration();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;{&#39;</span>)) {</div>
<div class="line">      primary = this.object();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.constants.hasOwnProperty(<span class="keyword">this</span>.peek().text)) {</div>
<div class="line">      primary = copy(this.constants[this.consume().text]);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().identifier) {</div>
<div class="line">      primary = this.identifier();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().constant) {</div>
<div class="line">      primary = this.constant();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;not a primary expression&#39;</span>, this.peek());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var next;</div>
<div class="line">    <span class="keywordflow">while</span> ((next = this.expect(<span class="charliteral">&#39;(&#39;</span>, <span class="charliteral">&#39;[&#39;</span>, <span class="charliteral">&#39;.&#39;</span>))) {</div>
<div class="line">      <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;(&#39;</span>) {</div>
<div class="line">        primary = {type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };</div>
<div class="line">        this.consume(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;[&#39;</span>) {</div>
<div class="line">        primary = { type: AST.MemberExpression, <span class="keywordtype">object</span>: primary, property: this.expression(), computed: <span class="keyword">true</span> };</div>
<div class="line">        this.consume(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;.&#39;</span>) {</div>
<div class="line">        primary = { type: AST.MemberExpression, <span class="keywordtype">object</span>: primary, property: this.identifier(), computed: <span class="keyword">false</span> };</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.throwError(<span class="stringliteral">&#39;IMPOSSIBLE&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> primary;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filter: <span class="keyword">function</span>(baseExpression) {</div>
<div class="line">    var args = [baseExpression];</div>
<div class="line">    var result = {type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: <span class="keyword">true</span>};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line">      args.push(this.expression());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  parseArguments: <span class="keyword">function</span>() {</div>
<div class="line">    var args = [];</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        args.push(this.expression());</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> args;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  identifier: <span class="keyword">function</span>() {</div>
<div class="line">    var token = this.consume();</div>
<div class="line">    <span class="keywordflow">if</span> (!token.identifier) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is not a valid identifier&#39;</span>, token);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.Identifier, name: token.text };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  constant: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// TODO check that it is a constant</span></div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.Literal, value: this.consume().value };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  arrayDeclaration: <span class="keyword">function</span>() {</div>
<div class="line">    var elements = [];</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;]&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek(<span class="charliteral">&#39;]&#39;</span>)) {</div>
<div class="line">          <span class="comment">// Support trailing commas per ES5.1.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        elements.push(this.expression());</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    this.consume(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.ArrayExpression, elements: elements };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">object</span>: <span class="keyword">function</span>() {</div>
<div class="line">    var properties = [], property;</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;}&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek(<span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line">          <span class="comment">// Support trailing commas per ES5.1.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        property = {type: AST.Property, kind: <span class="stringliteral">&#39;init&#39;</span>};</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek().constant) {</div>
<div class="line">          property.key = this.constant();</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().identifier) {</div>
<div class="line">          property.key = this.identifier();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.throwError(<span class="stringliteral">&quot;invalid key&quot;</span>, this.peek());</div>
<div class="line">        }</div>
<div class="line">        this.consume(<span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line">        property.value = this.expression();</div>
<div class="line">        properties.push(property);</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    this.consume(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {type: AST.ObjectExpression, properties: properties };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  throwError: <span class="keyword">function</span>(msg, token) {</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;syntax&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Syntax Error: Token \&#39;{0}\&#39; {1} at column {2} of the expression [{3}] starting at [{4}].&#39;</span>,</div>
<div class="line">          token.text, msg, (token.index + 1), <span class="keyword">this</span>.text, <span class="keyword">this</span>.text.substring(token.index));</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  consume: <span class="keyword">function</span>(e1) {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length === 0) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;ueoe&#39;</span>, <span class="stringliteral">&#39;Unexpected end of expression: {0}&#39;</span>, this.text);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var token = this.expect(e1);</div>
<div class="line">    <span class="keywordflow">if</span> (!token) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is unexpected, expecting [&#39;</span> + e1 + <span class="charliteral">&#39;]&#39;</span>, this.peek());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> token;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peekToken: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length === 0) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;ueoe&#39;</span>, <span class="stringliteral">&#39;Unexpected end of expression: {0}&#39;</span>, this.text);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.tokens[0];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peek: <span class="keyword">function</span>(e1, e2, e3, e4) {</div>
<div class="line">    <span class="keywordflow">return</span> this.peekAhead(0, e1, e2, e3, e4);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peekAhead: <span class="keyword">function</span>(i, e1, e2, e3, e4) {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length &gt; i) {</div>
<div class="line">      var token = this.tokens[i];</div>
<div class="line">      var t = token.text;</div>
<div class="line">      <span class="keywordflow">if</span> (t === e1 || t === e2 || t === e3 || t === e4 ||</div>
<div class="line">          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {</div>
<div class="line">        <span class="keywordflow">return</span> token;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expect: <span class="keyword">function</span>(e1, e2, e3, e4) {</div>
<div class="line">    var token = this.peek(e1, e2, e3, e4);</div>
<div class="line">    <span class="keywordflow">if</span> (token) {</div>
<div class="line">      this.tokens.shift();</div>
<div class="line">      <span class="keywordflow">return</span> token;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* `undefined` is not a constant, it is an identifier,</span></div>
<div class="line"><span class="comment">   * but using it as an identifier is not supported</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  constants: {</div>
<div class="line">    <span class="stringliteral">&#39;true&#39;</span>: { type: AST.Literal, value: <span class="keyword">true</span> },</div>
<div class="line">    <span class="stringliteral">&#39;false&#39;</span>: { type: AST.Literal, value: <span class="keyword">false</span> },</div>
<div class="line">    <span class="stringliteral">&#39;null&#39;</span>: { type: AST.Literal, value: null },</div>
<div class="line">    <span class="stringliteral">&#39;undefined&#39;</span>: {type: AST.Literal, value: undefined },</div>
<div class="line">    <span class="stringliteral">&#39;this&#39;</span>: {type: AST.ThisExpression }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ifDefined(v, d) {</div>
<div class="line">  <span class="keywordflow">return</span> typeof v !== <span class="stringliteral">&#39;undefined&#39;</span> ? v : d;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> plusFn(l, r) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof l === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> r;</div>
<div class="line">  <span class="keywordflow">if</span> (typeof r === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> l;</div>
<div class="line">  <span class="keywordflow">return</span> l + r;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isStateless($filter, filterName) {</div>
<div class="line">  var fn = $filter(filterName);</div>
<div class="line">  <span class="keywordflow">return</span> !fn.$stateful;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> findConstantAndWatchExpressions(ast, $filter) {</div>
<div class="line">  var allConstants;</div>
<div class="line">  var argsToWatch;</div>
<div class="line">  <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">  <span class="keywordflow">case</span> AST.Program:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    forEach(ast.body, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr.expression, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.expression.constant;</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">    ast.constant = <span class="keyword">true</span>;</div>
<div class="line">    ast.toWatch = [];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.argument, $filter);</div>
<div class="line">    ast.constant = ast.argument.constant;</div>
<div class="line">    ast.toWatch = ast.argument.toWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = ast.constant ? [] : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.test, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.alternate, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.consequent, $filter);</div>
<div class="line">    ast.constant = ast.test.constant &amp;&amp; ast.alternate.constant &amp;&amp; ast.consequent.constant;</div>
<div class="line">    ast.toWatch = ast.constant ? [] : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">    ast.constant = <span class="keyword">false</span>;</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.object, $filter);</div>
<div class="line">    <span class="keywordflow">if</span> (ast.computed) {</div>
<div class="line">      findConstantAndWatchExpressions(ast.property, $filter);</div>
<div class="line">    }</div>
<div class="line">    ast.constant = ast.object.constant &amp;&amp; (!ast.computed || ast.property.constant);</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.constant;</div>
<div class="line">      if (!expr.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, expr.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = ast.filter &amp;&amp; isStateless($filter, ast.callee.name) ? argsToWatch : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.constant;</div>
<div class="line">      if (!expr.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, expr.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = argsToWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">      findConstantAndWatchExpressions(property.value, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; property.value.constant;</div>
<div class="line">      if (!property.value.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, property.value.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = argsToWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">    ast.constant = <span class="keyword">false</span>;</div>
<div class="line">    ast.toWatch = [];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getInputs(body) {</div>
<div class="line">  <span class="keywordflow">if</span> (body.length != 1) <span class="keywordflow">return</span>;</div>
<div class="line">  var lastExpression = body[0].expression;</div>
<div class="line">  var candidate = lastExpression.toWatch;</div>
<div class="line">  <span class="keywordflow">if</span> (candidate.length !== 1) <span class="keywordflow">return</span> candidate;</div>
<div class="line">  <span class="keywordflow">return</span> candidate[0] !== lastExpression ? candidate : undefined;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isAssignable(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.type === AST.Identifier || ast.type === AST.MemberExpression;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assignableAST(ast) {</div>
<div class="line">  <span class="keywordflow">if</span> (ast.body.length === 1 &amp;&amp; isAssignable(ast.body[0].expression)) {</div>
<div class="line">    <span class="keywordflow">return</span> {type: AST.AssignmentExpression, left: ast.body[0].expression, right: {type: AST.NGValueParameter}, <span class="keyword">operator</span>: <span class="charliteral">&#39;=&#39;</span>};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isLiteral(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.body.length === 0 ||</div>
<div class="line">      ast.body.length === 1 &amp;&amp; (</div>
<div class="line">      ast.body[0].expression.type === AST.Literal ||</div>
<div class="line">      ast.body[0].expression.type === AST.ArrayExpression ||</div>
<div class="line">      ast.body[0].expression.type === AST.ObjectExpression);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isConstant(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.constant;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ASTCompiler(astBuilder, $filter) {</div>
<div class="line">  this.astBuilder = astBuilder;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ASTCompiler.prototype = {</div>
<div class="line">  compile: <span class="keyword">function</span>(expression, expensiveChecks) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    var ast = this.astBuilder.ast(expression);</div>
<div class="line">    this.state = {</div>
<div class="line">      nextId: 0,</div>
<div class="line">      filters: {},</div>
<div class="line">      expensiveChecks: expensiveChecks,</div>
<div class="line">      fn: {vars: [], body: [], own: {}},</div>
<div class="line">      assign: {vars: [], body: [], own: {}},</div>
<div class="line">      inputs: []</div>
<div class="line">    };</div>
<div class="line">    findConstantAndWatchExpressions(ast, <span class="keyword">self</span>.$filter);</div>
<div class="line">    var extra = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var assignable;</div>
<div class="line">    this.stage = <span class="stringliteral">&#39;assign&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> ((assignable = assignableAST(ast))) {</div>
<div class="line">      this.state.computing = <span class="stringliteral">&#39;assign&#39;</span>;</div>
<div class="line">      var result = this.nextId();</div>
<div class="line">      this.recurse(assignable, result);</div>
<div class="line">      extra = <span class="stringliteral">&#39;fn.assign=&#39;</span> + this.generateFunction(<span class="stringliteral">&#39;assign&#39;</span>, <span class="stringliteral">&#39;s,v,l&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    var toWatch = getInputs(ast.body);</div>
<div class="line">    <span class="keyword">self</span>.stage = <span class="stringliteral">&#39;inputs&#39;</span>;</div>
<div class="line">    forEach(toWatch, <span class="keyword">function</span>(watch, key) {</div>
<div class="line">      var fnKey = <span class="stringliteral">&#39;fn&#39;</span> + key;</div>
<div class="line">      <span class="keyword">self</span>.state[fnKey] = {vars: [], body: [], own: {}};</div>
<div class="line">      <span class="keyword">self</span>.state.computing = fnKey;</div>
<div class="line">      var intoId = <span class="keyword">self</span>.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(watch, intoId);</div>
<div class="line">      <span class="keyword">self</span>.return_(intoId);</div>
<div class="line">      <span class="keyword">self</span>.state.inputs.push(fnKey);</div>
<div class="line">      watch.watchId = key;</div>
<div class="line">    });</div>
<div class="line">    this.state.computing = <span class="stringliteral">&#39;fn&#39;</span>;</div>
<div class="line">    this.stage = <span class="stringliteral">&#39;main&#39;</span>;</div>
<div class="line">    this.recurse(ast);</div>
<div class="line">    var fnString =</div>
<div class="line">      <span class="comment">// The build and minification steps remove the string &quot;use strict&quot; from the code, but this is done using a regex.</span></div>
<div class="line">      <span class="comment">// This is a workaround for this until we do a better job at only removing the prefix only when we should.</span></div>
<div class="line">      <span class="charliteral">&#39;&quot;&#39;</span> + this.USE + <span class="charliteral">&#39; &#39;</span> + this.STRICT + <span class="stringliteral">&#39;&quot;;\n&#39;</span> +</div>
<div class="line">      this.filterPrefix() +</div>
<div class="line">      <span class="stringliteral">&#39;var fn=&#39;</span> + this.generateFunction(<span class="stringliteral">&#39;fn&#39;</span>, <span class="stringliteral">&#39;s,l,a,i&#39;</span>) +</div>
<div class="line">      extra +</div>
<div class="line">      this.watchFns() +</div>
<div class="line">      <span class="stringliteral">&#39;return fn;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* jshint -W054 */</span></div>
<div class="line">    var fn = (<span class="keyword">new</span> Function(<span class="stringliteral">&#39;$filter&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeMemberName&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeObject&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeFunction&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ifDefined&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;plus&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;text&#39;</span>,</div>
<div class="line">        fnString))(</div>
<div class="line">          this.$filter,</div>
<div class="line">          ensureSafeMemberName,</div>
<div class="line">          ensureSafeObject,</div>
<div class="line">          ensureSafeFunction,</div>
<div class="line">          ifDefined,</div>
<div class="line">          plusFn,</div>
<div class="line">          expression);</div>
<div class="line">    <span class="comment">/* jshint +W054 */</span></div>
<div class="line">    this.state = this.stage = undefined;</div>
<div class="line">    fn.literal = isLiteral(ast);</div>
<div class="line">    fn.constant = isConstant(ast);</div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  USE: <span class="stringliteral">&#39;use&#39;</span>,</div>
<div class="line"></div>
<div class="line">  STRICT: <span class="stringliteral">&#39;strict&#39;</span>,</div>
<div class="line"></div>
<div class="line">  watchFns: <span class="keyword">function</span>() {</div>
<div class="line">    var result = [];</div>
<div class="line">    var fns = this.state.inputs;</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    forEach(fns, <span class="keyword">function</span>(name) {</div>
<div class="line">      result.push(<span class="stringliteral">&#39;var &#39;</span> + name + <span class="charliteral">&#39;=&#39;</span> + <span class="keyword">self</span>.generateFunction(name, <span class="charliteral">&#39;s&#39;</span>));</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">if</span> (fns.length) {</div>
<div class="line">      result.push(<span class="stringliteral">&#39;fn.inputs=[&#39;</span> + fns.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;];&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  generateFunction: <span class="keyword">function</span>(name, params) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;function(&#39;</span> + params + <span class="stringliteral">&#39;){&#39;</span> +</div>
<div class="line">        this.varsPrefix(name) +</div>
<div class="line">        this.body(name) +</div>
<div class="line">        <span class="stringliteral">&#39;};&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filterPrefix: <span class="keyword">function</span>() {</div>
<div class="line">    var parts = [];</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    forEach(this.state.filters, <span class="keyword">function</span>(<span class="keywordtype">id</span>, filter) {</div>
<div class="line">      parts.push(id + <span class="stringliteral">&#39;=$filter(&#39;</span> + self.escape(filter) + <span class="stringliteral">&#39;)&#39;</span>);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">if</span> (parts.length) <span class="keywordflow">return</span> <span class="stringliteral">&#39;var &#39;</span> + parts.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  varsPrefix: <span class="keyword">function</span>(section) {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[section].vars.length ? <span class="stringliteral">&#39;var &#39;</span> + this.state[section].vars.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;;&#39;</span> : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  body: <span class="keyword">function</span>(section) {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[section].body.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  recurse: <span class="keyword">function</span>(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {</div>
<div class="line">    var left, right, <span class="keyword">self</span> = <span class="keyword">this</span>, args, expression;</div>
<div class="line">    recursionFn = recursionFn || noop;</div>
<div class="line">    <span class="keywordflow">if</span> (!skipWatchIdCheck &amp;&amp; isDefined(ast.watchId)) {</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      this.if_(<span class="charliteral">&#39;i&#39;</span>,</div>
<div class="line">        this.lazyAssign(intoId, this.computedMember(<span class="charliteral">&#39;i&#39;</span>, ast.watchId)),</div>
<div class="line">        <span class="keyword">this</span>.lazyRecurse(ast, intoId, nameId, recursionFn, create, <span class="keyword">true</span>)</div>
<div class="line">      );</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">    <span class="keywordflow">case</span> AST.Program:</div>
<div class="line">      forEach(ast.body, <span class="keyword">function</span>(expression, pos) {</div>
<div class="line">        self.recurse(expression.expression, undefined, undefined, function(expr) { right = expr; });</div>
<div class="line">        <span class="keywordflow">if</span> (pos !== ast.body.length - 1) {</div>
<div class="line">          <span class="keyword">self</span>.current().body.push(right, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keyword">self</span>.return_(right);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">      expression = this.escape(ast.value);</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">      this.recurse(ast.argument, undefined, undefined, <span class="keyword">function</span>(expr) { right = expr; });</div>
<div class="line">      expression = ast.operator + <span class="charliteral">&#39;(&#39;</span> + this.ifDefined(right, 0) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">      this.recurse(ast.left, undefined, undefined, <span class="keyword">function</span>(expr) { left = expr; });</div>
<div class="line">      this.recurse(ast.right, undefined, undefined, <span class="keyword">function</span>(expr) { right = expr; });</div>
<div class="line">      <span class="keywordflow">if</span> (ast.operator === <span class="charliteral">&#39;+&#39;</span>) {</div>
<div class="line">        expression = this.plus(left, right);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ast.operator === <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        expression = <span class="charliteral">&#39;(&#39;</span> + left + <span class="charliteral">&#39;)&#39;</span> + ast.operator + <span class="charliteral">&#39;(&#39;</span> + right + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.left, intoId);</div>
<div class="line">      <span class="keyword">self</span>.if_(ast.operator === <span class="stringliteral">&#39;&amp;&amp;&#39;</span> ? intoId : <span class="keyword">self</span>.not(intoId), <span class="keyword">self</span>.lazyRecurse(ast.right, intoId));</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.test, intoId);</div>
<div class="line">      <span class="keyword">self</span>.if_(intoId, <span class="keyword">self</span>.lazyRecurse(ast.alternate, intoId), <span class="keyword">self</span>.lazyRecurse(ast.consequent, intoId));</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keywordflow">if</span> (nameId) {</div>
<div class="line">        nameId.context = <span class="keyword">self</span>.stage === <span class="stringliteral">&#39;inputs&#39;</span> ? <span class="charliteral">&#39;s&#39;</span> : this.assign(this.nextId(), this.getHasOwnProperty(<span class="charliteral">&#39;l&#39;</span>, ast.name) + <span class="stringliteral">&#39;?l:s&#39;</span>);</div>
<div class="line">        nameId.computed = <span class="keyword">false</span>;</div>
<div class="line">        nameId.name = ast.name;</div>
<div class="line">      }</div>
<div class="line">      ensureSafeMemberName(ast.name);</div>
<div class="line">      <span class="keyword">self</span>.if_(<span class="keyword">self</span>.stage === <span class="stringliteral">&#39;inputs&#39;</span> || <span class="keyword">self</span>.not(<span class="keyword">self</span>.getHasOwnProperty(<span class="charliteral">&#39;l&#39;</span>, ast.name)),</div>
<div class="line">        <span class="keyword">function</span>() {</div>
<div class="line">          self.if_(self.stage === <span class="stringliteral">&#39;inputs&#39;</span> || <span class="stringliteral">&#39;s&#39;</span>, function() {</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(</div>
<div class="line">                self.not(self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name)),</div>
<div class="line">                self.lazyAssign(self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            self.assign(intoId, self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name));</div>
<div class="line">          });</div>
<div class="line">        }, intoId &amp;&amp; <span class="keyword">self</span>.lazyAssign(intoId, <span class="keyword">self</span>.nonComputedMember(<span class="charliteral">&#39;l&#39;</span>, ast.name))</div>
<div class="line">        );</div>
<div class="line">      <span class="keywordflow">if</span> (<span class="keyword">self</span>.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {</div>
<div class="line">        <span class="keyword">self</span>.addEnsureSafeObject(intoId);</div>
<div class="line">      }</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">      left = nameId &amp;&amp; (nameId.context = this.nextId()) || this.nextId();</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.object, left, undefined, <span class="keyword">function</span>() {</div>
<div class="line">        self.if_(self.notNull(left), function() {</div>
<div class="line">          if (ast.computed) {</div>
<div class="line">            right = self.nextId();</div>
<div class="line">            self.recurse(ast.property, right);</div>
<div class="line">            self.addEnsureSafeMemberName(right);</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            expression = self.ensureSafeObject(self.computedMember(left, right));</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">            if (nameId) {</div>
<div class="line">              nameId.computed = true;</div>
<div class="line">              nameId.name = right;</div>
<div class="line">            }</div>
<div class="line">          } else {</div>
<div class="line">            ensureSafeMemberName(ast.property.name);</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            expression = self.nonComputedMember(left, ast.property.name);</div>
<div class="line">            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {</div>
<div class="line">              expression = self.ensureSafeObject(expression);</div>
<div class="line">            }</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">            if (nameId) {</div>
<div class="line">              nameId.computed = false;</div>
<div class="line">              nameId.name = ast.property.name;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }, <span class="keyword">function</span>() {</div>
<div class="line">          self.assign(intoId, <span class="stringliteral">&#39;undefined&#39;</span>);</div>
<div class="line">        });</div>
<div class="line">        recursionFn(intoId);</div>
<div class="line">      }, !!create);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keywordflow">if</span> (ast.filter) {</div>
<div class="line">        right = <span class="keyword">self</span>.filter(ast.callee.name);</div>
<div class="line">        args = [];</div>
<div class="line">        forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">          var argument = self.nextId();</div>
<div class="line">          self.recurse(expr, argument);</div>
<div class="line">          args.push(argument);</div>
<div class="line">        });</div>
<div class="line">        expression = right + <span class="charliteral">&#39;(&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">        <span class="keyword">self</span>.assign(intoId, expression);</div>
<div class="line">        recursionFn(intoId);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        right = <span class="keyword">self</span>.nextId();</div>
<div class="line">        left = {};</div>
<div class="line">        args = [];</div>
<div class="line">        <span class="keyword">self</span>.recurse(ast.callee, right, left, <span class="keyword">function</span>() {</div>
<div class="line">          self.if_(self.notNull(right), function() {</div>
<div class="line">            self.addEnsureSafeFunction(right);</div>
<div class="line">            forEach(ast.arguments, function(expr) {</div>
<div class="line">              self.recurse(expr, self.nextId(), undefined, function(argument) {</div>
<div class="line">                args.push(self.ensureSafeObject(argument));</div>
<div class="line">              });</div>
<div class="line">            });</div>
<div class="line">            if (left.name) {</div>
<div class="line">              if (!self.state.expensiveChecks) {</div>
<div class="line">                self.addEnsureSafeObject(left.context);</div>
<div class="line">              }</div>
<div class="line">              expression = self.member(left.context, left.name, left.computed) + <span class="stringliteral">&#39;(&#39;</span> + args.join(<span class="stringliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;)&#39;</span>;</div>
<div class="line">            } else {</div>
<div class="line">              expression = right + <span class="stringliteral">&#39;(&#39;</span> + args.join(<span class="stringliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;)&#39;</span>;</div>
<div class="line">            }</div>
<div class="line">            expression = self.ensureSafeObject(expression);</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">          }, <span class="keyword">function</span>() {</div>
<div class="line">            self.assign(intoId, <span class="stringliteral">&#39;undefined&#39;</span>);</div>
<div class="line">          });</div>
<div class="line">          recursionFn(intoId);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">      right = this.nextId();</div>
<div class="line">      left = {};</div>
<div class="line">      <span class="keywordflow">if</span> (!isAssignable(ast.left)) {</div>
<div class="line">        <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;lval&#39;</span>, <span class="stringliteral">&#39;Trying to assing a value to a non l-value&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">      this.recurse(ast.left, undefined, left, <span class="keyword">function</span>() {</div>
<div class="line">        self.if_(self.notNull(left.context), function() {</div>
<div class="line">          self.recurse(ast.right, right);</div>
<div class="line">          self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));</div>
<div class="line">          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;</div>
<div class="line">          self.assign(intoId, expression);</div>
<div class="line">          recursionFn(intoId || expression);</div>
<div class="line">        });</div>
<div class="line">      }, 1);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">        self.recurse(expr, self.nextId(), undefined, function(argument) {</div>
<div class="line">          args.push(argument);</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      expression = <span class="charliteral">&#39;[&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">        self.recurse(property.value, self.nextId(), undefined, function(expr) {</div>
<div class="line">          args.push(self.escape(</div>
<div class="line">              property.key.type === AST.Identifier ? property.key.name :</div>
<div class="line">                (<span class="stringliteral">&#39;&#39;</span> + property.key.value)) +</div>
<div class="line">              <span class="stringliteral">&#39;:&#39;</span> + expr);</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      expression = <span class="charliteral">&#39;{&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;}&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">      this.assign(intoId, <span class="charliteral">&#39;s&#39;</span>);</div>
<div class="line">      recursionFn(<span class="charliteral">&#39;s&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.NGValueParameter:</div>
<div class="line">      this.assign(intoId, <span class="charliteral">&#39;v&#39;</span>);</div>
<div class="line">      recursionFn(<span class="charliteral">&#39;v&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  getHasOwnProperty: <span class="keyword">function</span>(element, property) {</div>
<div class="line">    var key = element + <span class="charliteral">&#39;.&#39;</span> + property;</div>
<div class="line">    var own = this.current().own;</div>
<div class="line">    <span class="keywordflow">if</span> (!own.hasOwnProperty(key)) {</div>
<div class="line">      own[key] = this.nextId(<span class="keyword">false</span>, element + <span class="stringliteral">&#39;&amp;&amp;(&#39;</span> + this.escape(property) + <span class="stringliteral">&#39; in &#39;</span> + element + <span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> own[key];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  assign: <span class="keyword">function</span>(id, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (!<span class="keywordtype">id</span>) <span class="keywordflow">return</span>;</div>
<div class="line">    this.current().body.push(<span class="keywordtype">id</span>, <span class="charliteral">&#39;=&#39;</span>, value, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> id;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filter: <span class="keyword">function</span>(filterName) {</div>
<div class="line">    <span class="keywordflow">if</span> (!this.state.filters.hasOwnProperty(filterName)) {</div>
<div class="line">      this.state.filters[filterName] = this.nextId(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.state.filters[filterName];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ifDefined: <span class="keyword">function</span>(id, defaultValue) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ifDefined(&#39;</span> + <span class="keywordtype">id</span> + <span class="charliteral">&#39;,&#39;</span> + this.escape(defaultValue) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  plus: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;plus(&#39;</span> + left + <span class="charliteral">&#39;,&#39;</span> + right + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  return_: <span class="keyword">function</span>(id) {</div>
<div class="line">    this.current().body.push(<span class="stringliteral">&#39;return &#39;</span>, <span class="keywordtype">id</span>, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  if_: <span class="keyword">function</span>(test, alternate, consequent) {</div>
<div class="line">    <span class="keywordflow">if</span> (test === <span class="keyword">true</span>) {</div>
<div class="line">      alternate();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var body = this.current().body;</div>
<div class="line">      body.push(<span class="stringliteral">&#39;if(&#39;</span>, test, <span class="stringliteral">&#39;){&#39;</span>);</div>
<div class="line">      alternate();</div>
<div class="line">      body.push(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (consequent) {</div>
<div class="line">        body.push(<span class="stringliteral">&#39;else{&#39;</span>);</div>
<div class="line">        consequent();</div>
<div class="line">        body.push(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  not: <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;!(&#39;</span> + expression + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  notNull: <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">return</span> expression + <span class="stringliteral">&#39;!=null&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  nonComputedMember: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> left + <span class="charliteral">&#39;.&#39;</span> + right;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  computedMember: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> left + <span class="charliteral">&#39;[&#39;</span> + right + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  member: <span class="keyword">function</span>(left, right, computed) {</div>
<div class="line">    <span class="keywordflow">if</span> (computed) <span class="keywordflow">return</span> this.computedMember(left, right);</div>
<div class="line">    <span class="keywordflow">return</span> this.nonComputedMember(left, right);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeObject: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeObject(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeMemberName: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeMemberName(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeFunction: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeFunction(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeObject: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeObject(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeMemberName: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeMemberName(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeFunction: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeFunction(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  lazyRecurse: <span class="keyword">function</span>(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  lazyAssign: <span class="keyword">function</span>(id, value) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">self</span>.assign(<span class="keywordtype">id</span>, value);</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  stringEscapeRegex: /[^ a-zA-Z0-9]/g,</div>
<div class="line"></div>
<div class="line">  stringEscapeFn: <span class="keyword">function</span>(c) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;\\u&#39;</span> + (<span class="stringliteral">&#39;0000&#39;</span> + c.charCodeAt(0).toString(16)).slice(-4);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  escape: <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isString(value)) <span class="keywordflow">return</span> <span class="stringliteral">&quot;&#39;&quot;</span> + value.replace(<span class="keyword">this</span>.stringEscapeRegex, <span class="keyword">this</span>.stringEscapeFn) + <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(value)) <span class="keywordflow">return</span> value.toString();</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="keyword">true</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;true&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="keyword">false</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;false&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (value === null) <span class="keywordflow">return</span> <span class="stringliteral">&#39;null&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (typeof value === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;undefined&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;esc&#39;</span>, <span class="stringliteral">&#39;IMPOSSIBLE&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  nextId: <span class="keyword">function</span>(skip, init) {</div>
<div class="line">    var <span class="keywordtype">id</span> = <span class="charliteral">&#39;v&#39;</span> + (this.state.nextId++);</div>
<div class="line">    <span class="keywordflow">if</span> (!skip) {</div>
<div class="line">      this.current().vars.push(<span class="keywordtype">id</span> + (init ? <span class="charliteral">&#39;=&#39;</span> + init : <span class="stringliteral">&#39;&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> id;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  current: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[this.state.computing];</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ASTInterpreter(astBuilder, $filter) {</div>
<div class="line">  this.astBuilder = astBuilder;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ASTInterpreter.prototype = {</div>
<div class="line">  compile: <span class="keyword">function</span>(expression, expensiveChecks) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    var ast = this.astBuilder.ast(expression);</div>
<div class="line">    this.expression = expression;</div>
<div class="line">    this.expensiveChecks = expensiveChecks;</div>
<div class="line">    findConstantAndWatchExpressions(ast, <span class="keyword">self</span>.$filter);</div>
<div class="line">    var assignable;</div>
<div class="line">    var assign;</div>
<div class="line">    <span class="keywordflow">if</span> ((assignable = assignableAST(ast))) {</div>
<div class="line">      assign = this.recurse(assignable);</div>
<div class="line">    }</div>
<div class="line">    var toWatch = getInputs(ast.body);</div>
<div class="line">    var inputs;</div>
<div class="line">    <span class="keywordflow">if</span> (toWatch) {</div>
<div class="line">      inputs = [];</div>
<div class="line">      forEach(toWatch, <span class="keyword">function</span>(watch, key) {</div>
<div class="line">        var input = <span class="keyword">self</span>.recurse(watch);</div>
<div class="line">        watch.input = input;</div>
<div class="line">        inputs.push(input);</div>
<div class="line">        watch.watchId = key;</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">    var expressions = [];</div>
<div class="line">    forEach(ast.body, <span class="keyword">function</span>(expression) {</div>
<div class="line">      expressions.push(self.recurse(expression.expression));</div>
<div class="line">    });</div>
<div class="line">    var fn = ast.body.length === 0 ? <span class="keyword">function</span>() {} :</div>
<div class="line">             ast.body.length === 1 ? expressions[0] :</div>
<div class="line">             <span class="keyword">function</span>(scope, locals) {</div>
<div class="line">               var lastValue;</div>
<div class="line">               forEach(expressions, <span class="keyword">function</span>(exp) {</div>
<div class="line">                 lastValue = exp(scope, locals);</div>
<div class="line">               });</div>
<div class="line">               <span class="keywordflow">return</span> lastValue;</div>
<div class="line">             };</div>
<div class="line">    <span class="keywordflow">if</span> (assign) {</div>
<div class="line">      fn.assign = <span class="keyword">function</span>(scope, value, locals) {</div>
<div class="line">        <span class="keywordflow">return</span> assign(scope, locals, value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (inputs) {</div>
<div class="line">      fn.inputs = inputs;</div>
<div class="line">    }</div>
<div class="line">    fn.literal = isLiteral(ast);</div>
<div class="line">    fn.constant = isConstant(ast);</div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  recurse: <span class="keyword">function</span>(ast, context, create) {</div>
<div class="line">    var left, right, <span class="keyword">self</span> = <span class="keyword">this</span>, args, expression;</div>
<div class="line">    <span class="keywordflow">if</span> (ast.input) {</div>
<div class="line">      <span class="keywordflow">return</span> this.inputs(ast.input, ast.watchId);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">    <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">      <span class="keywordflow">return</span> this.value(ast.value, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">      right = this.recurse(ast.argument);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;unary&#39;</span> + ast.operator](right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">      left = this.recurse(ast.left);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;binary&#39;</span> + ast.operator](left, right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">      left = this.recurse(ast.left);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;binary&#39;</span> + ast.operator](left, right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;ternary?:&#39;</span>](</div>
<div class="line">        this.recurse(ast.test),</div>
<div class="line">        this.recurse(ast.alternate),</div>
<div class="line">        this.recurse(ast.consequent),</div>
<div class="line">        context</div>
<div class="line">      );</div>
<div class="line">    <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">      ensureSafeMemberName(ast.name, <span class="keyword">self</span>.expression);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">self</span>.identifier(ast.name,</div>
<div class="line">                             <span class="keyword">self</span>.expensiveChecks || isPossiblyDangerousMemberName(ast.name),</div>
<div class="line">                             context, create, <span class="keyword">self</span>.expression);</div>
<div class="line">    <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">      left = this.recurse(ast.object, <span class="keyword">false</span>, !!create);</div>
<div class="line">      <span class="keywordflow">if</span> (!ast.computed) {</div>
<div class="line">        ensureSafeMemberName(ast.property.name, <span class="keyword">self</span>.expression);</div>
<div class="line">        right = ast.property.name;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ast.computed) right = this.recurse(ast.property);</div>
<div class="line">      <span class="keywordflow">return</span> ast.computed ?</div>
<div class="line">        this.computedMember(left, right, context, create, <span class="keyword">self</span>.expression) :</div>
<div class="line">        this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);</div>
<div class="line">    <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">        args.push(self.recurse(expr));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (ast.filter) right = this.$filter(ast.callee.name);</div>
<div class="line">      <span class="keywordflow">if</span> (!ast.filter) right = this.recurse(ast.callee, <span class="keyword">true</span>);</div>
<div class="line">      <span class="keywordflow">return</span> ast.filter ?</div>
<div class="line">        <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">          var values = [];</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">            values.push(args[i](scope, locals, assign, inputs));</div>
<div class="line">          }</div>
<div class="line">          var value = right.apply(undefined, values, inputs);</div>
<div class="line">          <span class="keywordflow">return</span> context ? {context: undefined, name: undefined, value: value} : value;</div>
<div class="line">        } :</div>
<div class="line">        <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">          var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">          var value;</div>
<div class="line">          <span class="keywordflow">if</span> (rhs.value != null) {</div>
<div class="line">            ensureSafeObject(rhs.context, <span class="keyword">self</span>.expression);</div>
<div class="line">            ensureSafeFunction(rhs.value, <span class="keyword">self</span>.expression);</div>
<div class="line">            var values = [];</div>
<div class="line">            <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">              values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), <span class="keyword">self</span>.expression));</div>
<div class="line">            }</div>
<div class="line">            value = ensureSafeObject(rhs.value.apply(rhs.context, values), <span class="keyword">self</span>.expression);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">        };</div>
<div class="line">    <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">      left = this.recurse(ast.left, <span class="keyword">true</span>, 1);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">        var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">        ensureSafeObject(lhs.value, <span class="keyword">self</span>.expression);</div>
<div class="line">        lhs.context[lhs.name] = rhs;</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: rhs} : rhs;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">        args.push(self.recurse(expr));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var value = [];</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">          value.push(args[i](scope, locals, assign, inputs));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">        args.push({key: property.key.type === AST.Identifier ?</div>
<div class="line">                        property.key.name :</div>
<div class="line">                        (<span class="stringliteral">&#39;&#39;</span> + property.key.value),</div>
<div class="line">                   value: self.recurse(property.value)</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var value = {};</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">          value[args[i].key] = args[i].value(scope, locals, assign, inputs);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: scope} : scope;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.NGValueParameter:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: assign} : assign;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="stringliteral">&#39;unary+&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(arg)) {</div>
<div class="line">        arg = +arg;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        arg = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;unary-&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(arg)) {</div>
<div class="line">        arg = -arg;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        arg = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;unary!&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = !argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary+&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">      var arg = plusFn(lhs, rhs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary-&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary*&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary/&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary%&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary===&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary!==&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary==&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary!=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&lt;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &lt; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&gt;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &gt; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&lt;=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &lt;= right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&gt;=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &gt;= right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&amp;&amp;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &amp;&amp; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary||&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;ternary?:&#39;</span>: <span class="keyword">function</span>(test, alternate, consequent, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  value: <span class="keyword">function</span>(value, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() { <span class="keywordflow">return</span> context ? {context: undefined, name: undefined, value: value} : value; };</div>
<div class="line">  },</div>
<div class="line">  identifier: <span class="keyword">function</span>(name, expensiveChecks, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var base = locals &amp;&amp; (name in locals) ? locals : scope;</div>
<div class="line">      <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; base &amp;&amp; !(base[name])) {</div>
<div class="line">        base[name] = {};</div>
<div class="line">      }</div>
<div class="line">      var value = base ? base[name] : undefined;</div>
<div class="line">      <span class="keywordflow">if</span> (expensiveChecks) {</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: base, name: name, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  computedMember: <span class="keyword">function</span>(left, right, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs;</div>
<div class="line">      var value;</div>
<div class="line">      <span class="keywordflow">if</span> (lhs != null) {</div>
<div class="line">        rhs = right(scope, locals, assign, inputs);</div>
<div class="line">        ensureSafeMemberName(rhs, expression);</div>
<div class="line">        <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; lhs &amp;&amp; !(lhs[rhs])) {</div>
<div class="line">          lhs[rhs] = {};</div>
<div class="line">        }</div>
<div class="line">        value = lhs[rhs];</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: lhs, name: rhs, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  nonComputedMember: <span class="keyword">function</span>(left, right, expensiveChecks, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; lhs &amp;&amp; !(lhs[right])) {</div>
<div class="line">        lhs[right] = {};</div>
<div class="line">      }</div>
<div class="line">      var value = lhs != null ? lhs[right] : undefined;</div>
<div class="line">      <span class="keywordflow">if</span> (expensiveChecks || isPossiblyDangerousMemberName(right)) {</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: lhs, name: right, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  inputs: <span class="keyword">function</span>(input, watchId) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, value, locals, inputs) {</div>
<div class="line">      <span class="keywordflow">if</span> (inputs) <span class="keywordflow">return</span> inputs[watchId];</div>
<div class="line">      <span class="keywordflow">return</span> input(scope, value, locals);</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var Parser = <span class="keyword">function</span>(lexer, $filter, options) {</div>
<div class="line">  this.lexer = lexer;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">  this.options = options;</div>
<div class="line">  this.ast = <span class="keyword">new</span> AST(this.lexer);</div>
<div class="line">  this.astCompiler = options.csp ? <span class="keyword">new</span> ASTInterpreter(this.ast, $filter) :</div>
<div class="line">                                   new ASTCompiler(this.ast, $filter);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Parser.prototype = {</div>
<div class="line">  constructor: Parser,</div>
<div class="line"></div>
<div class="line">  parse: <span class="keyword">function</span>(text) {</div>
<div class="line">    <span class="keywordflow">return</span> this.astCompiler.compile(text, this.options.expensiveChecks);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var getterFnCacheDefault = createMap();</div>
<div class="line">var getterFnCacheExpensive = createMap();</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isPossiblyDangerousMemberName(name) {</div>
<div class="line">  <span class="keywordflow">return</span> name == <span class="stringliteral">&#39;constructor&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var objectValueOf = Object.prototype.valueOf;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getValueOf(value) {</div>
<div class="line">  <span class="keywordflow">return</span> isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ParseProvider() {</div>
<div class="line">  var cacheDefault = createMap();</div>
<div class="line">  var cacheExpensive = createMap();</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$filter&#39;</span>, <span class="keyword">function</span>($filter) {</div>
<div class="line">    var noUnsafeEval = csp().noUnsafeEval;</div>
<div class="line">    var $parseOptions = {</div>
<div class="line">          csp: noUnsafeEval,</div>
<div class="line">          expensiveChecks: <span class="keyword">false</span></div>
<div class="line">        },</div>
<div class="line">        $parseOptionsExpensive = {</div>
<div class="line">          csp: noUnsafeEval,</div>
<div class="line">          expensiveChecks: <span class="keyword">true</span></div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> $parse(exp, interceptorFn, expensiveChecks) {</div>
<div class="line">      var parsedExpression, oneTime, cacheKey;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">switch</span> (typeof exp) {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">          exp = exp.trim();</div>
<div class="line">          cacheKey = exp;</div>
<div class="line"></div>
<div class="line">          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);</div>
<div class="line">          parsedExpression = cache[cacheKey];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!parsedExpression) {</div>
<div class="line">            <span class="keywordflow">if</span> (exp.charAt(0) === <span class="charliteral">&#39;:&#39;</span> &amp;&amp; exp.charAt(1) === <span class="charliteral">&#39;:&#39;</span>) {</div>
<div class="line">              oneTime = <span class="keyword">true</span>;</div>
<div class="line">              exp = exp.substring(2);</div>
<div class="line">            }</div>
<div class="line">            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;</div>
<div class="line">            var lexer = <span class="keyword">new</span> Lexer(parseOptions);</div>
<div class="line">            var parser = <span class="keyword">new</span> Parser(lexer, $filter, parseOptions);</div>
<div class="line">            parsedExpression = parser.parse(exp);</div>
<div class="line">            <span class="keywordflow">if</span> (parsedExpression.constant) {</div>
<div class="line">              parsedExpression.$$watchDelegate = constantWatchDelegate;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oneTime) {</div>
<div class="line">              parsedExpression.$$watchDelegate = parsedExpression.literal ?</div>
<div class="line">                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsedExpression.inputs) {</div>
<div class="line">              parsedExpression.$$watchDelegate = inputsWatchDelegate;</div>
<div class="line">            }</div>
<div class="line">            cache[cacheKey] = parsedExpression;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> addInterceptor(parsedExpression, interceptorFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">          <span class="keywordflow">return</span> addInterceptor(exp, interceptorFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">          <span class="keywordflow">return</span> noop;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> expressionInputDirtyCheck(newValue, oldValueOfValue) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (newValue == null || oldValueOfValue == null) { <span class="comment">// null/undefined</span></div>
<div class="line">        <span class="keywordflow">return</span> newValue === oldValueOfValue;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (typeof newValue === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// attempt to convert the value to a primitive type</span></div>
<div class="line">        <span class="comment">// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can</span></div>
<div class="line">        <span class="comment">//             be cheaply dirty-checked</span></div>
<div class="line">        newValue = getValueOf(newValue);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (typeof newValue === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">          <span class="comment">// objects/arrays are not supported - deep-watching them would be too expensive</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fall-through to the primitive equality check</span></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">//Primitive or NaN</span></div>
<div class="line">      <span class="keywordflow">return</span> newValue === oldValueOfValue || (newValue !== newValue &amp;&amp; oldValueOfValue !== oldValueOfValue);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {</div>
<div class="line">      var inputExpressions = parsedExpression.inputs;</div>
<div class="line">      var lastResult;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (inputExpressions.length === 1) {</div>
<div class="line">        var oldInputValueOf = expressionInputDirtyCheck; <span class="comment">// init to something unique so that equals check fails</span></div>
<div class="line">        inputExpressions = inputExpressions[0];</div>
<div class="line">        <span class="keywordflow">return</span> scope.$watch(<span class="keyword">function</span> expressionInputWatch(scope) {</div>
<div class="line">          var newInputValue = inputExpressions(scope);</div>
<div class="line">          <span class="keywordflow">if</span> (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {</div>
<div class="line">            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);</div>
<div class="line">            oldInputValueOf = newInputValue &amp;&amp; getValueOf(newInputValue);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> lastResult;</div>
<div class="line">        }, listener, objectEquality, prettyPrintExpression);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var oldInputValueOfValues = [];</div>
<div class="line">      var oldInputValues = [];</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {</div>
<div class="line">        oldInputValueOfValues[i] = expressionInputDirtyCheck; <span class="comment">// init to something unique so that equals check fails</span></div>
<div class="line">        oldInputValues[i] = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> scope.$watch(<span class="keyword">function</span> expressionInputsWatch(scope) {</div>
<div class="line">        var changed = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {</div>
<div class="line">          var newInputValue = inputExpressions[i](scope);</div>
<div class="line">          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {</div>
<div class="line">            oldInputValues[i] = newInputValue;</div>
<div class="line">            oldInputValueOfValues[i] = newInputValue &amp;&amp; getValueOf(newInputValue);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (changed) {</div>
<div class="line">          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> lastResult;</div>
<div class="line">      }, listener, objectEquality, prettyPrintExpression);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch, lastValue;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> oneTimeWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> oneTimeListener(value, old, scope) {</div>
<div class="line">        lastValue = value;</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">          scope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isDefined(lastValue)) {</div>
<div class="line">              unwatch();</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      }, objectEquality);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch, lastValue;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> oneTimeWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> oneTimeListener(value, old, scope) {</div>
<div class="line">        lastValue = value;</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.call(<span class="keyword">this</span>, value, old, scope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (isAllDefined(value)) {</div>
<div class="line">          scope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isAllDefined(lastValue)) unwatch();</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      }, objectEquality);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> isAllDefined(value) {</div>
<div class="line">        var allDefined = <span class="keyword">true</span>;</div>
<div class="line">        forEach(value, <span class="keyword">function</span>(val) {</div>
<div class="line">          <span class="keywordflow">if</span> (!isDefined(val)) allDefined = <span class="keyword">false</span>;</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> allDefined;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> constantWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> constantListener(value, old, scope) {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">        }</div>
<div class="line">        unwatch();</div>
<div class="line">      }, objectEquality);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addInterceptor(parsedExpression, interceptorFn) {</div>
<div class="line">      <span class="keywordflow">if</span> (!interceptorFn) <span class="keywordflow">return</span> parsedExpression;</div>
<div class="line">      var watchDelegate = parsedExpression.$$watchDelegate;</div>
<div class="line"></div>
<div class="line">      var regularWatch =</div>
<div class="line">          watchDelegate !== oneTimeLiteralWatchDelegate &amp;&amp;</div>
<div class="line">          watchDelegate !== oneTimeWatchDelegate;</div>
<div class="line"></div>
<div class="line">      var fn = regularWatch ? <span class="keyword">function</span> regularInterceptedExpression(scope, locals, assign, inputs) {</div>
<div class="line">        var value = parsedExpression(scope, locals, assign, inputs);</div>
<div class="line">        <span class="keywordflow">return</span> interceptorFn(value, scope, locals);</div>
<div class="line">      } : <span class="keyword">function</span> oneTimeInterceptedExpression(scope, locals, assign, inputs) {</div>
<div class="line">        var value = parsedExpression(scope, locals, assign, inputs);</div>
<div class="line">        var result = interceptorFn(value, scope, locals);</div>
<div class="line">        <span class="comment">// we only return the interceptor&#39;s result if the</span></div>
<div class="line">        <span class="comment">// initial value is defined (for bind-once)</span></div>
<div class="line">        <span class="keywordflow">return</span> isDefined(value) ? result : value;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Propagate $$watchDelegates other then inputsWatchDelegate</span></div>
<div class="line">      <span class="keywordflow">if</span> (parsedExpression.$$watchDelegate &amp;&amp;</div>
<div class="line">          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {</div>
<div class="line">        fn.$$watchDelegate = parsedExpression.$$watchDelegate;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!interceptorFn.$stateful) {</div>
<div class="line">        <span class="comment">// If there is an interceptor, but no watchDelegate then treat the interceptor like</span></div>
<div class="line">        <span class="comment">// we treat filters - it is assumed to be a pure function unless flagged with $stateful</span></div>
<div class="line">        fn.$$watchDelegate = inputsWatchDelegate;</div>
<div class="line">        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> fn;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $QProvider() {</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="keyword">function</span>($rootScope, $exceptionHandler) {</div>
<div class="line">    <span class="keywordflow">return</span> qFactory(<span class="keyword">function</span>(callback) {</div>
<div class="line">      $rootScope.$evalAsync(callback);</div>
<div class="line">    }, $exceptionHandler);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$QProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="keyword">function</span>($browser, $exceptionHandler) {</div>
<div class="line">    <span class="keywordflow">return</span> qFactory(<span class="keyword">function</span>(callback) {</div>
<div class="line">      $browser.defer(callback);</div>
<div class="line">    }, $exceptionHandler);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> qFactory(nextTick, exceptionHandler) {</div>
<div class="line">  var $qMinErr = minErr(<span class="stringliteral">&#39;$q&#39;</span>, TypeError);</div>
<div class="line">  <span class="keyword">function</span> callOnce(<span class="keyword">self</span>, resolveFn, rejectFn) {</div>
<div class="line">    var called = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">function</span> wrap(fn) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (called) <span class="keywordflow">return</span>;</div>
<div class="line">        called = <span class="keyword">true</span>;</div>
<div class="line">        fn.call(<span class="keyword">self</span>, value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> [wrap(resolveFn), wrap(rejectFn)];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var defer = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Deferred();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> Promise() {</div>
<div class="line">    this.$$state = { status: 0 };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  extend(Promise.prototype, {</div>
<div class="line">    then: function(onFulfilled, onRejected, progressBack) {</div>
<div class="line">      if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {</div>
<div class="line">        return this;</div>
<div class="line">      }</div>
<div class="line">      var result = new Deferred();</div>
<div class="line"></div>
<div class="line">      this.$$state.pending = this.$$state.pending || [];</div>
<div class="line">      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);</div>
<div class="line">      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);</div>
<div class="line"></div>
<div class="line">      return result.promise;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="stringliteral">&quot;catch&quot;</span>: <span class="keyword">function</span>(callback) {</div>
<div class="line">      return this.then(null, callback);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="stringliteral">&quot;finally&quot;</span>: <span class="keyword">function</span>(callback, progressBack) {</div>
<div class="line">      return this.then(function(value) {</div>
<div class="line">        return handleCallback(value, true, callback);</div>
<div class="line">      }, <span class="keyword">function</span>(error) {</div>
<div class="line">        return handleCallback(error, false, callback);</div>
<div class="line">      }, progressBack);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native</span></div>
<div class="line">  <span class="keyword">function</span> simpleBind(context, fn) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">      fn.call(context, value);</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> processQueue(state) {</div>
<div class="line">    var fn, deferred, pending;</div>
<div class="line"></div>
<div class="line">    pending = state.pending;</div>
<div class="line">    state.processScheduled = <span class="keyword">false</span>;</div>
<div class="line">    state.pending = undefined;</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = pending.length; i &lt; ii; ++i) {</div>
<div class="line">      deferred = pending[i][0];</div>
<div class="line">      fn = pending[i][state.status];</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(fn)) {</div>
<div class="line">          deferred.resolve(fn(state.value));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.status === 1) {</div>
<div class="line">          deferred.resolve(state.value);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          deferred.reject(state.value);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        deferred.reject(e);</div>
<div class="line">        exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> scheduleProcessQueue(state) {</div>
<div class="line">    <span class="keywordflow">if</span> (state.processScheduled || !state.pending) <span class="keywordflow">return</span>;</div>
<div class="line">    state.processScheduled = <span class="keyword">true</span>;</div>
<div class="line">    nextTick(<span class="keyword">function</span>() { processQueue(state); });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> Deferred() {</div>
<div class="line">    this.promise = <span class="keyword">new</span> Promise();</div>
<div class="line">    <span class="comment">//Necessary to support unbound execution :/</span></div>
<div class="line">    this.resolve = simpleBind(<span class="keyword">this</span>, this.resolve);</div>
<div class="line">    this.reject = simpleBind(<span class="keyword">this</span>, this.reject);</div>
<div class="line">    this.notify = simpleBind(<span class="keyword">this</span>, this.notify);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  extend(Deferred.prototype, {</div>
<div class="line">    resolve: function(val) {</div>
<div class="line">      if (this.promise.$$state.status) return;</div>
<div class="line">      if (val === this.promise) {</div>
<div class="line">        this.$$reject($qMinErr(</div>
<div class="line">          <span class="stringliteral">&#39;qcycle&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;Expected promise to be resolved with value other than itself &#39;{0}&#39;&quot;</span>,</div>
<div class="line">          val));</div>
<div class="line">      } else {</div>
<div class="line">        this.$$resolve(val);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    $$resolve: <span class="keyword">function</span>(val) {</div>
<div class="line">      var then, fns;</div>
<div class="line"></div>
<div class="line">      fns = callOnce(this, this.$$resolve, this.$$reject);</div>
<div class="line">      try {</div>
<div class="line">        if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then;</div>
<div class="line">        if (isFunction(then)) {</div>
<div class="line">          this.promise.$$state.status = -1;</div>
<div class="line">          then.call(val, fns[0], fns[1], this.notify);</div>
<div class="line">        } else {</div>
<div class="line">          this.promise.$$state.value = val;</div>
<div class="line">          this.promise.$$state.status = 1;</div>
<div class="line">          scheduleProcessQueue(this.promise.$$state);</div>
<div class="line">        }</div>
<div class="line">      } catch (e) {</div>
<div class="line">        fns[1](e);</div>
<div class="line">        exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    reject: <span class="keyword">function</span>(reason) {</div>
<div class="line">      <span class="keywordflow">if</span> (this.promise.$$state.status) <span class="keywordflow">return</span>;</div>
<div class="line">      this.$$reject(reason);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    $$reject: <span class="keyword">function</span>(reason) {</div>
<div class="line">      this.promise.$$state.value = reason;</div>
<div class="line">      this.promise.$$state.status = 2;</div>
<div class="line">      scheduleProcessQueue(this.promise.$$state);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    notify: <span class="keyword">function</span>(progress) {</div>
<div class="line">      var callbacks = this.promise.$$state.pending;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> ((this.promise.$$state.status &lt;= 0) &amp;&amp; callbacks &amp;&amp; callbacks.length) {</div>
<div class="line">        nextTick(<span class="keyword">function</span>() {</div>
<div class="line">          var callback, result;</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0, ii = callbacks.length; i &lt; ii; i++) {</div>
<div class="line">            result = callbacks[i][0];</div>
<div class="line">            callback = callbacks[i][3];</div>
<div class="line">            try {</div>
<div class="line">              result.notify(isFunction(callback) ? callback(progress) : progress);</div>
<div class="line">            } catch (e) {</div>
<div class="line">              exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  var reject = <span class="keyword">function</span>(reason) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    result.reject(reason);</div>
<div class="line">    <span class="keywordflow">return</span> result.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var makePromise = <span class="keyword">function</span> makePromise(value, resolved) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    <span class="keywordflow">if</span> (resolved) {</div>
<div class="line">      result.resolve(value);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result.reject(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var handleCallback = <span class="keyword">function</span> handleCallback(value, isResolved, callback) {</div>
<div class="line">    var callbackOutput = null;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(callback)) callbackOutput = callback();</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> makePromise(e, <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isPromiseLike(callbackOutput)) {</div>
<div class="line">      <span class="keywordflow">return</span> callbackOutput.then(<span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> makePromise(value, isResolved);</div>
<div class="line">      }, <span class="keyword">function</span>(error) {</div>
<div class="line">        <span class="keywordflow">return</span> makePromise(error, <span class="keyword">false</span>);</div>
<div class="line">      });</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> makePromise(value, isResolved);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var when = <span class="keyword">function</span>(value, callback, errback, progressBack) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    result.resolve(value);</div>
<div class="line">    <span class="keywordflow">return</span> result.promise.then(callback, errback, progressBack);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var resolve = when;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> all(promises) {</div>
<div class="line">    var deferred = <span class="keyword">new</span> Deferred(),</div>
<div class="line">        counter = 0,</div>
<div class="line">        results = isArray(promises) ? [] : {};</div>
<div class="line"></div>
<div class="line">    forEach(promises, <span class="keyword">function</span>(promise, key) {</div>
<div class="line">      counter++;</div>
<div class="line">      when(promise).then(<span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (results.hasOwnProperty(key)) <span class="keywordflow">return</span>;</div>
<div class="line">        results[key] = value;</div>
<div class="line">        <span class="keywordflow">if</span> (!(--counter)) deferred.resolve(results);</div>
<div class="line">      }, <span class="keyword">function</span>(reason) {</div>
<div class="line">        <span class="keywordflow">if</span> (results.hasOwnProperty(key)) <span class="keywordflow">return</span>;</div>
<div class="line">        deferred.reject(reason);</div>
<div class="line">      });</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (counter === 0) {</div>
<div class="line">      deferred.resolve(results);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> deferred.promise;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var $Q = <span class="keyword">function</span> Q(resolver) {</div>
<div class="line">    <span class="keywordflow">if</span> (!isFunction(resolver)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $qMinErr(<span class="stringliteral">&#39;norslvr&#39;</span>, <span class="stringliteral">&quot;Expected resolverFn, got &#39;{0}&#39;&quot;</span>, resolver);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!(<span class="keyword">this</span> instanceof Q)) {</div>
<div class="line">      <span class="comment">// More useful when $Q is the Promise itself.</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Q(resolver);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var deferred = <span class="keyword">new</span> Deferred();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> resolveFn(value) {</div>
<div class="line">      deferred.resolve(value);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> rejectFn(reason) {</div>
<div class="line">      deferred.reject(reason);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    resolver(resolveFn, rejectFn);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> deferred.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  $Q.defer = defer;</div>
<div class="line">  $Q.reject = reject;</div>
<div class="line">  $Q.when = when;</div>
<div class="line">  $Q.resolve = resolve;</div>
<div class="line">  $Q.all = all;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> $Q;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$RAFProvider() { <span class="comment">//rAF</span></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$timeout&#39;</span>, <span class="keyword">function</span>($window, $timeout) {</div>
<div class="line">    var requestAnimationFrame = $window.requestAnimationFrame ||</div>
<div class="line">                                $window.webkitRequestAnimationFrame;</div>
<div class="line"></div>
<div class="line">    var cancelAnimationFrame = $window.cancelAnimationFrame ||</div>
<div class="line">                               $window.webkitCancelAnimationFrame ||</div>
<div class="line">                               $window.webkitCancelRequestAnimationFrame;</div>
<div class="line"></div>
<div class="line">    var rafSupported = !!requestAnimationFrame;</div>
<div class="line">    var rafFn = rafSupported</div>
<div class="line">      ? <span class="keyword">function</span>(fn) {</div>
<div class="line">          var <span class="keywordtype">id</span> = requestAnimationFrame(fn);</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            cancelAnimationFrame(<span class="keywordtype">id</span>);</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      : <span class="keyword">function</span>(fn) {</div>
<div class="line">          var timer = $timeout(fn, 16.66, <span class="keyword">false</span>); <span class="comment">// 1000 / 60 = 16.666</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            $timeout.cancel(timer);</div>
<div class="line">          };</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    queueFn.supported = rafSupported;</div>
<div class="line"></div>
<div class="line">    var cancelLastRAF;</div>
<div class="line">    var taskCount = 0;</div>
<div class="line">    var taskQueue = [];</div>
<div class="line">    <span class="keywordflow">return</span> queueFn;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> flush() {</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; taskQueue.length; i++) {</div>
<div class="line">        var task = taskQueue[i];</div>
<div class="line">        <span class="keywordflow">if</span> (task) {</div>
<div class="line">          taskQueue[i] = null;</div>
<div class="line">          task();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      taskCount = taskQueue.length = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> queueFn(asyncFn) {</div>
<div class="line">      var index = taskQueue.length;</div>
<div class="line"></div>
<div class="line">      taskCount++;</div>
<div class="line">      taskQueue.push(asyncFn);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (index === 0) {</div>
<div class="line">        cancelLastRAF = rafFn(flush);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> cancelQueueFn() {</div>
<div class="line">        <span class="keywordflow">if</span> (index &gt;= 0) {</div>
<div class="line">          taskQueue[index] = null;</div>
<div class="line">          index = null;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (--taskCount === 0 &amp;&amp; cancelLastRAF) {</div>
<div class="line">            cancelLastRAF();</div>
<div class="line">            cancelLastRAF = null;</div>
<div class="line">            taskQueue.length = 0;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $RootScopeProvider() {</div>
<div class="line">  var TTL = 10;</div>
<div class="line">  var $rootScopeMinErr = minErr(<span class="stringliteral">&#39;$rootScope&#39;</span>);</div>
<div class="line">  var lastDirtyWatch = null;</div>
<div class="line">  var applyAsyncId = null;</div>
<div class="line"></div>
<div class="line">  this.digestTtl = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      TTL = value;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> TTL;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> createChildScopeClass(parent) {</div>
<div class="line">    <span class="keyword">function</span> ChildScope() {</div>
<div class="line">      this.$$watchers = this.$$nextSibling =</div>
<div class="line">          this.$$childHead = this.$$childTail = null;</div>
<div class="line">      this.$$listeners = {};</div>
<div class="line">      this.$$listenerCount = {};</div>
<div class="line">      this.$$watchersCount = 0;</div>
<div class="line">      this.$id = nextUid();</div>
<div class="line">      this.$$ChildScope = null;</div>
<div class="line">    }</div>
<div class="line">    ChildScope.prototype = parent;</div>
<div class="line">    <span class="keywordflow">return</span> ChildScope;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($injector, $exceptionHandler, $parse, $browser) {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> destroyChildScope($event) {</div>
<div class="line">        $event.currentScope.$$destroyed = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> Scope() {</div>
<div class="line">      this.$id = nextUid();</div>
<div class="line">      this.$$phase = this.$parent = this.$$watchers =</div>
<div class="line">                     this.$$nextSibling = this.$$prevSibling =</div>
<div class="line">                     this.$$childHead = this.$$childTail = null;</div>
<div class="line">      this.$root = <span class="keyword">this</span>;</div>
<div class="line">      this.$$destroyed = <span class="keyword">false</span>;</div>
<div class="line">      this.$$listeners = {};</div>
<div class="line">      this.$$listenerCount = {};</div>
<div class="line">      this.$$watchersCount = 0;</div>
<div class="line">      this.$$isolateBindings = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Scope.prototype = {</div>
<div class="line">      constructor: Scope,</div>
<div class="line">      $new: <span class="keyword">function</span>(isolate, parent) {</div>
<div class="line">        var child;</div>
<div class="line"></div>
<div class="line">        parent = parent || <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isolate) {</div>
<div class="line">          child = <span class="keyword">new</span> Scope();</div>
<div class="line">          child.$root = this.$root;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// Only create a child scope class if somebody asks for one,</span></div>
<div class="line">          <span class="comment">// but cache it to allow the VM to optimize lookups.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!this.$$ChildScope) {</div>
<div class="line">            this.$$ChildScope = createChildScopeClass(<span class="keyword">this</span>);</div>
<div class="line">          }</div>
<div class="line">          child = <span class="keyword">new</span> this.$$ChildScope();</div>
<div class="line">        }</div>
<div class="line">        child.$parent = parent;</div>
<div class="line">        child.$$prevSibling = parent.$$childTail;</div>
<div class="line">        <span class="keywordflow">if</span> (parent.$$childHead) {</div>
<div class="line">          parent.$$childTail.$$nextSibling = child;</div>
<div class="line">          parent.$$childTail = child;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          parent.$$childHead = parent.$$childTail = child;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// When the new scope is not isolated or we inherit from `this`, and</span></div>
<div class="line">        <span class="comment">// the parent scope is destroyed, the property `$$destroyed` is inherited</span></div>
<div class="line">        <span class="comment">// prototypically. In all other cases, this property needs to be set</span></div>
<div class="line">        <span class="comment">// when the parent scope is destroyed.</span></div>
<div class="line">        <span class="comment">// The listener needs to be added after the parent is set</span></div>
<div class="line">        <span class="keywordflow">if</span> (isolate || parent != <span class="keyword">this</span>) child.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, destroyChildScope);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> child;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $watch: <span class="keyword">function</span>(watchExp, listener, objectEquality, prettyPrintExpression) {</div>
<div class="line">        var <span class="keyword">get</span> = $parse(watchExp);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">get</span>.$$watchDelegate) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">get</span>.$$watchDelegate(<span class="keyword">this</span>, listener, objectEquality, <span class="keyword">get</span>, watchExp);</div>
<div class="line">        }</div>
<div class="line">        var scope = <span class="keyword">this</span>,</div>
<div class="line">            array = scope.$$watchers,</div>
<div class="line">            watcher = {</div>
<div class="line">              fn: listener,</div>
<div class="line">              last: initWatchVal,</div>
<div class="line">              <span class="keyword">get</span>: <span class="keyword">get</span>,</div>
<div class="line">              exp: prettyPrintExpression || watchExp,</div>
<div class="line">              eq: !!objectEquality</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        lastDirtyWatch = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!isFunction(listener)) {</div>
<div class="line">          watcher.fn = noop;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!array) {</div>
<div class="line">          array = scope.$$watchers = [];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// we use unshift since we use a while loop in $digest for speed.</span></div>
<div class="line">        <span class="comment">// the while loop reads in reverse order.</span></div>
<div class="line">        array.unshift(watcher);</div>
<div class="line">        incrementWatchersCount(<span class="keyword">this</span>, 1);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatch() {</div>
<div class="line">          <span class="keywordflow">if</span> (arrayRemove(array, watcher) &gt;= 0) {</div>
<div class="line">            incrementWatchersCount(scope, -1);</div>
<div class="line">          }</div>
<div class="line">          lastDirtyWatch = null;</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $watchGroup: <span class="keyword">function</span>(watchExpressions, listener) {</div>
<div class="line">        var oldValues = <span class="keyword">new</span> Array(watchExpressions.length);</div>
<div class="line">        var newValues = <span class="keyword">new</span> Array(watchExpressions.length);</div>
<div class="line">        var deregisterFns = [];</div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        var changeReactionScheduled = <span class="keyword">false</span>;</div>
<div class="line">        var firstRun = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!watchExpressions.length) {</div>
<div class="line">          <span class="comment">// No expressions means we call the listener ASAP</span></div>
<div class="line">          var shouldCall = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keyword">self</span>.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (shouldCall) listener(newValues, newValues, <span class="keyword">self</span>);</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatchGroup() {</div>
<div class="line">            shouldCall = <span class="keyword">false</span>;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (watchExpressions.length === 1) {</div>
<div class="line">          <span class="comment">// Special case size of one</span></div>
<div class="line">          <span class="keywordflow">return</span> this.$watch(watchExpressions[0], <span class="keyword">function</span> watchGroupAction(value, oldValue, scope) {</div>
<div class="line">            newValues[0] = value;</div>
<div class="line">            oldValues[0] = oldValue;</div>
<div class="line">            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        forEach(watchExpressions, <span class="keyword">function</span>(expr, i) {</div>
<div class="line">          var unwatchFn = <span class="keyword">self</span>.$watch(expr, <span class="keyword">function</span> watchGroupSubAction(value, oldValue) {</div>
<div class="line">            newValues[i] = value;</div>
<div class="line">            oldValues[i] = oldValue;</div>
<div class="line">            <span class="keywordflow">if</span> (!changeReactionScheduled) {</div>
<div class="line">              changeReactionScheduled = <span class="keyword">true</span>;</div>
<div class="line">              <span class="keyword">self</span>.$evalAsync(watchGroupAction);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          deregisterFns.push(unwatchFn);</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> watchGroupAction() {</div>
<div class="line">          changeReactionScheduled = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (firstRun) {</div>
<div class="line">            firstRun = <span class="keyword">false</span>;</div>
<div class="line">            listener(newValues, newValues, <span class="keyword">self</span>);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            listener(newValues, oldValues, <span class="keyword">self</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatchGroup() {</div>
<div class="line">          <span class="keywordflow">while</span> (deregisterFns.length) {</div>
<div class="line">            deregisterFns.shift()();</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $watchCollection: <span class="keyword">function</span>(obj, listener) {</div>
<div class="line">        $watchCollectionInterceptor.$stateful = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        <span class="comment">// the current value, updated on each dirty-check run</span></div>
<div class="line">        var newValue;</div>
<div class="line">        <span class="comment">// a shallow copy of the newValue from the last dirty-check run,</span></div>
<div class="line">        <span class="comment">// updated to match newValue during dirty-check run</span></div>
<div class="line">        var oldValue;</div>
<div class="line">        <span class="comment">// a shallow copy of the newValue from when the last change happened</span></div>
<div class="line">        var veryOldValue;</div>
<div class="line">        <span class="comment">// only track veryOldValue if the listener is asking for it</span></div>
<div class="line">        var trackVeryOldValue = (listener.length &gt; 1);</div>
<div class="line">        var changeDetected = 0;</div>
<div class="line">        var changeDetector = $parse(obj, $watchCollectionInterceptor);</div>
<div class="line">        var internalArray = [];</div>
<div class="line">        var internalObject = {};</div>
<div class="line">        var initRun = <span class="keyword">true</span>;</div>
<div class="line">        var oldLength = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $watchCollectionInterceptor(_value) {</div>
<div class="line">          newValue = _value;</div>
<div class="line">          var newLength, key, bothNaN, newItem, oldItem;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// If the new value is undefined, then return undefined as the watch may be a one-time watch</span></div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(newValue)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!isObject(newValue)) { <span class="comment">// if primitive</span></div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== newValue) {</div>
<div class="line">              oldValue = newValue;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArrayLike(newValue)) {</div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== internalArray) {</div>
<div class="line">              <span class="comment">// we are transitioning from something which was not an array into array.</span></div>
<div class="line">              oldValue = internalArray;</div>
<div class="line">              oldLength = oldValue.length = 0;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            newLength = newValue.length;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (oldLength !== newLength) {</div>
<div class="line">              <span class="comment">// if lengths do not match we need to trigger change notification</span></div>
<div class="line">              changeDetected++;</div>
<div class="line">              oldValue.length = oldLength = newLength;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// copy the items to oldValue and look for changes.</span></div>
<div class="line">            <span class="keywordflow">for</span> (var i = 0; i &lt; newLength; i++) {</div>
<div class="line">              oldItem = oldValue[i];</div>
<div class="line">              newItem = newValue[i];</div>
<div class="line"></div>
<div class="line">              bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);</div>
<div class="line">              <span class="keywordflow">if</span> (!bothNaN &amp;&amp; (oldItem !== newItem)) {</div>
<div class="line">                changeDetected++;</div>
<div class="line">                oldValue[i] = newItem;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== internalObject) {</div>
<div class="line">              <span class="comment">// we are transitioning from something which was not an object into object.</span></div>
<div class="line">              oldValue = internalObject = {};</div>
<div class="line">              oldLength = 0;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// copy the items to oldValue and look for changes.</span></div>
<div class="line">            newLength = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (key in newValue) {</div>
<div class="line">              <span class="keywordflow">if</span> (newValue.hasOwnProperty(key)) {</div>
<div class="line">                newLength++;</div>
<div class="line">                newItem = newValue[key];</div>
<div class="line">                oldItem = oldValue[key];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (key in oldValue) {</div>
<div class="line">                  bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);</div>
<div class="line">                  <span class="keywordflow">if</span> (!bothNaN &amp;&amp; (oldItem !== newItem)) {</div>
<div class="line">                    changeDetected++;</div>
<div class="line">                    oldValue[key] = newItem;</div>
<div class="line">                  }</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  oldLength++;</div>
<div class="line">                  oldValue[key] = newItem;</div>
<div class="line">                  changeDetected++;</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (oldLength &gt; newLength) {</div>
<div class="line">              <span class="comment">// we used to have more keys, need to find them and destroy them.</span></div>
<div class="line">              changeDetected++;</div>
<div class="line">              <span class="keywordflow">for</span> (key in oldValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (!newValue.hasOwnProperty(key)) {</div>
<div class="line">                  oldLength--;</div>
<div class="line">                  <span class="keyword">delete</span> oldValue[key];</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> changeDetected;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $watchCollectionAction() {</div>
<div class="line">          <span class="keywordflow">if</span> (initRun) {</div>
<div class="line">            initRun = <span class="keyword">false</span>;</div>
<div class="line">            listener(newValue, newValue, <span class="keyword">self</span>);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            listener(newValue, veryOldValue, <span class="keyword">self</span>);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// make a copy for the next time a collection is changed</span></div>
<div class="line">          <span class="keywordflow">if</span> (trackVeryOldValue) {</div>
<div class="line">            <span class="keywordflow">if</span> (!isObject(newValue)) {</div>
<div class="line">              <span class="comment">//primitive</span></div>
<div class="line">              veryOldValue = newValue;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArrayLike(newValue)) {</div>
<div class="line">              veryOldValue = <span class="keyword">new</span> Array(newValue.length);</div>
<div class="line">              <span class="keywordflow">for</span> (var i = 0; i &lt; newValue.length; i++) {</div>
<div class="line">                veryOldValue[i] = newValue[i];</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> { <span class="comment">// if object</span></div>
<div class="line">              veryOldValue = {};</div>
<div class="line">              <span class="keywordflow">for</span> (var key in newValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (hasOwnProperty.call(newValue, key)) {</div>
<div class="line">                  veryOldValue[key] = newValue[key];</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.$watch(changeDetector, $watchCollectionAction);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $digest: <span class="keyword">function</span>() {</div>
<div class="line">        var watch, value, last,</div>
<div class="line">            watchers,</div>
<div class="line">            length,</div>
<div class="line">            dirty, ttl = TTL,</div>
<div class="line">            next, current, target = <span class="keyword">this</span>,</div>
<div class="line">            watchLog = [],</div>
<div class="line">            logIdx, logMsg, asyncTask;</div>
<div class="line"></div>
<div class="line">        beginPhase(<span class="stringliteral">&#39;$digest&#39;</span>);</div>
<div class="line">        <span class="comment">// Check for changes to browser url that happened in sync before the call to $digest</span></div>
<div class="line">        $browser.$$checkUrlChange();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== null) {</div>
<div class="line">          <span class="comment">// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span></div>
<div class="line">          <span class="comment">// cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span></div>
<div class="line">          $browser.defer.cancel(applyAsyncId);</div>
<div class="line">          flushApplyAsync();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        lastDirtyWatch = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">do</span> { <span class="comment">// &quot;while dirty&quot; loop</span></div>
<div class="line">          dirty = <span class="keyword">false</span>;</div>
<div class="line">          current = target;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">while</span> (asyncQueue.length) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              asyncTask = asyncQueue.shift();</div>
<div class="line">              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">            lastDirtyWatch = null;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          traverseScopesLoop:</div>
<div class="line">          <span class="keywordflow">do</span> { <span class="comment">// &quot;traverse the scopes&quot; loop</span></div>
<div class="line">            <span class="keywordflow">if</span> ((watchers = current.$$watchers)) {</div>
<div class="line">              <span class="comment">// process our watches</span></div>
<div class="line">              length = watchers.length;</div>
<div class="line">              <span class="keywordflow">while</span> (length--) {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                  watch = watchers[length];</div>
<div class="line">                  <span class="comment">// Most common watches are on primitives, in which case we can short</span></div>
<div class="line">                  <span class="comment">// circuit it with === operator, only when === fails do we use .equals</span></div>
<div class="line">                  <span class="keywordflow">if</span> (watch) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</div>
<div class="line">                        !(watch.eq</div>
<div class="line">                            ? equals(value, last)</div>
<div class="line">                            : (typeof value === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; typeof last === <span class="stringliteral">&#39;number&#39;</span></div>
<div class="line">                               &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) {</div>
<div class="line">                      dirty = <span class="keyword">true</span>;</div>
<div class="line">                      lastDirtyWatch = watch;</div>
<div class="line">                      watch.last = watch.eq ? copy(value, null) : value;</div>
<div class="line">                      watch.fn(value, ((last === initWatchVal) ? value : last), current);</div>
<div class="line">                      <span class="keywordflow">if</span> (ttl &lt; 5) {</div>
<div class="line">                        logIdx = 4 - ttl;</div>
<div class="line">                        <span class="keywordflow">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div>
<div class="line">                        watchLog[logIdx].push({</div>
<div class="line">                          msg: isFunction(watch.exp) ? <span class="stringliteral">&#39;fn: &#39;</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div>
<div class="line">                          newVal: value,</div>
<div class="line">                          oldVal: last</div>
<div class="line">                        });</div>
<div class="line">                      }</div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (watch === lastDirtyWatch) {</div>
<div class="line">                      <span class="comment">// If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span></div>
<div class="line">                      <span class="comment">// have already been tested.</span></div>
<div class="line">                      dirty = <span class="keyword">false</span>;</div>
<div class="line">                      <span class="keywordflow">break</span> traverseScopesLoop;</div>
<div class="line">                    }</div>
<div class="line">                  }</div>
<div class="line">                } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">                  $exceptionHandler(e);</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Insanity Warning: scope depth-first traversal</span></div>
<div class="line">            <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div>
<div class="line">            <span class="comment">// this piece should be kept in sync with the traversal in $broadcast</span></div>
<div class="line">            <span class="keywordflow">if</span> (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||</div>
<div class="line">                (current !== target &amp;&amp; current.$$nextSibling)))) {</div>
<div class="line">              <span class="keywordflow">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) {</div>
<div class="line">                current = current.$parent;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">while</span> ((current = next));</div>
<div class="line"></div>
<div class="line">          <span class="comment">// `break traverseScopesLoop;` takes us to here</span></div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {</div>
<div class="line">            clearPhase();</div>
<div class="line">            <span class="keywordflow">throw</span> $rootScopeMinErr(<span class="stringliteral">&#39;infdig&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;{0} $digest() iterations reached. Aborting!\n&#39;</span> +</div>
<div class="line">                <span class="stringliteral">&#39;Watchers fired in the last 5 iterations: {1}&#39;</span>,</div>
<div class="line">                TTL, watchLog);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">while</span> (dirty || asyncQueue.length);</div>
<div class="line"></div>
<div class="line">        clearPhase();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (postDigestQueue.length) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            postDigestQueue.shift()();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $destroy: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="comment">// We can&#39;t destroy a scope that has been already destroyed.</span></div>
<div class="line">        <span class="keywordflow">if</span> (this.$$destroyed) <span class="keywordflow">return</span>;</div>
<div class="line">        var parent = this.$parent;</div>
<div class="line"></div>
<div class="line">        this.$broadcast(<span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">        this.$$destroyed = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">this</span> === $rootScope) {</div>
<div class="line">          <span class="comment">//Remove handlers attached to window when $rootScope is removed</span></div>
<div class="line">          $browser.$$applicationDestroyed();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        incrementWatchersCount(<span class="keyword">this</span>, -this.$$watchersCount);</div>
<div class="line">        <span class="keywordflow">for</span> (var eventName in this.$$listenerCount) {</div>
<div class="line">          decrementListenerCount(<span class="keyword">this</span>, this.$$listenerCount[eventName], eventName);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// sever all the references to parent scopes (after this cleanup, the current scope should</span></div>
<div class="line">        <span class="comment">// not be retained by any of our references and should be eligible for garbage collection)</span></div>
<div class="line">        <span class="keywordflow">if</span> (parent &amp;&amp; parent.$$childHead == <span class="keyword">this</span>) parent.$$childHead = this.$$nextSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (parent &amp;&amp; parent.$$childTail == <span class="keyword">this</span>) parent.$$childTail = this.$$prevSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Disable listeners, watchers and apply/digest methods</span></div>
<div class="line">        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;</div>
<div class="line">        this.$on = this.$watch = this.$watchGroup = <span class="keyword">function</span>() { <span class="keywordflow">return</span> noop; };</div>
<div class="line">        this.$$listeners = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// All of the code below is bogus code that works around V8&#39;s memory leak via optimized code</span></div>
<div class="line">        <span class="comment">// and inline caches.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// see:</span></div>
<div class="line">        <span class="comment">// - https://code.google.com/p/v8/issues/detail?id=2073#c26</span></div>
<div class="line">        <span class="comment">// - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909</span></div>
<div class="line">        <span class="comment">// - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451</span></div>
<div class="line"></div>
<div class="line">        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =</div>
<div class="line">            this.$$childTail = this.$root = this.$$watchers = null;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $eval: <span class="keyword">function</span>(expr, locals) {</div>
<div class="line">        <span class="keywordflow">return</span> $parse(expr)(<span class="keyword">this</span>, locals);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $evalAsync: <span class="keyword">function</span>(expr, locals) {</div>
<div class="line">        <span class="comment">// if we are outside of an $digest loop and this is the first time we are scheduling async</span></div>
<div class="line">        <span class="comment">// task also schedule async auto-flush</span></div>
<div class="line">        <span class="keywordflow">if</span> (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) {</div>
<div class="line">          $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (asyncQueue.length) {</div>
<div class="line">              $rootScope.$digest();</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        asyncQueue.push({scope: <span class="keyword">this</span>, expression: expr, locals: locals});</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $$postDigest: <span class="keyword">function</span>(fn) {</div>
<div class="line">        postDigestQueue.push(fn);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $apply: <span class="keyword">function</span>(expr) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          beginPhase(<span class="stringliteral">&#39;$apply&#39;</span>);</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">return</span> this.$eval(expr);</div>
<div class="line">          } <span class="keywordflow">finally</span> {</div>
<div class="line">            clearPhase();</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        } <span class="keywordflow">finally</span> {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            $rootScope.$digest();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">            <span class="keywordflow">throw</span> e;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $applyAsync: <span class="keyword">function</span>(expr) {</div>
<div class="line">        var scope = <span class="keyword">this</span>;</div>
<div class="line">        expr &amp;&amp; applyAsyncQueue.push($applyAsyncExpression);</div>
<div class="line">        scheduleApplyAsync();</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $applyAsyncExpression() {</div>
<div class="line">          scope.$eval(expr);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $on: <span class="keyword">function</span>(name, listener) {</div>
<div class="line">        var namedListeners = this.$$listeners[name];</div>
<div class="line">        <span class="keywordflow">if</span> (!namedListeners) {</div>
<div class="line">          this.$$listeners[name] = namedListeners = [];</div>
<div class="line">        }</div>
<div class="line">        namedListeners.push(listener);</div>
<div class="line"></div>
<div class="line">        var current = <span class="keyword">this</span>;</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!current.$$listenerCount[name]) {</div>
<div class="line">            current.$$listenerCount[name] = 0;</div>
<div class="line">          }</div>
<div class="line">          current.$$listenerCount[name]++;</div>
<div class="line">        } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line"></div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          var indexOfListener = namedListeners.indexOf(listener);</div>
<div class="line">          <span class="keywordflow">if</span> (indexOfListener !== -1) {</div>
<div class="line">            namedListeners[indexOfListener] = null;</div>
<div class="line">            decrementListenerCount(<span class="keyword">self</span>, 1, name);</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $emit: <span class="keyword">function</span>(name, args) {</div>
<div class="line">        var empty = [],</div>
<div class="line">            namedListeners,</div>
<div class="line">            scope = <span class="keyword">this</span>,</div>
<div class="line">            stopPropagation = <span class="keyword">false</span>,</div>
<div class="line">            event = {</div>
<div class="line">              name: name,</div>
<div class="line">              targetScope: scope,</div>
<div class="line">              stopPropagation: <span class="keyword">function</span>() {stopPropagation = <span class="keyword">true</span>;},</div>
<div class="line">              preventDefault: <span class="keyword">function</span>() {</div>
<div class="line">                event.defaultPrevented = <span class="keyword">true</span>;</div>
<div class="line">              },</div>
<div class="line">              defaultPrevented: <span class="keyword">false</span></div>
<div class="line">            },</div>
<div class="line">            listenerArgs = concat([event], arguments, 1),</div>
<div class="line">            i, length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          namedListeners = scope.$$listeners[name] || empty;</div>
<div class="line">          event.currentScope = scope;</div>
<div class="line">          <span class="keywordflow">for</span> (i = 0, length = namedListeners.length; i &lt; length; i++) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// if listeners were deregistered, defragment the array</span></div>
<div class="line">            <span class="keywordflow">if</span> (!namedListeners[i]) {</div>
<div class="line">              namedListeners.splice(i, 1);</div>
<div class="line">              i--;</div>
<div class="line">              length--;</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              <span class="comment">//allow all listeners attached to the current scope to run</span></div>
<div class="line">              namedListeners[i].apply(null, listenerArgs);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">//if any listener on the current scope stops propagation, prevent bubbling</span></div>
<div class="line">          <span class="keywordflow">if</span> (stopPropagation) {</div>
<div class="line">            event.currentScope = null;</div>
<div class="line">            <span class="keywordflow">return</span> event;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">//traverse upwards</span></div>
<div class="line">          scope = scope.$parent;</div>
<div class="line">        } <span class="keywordflow">while</span> (scope);</div>
<div class="line"></div>
<div class="line">        event.currentScope = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> event;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $broadcast: <span class="keyword">function</span>(name, args) {</div>
<div class="line">        var target = <span class="keyword">this</span>,</div>
<div class="line">            current = target,</div>
<div class="line">            next = target,</div>
<div class="line">            event = {</div>
<div class="line">              name: name,</div>
<div class="line">              targetScope: target,</div>
<div class="line">              preventDefault: <span class="keyword">function</span>() {</div>
<div class="line">                event.defaultPrevented = <span class="keyword">true</span>;</div>
<div class="line">              },</div>
<div class="line">              defaultPrevented: <span class="keyword">false</span></div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!target.$$listenerCount[name]) <span class="keywordflow">return</span> event;</div>
<div class="line"></div>
<div class="line">        var listenerArgs = concat([event], arguments, 1),</div>
<div class="line">            listeners, i, length;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//down while you can, then up and next sibling or up and next sibling until back at root</span></div>
<div class="line">        <span class="keywordflow">while</span> ((current = next)) {</div>
<div class="line">          event.currentScope = current;</div>
<div class="line">          listeners = current.$$listeners[name] || [];</div>
<div class="line">          <span class="keywordflow">for</span> (i = 0, length = listeners.length; i &lt; length; i++) {</div>
<div class="line">            <span class="comment">// if listeners were deregistered, defragment the array</span></div>
<div class="line">            <span class="keywordflow">if</span> (!listeners[i]) {</div>
<div class="line">              listeners.splice(i, 1);</div>
<div class="line">              i--;</div>
<div class="line">              length--;</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              listeners[i].apply(null, listenerArgs);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Insanity Warning: scope depth-first traversal</span></div>
<div class="line">          <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div>
<div class="line">          <span class="comment">// this piece should be kept in sync with the traversal in $digest</span></div>
<div class="line">          <span class="comment">// (though it differs due to having the extra check for $$listenerCount)</span></div>
<div class="line">          <span class="keywordflow">if</span> (!(next = ((current.$$listenerCount[name] &amp;&amp; current.$$childHead) ||</div>
<div class="line">              (current !== target &amp;&amp; current.$$nextSibling)))) {</div>
<div class="line">            <span class="keywordflow">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) {</div>
<div class="line">              current = current.$parent;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        event.currentScope = null;</div>
<div class="line">        <span class="keywordflow">return</span> event;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var $rootScope = <span class="keyword">new</span> Scope();</div>
<div class="line"></div>
<div class="line">    <span class="comment">//The internal queues. Expose them on the $rootScope for debugging/testing purposes.</span></div>
<div class="line">    var asyncQueue = $rootScope.$$asyncQueue = [];</div>
<div class="line">    var postDigestQueue = $rootScope.$$postDigestQueue = [];</div>
<div class="line">    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> $rootScope;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> beginPhase(phase) {</div>
<div class="line">      <span class="keywordflow">if</span> ($rootScope.$$phase) {</div>
<div class="line">        <span class="keywordflow">throw</span> $rootScopeMinErr(<span class="stringliteral">&#39;inprog&#39;</span>, <span class="stringliteral">&#39;{0} already in progress&#39;</span>, $rootScope.$$phase);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $rootScope.$$phase = phase;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> clearPhase() {</div>
<div class="line">      $rootScope.$$phase = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> incrementWatchersCount(current, count) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        current.$$watchersCount += count;</div>
<div class="line">      } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> decrementListenerCount(current, count, name) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        current.$$listenerCount[name] -= count;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (current.$$listenerCount[name] === 0) {</div>
<div class="line">          <span class="keyword">delete</span> current.$$listenerCount[name];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> initWatchVal() {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> flushApplyAsync() {</div>
<div class="line">      <span class="keywordflow">while</span> (applyAsyncQueue.length) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          applyAsyncQueue.shift()();</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      applyAsyncId = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scheduleApplyAsync() {</div>
<div class="line">      <span class="keywordflow">if</span> (applyAsyncId === null) {</div>
<div class="line">        applyAsyncId = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">          $rootScope.$apply(flushApplyAsync);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$SanitizeUriProvider() {</div>
<div class="line">  var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,</div>
<div class="line">    imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;</div>
<div class="line"></div>
<div class="line">  this.aHrefSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      aHrefSanitizationWhitelist = regexp;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> aHrefSanitizationWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.imgSrcSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      imgSrcSanitizationWhitelist = regexp;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> imgSrcSanitizationWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> sanitizeUri(uri, isImage) {</div>
<div class="line">      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;</div>
<div class="line">      var normalizedVal;</div>
<div class="line">      normalizedVal = urlResolve(uri).href;</div>
<div class="line">      <span class="keywordflow">if</span> (normalizedVal !== <span class="stringliteral">&#39;&#39;</span> &amp;&amp; !normalizedVal.match(regex)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;unsafe:&#39;</span> + normalizedVal;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> uri;</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line">var $sceMinErr = minErr(<span class="stringliteral">&#39;$sce&#39;</span>);</div>
<div class="line"></div>
<div class="line">var SCE_CONTEXTS = {</div>
<div class="line">  HTML: <span class="stringliteral">&#39;html&#39;</span>,</div>
<div class="line">  CSS: <span class="stringliteral">&#39;css&#39;</span>,</div>
<div class="line">  URL: <span class="stringliteral">&#39;url&#39;</span>,</div>
<div class="line">  <span class="comment">// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a</span></div>
<div class="line">  <span class="comment">// url.  (e.g. ng-include, script src, templateUrl)</span></div>
<div class="line">  RESOURCE_URL: <span class="stringliteral">&#39;resourceUrl&#39;</span>,</div>
<div class="line">  JS: <span class="stringliteral">&#39;js&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper functions follow.</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> adjustMatcher(matcher) {</div>
<div class="line">  <span class="keywordflow">if</span> (matcher === <span class="stringliteral">&#39;self&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> matcher;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(matcher)) {</div>
<div class="line">    <span class="comment">// Strings match exactly except for 2 wildcards - &#39;*&#39; and &#39;**&#39;.</span></div>
<div class="line">    <span class="comment">// &#39;*&#39; matches any character except those from the set &#39;:/.?&amp;&#39;.</span></div>
<div class="line">    <span class="comment">// &#39;**&#39; matches any character (like .* in a RegExp).</span></div>
<div class="line">    <span class="comment">// More than 2 *&#39;s raises an error as it&#39;s ill defined.</span></div>
<div class="line">    <span class="keywordflow">if</span> (matcher.indexOf(<span class="stringliteral">&#39;***&#39;</span>) &gt; -1) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;iwcard&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Illegal sequence *** in string matcher.  String: {0}&#39;</span>, matcher);</div>
<div class="line">    }</div>
<div class="line">    matcher = escapeForRegexp(matcher).</div>
<div class="line">                  replace(<span class="stringliteral">&#39;\\*\\*&#39;</span>, <span class="stringliteral">&#39;.*&#39;</span>).</div>
<div class="line">                  replace(<span class="stringliteral">&#39;\\*&#39;</span>, <span class="stringliteral">&#39;[^:/.?&amp;;]*&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RegExp(<span class="charliteral">&#39;^&#39;</span> + matcher + <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(matcher)) {</div>
<div class="line">    <span class="comment">// The only other type of matcher allowed is a Regexp.</span></div>
<div class="line">    <span class="comment">// Match entire URL / disallow partial matches.</span></div>
<div class="line">    <span class="comment">// Flags are reset (i.e. no global, ignoreCase or multiline)</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RegExp(<span class="charliteral">&#39;^&#39;</span> + matcher.source + <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;imatcher&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Matchers may only be &quot;self&quot;, string patterns or RegExp objects&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> adjustMatchers(matchers) {</div>
<div class="line">  var adjustedMatchers = [];</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(matchers)) {</div>
<div class="line">    forEach(matchers, <span class="keyword">function</span>(matcher) {</div>
<div class="line">      adjustedMatchers.push(adjustMatcher(matcher));</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> adjustedMatchers;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SceDelegateProvider() {</div>
<div class="line">  this.SCE_CONTEXTS = SCE_CONTEXTS;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Resource URLs can also be trusted by policy.</span></div>
<div class="line">  var resourceUrlWhitelist = [<span class="stringliteral">&#39;self&#39;</span>],</div>
<div class="line">      resourceUrlBlacklist = [];</div>
<div class="line"></div>
<div class="line">  this.resourceUrlWhitelist = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      resourceUrlWhitelist = adjustMatchers(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> resourceUrlWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.resourceUrlBlacklist = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      resourceUrlBlacklist = adjustMatchers(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> resourceUrlBlacklist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line"></div>
<div class="line">    var htmlSanitizer = <span class="keyword">function</span> htmlSanitizer(html) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;unsafe&#39;</span>, <span class="stringliteral">&#39;Attempting to use an unsafe value in a safe context.&#39;</span>);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ($injector.has(<span class="stringliteral">&#39;$sanitize&#39;</span>)) {</div>
<div class="line">      htmlSanitizer = $injector.get(<span class="stringliteral">&#39;$sanitize&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> matchUrl(matcher, parsedUrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (matcher === <span class="stringliteral">&#39;self&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> urlIsSameOrigin(parsedUrl);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// definitely a regex.  See adjustMatchers()</span></div>
<div class="line">        <span class="keywordflow">return</span> !!matcher.exec(parsedUrl.href);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> isResourceUrlAllowedByPolicy(url) {</div>
<div class="line">      var parsedUrl = urlResolve(url.toString());</div>
<div class="line">      var i, n, allowed = <span class="keyword">false</span>;</div>
<div class="line">      <span class="comment">// Ensure that at least one item from the whitelist allows this url.</span></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0, n = resourceUrlWhitelist.length; i &lt; n; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {</div>
<div class="line">          allowed = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (allowed) {</div>
<div class="line">        <span class="comment">// Ensure that no item from the blacklist blocked this url.</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, n = resourceUrlBlacklist.length; i &lt; n; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {</div>
<div class="line">            allowed = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> allowed;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> generateHolderType(Base) {</div>
<div class="line">      var holderType = <span class="keyword">function</span> TrustedValueHolderType(trustedValue) {</div>
<div class="line">        this.$$unwrapTrustedValue = <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> trustedValue;</div>
<div class="line">        };</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">if</span> (Base) {</div>
<div class="line">        holderType.prototype = <span class="keyword">new</span> Base();</div>
<div class="line">      }</div>
<div class="line">      holderType.prototype.valueOf = <span class="keyword">function</span> sceValueOf() {</div>
<div class="line">        <span class="keywordflow">return</span> this.$$unwrapTrustedValue();</div>
<div class="line">      };</div>
<div class="line">      holderType.prototype.toString = <span class="keyword">function</span> sceToString() {</div>
<div class="line">        <span class="keywordflow">return</span> this.$$unwrapTrustedValue().toString();</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">return</span> holderType;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var trustedValueHolderBase = generateHolderType(),</div>
<div class="line">        byType = {};</div>
<div class="line"></div>
<div class="line">    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> trustAs(type, trustedValue) {</div>
<div class="line">      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);</div>
<div class="line">      <span class="keywordflow">if</span> (!Constructor) {</div>
<div class="line">        <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;icontext&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Attempted to trust a value in invalid context. Context: {0}; Value: {1}&#39;</span>,</div>
<div class="line">            type, trustedValue);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (trustedValue === null || trustedValue === undefined || trustedValue === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> trustedValue;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting</span></div>
<div class="line">      <span class="comment">// mutable objects, we ensure here that the value passed in is actually a string.</span></div>
<div class="line">      <span class="keywordflow">if</span> (typeof trustedValue !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;itype&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Attempted to trust a non-string value in a content requiring a string: Context: {0}&#39;</span>,</div>
<div class="line">            type);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Constructor(trustedValue);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> valueOf(maybeTrusted) {</div>
<div class="line">      <span class="keywordflow">if</span> (maybeTrusted instanceof trustedValueHolderBase) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted.$$unwrapTrustedValue();</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getTrusted(type, maybeTrusted) {</div>
<div class="line">      <span class="keywordflow">if</span> (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">      }</div>
<div class="line">      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);</div>
<div class="line">      <span class="keywordflow">if</span> (constructor &amp;&amp; maybeTrusted instanceof constructor) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted.$$unwrapTrustedValue();</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// If we get here, then we may only take one of two actions.</span></div>
<div class="line">      <span class="comment">// 1. sanitize the value for the requested type, or</span></div>
<div class="line">      <span class="comment">// 2. throw an exception.</span></div>
<div class="line">      <span class="keywordflow">if</span> (type === SCE_CONTEXTS.RESOURCE_URL) {</div>
<div class="line">        <span class="keywordflow">if</span> (isResourceUrlAllowedByPolicy(maybeTrusted)) {</div>
<div class="line">          <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;insecurl&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&#39;Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}&#39;</span>,</div>
<div class="line">              maybeTrusted.toString());</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === SCE_CONTEXTS.HTML) {</div>
<div class="line">        <span class="keywordflow">return</span> htmlSanitizer(maybeTrusted);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;unsafe&#39;</span>, <span class="stringliteral">&#39;Attempting to use an unsafe value in a safe context.&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> { trustAs: trustAs,</div>
<div class="line">             getTrusted: getTrusted,</div>
<div class="line">             valueOf: valueOf };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint maxlen: false*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint maxlen: 100 */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SceProvider() {</div>
<div class="line">  var enabled = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">  this.enabled = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      enabled = !!value;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> enabled;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Design notes on the default implementation for SCE.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * The API contract for the SCE delegate</span></div>
<div class="line"><span class="comment">   * -------------------------------------</span></div>
<div class="line"><span class="comment">   * The SCE delegate object must provide the following 3 methods:</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - trustAs(contextEnum, value)</span></div>
<div class="line"><span class="comment">   *     This method is used to tell the SCE service that the provided value is OK to use in the</span></div>
<div class="line"><span class="comment">   *     contexts specified by contextEnum.  It must return an object that will be accepted by</span></div>
<div class="line"><span class="comment">   *     getTrusted() for a compatible contextEnum and return this value.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - valueOf(value)</span></div>
<div class="line"><span class="comment">   *     For values that were not produced by trustAs(), return them as is.  For values that were</span></div>
<div class="line"><span class="comment">   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if</span></div>
<div class="line"><span class="comment">   *     trustAs is wrapping the given values into some type, this operation unwraps it when given</span></div>
<div class="line"><span class="comment">   *     such a value.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - getTrusted(contextEnum, value)</span></div>
<div class="line"><span class="comment">   *     This function should return the a value that is safe to use in the context specified by</span></div>
<div class="line"><span class="comment">   *     contextEnum or throw and exception otherwise.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be</span></div>
<div class="line"><span class="comment">   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For</span></div>
<div class="line"><span class="comment">   * instance, an implementation could maintain a registry of all trusted objects by context.  In</span></div>
<div class="line"><span class="comment">   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would</span></div>
<div class="line"><span class="comment">   * return the same object passed in if it was found in the registry under a compatible context or</span></div>
<div class="line"><span class="comment">   * throw an exception otherwise.  An implementation might only wrap values some of the time based</span></div>
<div class="line"><span class="comment">   * on some criteria.  getTrusted() might return a value and not throw an exception for special</span></div>
<div class="line"><span class="comment">   * constants or objects even if not wrapped.  All such implementations fulfill this contract.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * A note on the inheritance model for SCE contexts</span></div>
<div class="line"><span class="comment">   * ------------------------------------------------</span></div>
<div class="line"><span class="comment">   * I&#39;ve used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This</span></div>
<div class="line"><span class="comment">   * is purely an implementation details.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * The contract is simply this:</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)</span></div>
<div class="line"><span class="comment">   *     will also succeed.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * Inheritance happens to capture this in a natural way.  In some future, we</span></div>
<div class="line"><span class="comment">   * may not use inheritance anymore.  That is OK because no code outside of</span></div>
<div class="line"><span class="comment">   * sce.js and sceSpecs.js would need to be aware of this detail.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$sceDelegate&#39;</span>, <span class="keyword">function</span>(</div>
<div class="line">                $parse,   $sceDelegate) {</div>
<div class="line">    <span class="comment">// Prereq: Ensure that we&#39;re not running in IE&lt;11 quirks mode.  In that mode, IE &lt; 11 allow</span></div>
<div class="line">    <span class="comment">// the &quot;expression(javascript expression)&quot; syntax which is insecure.</span></div>
<div class="line">    <span class="keywordflow">if</span> (enabled &amp;&amp; msie &lt; 8) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;iequirks&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Strict Contextual Escaping does not support Internet Explorer version &lt; 11 in quirks &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;mode.  You can fix this by adding the text &lt;!doctype html&gt; to the top of your HTML &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;document.  See http://docs.angularjs.org/api/ng.$sce for more information.&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var sce = shallowCopy(SCE_CONTEXTS);</div>
<div class="line"></div>
<div class="line">    sce.isEnabled = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> enabled;</div>
<div class="line">    };</div>
<div class="line">    sce.trustAs = $sceDelegate.trustAs;</div>
<div class="line">    sce.getTrusted = $sceDelegate.getTrusted;</div>
<div class="line">    sce.valueOf = $sceDelegate.valueOf;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!enabled) {</div>
<div class="line">      sce.trustAs = sce.getTrusted = <span class="keyword">function</span>(type, value) { <span class="keywordflow">return</span> value; };</div>
<div class="line">      sce.valueOf = identity;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    sce.parseAs = <span class="keyword">function</span> sceParseAs(type, expr) {</div>
<div class="line">      var parsed = $parse(expr);</div>
<div class="line">      <span class="keywordflow">if</span> (parsed.literal &amp;&amp; parsed.constant) {</div>
<div class="line">        <span class="keywordflow">return</span> parsed;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> $parse(expr, <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> sce.getTrusted(type, value);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shorthand delegations.</span></div>
<div class="line">    var parse = sce.parseAs,</div>
<div class="line">        getTrusted = sce.getTrusted,</div>
<div class="line">        trustAs = sce.trustAs;</div>
<div class="line"></div>
<div class="line">    forEach(SCE_CONTEXTS, <span class="keyword">function</span>(enumValue, name) {</div>
<div class="line">      var lName = lowercase(name);</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;parse_as_&quot;</span> + lName)] = <span class="keyword">function</span>(expr) {</div>
<div class="line">        <span class="keywordflow">return</span> parse(enumValue, expr);</div>
<div class="line">      };</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;get_trusted_&quot;</span> + lName)] = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> getTrusted(enumValue, value);</div>
<div class="line">      };</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;trust_as_&quot;</span> + lName)] = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> trustAs(enumValue, value);</div>
<div class="line">      };</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> sce;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SnifferProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>, <span class="keyword">function</span>($window, $document) {</div>
<div class="line">    var eventSupport = {},</div>
<div class="line">        android =</div>
<div class="line">          toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),</div>
<div class="line">        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),</div>
<div class="line">        document = $document[0] || {},</div>
<div class="line">        vendorPrefix,</div>
<div class="line">        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,</div>
<div class="line">        bodyStyle = document.body &amp;&amp; document.body.style,</div>
<div class="line">        transitions = <span class="keyword">false</span>,</div>
<div class="line">        animations = <span class="keyword">false</span>,</div>
<div class="line">        match;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bodyStyle) {</div>
<div class="line">      <span class="keywordflow">for</span> (var prop in bodyStyle) {</div>
<div class="line">        <span class="keywordflow">if</span> (match = vendorRegex.exec(prop)) {</div>
<div class="line">          vendorPrefix = match[0];</div>
<div class="line">          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!vendorPrefix) {</div>
<div class="line">        vendorPrefix = (<span class="stringliteral">&#39;WebkitOpacity&#39;</span> in bodyStyle) &amp;&amp; <span class="stringliteral">&#39;webkit&#39;</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      transitions = !!((<span class="stringliteral">&#39;transition&#39;</span> in bodyStyle) || (vendorPrefix + <span class="stringliteral">&#39;Transition&#39;</span> in bodyStyle));</div>
<div class="line">      animations  = !!((<span class="stringliteral">&#39;animation&#39;</span> in bodyStyle) || (vendorPrefix + <span class="stringliteral">&#39;Animation&#39;</span> in bodyStyle));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (android &amp;&amp; (!transitions ||  !animations)) {</div>
<div class="line">        transitions = isString(bodyStyle.webkitTransition);</div>
<div class="line">        animations = isString(bodyStyle.webkitAnimation);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      <span class="comment">// Android has history.pushState, but it does not update location correctly</span></div>
<div class="line">      <span class="comment">// so let&#39;s not use the history API at all.</span></div>
<div class="line">      <span class="comment">// http://code.google.com/p/android/issues/detail?id=17471</span></div>
<div class="line">      <span class="comment">// https://github.com/angular/angular.js/issues/904</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// older webkit browser (533.9) on Boxee box has exactly the same problem as Android has</span></div>
<div class="line">      <span class="comment">// so let&#39;s not use the history API also</span></div>
<div class="line">      <span class="comment">// We are purposefully using `!(android &lt; 4)` to cover the case when `android` is undefined</span></div>
<div class="line">      <span class="comment">// jshint -W018</span></div>
<div class="line">      history: !!($window.history &amp;&amp; $window.history.pushState &amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),</div>
<div class="line">      <span class="comment">// jshint +W018</span></div>
<div class="line">      hasEvent: <span class="keyword">function</span>(event) {</div>
<div class="line">        <span class="comment">// IE9 implements &#39;input&#39; event it&#39;s so fubared that we rather pretend that it doesn&#39;t have</span></div>
<div class="line">        <span class="comment">// it. In particular the event is not fired when backspace or delete key are pressed or</span></div>
<div class="line">        <span class="comment">// when cut operation is performed.</span></div>
<div class="line">        <span class="comment">// IE10+ implements &#39;input&#39; event but it erroneously fires under various situations,</span></div>
<div class="line">        <span class="comment">// e.g. when placeholder changes, or a form is focused.</span></div>
<div class="line">        <span class="keywordflow">if</span> (event === <span class="stringliteral">&#39;input&#39;</span> &amp;&amp; msie &lt;= 11) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(eventSupport[event])) {</div>
<div class="line">          var divElm = document.createElement(<span class="stringliteral">&#39;div&#39;</span>);</div>
<div class="line">          eventSupport[event] = <span class="stringliteral">&#39;on&#39;</span> + event in divElm;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> eventSupport[event];</div>
<div class="line">      },</div>
<div class="line">      csp: csp(),</div>
<div class="line">      vendorPrefix: vendorPrefix,</div>
<div class="line">      transitions: transitions,</div>
<div class="line">      animations: animations,</div>
<div class="line">      android: android</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $compileMinErr = minErr(<span class="stringliteral">&#39;$compile&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TemplateRequestProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$templateCache&#39;</span>, <span class="stringliteral">&#39;$http&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$sce&#39;</span>, <span class="keyword">function</span>($templateCache, $http, $q, $sce) {</div>
<div class="line">    <span class="keyword">function</span> handleRequestFn(tpl, ignoreRequestError) {</div>
<div class="line">      handleRequestFn.totalPendingRequests++;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We consider the template cache holds only trusted templates, so</span></div>
<div class="line">      <span class="comment">// there&#39;s no need to go through whitelisting again for keys that already</span></div>
<div class="line">      <span class="comment">// are included in there. This also makes Angular accept any script</span></div>
<div class="line">      <span class="comment">// directive, no matter its name. However, we still need to unwrap trusted</span></div>
<div class="line">      <span class="comment">// types.</span></div>
<div class="line">      <span class="keywordflow">if</span> (!isString(tpl) || !$templateCache.get(tpl)) {</div>
<div class="line">        tpl = $sce.getTrustedResourceUrl(tpl);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var transformResponse = $http.defaults &amp;&amp; $http.defaults.transformResponse;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(transformResponse)) {</div>
<div class="line">        transformResponse = transformResponse.filter(<span class="keyword">function</span>(transformer) {</div>
<div class="line">          <span class="keywordflow">return</span> transformer !== defaultHttpResponseTransform;</div>
<div class="line">        });</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformResponse === defaultHttpResponseTransform) {</div>
<div class="line">        transformResponse = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var httpOptions = {</div>
<div class="line">        cache: $templateCache,</div>
<div class="line">        transformResponse: transformResponse</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> $http.get(tpl, httpOptions)</div>
<div class="line">        [<span class="stringliteral">&#39;finally&#39;</span>](<span class="keyword">function</span>() {</div>
<div class="line">          handleRequestFn.totalPendingRequests--;</div>
<div class="line">        })</div>
<div class="line">        .then(<span class="keyword">function</span>(response) {</div>
<div class="line">          $templateCache.put(tpl, response.data);</div>
<div class="line">          <span class="keywordflow">return</span> response.data;</div>
<div class="line">        }, handleError);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> handleError(resp) {</div>
<div class="line">        <span class="keywordflow">if</span> (!ignoreRequestError) {</div>
<div class="line">          <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tpload&#39;</span>, <span class="stringliteral">&#39;Failed to load template: {0} (HTTP status: {1} {2})&#39;</span>,</div>
<div class="line">            tpl, resp.status, resp.statusText);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> $q.reject(resp);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    handleRequestFn.totalPendingRequests = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> handleRequestFn;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$TestabilityProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$location&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($rootScope,   $browser,   $location) {</div>
<div class="line"></div>
<div class="line">    var testability = {};</div>
<div class="line"></div>
<div class="line">    testability.findBindings = <span class="keyword">function</span>(element, expression, opt_exactMatch) {</div>
<div class="line">      var bindings = element.getElementsByClassName(<span class="stringliteral">&#39;ng-binding&#39;</span>);</div>
<div class="line">      var matches = [];</div>
<div class="line">      forEach(bindings, <span class="keyword">function</span>(binding) {</div>
<div class="line">        var dataBinding = angular.element(binding).data(<span class="stringliteral">&#39;$binding&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (dataBinding) {</div>
<div class="line">          forEach(dataBinding, <span class="keyword">function</span>(bindingName) {</div>
<div class="line">            <span class="keywordflow">if</span> (opt_exactMatch) {</div>
<div class="line">              var matcher = <span class="keyword">new</span> RegExp(<span class="stringliteral">&#39;(^|\\s)&#39;</span> + escapeForRegexp(expression) + <span class="stringliteral">&#39;(\\s|\\||$)&#39;</span>);</div>
<div class="line">              <span class="keywordflow">if</span> (matcher.test(bindingName)) {</div>
<div class="line">                matches.push(binding);</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="keywordflow">if</span> (bindingName.indexOf(expression) != -1) {</div>
<div class="line">                matches.push(binding);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> matches;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.findModels = <span class="keyword">function</span>(element, expression, opt_exactMatch) {</div>
<div class="line">      var prefixes = [<span class="stringliteral">&#39;ng-&#39;</span>, <span class="stringliteral">&#39;data-ng-&#39;</span>, <span class="stringliteral">&#39;ng\\:&#39;</span>];</div>
<div class="line">      <span class="keywordflow">for</span> (var p = 0; p &lt; prefixes.length; ++p) {</div>
<div class="line">        var attributeEquals = opt_exactMatch ? <span class="charliteral">&#39;=&#39;</span> : <span class="stringliteral">&#39;*=&#39;</span>;</div>
<div class="line">        var selector = <span class="charliteral">&#39;[&#39;</span> + prefixes[p] + <span class="stringliteral">&#39;model&#39;</span> + attributeEquals + <span class="charliteral">&#39;&quot;&#39;</span> + expression + <span class="stringliteral">&#39;&quot;]&#39;</span>;</div>
<div class="line">        var elements = element.querySelectorAll(selector);</div>
<div class="line">        <span class="keywordflow">if</span> (elements.length) {</div>
<div class="line">          <span class="keywordflow">return</span> elements;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.getLocation = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> $location.url();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.setLocation = <span class="keyword">function</span>(url) {</div>
<div class="line">      <span class="keywordflow">if</span> (url !== $location.url()) {</div>
<div class="line">        $location.url(url);</div>
<div class="line">        $rootScope.$digest();</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.whenStable = <span class="keyword">function</span>(callback) {</div>
<div class="line">      $browser.notifyWhenNoOutstandingRequests(callback);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> testability;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TimeoutProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$$q&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) {</div>
<div class="line"></div>
<div class="line">    var deferreds = {};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> timeout(fn, delay, invokeApply) {</div>
<div class="line">      <span class="keywordflow">if</span> (!isFunction(fn)) {</div>
<div class="line">        invokeApply = delay;</div>
<div class="line">        delay = fn;</div>
<div class="line">        fn = noop;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var args = sliceArgs(arguments, 3),</div>
<div class="line">          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),</div>
<div class="line">          deferred = (skipApply ? $$q : $q).defer(),</div>
<div class="line">          promise = deferred.promise,</div>
<div class="line">          timeoutId;</div>
<div class="line"></div>
<div class="line">      timeoutId = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          deferred.resolve(fn.apply(null, args));</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          deferred.reject(e);</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">finally</span> {</div>
<div class="line">          <span class="keyword">delete</span> deferreds[promise.$$timeoutId];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!skipApply) $rootScope.$apply();</div>
<div class="line">      }, delay);</div>
<div class="line"></div>
<div class="line">      promise.$$timeoutId = timeoutId;</div>
<div class="line">      deferreds[timeoutId] = deferred;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> promise;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    timeout.cancel = <span class="keyword">function</span>(promise) {</div>
<div class="line">      <span class="keywordflow">if</span> (promise &amp;&amp; promise.$$timeoutId in deferreds) {</div>
<div class="line">        deferreds[promise.$$timeoutId].reject(<span class="stringliteral">&#39;canceled&#39;</span>);</div>
<div class="line">        <span class="keyword">delete</span> deferreds[promise.$$timeoutId];</div>
<div class="line">        <span class="keywordflow">return</span> $browser.defer.cancel(promise.$$timeoutId);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> timeout;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// NOTE:  The usage of window and document instead of $window and $document here is</span></div>
<div class="line"><span class="comment">// deliberate.  This service depends on the specific behavior of anchor nodes created by the</span></div>
<div class="line"><span class="comment">// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and</span></div>
<div class="line"><span class="comment">// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it</span></div>
<div class="line"><span class="comment">// doesn&#39;t know about mocked locations and resolves URLs to the real document - which is</span></div>
<div class="line"><span class="comment">// exactly the behavior needed here.  There is little value is mocking these out for this</span></div>
<div class="line"><span class="comment">// service.</span></div>
<div class="line">var urlParsingNode = document.createElement(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">var originUrl = urlResolve(window.location.href);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlResolve(url) {</div>
<div class="line">  var href = url;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (msie) {</div>
<div class="line">    <span class="comment">// Normalize before parse.  Refer Implementation Notes on why this is</span></div>
<div class="line">    <span class="comment">// done in two steps on IE.</span></div>
<div class="line">    urlParsingNode.setAttribute(<span class="stringliteral">&quot;href&quot;</span>, href);</div>
<div class="line">    href = urlParsingNode.href;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  urlParsingNode.setAttribute(<span class="stringliteral">&#39;href&#39;</span>, href);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils</span></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    href: urlParsingNode.href,</div>
<div class="line">    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    host: urlParsingNode.host,</div>
<div class="line">    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    hostname: urlParsingNode.hostname,</div>
<div class="line">    port: urlParsingNode.port,</div>
<div class="line">    pathname: (urlParsingNode.pathname.charAt(0) === <span class="charliteral">&#39;/&#39;</span>)</div>
<div class="line">      ? urlParsingNode.pathname</div>
<div class="line">      : <span class="charliteral">&#39;/&#39;</span> + urlParsingNode.pathname</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlIsSameOrigin(requestUrl) {</div>
<div class="line">  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;</div>
<div class="line">  <span class="keywordflow">return</span> (parsed.protocol === originUrl.protocol &amp;&amp;</div>
<div class="line">          parsed.host === originUrl.host);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $WindowProvider() {</div>
<div class="line">  this.$get = valueFn(window);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$CookieReader($document) {</div>
<div class="line">  var rawDocument = $document[0] || {};</div>
<div class="line">  var lastCookies = {};</div>
<div class="line">  var lastCookieString = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> safeDecodeURIComponent(str) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">return</span> decodeURIComponent(str);</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> str;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    var cookieArray, cookie, i, index, name;</div>
<div class="line">    var currentCookieString = rawDocument.cookie || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (currentCookieString !== lastCookieString) {</div>
<div class="line">      lastCookieString = currentCookieString;</div>
<div class="line">      cookieArray = lastCookieString.split(<span class="stringliteral">&#39;; &#39;</span>);</div>
<div class="line">      lastCookies = {};</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; cookieArray.length; i++) {</div>
<div class="line">        cookie = cookieArray[i];</div>
<div class="line">        index = cookie.indexOf(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (index &gt; 0) { <span class="comment">//ignore nameless cookies</span></div>
<div class="line">          name = safeDecodeURIComponent(cookie.substring(0, index));</div>
<div class="line">          <span class="comment">// the first value that is seen for a cookie is the most</span></div>
<div class="line">          <span class="comment">// specific one.  values for the same cookie name that</span></div>
<div class="line">          <span class="comment">// follow are for less specific paths.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lastCookies[name] === undefined) {</div>
<div class="line">            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> lastCookies;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">$$CookieReader.$inject = [<span class="stringliteral">&#39;$document&#39;</span>];</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$CookieReaderProvider() {</div>
<div class="line">  this.$get = $$CookieReader;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global currencyFilter: true,</span></div>
<div class="line"><span class="comment"> dateFilter: true,</span></div>
<div class="line"><span class="comment"> filterFilter: true,</span></div>
<div class="line"><span class="comment"> jsonFilter: true,</span></div>
<div class="line"><span class="comment"> limitToFilter: true,</span></div>
<div class="line"><span class="comment"> lowercaseFilter: true,</span></div>
<div class="line"><span class="comment"> numberFilter: true,</span></div>
<div class="line"><span class="comment"> orderByFilter: true,</span></div>
<div class="line"><span class="comment"> uppercaseFilter: true,</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line">$FilterProvider.$inject = [<span class="stringliteral">&#39;$provide&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> $FilterProvider($provide) {</div>
<div class="line">  var suffix = <span class="stringliteral">&#39;Filter&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> <span class="keyword">register</span>(name, factory) {</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(name)) {</div>
<div class="line">      var filters = {};</div>
<div class="line">      forEach(name, <span class="keyword">function</span>(filter, key) {</div>
<div class="line">        filters[key] = <span class="keyword">register</span>(key, filter);</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> filters;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $provide.factory(name + suffix, factory);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">register</span>;</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(name) {</div>
<div class="line">      <span class="keywordflow">return</span> $injector.get(name + suffix);</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* global</span></div>
<div class="line"><span class="comment">    currencyFilter: false,</span></div>
<div class="line"><span class="comment">    dateFilter: false,</span></div>
<div class="line"><span class="comment">    filterFilter: false,</span></div>
<div class="line"><span class="comment">    jsonFilter: false,</span></div>
<div class="line"><span class="comment">    limitToFilter: false,</span></div>
<div class="line"><span class="comment">    lowercaseFilter: false,</span></div>
<div class="line"><span class="comment">    numberFilter: false,</span></div>
<div class="line"><span class="comment">    orderByFilter: false,</span></div>
<div class="line"><span class="comment">    uppercaseFilter: false,</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line"></div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;currency&#39;</span>, currencyFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;date&#39;</span>, dateFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;filter&#39;</span>, filterFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;json&#39;</span>, jsonFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;limitTo&#39;</span>, limitToFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;lowercase&#39;</span>, lowercaseFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;number&#39;</span>, numberFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;orderBy&#39;</span>, orderByFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;uppercase&#39;</span>, uppercaseFilter);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> filterFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(array, expression, comparator) {</div>
<div class="line">    <span class="keywordflow">if</span> (!isArrayLike(array)) {</div>
<div class="line">      <span class="keywordflow">if</span> (array == null) {</div>
<div class="line">        <span class="keywordflow">return</span> array;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;filter&#39;</span>)(<span class="stringliteral">&#39;notarray&#39;</span>, <span class="stringliteral">&#39;Expected array but received: {0}&#39;</span>, array);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var expressionType = getTypeForFilter(expression);</div>
<div class="line">    var predicateFn;</div>
<div class="line">    var matchAgainstAnyProp;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (expressionType) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">        predicateFn = expression;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;boolean&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;null&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;number&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">        matchAgainstAnyProp = <span class="keyword">true</span>;</div>
<div class="line">        <span class="comment">//jshint -W086</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;object&#39;</span>:</div>
<div class="line">        <span class="comment">//jshint +W086</span></div>
<div class="line">        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> array;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> Array.prototype.filter.call(array, predicateFn);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper functions for `filterFilter`</span></div>
<div class="line"><span class="keyword">function</span> createPredicateFn(expression, comparator, matchAgainstAnyProp) {</div>
<div class="line">  var shouldMatchPrimitives = isObject(expression) &amp;&amp; (<span class="charliteral">&#39;$&#39;</span> in expression);</div>
<div class="line">  var predicateFn;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (comparator === <span class="keyword">true</span>) {</div>
<div class="line">    comparator = equals;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isFunction(comparator)) {</div>
<div class="line">    comparator = <span class="keyword">function</span>(actual, expected) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(actual)) {</div>
<div class="line">        <span class="comment">// No substring matching against `undefined`</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> ((actual === null) || (expected === null)) {</div>
<div class="line">        <span class="comment">// No substring matching against `null`; only match against `null`</span></div>
<div class="line">        <span class="keywordflow">return</span> actual === expected;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(expected) || (isObject(actual) &amp;&amp; !hasCustomToString(actual))) {</div>
<div class="line">        <span class="comment">// Should not compare primitives against objects, unless they have custom `toString` method</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      actual = lowercase(<span class="stringliteral">&#39;&#39;</span> + actual);</div>
<div class="line">      expected = lowercase(<span class="stringliteral">&#39;&#39;</span> + expected);</div>
<div class="line">      <span class="keywordflow">return</span> actual.indexOf(expected) !== -1;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  predicateFn = <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">if</span> (shouldMatchPrimitives &amp;&amp; !isObject(item)) {</div>
<div class="line">      <span class="keywordflow">return</span> deepCompare(item, expression.$, comparator, <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> deepCompare(item, expression, comparator, matchAgainstAnyProp);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> predicateFn;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {</div>
<div class="line">  var actualType = getTypeForFilter(actual);</div>
<div class="line">  var expectedType = getTypeForFilter(expected);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((expectedType === <span class="stringliteral">&#39;string&#39;</span>) &amp;&amp; (expected.charAt(0) === <span class="charliteral">&#39;!&#39;</span>)) {</div>
<div class="line">    <span class="keywordflow">return</span> !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(actual)) {</div>
<div class="line">    <span class="comment">// In case `actual` is an array, consider it a match</span></div>
<div class="line">    <span class="comment">// if ANY of it&#39;s items matches `expected`</span></div>
<div class="line">    <span class="keywordflow">return</span> actual.some(<span class="keyword">function</span>(item) {</div>
<div class="line">      <span class="keywordflow">return</span> deepCompare(item, expected, comparator, matchAgainstAnyProp);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">switch</span> (actualType) {</div>
<div class="line">    <span class="keywordflow">case</span> <span class="stringliteral">&#39;object&#39;</span>:</div>
<div class="line">      var key;</div>
<div class="line">      <span class="keywordflow">if</span> (matchAgainstAnyProp) {</div>
<div class="line">        <span class="keywordflow">for</span> (key in actual) {</div>
<div class="line">          <span class="keywordflow">if</span> ((key.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) &amp;&amp; deepCompare(actual[key], expected, comparator, <span class="keyword">true</span>)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dontMatchWholeObject ? <span class="keyword">false</span> : deepCompare(actual, expected, comparator, <span class="keyword">false</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (expectedType === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">for</span> (key in expected) {</div>
<div class="line">          var expectedVal = expected[key];</div>
<div class="line">          <span class="keywordflow">if</span> (isFunction(expectedVal) || isUndefined(expectedVal)) {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          var matchAnyProperty = key === <span class="charliteral">&#39;$&#39;</span>;</div>
<div class="line">          var actualVal = matchAnyProperty ? actual : actual[key];</div>
<div class="line">          <span class="keywordflow">if</span> (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> comparator(actual, expected);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">      <span class="keywordflow">return</span> comparator(actual, expected);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Used for easily differentiating between `null` and actual `object`</span></div>
<div class="line"><span class="keyword">function</span> getTypeForFilter(val) {</div>
<div class="line">  <span class="keywordflow">return</span> (val === null) ? <span class="stringliteral">&#39;null&#39;</span> : typeof val;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">currencyFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> currencyFilter($locale) {</div>
<div class="line">  var formats = $locale.NUMBER_FORMATS;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(amount, currencySymbol, fractionSize) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(currencySymbol)) {</div>
<div class="line">      currencySymbol = formats.CURRENCY_SYM;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(fractionSize)) {</div>
<div class="line">      fractionSize = formats.PATTERNS[1].maxFrac;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if null or undefined pass it through</span></div>
<div class="line">    <span class="keywordflow">return</span> (amount == null)</div>
<div class="line">        ? amount</div>
<div class="line">        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).</div>
<div class="line">            replace(/\u00A4/g, currencySymbol);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">numberFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> numberFilter($locale) {</div>
<div class="line">  var formats = $locale.NUMBER_FORMATS;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(number, fractionSize) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if null or undefined pass it through</span></div>
<div class="line">    <span class="keywordflow">return</span> (number == null)</div>
<div class="line">        ? number</div>
<div class="line">        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,</div>
<div class="line">                       fractionSize);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var DECIMAL_SEP = <span class="charliteral">&#39;.&#39;</span>;</div>
<div class="line"><span class="keyword">function</span> formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {</div>
<div class="line">  <span class="keywordflow">if</span> (isObject(number)) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  var isNegative = number &lt; 0;</div>
<div class="line">  number = Math.abs(number);</div>
<div class="line"></div>
<div class="line">  var isInfinity = number === Infinity;</div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; !isFinite(number)) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  var numStr = number + <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      formatedText = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      hasExponent = <span class="keyword">false</span>,</div>
<div class="line">      parts = [];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isInfinity) formatedText = <span class="stringliteral">&#39;\u221e&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; numStr.indexOf(<span class="charliteral">&#39;e&#39;</span>) !== -1) {</div>
<div class="line">    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);</div>
<div class="line">    <span class="keywordflow">if</span> (match &amp;&amp; match[2] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; match[3] &gt; fractionSize + 1) {</div>
<div class="line">      number = 0;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      formatedText = numStr;</div>
<div class="line">      hasExponent = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; !hasExponent) {</div>
<div class="line">    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || <span class="stringliteral">&#39;&#39;</span>).length;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// determine fractionSize if it is not specified</span></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(fractionSize)) {</div>
<div class="line">      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// safely round numbers in JS without hitting imprecisions of floating-point arithmetics</span></div>
<div class="line">    <span class="comment">// inspired by:</span></div>
<div class="line">    <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round</span></div>
<div class="line">    number = +(Math.round(+(number.toString() + <span class="charliteral">&#39;e&#39;</span> + fractionSize)).toString() + <span class="charliteral">&#39;e&#39;</span> + -fractionSize);</div>
<div class="line"></div>
<div class="line">    var fraction = (<span class="stringliteral">&#39;&#39;</span> + number).split(DECIMAL_SEP);</div>
<div class="line">    var whole = fraction[0];</div>
<div class="line">    fraction = fraction[1] || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    var i, pos = 0,</div>
<div class="line">        lgroup = pattern.lgSize,</div>
<div class="line">        group = pattern.gSize;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (whole.length &gt;= (lgroup + group)) {</div>
<div class="line">      pos = whole.length - lgroup;</div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; pos; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> ((pos - i) % group === 0 &amp;&amp; i !== 0) {</div>
<div class="line">          formatedText += groupSep;</div>
<div class="line">        }</div>
<div class="line">        formatedText += whole.charAt(i);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = pos; i &lt; whole.length; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((whole.length - i) % lgroup === 0 &amp;&amp; i !== 0) {</div>
<div class="line">        formatedText += groupSep;</div>
<div class="line">      }</div>
<div class="line">      formatedText += whole.charAt(i);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// format fraction part.</span></div>
<div class="line">    <span class="keywordflow">while</span> (fraction.length &lt; fractionSize) {</div>
<div class="line">      fraction += <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fractionSize &amp;&amp; fractionSize !== <span class="stringliteral">&quot;0&quot;</span>) formatedText += decimalSep + fraction.substr(0, fractionSize);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (fractionSize &gt; 0 &amp;&amp; number &lt; 1) {</div>
<div class="line">      formatedText = number.toFixed(fractionSize);</div>
<div class="line">      number = parseFloat(formatedText);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (number === 0) {</div>
<div class="line">    isNegative = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  parts.push(isNegative ? pattern.negPre : pattern.posPre,</div>
<div class="line">             formatedText,</div>
<div class="line">             isNegative ? pattern.negSuf : pattern.posSuf);</div>
<div class="line">  <span class="keywordflow">return</span> parts.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> padNumber(num, digits, trim) {</div>
<div class="line">  var neg = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (num &lt; 0) {</div>
<div class="line">    neg =  <span class="charliteral">&#39;-&#39;</span>;</div>
<div class="line">    num = -num;</div>
<div class="line">  }</div>
<div class="line">  num = <span class="stringliteral">&#39;&#39;</span> + num;</div>
<div class="line">  <span class="keywordflow">while</span> (num.length &lt; digits) num = <span class="charliteral">&#39;0&#39;</span> + num;</div>
<div class="line">  <span class="keywordflow">if</span> (trim) {</div>
<div class="line">    num = num.substr(num.length - digits);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> neg + num;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> dateGetter(name, size, offset, trim) {</div>
<div class="line">  offset = offset || 0;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date) {</div>
<div class="line">    var value = date[<span class="stringliteral">&#39;get&#39;</span> + name]();</div>
<div class="line">    <span class="keywordflow">if</span> (offset &gt; 0 || value &gt; -offset) {</div>
<div class="line">      value += offset;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (value === 0 &amp;&amp; offset == -12) value = 12;</div>
<div class="line">    <span class="keywordflow">return</span> padNumber(value, size, trim);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> dateStrGetter(name, shortForm) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date, formats) {</div>
<div class="line">    var value = date[<span class="stringliteral">&#39;get&#39;</span> + name]();</div>
<div class="line">    var <span class="keyword">get</span> = uppercase(shortForm ? (<span class="stringliteral">&#39;SHORT&#39;</span> + name) : name);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> formats[<span class="keyword">get</span>][value];</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> timeZoneGetter(date, formats, offset) {</div>
<div class="line">  var zone = -1 * offset;</div>
<div class="line">  var paddedZone = (zone &gt;= 0) ? <span class="stringliteral">&quot;+&quot;</span> : <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">  paddedZone += padNumber(Math[zone &gt; 0 ? <span class="stringliteral">&#39;floor&#39;</span> : <span class="stringliteral">&#39;ceil&#39;</span>](zone / 60), 2) +</div>
<div class="line">                padNumber(Math.abs(zone % 60), 2);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> paddedZone;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getFirstThursdayOfYear(year) {</div>
<div class="line">    <span class="comment">// 0 = index of January</span></div>
<div class="line">    var dayOfWeekOnFirst = (<span class="keyword">new</span> Date(year, 0, 1)).getDay();</div>
<div class="line">    <span class="comment">// 4 = index of Thursday (+1 to account for 1st = 5)</span></div>
<div class="line">    <span class="comment">// 11 = index of *next* Thursday (+1 account for 1st = 12)</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Date(year, 0, ((dayOfWeekOnFirst &lt;= 4) ? 5 : 12) - dayOfWeekOnFirst);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getThursdayThisWeek(datetime) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Date(datetime.getFullYear(), datetime.getMonth(),</div>
<div class="line">      <span class="comment">// 4 = index of Thursday</span></div>
<div class="line">      datetime.getDate() + (4 - datetime.getDay()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> weekGetter(size) {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">function</span>(date) {</div>
<div class="line">      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),</div>
<div class="line">         thisThurs = getThursdayThisWeek(date);</div>
<div class="line"></div>
<div class="line">      var diff = +thisThurs - +firstThurs,</div>
<div class="line">         result = 1 + Math.round(diff / 6.048e8); <span class="comment">// 6.048e8 ms per week</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> padNumber(result, size);</div>
<div class="line">   };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ampmGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> eraGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getFullYear() &lt;= 0 ? formats.ERAS[0] : formats.ERAS[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> longEraGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getFullYear() &lt;= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var DATE_FORMATS = {</div>
<div class="line">  yyyy: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 4),</div>
<div class="line">    yy: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 2, 0, <span class="keyword">true</span>),</div>
<div class="line">     y: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 1),</div>
<div class="line">  MMMM: dateStrGetter(<span class="stringliteral">&#39;Month&#39;</span>),</div>
<div class="line">   MMM: dateStrGetter(<span class="stringliteral">&#39;Month&#39;</span>, <span class="keyword">true</span>),</div>
<div class="line">    MM: dateGetter(<span class="stringliteral">&#39;Month&#39;</span>, 2, 1),</div>
<div class="line">     M: dateGetter(<span class="stringliteral">&#39;Month&#39;</span>, 1, 1),</div>
<div class="line">    dd: dateGetter(<span class="stringliteral">&#39;Date&#39;</span>, 2),</div>
<div class="line">     d: dateGetter(<span class="stringliteral">&#39;Date&#39;</span>, 1),</div>
<div class="line">    HH: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 2),</div>
<div class="line">     H: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 1),</div>
<div class="line">    hh: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 2, -12),</div>
<div class="line">     h: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 1, -12),</div>
<div class="line">    mm: dateGetter(<span class="stringliteral">&#39;Minutes&#39;</span>, 2),</div>
<div class="line">     m: dateGetter(<span class="stringliteral">&#39;Minutes&#39;</span>, 1),</div>
<div class="line">    ss: dateGetter(<span class="stringliteral">&#39;Seconds&#39;</span>, 2),</div>
<div class="line">     s: dateGetter(<span class="stringliteral">&#39;Seconds&#39;</span>, 1),</div>
<div class="line">     <span class="comment">// while ISO 8601 requires fractions to be prefixed with `.` or `,`</span></div>
<div class="line">     <span class="comment">// we can be just safely rely on using `sss` since we currently don&#39;t support single or two digit fractions</span></div>
<div class="line">   sss: dateGetter(<span class="stringliteral">&#39;Milliseconds&#39;</span>, 3),</div>
<div class="line">  EEEE: dateStrGetter(<span class="stringliteral">&#39;Day&#39;</span>),</div>
<div class="line">   EEE: dateStrGetter(<span class="stringliteral">&#39;Day&#39;</span>, <span class="keyword">true</span>),</div>
<div class="line">     a: ampmGetter,</div>
<div class="line">     Z: timeZoneGetter,</div>
<div class="line">    ww: weekGetter(2),</div>
<div class="line">     w: weekGetter(1),</div>
<div class="line">     G: eraGetter,</div>
<div class="line">     GG: eraGetter,</div>
<div class="line">     GGG: eraGetter,</div>
<div class="line">     GGGG: longEraGetter</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG<span class="stringliteral">&#39;]+)|(?:&#39;</span>(?:[^<span class="stringliteral">&#39;]|&#39;</span><span class="stringliteral">&#39;)*&#39;</span>)|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,</div>
<div class="line">    NUMBER_STRING = /^\-?\d+$/;</div>
<div class="line"></div>
<div class="line">dateFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> dateFilter($locale) {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;</div>
<div class="line">                     <span class="comment">// 1        2       3         4          5          6          7          8  9     10      11</span></div>
<div class="line">  <span class="keyword">function</span> jsonStringToDate(<span class="keywordtype">string</span>) {</div>
<div class="line">    var match;</div>
<div class="line">    <span class="keywordflow">if</span> (match = <span class="keywordtype">string</span>.match(R_ISO8601_STR)) {</div>
<div class="line">      var date = <span class="keyword">new</span> Date(0),</div>
<div class="line">          tzHour = 0,</div>
<div class="line">          tzMin  = 0,</div>
<div class="line">          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,</div>
<div class="line">          timeSetter = match[8] ? date.setUTCHours : date.setHours;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (match[9]) {</div>
<div class="line">        tzHour = toInt(match[9] + match[10]);</div>
<div class="line">        tzMin = toInt(match[9] + match[11]);</div>
<div class="line">      }</div>
<div class="line">      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));</div>
<div class="line">      var h = toInt(match[4] || 0) - tzHour;</div>
<div class="line">      var m = toInt(match[5] || 0) - tzMin;</div>
<div class="line">      var s = toInt(match[6] || 0);</div>
<div class="line">      var ms = Math.round(parseFloat(<span class="stringliteral">&#39;0.&#39;</span> + (match[7] || 0)) * 1000);</div>
<div class="line">      timeSetter.call(date, h, m, s, ms);</div>
<div class="line">      <span class="keywordflow">return</span> date;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> string;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date, format, timezone) {</div>
<div class="line">    var text = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">        parts = [],</div>
<div class="line">        fn, match;</div>
<div class="line"></div>
<div class="line">    format = format || <span class="stringliteral">&#39;mediumDate&#39;</span>;</div>
<div class="line">    format = $locale.DATETIME_FORMATS[format] || format;</div>
<div class="line">    <span class="keywordflow">if</span> (isString(date)) {</div>
<div class="line">      date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(date)) {</div>
<div class="line">      date = <span class="keyword">new</span> Date(date);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isDate(date) || !isFinite(date.getTime())) {</div>
<div class="line">      <span class="keywordflow">return</span> date;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (format) {</div>
<div class="line">      match = DATE_FORMATS_SPLIT.exec(format);</div>
<div class="line">      <span class="keywordflow">if</span> (match) {</div>
<div class="line">        parts = concat(parts, match, 1);</div>
<div class="line">        format = parts.pop();</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        parts.push(format);</div>
<div class="line">        format = null;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var dateTimezoneOffset = date.getTimezoneOffset();</div>
<div class="line">    <span class="keywordflow">if</span> (timezone) {</div>
<div class="line">      dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());</div>
<div class="line">      date = convertTimezoneToLocal(date, timezone, <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    forEach(parts, <span class="keyword">function</span>(value) {</div>
<div class="line">      fn = DATE_FORMATS[value];</div>
<div class="line">      text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset)</div>
<div class="line">                 : value.replace(/(^<span class="stringliteral">&#39;|&#39;</span>$)/g, <span class="stringliteral">&#39;&#39;</span>).replace(/<span class="stringliteral">&#39;&#39;</span>/g, <span class="stringliteral">&quot;&#39;&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> text;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jsonFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(object, spacing) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(spacing)) {</div>
<div class="line">        spacing = 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> toJson(<span class="keywordtype">object</span>, spacing);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var lowercaseFilter = valueFn(lowercase);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var uppercaseFilter = valueFn(uppercase);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> limitToFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(input, limit, begin) {</div>
<div class="line">    <span class="keywordflow">if</span> (Math.abs(Number(limit)) === Infinity) {</div>
<div class="line">      limit = Number(limit);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      limit = toInt(limit);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isNaN(limit)) <span class="keywordflow">return</span> input;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(input)) input = input.toString();</div>
<div class="line">    <span class="keywordflow">if</span> (!isArray(input) &amp;&amp; !isString(input)) <span class="keywordflow">return</span> input;</div>
<div class="line"></div>
<div class="line">    begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);</div>
<div class="line">    begin = (begin &lt; 0 &amp;&amp; begin &gt;= -input.length) ? input.length + begin : begin;</div>
<div class="line"></div>
<div class="line">    if (limit &gt;= 0) {</div>
<div class="line">      <span class="keywordflow">return</span> input.slice(begin, begin + limit);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (begin === 0) {</div>
<div class="line">        <span class="keywordflow">return</span> input.slice(limit, input.length);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> input.slice(Math.max(0, begin + limit), begin);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">orderByFilter.$inject = [<span class="stringliteral">&#39;$parse&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> orderByFilter($parse) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(array, sortPredicate, reverseOrder) {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!(isArrayLike(array))) <span class="keywordflow">return</span> array;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isArray(sortPredicate)) { sortPredicate = [sortPredicate]; }</div>
<div class="line">    <span class="keywordflow">if</span> (sortPredicate.length === 0) { sortPredicate = [<span class="charliteral">&#39;+&#39;</span>]; }</div>
<div class="line"></div>
<div class="line">    var predicates = processPredicates(sortPredicate, reverseOrder);</div>
<div class="line">    <span class="comment">// Add a predicate at the end that evaluates to the element index. This makes the</span></div>
<div class="line">    <span class="comment">// sort stable as it works as a tie-breaker when all the input predicates cannot</span></div>
<div class="line">    <span class="comment">// distinguish between two elements.</span></div>
<div class="line">    predicates.push({ <span class="keyword">get</span>: <span class="keyword">function</span>() { <span class="keywordflow">return</span> {}; }, descending: reverseOrder ? -1 : 1});</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The next three lines are a version of a Swartzian Transform idiom from Perl</span></div>
<div class="line">    <span class="comment">// (sometimes called the Decorate-Sort-Undecorate idiom)</span></div>
<div class="line">    <span class="comment">// See https://en.wikipedia.org/wiki/Schwartzian_transform</span></div>
<div class="line">    var compareValues = Array.prototype.map.call(array, getComparisonObject);</div>
<div class="line">    compareValues.sort(doComparison);</div>
<div class="line">    array = compareValues.map(<span class="keyword">function</span>(item) { <span class="keywordflow">return</span> item.value; });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> array;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getComparisonObject(value, index) {</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        value: value,</div>
<div class="line">        predicateValues: predicates.map(<span class="keyword">function</span>(predicate) {</div>
<div class="line">          <span class="keywordflow">return</span> getPredicateValue(predicate.get(value), index);</div>
<div class="line">        })</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> doComparison(v1, v2) {</div>
<div class="line">      var result = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (var index=0, length = predicates.length; index &lt; length; ++index) {</div>
<div class="line">        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;</div>
<div class="line">        <span class="keywordflow">if</span> (result) <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> processPredicates(sortPredicate, reverseOrder) {</div>
<div class="line">    reverseOrder = reverseOrder ? -1 : 1;</div>
<div class="line">    <span class="keywordflow">return</span> sortPredicate.map(<span class="keyword">function</span>(predicate) {</div>
<div class="line">      var descending = 1, <span class="keyword">get</span> = identity;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(predicate)) {</div>
<div class="line">        <span class="keyword">get</span> = predicate;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(predicate)) {</div>
<div class="line">        <span class="keywordflow">if</span> ((predicate.charAt(0) == <span class="charliteral">&#39;+&#39;</span> || predicate.charAt(0) == <span class="charliteral">&#39;-&#39;</span>)) {</div>
<div class="line">          descending = predicate.charAt(0) == <span class="charliteral">&#39;-&#39;</span> ? -1 : 1;</div>
<div class="line">          predicate = predicate.substring(1);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (predicate !== <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          <span class="keyword">get</span> = $parse(predicate);</div>
<div class="line">          <span class="keywordflow">if</span> (<span class="keyword">get</span>.constant) {</div>
<div class="line">            var key = <span class="keyword">get</span>();</div>
<div class="line">            <span class="keyword">get</span> = <span class="keyword">function</span>(value) { <span class="keywordflow">return</span> value[key]; };</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> { <span class="keyword">get</span>: <span class="keyword">get</span>, descending: descending * reverseOrder };</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> isPrimitive(value) {</div>
<div class="line">    <span class="keywordflow">switch</span> (typeof value) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;number&#39;</span>: <span class="comment">/* falls through */</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;boolean&#39;</span>: <span class="comment">/* falls through */</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> objectValue(value, index) {</div>
<div class="line">    <span class="comment">// If `valueOf` is a valid function use that</span></div>
<div class="line">    <span class="keywordflow">if</span> (typeof value.valueOf === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      value = value.valueOf();</div>
<div class="line">      <span class="keywordflow">if</span> (isPrimitive(value)) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// If `toString` is a valid function and not the one from `Object.prototype` use that</span></div>
<div class="line">    <span class="keywordflow">if</span> (hasCustomToString(value)) {</div>
<div class="line">      value = value.toString();</div>
<div class="line">      <span class="keywordflow">if</span> (isPrimitive(value)) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// We have a basic object so we use the position of the object in the collection</span></div>
<div class="line">    <span class="keywordflow">return</span> index;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getPredicateValue(value, index) {</div>
<div class="line">    var type = typeof value;</div>
<div class="line">    <span class="keywordflow">if</span> (value === null) {</div>
<div class="line">      type = <span class="stringliteral">&#39;string&#39;</span>;</div>
<div class="line">      value = <span class="stringliteral">&#39;null&#39;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">      value = value.toLowerCase();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">      value = objectValue(value, index);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> { value: value, type: type };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> compare(v1, v2) {</div>
<div class="line">    var result = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (v1.type === v2.type) {</div>
<div class="line">      <span class="keywordflow">if</span> (v1.value !== v2.value) {</div>
<div class="line">        result = v1.value &lt; v2.value ? -1 : 1;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = v1.type &lt; v2.type ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ngDirective(directive) {</div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(directive)) {</div>
<div class="line">    directive = {</div>
<div class="line">      link: directive</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">  directive.restrict = directive.restrict || <span class="stringliteral">&#39;AC&#39;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> valueFn(directive);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var htmlAnchorDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">  compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">    <span class="keywordflow">if</span> (!attr.href &amp;&amp; !attr.xlinkHref) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element) {</div>
<div class="line">        <span class="comment">// If the linked element is not an anchor tag anymore, do nothing</span></div>
<div class="line">        <span class="keywordflow">if</span> (element[0].nodeName.toLowerCase() !== <span class="charliteral">&#39;a&#39;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// SVGAElement does not use the href attribute, but rather the &#39;xlinkHref&#39; attribute.</span></div>
<div class="line">        var href = toString.call(element.prop(<span class="stringliteral">&#39;href&#39;</span>)) === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span> ?</div>
<div class="line">                   <span class="stringliteral">&#39;xlink:href&#39;</span> : <span class="stringliteral">&#39;href&#39;</span>;</div>
<div class="line">        element.on(<span class="stringliteral">&#39;click&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">          <span class="comment">// if we have no href url, then don&#39;t navigate anywhere.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!element.attr(href)) {</div>
<div class="line">            event.preventDefault();</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngAttributeAliasDirectives = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// boolean attrs are evaluated</span></div>
<div class="line">forEach(BOOLEAN_ATTR, <span class="keyword">function</span>(propName, attrName) {</div>
<div class="line">  <span class="comment">// binding to multiple is not supported</span></div>
<div class="line">  <span class="keywordflow">if</span> (propName == <span class="stringliteral">&quot;multiple&quot;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> defaultLinkFn(scope, element, attr) {</div>
<div class="line">    scope.$watch(attr[normalized], <span class="keyword">function</span> ngBooleanAttrWatchAction(value) {</div>
<div class="line">      attr.$set(attrName, !!value);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var normalized = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + attrName);</div>
<div class="line">  var linkFn = defaultLinkFn;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (propName === <span class="stringliteral">&#39;checked&#39;</span>) {</div>
<div class="line">    linkFn = <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      <span class="comment">// ensuring ngChecked doesn&#39;t interfere with ngModel when both are set on the same input</span></div>
<div class="line">      <span class="keywordflow">if</span> (attr.ngModel !== attr[normalized]) {</div>
<div class="line">        defaultLinkFn(scope, element, attr);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  ngAttributeAliasDirectives[normalized] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">      priority: 100,</div>
<div class="line">      link: linkFn</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// aliased input attrs are evaluated</span></div>
<div class="line">forEach(ALIASED_ATTR, <span class="keyword">function</span>(htmlAttr, ngAttr) {</div>
<div class="line">  ngAttributeAliasDirectives[ngAttr] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      priority: 100,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        <span class="comment">//special case ngPattern when a literal regular expression value</span></div>
<div class="line">        <span class="comment">//is used as the expression (this way we don&#39;t have to watch anything).</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngAttr === <span class="stringliteral">&quot;ngPattern&quot;</span> &amp;&amp; attr.ngPattern.charAt(0) == <span class="stringliteral">&quot;/&quot;</span>) {</div>
<div class="line">          var match = attr.ngPattern.match(REGEX_STRING_REGEXP);</div>
<div class="line">          <span class="keywordflow">if</span> (match) {</div>
<div class="line">            attr.$set(<span class="stringliteral">&quot;ngPattern&quot;</span>, <span class="keyword">new</span> RegExp(match[1], match[2]));</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        scope.$watch(attr[ngAttr], <span class="keyword">function</span> ngAttrAliasWatchAction(value) {</div>
<div class="line">          attr.$set(ngAttr, value);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// ng-src, ng-srcset, ng-href are interpolated</span></div>
<div class="line">forEach([<span class="stringliteral">&#39;src&#39;</span>, <span class="stringliteral">&#39;srcset&#39;</span>, <span class="stringliteral">&#39;href&#39;</span>], <span class="keyword">function</span>(attrName) {</div>
<div class="line">  var normalized = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + attrName);</div>
<div class="line">  ngAttributeAliasDirectives[normalized] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      priority: 99, <span class="comment">// it needs to run after the attributes are interpolated</span></div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        var propName = attrName,</div>
<div class="line">            name = attrName;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (attrName === <span class="stringliteral">&#39;href&#39;</span> &amp;&amp;</div>
<div class="line">            toString.call(element.prop(<span class="stringliteral">&#39;href&#39;</span>)) === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span>) {</div>
<div class="line">          name = <span class="stringliteral">&#39;xlinkHref&#39;</span>;</div>
<div class="line">          attr.$attr[name] = <span class="stringliteral">&#39;xlink:href&#39;</span>;</div>
<div class="line">          propName = null;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        attr.$observe(normalized, <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">if</span> (!value) {</div>
<div class="line">            <span class="keywordflow">if</span> (attrName === <span class="stringliteral">&#39;href&#39;</span>) {</div>
<div class="line">              attr.$set(name, null);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          attr.$set(name, value);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// on IE, if &quot;ng:src&quot; directive declaration is used and &quot;src&quot; attribute doesn&#39;t exist</span></div>
<div class="line">          <span class="comment">// then calling element.setAttribute(&#39;src&#39;, &#39;foo&#39;) doesn&#39;t do anything, so we need</span></div>
<div class="line">          <span class="comment">// to set the property as well to achieve the desired effect.</span></div>
<div class="line">          <span class="comment">// we use attr[attrName] value since $set can sanitize the url.</span></div>
<div class="line">          <span class="keywordflow">if</span> (msie &amp;&amp; propName) element.prop(propName, attr[name]);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">var nullFormCtrl = {</div>
<div class="line">  $addControl: noop,</div>
<div class="line">  $$renameControl: nullFormRenameControl,</div>
<div class="line">  $removeControl: noop,</div>
<div class="line">  $setValidity: noop,</div>
<div class="line">  $setDirty: noop,</div>
<div class="line">  $setPristine: noop,</div>
<div class="line">  $setSubmitted: noop</div>
<div class="line">},</div>
<div class="line">SUBMITTED_CLASS = <span class="stringliteral">&#39;ng-submitted&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nullFormRenameControl(control, name) {</div>
<div class="line">  control.$name = name;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//asks for $scope to fool the BC controller module</span></div>
<div class="line">FormController.$inject = [<span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> FormController(element, attrs, $scope, $animate, $interpolate) {</div>
<div class="line">  var form = <span class="keyword">this</span>,</div>
<div class="line">      controls = [];</div>
<div class="line"></div>
<div class="line">  var parentForm = form.$$parentForm = element.parent().controller(<span class="stringliteral">&#39;form&#39;</span>) || nullFormCtrl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// init state</span></div>
<div class="line">  form.$error = {};</div>
<div class="line">  form.$$success = {};</div>
<div class="line">  form.$pending = undefined;</div>
<div class="line">  form.$name = $interpolate(attrs.name || attrs.ngForm || <span class="stringliteral">&#39;&#39;</span>)($scope);</div>
<div class="line">  form.$dirty = <span class="keyword">false</span>;</div>
<div class="line">  form.$pristine = <span class="keyword">true</span>;</div>
<div class="line">  form.$valid = <span class="keyword">true</span>;</div>
<div class="line">  form.$invalid = <span class="keyword">false</span>;</div>
<div class="line">  form.$submitted = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  parentForm.$addControl(form);</div>
<div class="line"></div>
<div class="line">  form.$rollbackViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$rollbackViewValue();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$commitViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$commitViewValue();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$addControl = <span class="keyword">function</span>(control) {</div>
<div class="line">    <span class="comment">// Breaking change - before, inputs whose name was &quot;hasOwnProperty&quot; were quietly ignored</span></div>
<div class="line">    <span class="comment">// and not added to the scope.  Now we throw an error.</span></div>
<div class="line">    assertNotHasOwnProperty(control.$name, <span class="stringliteral">&#39;input&#39;</span>);</div>
<div class="line">    controls.push(control);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (control.$name) {</div>
<div class="line">      form[control.$name] = control;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Private API: rename a form control</span></div>
<div class="line">  form.$$renameControl = <span class="keyword">function</span>(control, newName) {</div>
<div class="line">    var oldName = control.$name;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (form[oldName] === control) {</div>
<div class="line">      <span class="keyword">delete</span> form[oldName];</div>
<div class="line">    }</div>
<div class="line">    form[newName] = control;</div>
<div class="line">    control.$name = newName;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$removeControl = <span class="keyword">function</span>(control) {</div>
<div class="line">    <span class="keywordflow">if</span> (control.$name &amp;&amp; form[control.$name] === control) {</div>
<div class="line">      <span class="keyword">delete</span> form[control.$name];</div>
<div class="line">    }</div>
<div class="line">    forEach(form.$pending, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line">    forEach(form.$error, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line">    forEach(form.$$success, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    arrayRemove(controls, control);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  addSetValidityMethod({</div>
<div class="line">    ctrl: <span class="keyword">this</span>,</div>
<div class="line">    $element: element,</div>
<div class="line">    set: <span class="keyword">function</span>(object, property, controller) {</div>
<div class="line">      var list = <span class="keywordtype">object</span>[property];</div>
<div class="line">      <span class="keywordflow">if</span> (!list) {</div>
<div class="line">        <span class="keywordtype">object</span>[property] = [controller];</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var index = list.indexOf(controller);</div>
<div class="line">        <span class="keywordflow">if</span> (index === -1) {</div>
<div class="line">          list.push(controller);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    unset: <span class="keyword">function</span>(object, property, controller) {</div>
<div class="line">      var list = <span class="keywordtype">object</span>[property];</div>
<div class="line">      <span class="keywordflow">if</span> (!list) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      arrayRemove(list, controller);</div>
<div class="line">      <span class="keywordflow">if</span> (list.length === 0) {</div>
<div class="line">        <span class="keyword">delete</span> <span class="keywordtype">object</span>[property];</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    parentForm: parentForm,</div>
<div class="line">    $animate: $animate</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  form.$setDirty = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.removeClass(element, PRISTINE_CLASS);</div>
<div class="line">    $animate.addClass(element, DIRTY_CLASS);</div>
<div class="line">    form.$dirty = <span class="keyword">true</span>;</div>
<div class="line">    form.$pristine = <span class="keyword">false</span>;</div>
<div class="line">    parentForm.$setDirty();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setPristine = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + <span class="charliteral">&#39; &#39;</span> + SUBMITTED_CLASS);</div>
<div class="line">    form.$dirty = <span class="keyword">false</span>;</div>
<div class="line">    form.$pristine = <span class="keyword">true</span>;</div>
<div class="line">    form.$submitted = <span class="keyword">false</span>;</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$setPristine();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setUntouched = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$setUntouched();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setSubmitted = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.addClass(element, SUBMITTED_CLASS);</div>
<div class="line">    form.$submitted = <span class="keyword">true</span>;</div>
<div class="line">    parentForm.$setSubmitted();</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var formDirectiveFactory = <span class="keyword">function</span>(isNgForm) {</div>
<div class="line">  <span class="keywordflow">return</span> [<span class="stringliteral">&#39;$timeout&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="keyword">function</span>($timeout, $parse) {</div>
<div class="line">    var formDirective = {</div>
<div class="line">      name: <span class="stringliteral">&#39;form&#39;</span>,</div>
<div class="line">      restrict: isNgForm ? <span class="stringliteral">&#39;EAC&#39;</span> : <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">      controller: FormController,</div>
<div class="line">      compile: <span class="keyword">function</span> ngFormCompile(formElement, attr) {</div>
<div class="line">        <span class="comment">// Setup initial state of the control</span></div>
<div class="line">        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);</div>
<div class="line"></div>
<div class="line">        var nameAttr = attr.name ? <span class="stringliteral">&#39;name&#39;</span> : (isNgForm &amp;&amp; attr.ngForm ? <span class="stringliteral">&#39;ngForm&#39;</span> : <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">          pre: <span class="keyword">function</span> ngFormPreLink(scope, formElement, attr, controller) {</div>
<div class="line">            <span class="comment">// if `action` attr is not present on the form, prevent the default action (submission)</span></div>
<div class="line">            <span class="keywordflow">if</span> (!(<span class="stringliteral">&#39;action&#39;</span> in attr)) {</div>
<div class="line">              <span class="comment">// we can&#39;t use jq events because if a form is destroyed during submission the default</span></div>
<div class="line">              <span class="comment">// action is not prevented. see #1238</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// IE 9 is not affected because it doesn&#39;t fire a submit event and try to do a full</span></div>
<div class="line">              <span class="comment">// page reload if the form was destroyed by submission of the form via a click handler</span></div>
<div class="line">              <span class="comment">// on a button in the form. Looks like an IE9 specific bug.</span></div>
<div class="line">              var handleFormSubmission = <span class="keyword">function</span>(event) {</div>
<div class="line">                scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">                  controller.$commitViewValue();</div>
<div class="line">                  controller.$setSubmitted();</div>
<div class="line">                });</div>
<div class="line"></div>
<div class="line">                event.preventDefault();</div>
<div class="line">              };</div>
<div class="line"></div>
<div class="line">              addEventListenerFn(formElement[0], <span class="stringliteral">&#39;submit&#39;</span>, handleFormSubmission);</div>
<div class="line"></div>
<div class="line">              <span class="comment">// unregister the preventDefault listener so that we don&#39;t not leak memory but in a</span></div>
<div class="line">              <span class="comment">// way that will achieve the prevention of the default action.</span></div>
<div class="line">              formElement.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">                $timeout(<span class="keyword">function</span>() {</div>
<div class="line">                  removeEventListenerFn(formElement[0], <span class="stringliteral">&#39;submit&#39;</span>, handleFormSubmission);</div>
<div class="line">                }, 0, <span class="keyword">false</span>);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            var parentFormCtrl = controller.$$parentForm;</div>
<div class="line">            var setter = nameAttr ? getSetter(controller.$name) : noop;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (nameAttr) {</div>
<div class="line">              setter(scope, controller);</div>
<div class="line">              attr.$observe(nameAttr, <span class="keyword">function</span>(newValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (controller.$name === newValue) <span class="keywordflow">return</span>;</div>
<div class="line">                setter(scope, undefined);</div>
<div class="line">                parentFormCtrl.$$renameControl(controller, newValue);</div>
<div class="line">                setter = getSetter(controller.$name);</div>
<div class="line">                setter(scope, controller);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">            formElement.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">              parentFormCtrl.$removeControl(controller);</div>
<div class="line">              setter(scope, undefined);</div>
<div class="line">              extend(controller, nullFormCtrl); <span class="comment">//stop propagating child destruction handlers upwards</span></div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> formDirective;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getSetter(expression) {</div>
<div class="line">      <span class="keywordflow">if</span> (expression === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="comment">//create an assignable expression, so forms with an empty name can be renamed later</span></div>
<div class="line">        <span class="keywordflow">return</span> $parse(<span class="stringliteral">&#39;this[&quot;&quot;]&#39;</span>).assign;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> $parse(expression).assign || noop;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var formDirective = formDirectiveFactory();</div>
<div class="line">var ngFormDirective = formDirectiveFactory(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global VALID_CLASS: false,</span></div>
<div class="line"><span class="comment">  INVALID_CLASS: false,</span></div>
<div class="line"><span class="comment">  PRISTINE_CLASS: false,</span></div>
<div class="line"><span class="comment">  DIRTY_CLASS: false,</span></div>
<div class="line"><span class="comment">  UNTOUCHED_CLASS: false,</span></div>
<div class="line"><span class="comment">  TOUCHED_CLASS: false,</span></div>
<div class="line"><span class="comment">  ngModelMinErr: false,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Regex code is obtained from SO: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231</span></div>
<div class="line">var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;</div>
<div class="line">var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/;</div>
<div class="line">var EMAIL_REGEXP = /^[a-z0-9!#$%&amp;<span class="stringliteral">&#39;*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;</span></div>
<div class="line"><span class="stringliteral">var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;</span></div>
<div class="line"><span class="stringliteral">var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;</span></div>
<div class="line"><span class="stringliteral">var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;</span></div>
<div class="line"><span class="stringliteral">var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;</span></div>
<div class="line"><span class="stringliteral">var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;</span></div>
<div class="line"><span class="stringliteral">var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">var inputType = {</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>text<span class="stringliteral">&#39;: textInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>date<span class="stringliteral">&#39;: createDateInputType(&#39;</span>date<span class="stringliteral">&#39;, DATE_REGEXP,</span></div>
<div class="line"><span class="stringliteral">         createDateParser(DATE_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;, &#39;</span>dd<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">         &#39;</span>yyyy-MM-dd<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>datetime-local<span class="stringliteral">&#39;: createDateInputType(&#39;</span>datetimelocal<span class="stringliteral">&#39;, DATETIMELOCAL_REGEXP,</span></div>
<div class="line"><span class="stringliteral">      createDateParser(DATETIMELOCAL_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;, &#39;</span>dd<span class="stringliteral">&#39;, &#39;</span>HH<span class="stringliteral">&#39;, &#39;</span>mm<span class="stringliteral">&#39;, &#39;</span>ss<span class="stringliteral">&#39;, &#39;</span>sss<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">      &#39;</span>yyyy-MM-ddTHH:mm:ss.sss<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>time<span class="stringliteral">&#39;: createDateInputType(&#39;</span>time<span class="stringliteral">&#39;, TIME_REGEXP,</span></div>
<div class="line"><span class="stringliteral">      createDateParser(TIME_REGEXP, [&#39;</span>HH<span class="stringliteral">&#39;, &#39;</span>mm<span class="stringliteral">&#39;, &#39;</span>ss<span class="stringliteral">&#39;, &#39;</span>sss<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">     &#39;</span>HH:mm:ss.sss<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>week<span class="stringliteral">&#39;: createDateInputType(&#39;</span>week<span class="stringliteral">&#39;, WEEK_REGEXP, weekParser, &#39;</span>yyyy-Www<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>month<span class="stringliteral">&#39;: createDateInputType(&#39;</span>month<span class="stringliteral">&#39;, MONTH_REGEXP,</span></div>
<div class="line"><span class="stringliteral">     createDateParser(MONTH_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">     &#39;</span>yyyy-MM<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>number<span class="stringliteral">&#39;: numberInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>url<span class="stringliteral">&#39;: urlInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>email<span class="stringliteral">&#39;: emailInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>radio<span class="stringliteral">&#39;: radioInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>checkbox<span class="stringliteral">&#39;: checkboxInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>hidden<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>button<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>submit<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>reset<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>file<span class="stringliteral">&#39;: noop</span></div>
<div class="line"><span class="stringliteral">};</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function stringBasedInputType(ctrl) {</span></div>
<div class="line"><span class="stringliteral">  ctrl.$formatters.push(function(value) {</span></div>
<div class="line"><span class="stringliteral">    return ctrl.$isEmpty(value) ? value : value.toString();</span></div>
<div class="line"><span class="stringliteral">  });</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {</span></div>
<div class="line"><span class="stringliteral">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</span></div>
<div class="line"><span class="stringliteral">  stringBasedInputType(ctrl);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {</span></div>
<div class="line"><span class="stringliteral">  var type = lowercase(element[0].type);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  // In composition mode, users are still inputing intermediate text buffer,</span></div>
<div class="line"><span class="stringliteral">  // hold the listener until composition is done.</span></div>
<div class="line"><span class="stringliteral">  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent</span></div>
<div class="line"><span class="stringliteral">  if (!$sniffer.android) {</span></div>
<div class="line"><span class="stringliteral">    var composing = false;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    element.on(&#39;</span>compositionstart<span class="stringliteral">&#39;, function(data) {</span></div>
<div class="line"><span class="stringliteral">      composing = true;</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    element.on(&#39;</span>compositionend<span class="stringliteral">&#39;, function() {</span></div>
<div class="line"><span class="stringliteral">      composing = false;</span></div>
<div class="line"><span class="stringliteral">      listener();</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  var listener = function(ev) {</span></div>
<div class="line"><span class="stringliteral">    if (timeout) {</span></div>
<div class="line"><span class="stringliteral">      $browser.defer.cancel(timeout);</span></div>
<div class="line"><span class="stringliteral">      timeout = null;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">    if (composing) return;</span></div>
<div class="line"><span class="stringliteral">    var value = element.val(),</span></div>
<div class="line"><span class="stringliteral">        event = ev &amp;&amp; ev.type;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // By default we will trim the value</span></div>
<div class="line"><span class="stringliteral">    // If the attribute ng-trim exists we will avoid trimming</span></div>
<div class="line"><span class="stringliteral">    // If input type is &#39;</span>password<span class="stringliteral">&#39;, the value is never trimmed</span></div>
<div class="line"><span class="stringliteral">    if (type !== &#39;</span>password<span class="stringliteral">&#39; &amp;&amp; (!attr.ngTrim || attr.ngTrim !== &#39;</span><span class="keyword">false</span><span class="stringliteral">&#39;)) {</span></div>
<div class="line"><span class="stringliteral">      value = trim(value);</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // If a control is suffering from bad input (due to native validators), browsers discard its</span></div>
<div class="line"><span class="stringliteral">    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the</span></div>
<div class="line"><span class="stringliteral">    // control&#39;</span>s value is the same empty value twice in a row.</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$viewValue !== value || (value === <span class="stringliteral">&#39;&#39;</span> &amp;&amp; ctrl.$$hasNativeValidators)) {</div>
<div class="line">      ctrl.$setViewValue(value, event);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if the browser does support &quot;input&quot; event, we are fine - except on IE9 which doesn&#39;t fire the</span></div>
<div class="line">  <span class="comment">// input event on backspace, delete or cut</span></div>
<div class="line">  <span class="keywordflow">if</span> ($sniffer.hasEvent(<span class="stringliteral">&#39;input&#39;</span>)) {</div>
<div class="line">    element.on(<span class="stringliteral">&#39;input&#39;</span>, listener);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    var timeout;</div>
<div class="line"></div>
<div class="line">    var deferListener = <span class="keyword">function</span>(ev, input, origValue) {</div>
<div class="line">      <span class="keywordflow">if</span> (!timeout) {</div>
<div class="line">        timeout = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">          timeout = null;</div>
<div class="line">          <span class="keywordflow">if</span> (!input || input.value !== origValue) {</div>
<div class="line">            listener(ev);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    element.on(<span class="stringliteral">&#39;keydown&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">      var key = event.keyCode;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// ignore</span></div>
<div class="line">      <span class="comment">//    command            modifiers                   arrows</span></div>
<div class="line">      <span class="keywordflow">if</span> (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      deferListener(event, <span class="keyword">this</span>, this.value);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if user modifies input value using context menu in IE, we need &quot;paste&quot; and &quot;cut&quot; events to catch it</span></div>
<div class="line">    <span class="keywordflow">if</span> ($sniffer.hasEvent(<span class="stringliteral">&#39;paste&#39;</span>)) {</div>
<div class="line">      element.on(<span class="stringliteral">&#39;paste cut&#39;</span>, deferListener);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if user paste into input using mouse on older browser</span></div>
<div class="line">  <span class="comment">// or form autocomplete on newer browser, we need &quot;change&quot; event to catch it</span></div>
<div class="line">  element.on(<span class="stringliteral">&#39;change&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// Workaround for Firefox validation #12102.</span></div>
<div class="line">    var value = ctrl.$isEmpty(ctrl.$viewValue) ? <span class="stringliteral">&#39;&#39;</span> : ctrl.$viewValue;</div>
<div class="line">    <span class="keywordflow">if</span> (element.val() !== value) {</div>
<div class="line">      element.val(value);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> weekParser(isoWeek, existingDate) {</div>
<div class="line">  <span class="keywordflow">if</span> (isDate(isoWeek)) {</div>
<div class="line">    <span class="keywordflow">return</span> isoWeek;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isString(isoWeek)) {</div>
<div class="line">    WEEK_REGEXP.lastIndex = 0;</div>
<div class="line">    var parts = WEEK_REGEXP.exec(isoWeek);</div>
<div class="line">    <span class="keywordflow">if</span> (parts) {</div>
<div class="line">      var year = +parts[1],</div>
<div class="line">          week = +parts[2],</div>
<div class="line">          hours = 0,</div>
<div class="line">          minutes = 0,</div>
<div class="line">          seconds = 0,</div>
<div class="line">          milliseconds = 0,</div>
<div class="line">          firstThurs = getFirstThursdayOfYear(year),</div>
<div class="line">          addDays = (week - 1) * 7;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (existingDate) {</div>
<div class="line">        hours = existingDate.getHours();</div>
<div class="line">        minutes = existingDate.getMinutes();</div>
<div class="line">        seconds = existingDate.getSeconds();</div>
<div class="line">        milliseconds = existingDate.getMilliseconds();</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> NaN;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createDateParser(regexp, mapping) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(iso, date) {</div>
<div class="line">    var parts, map;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDate(iso)) {</div>
<div class="line">      <span class="keywordflow">return</span> iso;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isString(iso)) {</div>
<div class="line">      <span class="comment">// When a date is JSON&#39;ified to wraps itself inside of an extra</span></div>
<div class="line">      <span class="comment">// set of double quotes. This makes the date parsing code unable</span></div>
<div class="line">      <span class="comment">// to match the date string and parse it as a date.</span></div>
<div class="line">      <span class="keywordflow">if</span> (iso.charAt(0) == <span class="charliteral">&#39;&quot;&#39;</span> &amp;&amp; iso.charAt(iso.length - 1) == <span class="charliteral">&#39;&quot;&#39;</span>) {</div>
<div class="line">        iso = iso.substring(1, iso.length - 1);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ISO_DATE_REGEXP.test(iso)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Date(iso);</div>
<div class="line">      }</div>
<div class="line">      regexp.lastIndex = 0;</div>
<div class="line">      parts = regexp.exec(iso);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (parts) {</div>
<div class="line">        parts.shift();</div>
<div class="line">        <span class="keywordflow">if</span> (date) {</div>
<div class="line">          map = {</div>
<div class="line">            yyyy: date.getFullYear(),</div>
<div class="line">            MM: date.getMonth() + 1,</div>
<div class="line">            dd: date.getDate(),</div>
<div class="line">            HH: date.getHours(),</div>
<div class="line">            mm: date.getMinutes(),</div>
<div class="line">            ss: date.getSeconds(),</div>
<div class="line">            sss: date.getMilliseconds() / 1000</div>
<div class="line">          };</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        forEach(parts, <span class="keyword">function</span>(part, index) {</div>
<div class="line">          <span class="keywordflow">if</span> (index &lt; mapping.length) {</div>
<div class="line">            map[mapping[index]] = +part;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> NaN;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createDateInputType(type, regexp, parseDate, format) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span> dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {</div>
<div class="line">    badInputChecker(scope, element, attr, ctrl);</div>
<div class="line">    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">    var timezone = ctrl &amp;&amp; ctrl.$options &amp;&amp; ctrl.$options.timezone;</div>
<div class="line">    var previousDate;</div>
<div class="line"></div>
<div class="line">    ctrl.$$parserName = type;</div>
<div class="line">    ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$isEmpty(value)) <span class="keywordflow">return</span> null;</div>
<div class="line">      <span class="keywordflow">if</span> (regexp.test(value)) {</div>
<div class="line">        <span class="comment">// Note: We cannot read ctrl.$modelValue, as there might be a different</span></div>
<div class="line">        <span class="comment">// parser/formatter in the processing chain so that the model</span></div>
<div class="line">        <span class="comment">// contains some different data format!</span></div>
<div class="line">        var parsedDate = parseDate(value, previousDate);</div>
<div class="line">        <span class="keywordflow">if</span> (timezone) {</div>
<div class="line">          parsedDate = convertTimezoneToLocal(parsedDate, timezone);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> parsedDate;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> undefined;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">if</span> (value &amp;&amp; !isDate(value)) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;datefmt&#39;</span>, <span class="stringliteral">&#39;Expected `{0}` to be a date&#39;</span>, value);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isValidDate(value)) {</div>
<div class="line">        previousDate = value;</div>
<div class="line">        <span class="keywordflow">if</span> (previousDate &amp;&amp; timezone) {</div>
<div class="line">          previousDate = convertTimezoneToLocal(previousDate, timezone, <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> $filter(<span class="stringliteral">&#39;date&#39;</span>)(value, format, timezone);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        previousDate = null;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(attr.min) || attr.ngMin) {</div>
<div class="line">      var minVal;</div>
<div class="line">      ctrl.$validators.min = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !isValidDate(value) || isUndefined(minVal) || parseDate(value) &gt;= minVal;</div>
<div class="line">      };</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;min&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">        minVal = parseObservedDateValue(val);</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(attr.max) || attr.ngMax) {</div>
<div class="line">      var maxVal;</div>
<div class="line">      ctrl.$validators.max = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !isValidDate(value) || isUndefined(maxVal) || parseDate(value) &lt;= maxVal;</div>
<div class="line">      };</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;max&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">        maxVal = parseObservedDateValue(val);</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> isValidDate(value) {</div>
<div class="line">      <span class="comment">// Invalid Date: getTime() returns NaN</span></div>
<div class="line">      <span class="keywordflow">return</span> value &amp;&amp; !(value.getTime &amp;&amp; value.getTime() !== value.getTime());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> parseObservedDateValue(val) {</div>
<div class="line">      <span class="keywordflow">return</span> isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> badInputChecker(scope, element, attr, ctrl) {</div>
<div class="line">  var node = element[0];</div>
<div class="line">  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);</div>
<div class="line">  <span class="keywordflow">if</span> (nativeValidation) {</div>
<div class="line">    ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};</div>
<div class="line">      <span class="comment">// Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):</span></div>
<div class="line">      <span class="comment">// - also sets validity.badInput (should only be validity.typeMismatch).</span></div>
<div class="line">      <span class="comment">// - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)</span></div>
<div class="line">      <span class="comment">// - can ignore this case as we can still read out the erroneous email...</span></div>
<div class="line">      <span class="keywordflow">return</span> validity.badInput &amp;&amp; !validity.typeMismatch ? undefined : value;</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  badInputChecker(scope, element, attr, ctrl);</div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;number&#39;</span>;</div>
<div class="line">  ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$isEmpty(value))      <span class="keywordflow">return</span> null;</div>
<div class="line">    <span class="keywordflow">if</span> (NUMBER_REGEXP.test(value)) <span class="keywordflow">return</span> parseFloat(value);</div>
<div class="line">    <span class="keywordflow">return</span> undefined;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl.$isEmpty(value)) {</div>
<div class="line">      <span class="keywordflow">if</span> (!isNumber(value)) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;numfmt&#39;</span>, <span class="stringliteral">&#39;Expected `{0}` to be a number&#39;</span>, value);</div>
<div class="line">      }</div>
<div class="line">      value = value.toString();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(attr.min) || attr.ngMin) {</div>
<div class="line">    var minVal;</div>
<div class="line">    ctrl.$validators.min = <span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(minVal) || value &gt;= minVal;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    attr.$observe(<span class="stringliteral">&#39;min&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(val) &amp;&amp; !isNumber(val)) {</div>
<div class="line">        val = parseFloat(val, 10);</div>
<div class="line">      }</div>
<div class="line">      minVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;</div>
<div class="line">      <span class="comment">// TODO(matsko): implement validateLater to reduce number of validations</span></div>
<div class="line">      ctrl.$validate();</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(attr.max) || attr.ngMax) {</div>
<div class="line">    var maxVal;</div>
<div class="line">    ctrl.$validators.max = <span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(maxVal) || value &lt;= maxVal;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    attr.$observe(<span class="stringliteral">&#39;max&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(val) &amp;&amp; !isNumber(val)) {</div>
<div class="line">        val = parseFloat(val, 10);</div>
<div class="line">      }</div>
<div class="line">      maxVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;</div>
<div class="line">      <span class="comment">// TODO(matsko): implement validateLater to reduce number of validations</span></div>
<div class="line">      ctrl.$validate();</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  <span class="comment">// Note: no badInputChecker here by purpose as `url` is only a validation</span></div>
<div class="line">  <span class="comment">// in browsers, i.e. we can always read out input.value even if it is not valid!</span></div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">  stringBasedInputType(ctrl);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;url&#39;</span>;</div>
<div class="line">  ctrl.$validators.url = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">    var value = modelValue || viewValue;</div>
<div class="line">    <span class="keywordflow">return</span> ctrl.$isEmpty(value) || URL_REGEXP.test(value);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  <span class="comment">// Note: no badInputChecker here by purpose as `url` is only a validation</span></div>
<div class="line">  <span class="comment">// in browsers, i.e. we can always read out input.value even if it is not valid!</span></div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">  stringBasedInputType(ctrl);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;email&#39;</span>;</div>
<div class="line">  ctrl.$validators.email = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">    var value = modelValue || viewValue;</div>
<div class="line">    <span class="keywordflow">return</span> ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> radioInputType(scope, element, attr, ctrl) {</div>
<div class="line">  <span class="comment">// make the name unique, if not defined</span></div>
<div class="line">  <span class="keywordflow">if</span> (isUndefined(attr.name)) {</div>
<div class="line">    element.attr(<span class="stringliteral">&#39;name&#39;</span>, nextUid());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var listener = <span class="keyword">function</span>(ev) {</div>
<div class="line">    <span class="keywordflow">if</span> (element[0].checked) {</div>
<div class="line">      ctrl.$setViewValue(attr.value, ev &amp;&amp; ev.type);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  element.on(<span class="stringliteral">&#39;click&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    var value = attr.value;</div>
<div class="line">    element[0].checked = (value == ctrl.$viewValue);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  attr.$observe(<span class="stringliteral">&#39;value&#39;</span>, ctrl.$render);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> parseConstantExpr($parse, context, name, expression, fallback) {</div>
<div class="line">  var parseFn;</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(expression)) {</div>
<div class="line">    parseFn = $parse(expression);</div>
<div class="line">    <span class="keywordflow">if</span> (!parseFn.constant) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;constexpr&#39;</span>, <span class="stringliteral">&#39;Expected constant expression for `{0}`, but saw &#39;</span> +</div>
<div class="line">                                   <span class="stringliteral">&#39;`{1}`.&#39;</span>, name, expression);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> parseFn(context);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> fallback;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {</div>
<div class="line">  var trueValue = parseConstantExpr($parse, scope, <span class="stringliteral">&#39;ngTrueValue&#39;</span>, attr.ngTrueValue, <span class="keyword">true</span>);</div>
<div class="line">  var falseValue = parseConstantExpr($parse, scope, <span class="stringliteral">&#39;ngFalseValue&#39;</span>, attr.ngFalseValue, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">  var listener = <span class="keyword">function</span>(ev) {</div>
<div class="line">    ctrl.$setViewValue(element[0].checked, ev &amp;&amp; ev.type);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  element.on(<span class="stringliteral">&#39;click&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    element[0].checked = ctrl.$viewValue;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`</span></div>
<div class="line">  <span class="comment">// This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert</span></div>
<div class="line">  <span class="comment">// it to a boolean.</span></div>
<div class="line">  ctrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> value === <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> equals(value, trueValue);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> value ? trueValue : falseValue;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var inputDirective = [<span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$filter&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($browser, $sniffer, $filter, $parse) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    link: {</div>
<div class="line">      pre: <span class="keyword">function</span>(scope, element, attr, ctrls) {</div>
<div class="line">        <span class="keywordflow">if</span> (ctrls[0]) {</div>
<div class="line">          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,</div>
<div class="line">                                                              $browser, $filter, $parse);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var CONSTANT_VALUE_REGEXP = /^(<span class="keyword">true</span>|<span class="keyword">false</span>|\d+)$/;</div>
<div class="line">var ngValueDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    compile: <span class="keyword">function</span>(tpl, tplAttr) {</div>
<div class="line">      <span class="keywordflow">if</span> (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> ngValueConstantLink(scope, elm, attr) {</div>
<div class="line">          attr.$set(<span class="stringliteral">&#39;value&#39;</span>, scope.$eval(attr.ngValue));</div>
<div class="line">        };</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> ngValueLink(scope, elm, attr) {</div>
<div class="line">          scope.$watch(attr.ngValue, <span class="keyword">function</span> valueWatchAction(value) {</div>
<div class="line">            attr.$set(<span class="stringliteral">&#39;value&#39;</span>, value);</div>
<div class="line">          });</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var ngBindDirective = [<span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="stringliteral">&#39;AC&#39;</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindCompile(templateElement) {</div>
<div class="line">      $compile.$$addBindingClass(templateElement);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindLink(scope, element, attr) {</div>
<div class="line">        $compile.$$addBindingInfo(element, attr.ngBind);</div>
<div class="line">        element = element[0];</div>
<div class="line">        scope.$watch(attr.ngBind, <span class="keyword">function</span> ngBindWatchAction(value) {</div>
<div class="line">          element.textContent = value === undefined ? <span class="stringliteral">&#39;&#39;</span> : value;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngBindTemplateDirective = [<span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($interpolate, $compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindTemplateCompile(templateElement) {</div>
<div class="line">      $compile.$$addBindingClass(templateElement);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindTemplateLink(scope, element, attr) {</div>
<div class="line">        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));</div>
<div class="line">        $compile.$$addBindingInfo(element, interpolateFn.expressions);</div>
<div class="line">        element = element[0];</div>
<div class="line">        attr.$observe(<span class="stringliteral">&#39;ngBindTemplate&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">          element.textContent = value === undefined ? <span class="stringliteral">&#39;&#39;</span> : value;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngBindHtmlDirective = [<span class="stringliteral">&#39;$sce&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($sce, $parse, $compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindHtmlCompile(tElement, tAttrs) {</div>
<div class="line">      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);</div>
<div class="line">      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, <span class="keyword">function</span> getStringValue(value) {</div>
<div class="line">        <span class="keywordflow">return</span> (value || <span class="stringliteral">&#39;&#39;</span>).toString();</div>
<div class="line">      });</div>
<div class="line">      $compile.$$addBindingClass(tElement);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindHtmlLink(scope, element, attr) {</div>
<div class="line">        $compile.$$addBindingInfo(element, attr.ngBindHtml);</div>
<div class="line"></div>
<div class="line">        scope.$watch(ngBindHtmlWatch, <span class="keyword">function</span> ngBindHtmlWatchAction() {</div>
<div class="line">          <span class="comment">// we re-evaluate the expr because we want a TrustedValueHolderType</span></div>
<div class="line">          <span class="comment">// for $sce, not a string</span></div>
<div class="line">          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngChangeDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">  require: <span class="stringliteral">&#39;ngModel&#39;</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attr, ctrl) {</div>
<div class="line">    ctrl.$viewChangeListeners.push(<span class="keyword">function</span>() {</div>
<div class="line">      scope.$eval(attr.ngChange);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> classDirective(name, selector) {</div>
<div class="line">  name = <span class="stringliteral">&#39;ngClass&#39;</span> + name;</div>
<div class="line">  <span class="keywordflow">return</span> [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="stringliteral">&#39;AC&#39;</span>,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        var oldVal;</div>
<div class="line"></div>
<div class="line">        scope.$watch(attr[name], ngClassWatchAction, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">        attr.$observe(<span class="stringliteral">&#39;class&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">          ngClassWatchAction(scope.$eval(attr[name]));</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (name !== <span class="stringliteral">&#39;ngClass&#39;</span>) {</div>
<div class="line">          scope.$watch(<span class="stringliteral">&#39;$index&#39;</span>, <span class="keyword">function</span>($index, old$index) {</div>
<div class="line">            <span class="comment">// jshint bitwise: false</span></div>
<div class="line">            var mod = $index &amp; 1;</div>
<div class="line">            <span class="keywordflow">if</span> (mod !== (old$index &amp; 1)) {</div>
<div class="line">              var classes = arrayClasses(scope.$eval(attr[name]));</div>
<div class="line">              mod === selector ?</div>
<div class="line">                addClasses(classes) :</div>
<div class="line">                removeClasses(classes);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> addClasses(classes) {</div>
<div class="line">          var newClasses = digestClassCounts(classes, 1);</div>
<div class="line">          attr.$addClass(newClasses);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> removeClasses(classes) {</div>
<div class="line">          var newClasses = digestClassCounts(classes, -1);</div>
<div class="line">          attr.$removeClass(newClasses);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> digestClassCounts(classes, count) {</div>
<div class="line">          <span class="comment">// Use createMap() to prevent class assumptions involving property</span></div>
<div class="line">          <span class="comment">// names in Object.prototype</span></div>
<div class="line">          var classCounts = element.data(<span class="stringliteral">&#39;$classCounts&#39;</span>) || createMap();</div>
<div class="line">          var classesToUpdate = [];</div>
<div class="line">          forEach(classes, <span class="keyword">function</span>(className) {</div>
<div class="line">            <span class="keywordflow">if</span> (count &gt; 0 || classCounts[className]) {</div>
<div class="line">              classCounts[className] = (classCounts[className] || 0) + count;</div>
<div class="line">              <span class="keywordflow">if</span> (classCounts[className] === +(count &gt; 0)) {</div>
<div class="line">                classesToUpdate.push(className);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          element.data(<span class="stringliteral">&#39;$classCounts&#39;</span>, classCounts);</div>
<div class="line">          <span class="keywordflow">return</span> classesToUpdate.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> updateClasses(oldClasses, newClasses) {</div>
<div class="line">          var toAdd = arrayDifference(newClasses, oldClasses);</div>
<div class="line">          var toRemove = arrayDifference(oldClasses, newClasses);</div>
<div class="line">          toAdd = digestClassCounts(toAdd, 1);</div>
<div class="line">          toRemove = digestClassCounts(toRemove, -1);</div>
<div class="line">          <span class="keywordflow">if</span> (toAdd &amp;&amp; toAdd.length) {</div>
<div class="line">            $animate.addClass(element, toAdd);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (toRemove &amp;&amp; toRemove.length) {</div>
<div class="line">            $animate.removeClass(element, toRemove);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> ngClassWatchAction(newVal) {</div>
<div class="line">          <span class="keywordflow">if</span> (selector === <span class="keyword">true</span> || scope.$index % 2 === selector) {</div>
<div class="line">            var newClasses = arrayClasses(newVal || []);</div>
<div class="line">            <span class="keywordflow">if</span> (!oldVal) {</div>
<div class="line">              addClasses(newClasses);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!equals(newVal,oldVal)) {</div>
<div class="line">              var oldClasses = arrayClasses(oldVal);</div>
<div class="line">              updateClasses(oldClasses, newClasses);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          oldVal = shallowCopy(newVal);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> arrayDifference(tokens1, tokens2) {</div>
<div class="line">      var values = [];</div>
<div class="line"></div>
<div class="line">      outer:</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; tokens1.length; i++) {</div>
<div class="line">        var token = tokens1[i];</div>
<div class="line">        <span class="keywordflow">for</span> (var j = 0; j &lt; tokens2.length; j++) {</div>
<div class="line">          <span class="keywordflow">if</span> (token == tokens2[j]) <span class="keywordflow">continue</span> outer;</div>
<div class="line">        }</div>
<div class="line">        values.push(token);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> values;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> arrayClasses(classVal) {</div>
<div class="line">      var classes = [];</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(classVal)) {</div>
<div class="line">        forEach(classVal, <span class="keyword">function</span>(v) {</div>
<div class="line">          classes = classes.concat(arrayClasses(v));</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> classes;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(classVal)) {</div>
<div class="line">        <span class="keywordflow">return</span> classVal.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(classVal)) {</div>
<div class="line">        forEach(classVal, <span class="keyword">function</span>(v, k) {</div>
<div class="line">          <span class="keywordflow">if</span> (v) {</div>
<div class="line">            classes = classes.concat(k.split(<span class="charliteral">&#39; &#39;</span>));</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> classes;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> classVal;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngClassDirective = classDirective(<span class="stringliteral">&#39;&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">var ngClassOddDirective = classDirective(<span class="stringliteral">&#39;Odd&#39;</span>, 0);</div>
<div class="line"></div>
<div class="line">var ngClassEvenDirective = classDirective(<span class="stringliteral">&#39;Even&#39;</span>, 1);</div>
<div class="line"></div>
<div class="line">var ngCloakDirective = ngDirective({</div>
<div class="line">  compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">    attr.$set(<span class="stringliteral">&#39;ngCloak&#39;</span>, undefined);</div>
<div class="line">    element.removeClass(<span class="stringliteral">&#39;ng-cloak&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngControllerDirective = [<span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    scope: <span class="keyword">true</span>,</div>
<div class="line">    controller: <span class="charliteral">&#39;@&#39;</span>,</div>
<div class="line">    priority: 500</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"><span class="comment">// ngCsp is not implemented as a proper directive any more, because we need it be processed while we</span></div>
<div class="line"><span class="comment">// bootstrap the system (before $parse is instantiated), for this reason we just have</span></div>
<div class="line"><span class="comment">// the csp() fn that looks for the `ng-csp` attribute anywhere in the current doc</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * A collection of directives that allows creation of custom event handlers that are defined as</span></div>
<div class="line"><span class="comment"> * angular expressions and are compiled and executed within the current scope.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">var ngEventDirectives = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// For events that might fire synchronously during DOM manipulation</span></div>
<div class="line"><span class="comment">// we need to execute their event handlers asynchronously using $evalAsync,</span></div>
<div class="line"><span class="comment">// so that they are not executed in an inconsistent state.</span></div>
<div class="line">var forceAsyncEvents = {</div>
<div class="line">  <span class="stringliteral">&#39;blur&#39;</span>: <span class="keyword">true</span>,</div>
<div class="line">  <span class="stringliteral">&#39;focus&#39;</span>: <span class="keyword">true</span></div>
<div class="line">};</div>
<div class="line">forEach(</div>
<div class="line">  <span class="stringliteral">&#39;click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste&#39;</span>.split(<span class="charliteral">&#39; &#39;</span>),</div>
<div class="line">  <span class="keyword">function</span>(eventName) {</div>
<div class="line">    var directiveName = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + eventName);</div>
<div class="line">    ngEventDirectives[directiveName] = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($parse, $rootScope) {</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">        compile: <span class="keyword">function</span>($element, attr) {</div>
<div class="line">          <span class="comment">// We expose the powerful $event object on the scope that provides access to the Window,</span></div>
<div class="line">          <span class="comment">// etc. that isn&#39;t protected by the fast paths in $parse.  We explicitly request better</span></div>
<div class="line">          <span class="comment">// checks at the cost of speed since event handler expressions are not executed as</span></div>
<div class="line">          <span class="comment">// frequently as regular change detection.</span></div>
<div class="line">          var fn = $parse(attr[directiveName], <span class="comment">/* interceptorFn */</span> null, <span class="comment">/* expensiveChecks */</span> <span class="keyword">true</span>);</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span> ngEventHandler(scope, element) {</div>
<div class="line">            element.on(eventName, <span class="keyword">function</span>(event) {</div>
<div class="line">              var callback = <span class="keyword">function</span>() {</div>
<div class="line">                fn(scope, {$event:event});</div>
<div class="line">              };</div>
<div class="line">              <span class="keywordflow">if</span> (forceAsyncEvents[eventName] &amp;&amp; $rootScope.$$phase) {</div>
<div class="line">                scope.$evalAsync(callback);</div>
<div class="line">              } <span class="keywordflow">else</span> {</div>
<div class="line">                scope.$apply(callback);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }];</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">var ngIfDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    priority: 600,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    $$tlb: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>($scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line">        var block, childScope, previousElements;</div>
<div class="line">        $scope.$watch($attr.ngIf, <span class="keyword">function</span> ngIfWatchAction(value) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (value) {</div>
<div class="line">            <span class="keywordflow">if</span> (!childScope) {</div>
<div class="line">              $transclude(<span class="keyword">function</span>(clone, newScope) {</div>
<div class="line">                childScope = newScope;</div>
<div class="line">                clone[clone.length++] = document.createComment(<span class="stringliteral">&#39; end ngIf: &#39;</span> + $attr.ngIf + <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">                <span class="comment">// Note: We only need the first/last node of the cloned nodes.</span></div>
<div class="line">                <span class="comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span></div>
<div class="line">                <span class="comment">// by a directive with templateUrl when its template arrives.</span></div>
<div class="line">                block = {</div>
<div class="line">                  clone: clone</div>
<div class="line">                };</div>
<div class="line">                $animate.enter(clone, $element.parent(), $element);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (previousElements) {</div>
<div class="line">              previousElements.remove();</div>
<div class="line">              previousElements = null;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (childScope) {</div>
<div class="line">              childScope.$destroy();</div>
<div class="line">              childScope = null;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (block) {</div>
<div class="line">              previousElements = getBlockNodes(block.clone);</div>
<div class="line">              $animate.leave(previousElements).then(<span class="keyword">function</span>() {</div>
<div class="line">                previousElements = null;</div>
<div class="line">              });</div>
<div class="line">              block = null;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngIncludeDirective = [<span class="stringliteral">&#39;$templateRequest&#39;</span>, <span class="stringliteral">&#39;$anchorScroll&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>,</div>
<div class="line">                  <span class="keyword">function</span>($templateRequest,   $anchorScroll,   $animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="stringliteral">&#39;ECA&#39;</span>,</div>
<div class="line">    priority: 400,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    controller: angular.noop,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">      var srcExp = attr.ngInclude || attr.src,</div>
<div class="line">          onloadExp = attr.onload || <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">          autoScrollExp = attr.autoscroll;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line">        var changeCounter = 0,</div>
<div class="line">            currentScope,</div>
<div class="line">            previousElement,</div>
<div class="line">            currentElement;</div>
<div class="line"></div>
<div class="line">        var cleanupLastIncludeContent = <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (previousElement) {</div>
<div class="line">            previousElement.remove();</div>
<div class="line">            previousElement = null;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (currentScope) {</div>
<div class="line">            currentScope.$destroy();</div>
<div class="line">            currentScope = null;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (currentElement) {</div>
<div class="line">            $animate.leave(currentElement).then(<span class="keyword">function</span>() {</div>
<div class="line">              previousElement = null;</div>
<div class="line">            });</div>
<div class="line">            previousElement = currentElement;</div>
<div class="line">            currentElement = null;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        scope.$watch(srcExp, <span class="keyword">function</span> ngIncludeWatchAction(src) {</div>
<div class="line">          var afterAnimation = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) {</div>
<div class="line">              $anchorScroll();</div>
<div class="line">            }</div>
<div class="line">          };</div>
<div class="line">          var thisChangeId = ++changeCounter;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (src) {</div>
<div class="line">            <span class="comment">//set the 2nd param to true to ignore the template request error so that the inner</span></div>
<div class="line">            <span class="comment">//contents and scope can be cleaned up.</span></div>
<div class="line">            $templateRequest(src, <span class="keyword">true</span>).then(<span class="keyword">function</span>(response) {</div>
<div class="line">              <span class="keywordflow">if</span> (thisChangeId !== changeCounter) <span class="keywordflow">return</span>;</div>
<div class="line">              var newScope = scope.$new();</div>
<div class="line">              ctrl.template = response;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Note: This will also link all children of ng-include that were contained in the original</span></div>
<div class="line">              <span class="comment">// html. If that content contains controllers, ... they could pollute/change the scope.</span></div>
<div class="line">              <span class="comment">// However, using ng-include on an element with additional content does not make sense...</span></div>
<div class="line">              <span class="comment">// Note: We can&#39;t remove them in the cloneAttchFn of $transclude as that</span></div>
<div class="line">              <span class="comment">// function is called before linking the content, which would apply child</span></div>
<div class="line">              <span class="comment">// directives to non existing elements.</span></div>
<div class="line">              var clone = $transclude(newScope, <span class="keyword">function</span>(clone) {</div>
<div class="line">                cleanupLastIncludeContent();</div>
<div class="line">                $animate.enter(clone, null, $element).then(afterAnimation);</div>
<div class="line">              });</div>
<div class="line"></div>
<div class="line">              currentScope = newScope;</div>
<div class="line">              currentElement = clone;</div>
<div class="line"></div>
<div class="line">              currentScope.$emit(<span class="stringliteral">&#39;$includeContentLoaded&#39;</span>, src);</div>
<div class="line">              scope.$eval(onloadExp);</div>
<div class="line">            }, <span class="keyword">function</span>() {</div>
<div class="line">              <span class="keywordflow">if</span> (thisChangeId === changeCounter) {</div>
<div class="line">                cleanupLastIncludeContent();</div>
<div class="line">                scope.$emit(<span class="stringliteral">&#39;$includeContentError&#39;</span>, src);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            scope.$emit(<span class="stringliteral">&#39;$includeContentRequested&#39;</span>, src);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            cleanupLastIncludeContent();</div>
<div class="line">            ctrl.template = null;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"><span class="comment">// This directive is called during the $transclude call of the first `ngInclude` directive.</span></div>
<div class="line"><span class="comment">// It will replace and compile the content of the element with the loaded template.</span></div>
<div class="line"><span class="comment">// We need this directive so that the element content is already filled when</span></div>
<div class="line"><span class="comment">// the link function of another directive on the same element as ngInclude</span></div>
<div class="line"><span class="comment">// is called.</span></div>
<div class="line">var ngIncludeFillContentDirective = [<span class="stringliteral">&#39;$compile&#39;</span>,</div>
<div class="line">  <span class="keyword">function</span>($compile) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="stringliteral">&#39;ECA&#39;</span>,</div>
<div class="line">      priority: -400,</div>
<div class="line">      require: <span class="stringliteral">&#39;ngInclude&#39;</span>,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, $element, $attr, ctrl) {</div>
<div class="line">        <span class="keywordflow">if</span> (/SVG/.test($element[0].toString())) {</div>
<div class="line">          <span class="comment">// WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not</span></div>
<div class="line">          <span class="comment">// support innerHTML, so detect this here and try to generate the contents</span></div>
<div class="line">          <span class="comment">// specially.</span></div>
<div class="line">          $element.empty();</div>
<div class="line">          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,</div>
<div class="line">              <span class="keyword">function</span> namespaceAdaptedClone(clone) {</div>
<div class="line">            $element.append(clone);</div>
<div class="line">          }, {futureParentElement: $element});</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        $element.html(ctrl.template);</div>
<div class="line">        $compile($element.contents())(scope);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line"></div>
<div class="line">var ngInitDirective = ngDirective({</div>
<div class="line">  priority: 450,</div>
<div class="line">  compile: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      pre: <span class="keyword">function</span>(scope, element, attrs) {</div>
<div class="line">        scope.$eval(attrs.ngInit);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngListDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    require: <span class="stringliteral">&#39;ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ctrl) {</div>
<div class="line">      <span class="comment">// We want to control whitespace trimming so we use this convoluted approach</span></div>
<div class="line">      <span class="comment">// to access the ngList attribute, which doesn&#39;t pre-trim the attribute</span></div>
<div class="line">      var ngList = element.attr(attr.$attr.ngList) || <span class="stringliteral">&#39;, &#39;</span>;</div>
<div class="line">      var trimValues = attr.ngTrim !== <span class="stringliteral">&#39;false&#39;</span>;</div>
<div class="line">      var separator = trimValues ? trim(ngList) : ngList;</div>
<div class="line"></div>
<div class="line">      var parse = <span class="keyword">function</span>(viewValue) {</div>
<div class="line">        <span class="comment">// If the viewValue is invalid (say required but empty) it will be `undefined`</span></div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(viewValue)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        var list = [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (viewValue) {</div>
<div class="line">          forEach(viewValue.split(separator), <span class="keyword">function</span>(value) {</div>
<div class="line">            <span class="keywordflow">if</span> (value) list.push(trimValues ? trim(value) : value);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> list;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      ctrl.$parsers.push(parse);</div>
<div class="line">      ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (isArray(value)) {</div>
<div class="line">          <span class="keywordflow">return</span> value.join(ngList);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> undefined;</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Override the standard $isEmpty because an empty array means the input is empty.</span></div>
<div class="line">      ctrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !value || !value.length;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global VALID_CLASS: true,</span></div>
<div class="line"><span class="comment">  INVALID_CLASS: true,</span></div>
<div class="line"><span class="comment">  PRISTINE_CLASS: true,</span></div>
<div class="line"><span class="comment">  DIRTY_CLASS: true,</span></div>
<div class="line"><span class="comment">  UNTOUCHED_CLASS: true,</span></div>
<div class="line"><span class="comment">  TOUCHED_CLASS: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line">var VALID_CLASS = <span class="stringliteral">&#39;ng-valid&#39;</span>,</div>
<div class="line">    INVALID_CLASS = <span class="stringliteral">&#39;ng-invalid&#39;</span>,</div>
<div class="line">    PRISTINE_CLASS = <span class="stringliteral">&#39;ng-pristine&#39;</span>,</div>
<div class="line">    DIRTY_CLASS = <span class="stringliteral">&#39;ng-dirty&#39;</span>,</div>
<div class="line">    UNTOUCHED_CLASS = <span class="stringliteral">&#39;ng-untouched&#39;</span>,</div>
<div class="line">    TOUCHED_CLASS = <span class="stringliteral">&#39;ng-touched&#39;</span>,</div>
<div class="line">    PENDING_CLASS = <span class="stringliteral">&#39;ng-pending&#39;</span>;</div>
<div class="line"></div>
<div class="line">var ngModelMinErr = minErr(<span class="stringliteral">&#39;ngModel&#39;</span>);</div>
<div class="line"></div>
<div class="line">var NgModelController = [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$timeout&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {</div>
<div class="line">  this.$viewValue = Number.NaN;</div>
<div class="line">  this.$modelValue = Number.NaN;</div>
<div class="line">  this.$$rawModelValue = undefined; <span class="comment">// stores the parsed modelValue / model set from scope regardless of validity.</span></div>
<div class="line">  this.$validators = {};</div>
<div class="line">  this.$asyncValidators = {};</div>
<div class="line">  this.$parsers = [];</div>
<div class="line">  this.$formatters = [];</div>
<div class="line">  this.$viewChangeListeners = [];</div>
<div class="line">  this.$untouched = <span class="keyword">true</span>;</div>
<div class="line">  this.$touched = <span class="keyword">false</span>;</div>
<div class="line">  this.$pristine = <span class="keyword">true</span>;</div>
<div class="line">  this.$dirty = <span class="keyword">false</span>;</div>
<div class="line">  this.$valid = <span class="keyword">true</span>;</div>
<div class="line">  this.$invalid = <span class="keyword">false</span>;</div>
<div class="line">  this.$error = {}; <span class="comment">// keep invalid keys here</span></div>
<div class="line">  this.$$success = {}; <span class="comment">// keep valid keys here</span></div>
<div class="line">  this.$pending = undefined; <span class="comment">// keep pending keys here</span></div>
<div class="line">  this.$name = $interpolate($attr.name || <span class="stringliteral">&#39;&#39;</span>, <span class="keyword">false</span>)($scope);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  var parsedNgModel = $parse($attr.ngModel),</div>
<div class="line">      parsedNgModelAssign = parsedNgModel.assign,</div>
<div class="line">      ngModelGet = parsedNgModel,</div>
<div class="line">      ngModelSet = parsedNgModelAssign,</div>
<div class="line">      pendingDebounce = null,</div>
<div class="line">      parserValid,</div>
<div class="line">      ctrl = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.$$setOptions = <span class="keyword">function</span>(options) {</div>
<div class="line">    ctrl.$options = options;</div>
<div class="line">    <span class="keywordflow">if</span> (options &amp;&amp; options.getterSetter) {</div>
<div class="line">      var invokeModelGetter = $parse($attr.ngModel + <span class="stringliteral">&#39;()&#39;</span>),</div>
<div class="line">          invokeModelSetter = $parse($attr.ngModel + <span class="stringliteral">&#39;($$$p)&#39;</span>);</div>
<div class="line"></div>
<div class="line">      ngModelGet = <span class="keyword">function</span>($scope) {</div>
<div class="line">        var modelValue = parsedNgModel($scope);</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(modelValue)) {</div>
<div class="line">          modelValue = invokeModelGetter($scope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> modelValue;</div>
<div class="line">      };</div>
<div class="line">      ngModelSet = <span class="keyword">function</span>($scope, newValue) {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(parsedNgModel($scope))) {</div>
<div class="line">          invokeModelSetter($scope, {$$$p: ctrl.$modelValue});</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          parsedNgModelAssign($scope, ctrl.$modelValue);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!parsedNgModel.assign) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;nonassign&#39;</span>, <span class="stringliteral">&quot;Expression &#39;{0}&#39; is non-assignable. Element: {1}&quot;</span>,</div>
<div class="line">          $attr.ngModel, startingTag($element));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$render = noop;</div>
<div class="line"></div>
<div class="line">  this.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> isUndefined(value) || value === <span class="stringliteral">&#39;&#39;</span> || value === null || value !== value;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var parentForm = $element.inheritedData(<span class="stringliteral">&#39;$formController&#39;</span>) || nullFormCtrl,</div>
<div class="line">      currentValidationRunId = 0;</div>
<div class="line"></div>
<div class="line">  addSetValidityMethod({</div>
<div class="line">    ctrl: <span class="keyword">this</span>,</div>
<div class="line">    $element: $element,</div>
<div class="line">    set: <span class="keyword">function</span>(object, property) {</div>
<div class="line">      <span class="keywordtype">object</span>[property] = <span class="keyword">true</span>;</div>
<div class="line">    },</div>
<div class="line">    unset: <span class="keyword">function</span>(object, property) {</div>
<div class="line">      <span class="keyword">delete</span> <span class="keywordtype">object</span>[property];</div>
<div class="line">    },</div>
<div class="line">    parentForm: parentForm,</div>
<div class="line">    $animate: $animate</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  this.$setPristine = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$dirty = <span class="keyword">false</span>;</div>
<div class="line">    ctrl.$pristine = <span class="keyword">true</span>;</div>
<div class="line">    $animate.removeClass($element, DIRTY_CLASS);</div>
<div class="line">    $animate.addClass($element, PRISTINE_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setDirty = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$dirty = <span class="keyword">true</span>;</div>
<div class="line">    ctrl.$pristine = <span class="keyword">false</span>;</div>
<div class="line">    $animate.removeClass($element, PRISTINE_CLASS);</div>
<div class="line">    $animate.addClass($element, DIRTY_CLASS);</div>
<div class="line">    parentForm.$setDirty();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setUntouched = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$touched = <span class="keyword">false</span>;</div>
<div class="line">    ctrl.$untouched = <span class="keyword">true</span>;</div>
<div class="line">    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setTouched = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$touched = <span class="keyword">true</span>;</div>
<div class="line">    ctrl.$untouched = <span class="keyword">false</span>;</div>
<div class="line">    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$rollbackViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line">    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    ctrl.$render();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$validate = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// ignore $validate before model is initialized</span></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    <span class="comment">// Note: we use the $$rawModelValue as $modelValue might have been</span></div>
<div class="line">    <span class="comment">// set to undefined during a view -&gt; model update that found validation</span></div>
<div class="line">    <span class="comment">// errors. We can&#39;t parse the view here, since that could change</span></div>
<div class="line">    <span class="comment">// the model although neither viewValue nor the model on the scope changed</span></div>
<div class="line">    var modelValue = ctrl.$$rawModelValue;</div>
<div class="line"></div>
<div class="line">    var prevValid = ctrl.$valid;</div>
<div class="line">    var prevModelValue = ctrl.$modelValue;</div>
<div class="line"></div>
<div class="line">    var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;</div>
<div class="line"></div>
<div class="line">    ctrl.$$runValidators(modelValue, viewValue, <span class="keyword">function</span>(allValid) {</div>
<div class="line">      <span class="comment">// If there was no change in validity, don&#39;t update the model</span></div>
<div class="line">      <span class="comment">// This prevents changing an invalid modelValue to undefined</span></div>
<div class="line">      <span class="keywordflow">if</span> (!allowInvalid &amp;&amp; prevValid !== allValid) {</div>
<div class="line">        <span class="comment">// Note: Don&#39;t check ctrl.$valid here, as we could have</span></div>
<div class="line">        <span class="comment">// external validators (e.g. calculated on the server),</span></div>
<div class="line">        <span class="comment">// that just call $setValidity and need the model value</span></div>
<div class="line">        <span class="comment">// to calculate their validity.</span></div>
<div class="line">        ctrl.$modelValue = allValid ? modelValue : undefined;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (ctrl.$modelValue !== prevModelValue) {</div>
<div class="line">          ctrl.$$writeModelToScope();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$runValidators = <span class="keyword">function</span>(modelValue, viewValue, doneCallback) {</div>
<div class="line">    currentValidationRunId++;</div>
<div class="line">    var localValidationRunId = currentValidationRunId;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check parser error</span></div>
<div class="line">    <span class="keywordflow">if</span> (!processParseErrors()) {</div>
<div class="line">      validationDone(<span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!processSyncValidators()) {</div>
<div class="line">      validationDone(<span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    processAsyncValidators();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processParseErrors() {</div>
<div class="line">      var errorKey = ctrl.$$parserName || <span class="stringliteral">&#39;parse&#39;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (parserValid === undefined) {</div>
<div class="line">        setValidity(errorKey, null);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (!parserValid) {</div>
<div class="line">          forEach(ctrl.$validators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">            setValidity(name, null);</div>
<div class="line">          });</div>
<div class="line">          forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">            setValidity(name, null);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Set the parse error last, to prevent unsetting it, should a $validators key == parserName</span></div>
<div class="line">        setValidity(errorKey, parserValid);</div>
<div class="line">        <span class="keywordflow">return</span> parserValid;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processSyncValidators() {</div>
<div class="line">      var syncValidatorsValid = <span class="keyword">true</span>;</div>
<div class="line">      forEach(ctrl.$validators, <span class="keyword">function</span>(validator, name) {</div>
<div class="line">        var result = validator(modelValue, viewValue);</div>
<div class="line">        syncValidatorsValid = syncValidatorsValid &amp;&amp; result;</div>
<div class="line">        setValidity(name, result);</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!syncValidatorsValid) {</div>
<div class="line">        forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">          setValidity(name, null);</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processAsyncValidators() {</div>
<div class="line">      var validatorPromises = [];</div>
<div class="line">      var allValid = <span class="keyword">true</span>;</div>
<div class="line">      forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(validator, name) {</div>
<div class="line">        var promise = validator(modelValue, viewValue);</div>
<div class="line">        if (!isPromiseLike(promise)) {</div>
<div class="line">          throw ngModelMinErr(<span class="stringliteral">&quot;$asyncValidators&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Expected asynchronous validator to return a promise but got &#39;{0}&#39; instead.&quot;</span>, promise);</div>
<div class="line">        }</div>
<div class="line">        setValidity(name, undefined);</div>
<div class="line">        validatorPromises.push(promise.then(<span class="keyword">function</span>() {</div>
<div class="line">          setValidity(name, true);</div>
<div class="line">        }, <span class="keyword">function</span>(error) {</div>
<div class="line">          allValid = false;</div>
<div class="line">          setValidity(name, false);</div>
<div class="line">        }));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!validatorPromises.length) {</div>
<div class="line">        validationDone(<span class="keyword">true</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        $q.all(validatorPromises).then(<span class="keyword">function</span>() {</div>
<div class="line">          validationDone(allValid);</div>
<div class="line">        }, noop);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> setValidity(name, isValid) {</div>
<div class="line">      <span class="keywordflow">if</span> (localValidationRunId === currentValidationRunId) {</div>
<div class="line">        ctrl.$setValidity(name, isValid);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> validationDone(allValid) {</div>
<div class="line">      <span class="keywordflow">if</span> (localValidationRunId === currentValidationRunId) {</div>
<div class="line"></div>
<div class="line">        doneCallback(allValid);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$commitViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    var viewValue = ctrl.$viewValue;</div>
<div class="line"></div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If the view value has not changed then we should just exit, except in the case where there is</span></div>
<div class="line">    <span class="comment">// a native validator on the element. In this case the validation state may have changed even though</span></div>
<div class="line">    <span class="comment">// the viewValue has stayed empty.</span></div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$$lastCommittedViewValue === viewValue &amp;&amp; (viewValue !== <span class="stringliteral">&#39;&#39;</span> || !ctrl.$$hasNativeValidators)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    ctrl.$$lastCommittedViewValue = viewValue;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// change to dirty</span></div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pristine) {</div>
<div class="line">      this.$setDirty();</div>
<div class="line">    }</div>
<div class="line">    this.$$parseAndValidate();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseAndValidate = <span class="keyword">function</span>() {</div>
<div class="line">    var viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    var modelValue = viewValue;</div>
<div class="line">    parserValid = isUndefined(modelValue) ? undefined : <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (parserValid) {</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; ctrl.$parsers.length; i++) {</div>
<div class="line">        modelValue = ctrl.$parsers[i](modelValue);</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(modelValue)) {</div>
<div class="line">          parserValid = <span class="keyword">false</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {</div>
<div class="line">      <span class="comment">// ctrl.$modelValue has not been touched yet...</span></div>
<div class="line">      ctrl.$modelValue = ngModelGet($scope);</div>
<div class="line">    }</div>
<div class="line">    var prevModelValue = ctrl.$modelValue;</div>
<div class="line">    var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;</div>
<div class="line">    ctrl.$$rawModelValue = modelValue;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (allowInvalid) {</div>
<div class="line">      ctrl.$modelValue = modelValue;</div>
<div class="line">      writeToModelIfNeeded();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.</span></div>
<div class="line">    <span class="comment">// This can happen if e.g. $setViewValue is called from inside a parser</span></div>
<div class="line">    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, <span class="keyword">function</span>(allValid) {</div>
<div class="line">      if (!allowInvalid) {</div>
<div class="line">        <span class="comment">// Note: Don&#39;t check ctrl.$valid here, as we could have</span></div>
<div class="line">        <span class="comment">// external validators (e.g. calculated on the server),</span></div>
<div class="line">        <span class="comment">// that just call $setValidity and need the model value</span></div>
<div class="line">        <span class="comment">// to calculate their validity.</span></div>
<div class="line">        ctrl.$modelValue = allValid ? modelValue : undefined;</div>
<div class="line">        writeToModelIfNeeded();</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> writeToModelIfNeeded() {</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$modelValue !== prevModelValue) {</div>
<div class="line">        ctrl.$$writeModelToScope();</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$writeModelToScope = <span class="keyword">function</span>() {</div>
<div class="line">    ngModelSet($scope, ctrl.$modelValue);</div>
<div class="line">    forEach(ctrl.$viewChangeListeners, <span class="keyword">function</span>(listener) {</div>
<div class="line">      try {</div>
<div class="line">        listener();</div>
<div class="line">      } catch (e) {</div>
<div class="line">        $exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setViewValue = <span class="keyword">function</span>(value, trigger) {</div>
<div class="line">    ctrl.$viewValue = value;</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl.$options || ctrl.$options.updateOnDefault) {</div>
<div class="line">      ctrl.$$debounceViewValueCommit(trigger);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$debounceViewValueCommit = <span class="keyword">function</span>(trigger) {</div>
<div class="line">    var debounceDelay = 0,</div>
<div class="line">        options = ctrl.$options,</div>
<div class="line">        debounce;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (options &amp;&amp; isDefined(options.debounce)) {</div>
<div class="line">      debounce = options.debounce;</div>
<div class="line">      <span class="keywordflow">if</span> (isNumber(debounce)) {</div>
<div class="line">        debounceDelay = debounce;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNumber(debounce[trigger])) {</div>
<div class="line">        debounceDelay = debounce[trigger];</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNumber(debounce[<span class="stringliteral">&#39;default&#39;</span>])) {</div>
<div class="line">        debounceDelay = debounce[<span class="stringliteral">&#39;default&#39;</span>];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line">    <span class="keywordflow">if</span> (debounceDelay) {</div>
<div class="line">      pendingDebounce = $timeout(<span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$commitViewValue();</div>
<div class="line">      }, debounceDelay);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ($rootScope.$$phase) {</div>
<div class="line">      ctrl.$commitViewValue();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      $scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$commitViewValue();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// model -&gt; value</span></div>
<div class="line">  <span class="comment">// Note: we cannot use a normal scope.$watch as we want to detect the following:</span></div>
<div class="line">  <span class="comment">// 1. scope value is &#39;a&#39;</span></div>
<div class="line">  <span class="comment">// 2. user enters &#39;b&#39;</span></div>
<div class="line">  <span class="comment">// 3. ng-change kicks in and reverts scope value to &#39;a&#39;</span></div>
<div class="line">  <span class="comment">//    -&gt; scope value did not change since the last digest as</span></div>
<div class="line">  <span class="comment">//       ng-change executes in apply phase</span></div>
<div class="line">  <span class="comment">// 4. view should be changed back to &#39;a&#39;</span></div>
<div class="line">  $scope.$watch(<span class="keyword">function</span> ngModelWatch() {</div>
<div class="line">    var modelValue = ngModelGet($scope);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if scope model value and ngModel value are out of sync</span></div>
<div class="line">    <span class="comment">// TODO(perf): why not move this to the action fn?</span></div>
<div class="line">    <span class="keywordflow">if</span> (modelValue !== ctrl.$modelValue &amp;&amp;</div>
<div class="line">       <span class="comment">// checks for NaN is needed to allow setting the model to NaN when there&#39;s an asyncValidator</span></div>
<div class="line">       (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)</div>
<div class="line">    ) {</div>
<div class="line">      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;</div>
<div class="line">      parserValid = undefined;</div>
<div class="line"></div>
<div class="line">      var formatters = ctrl.$formatters,</div>
<div class="line">          idx = formatters.length;</div>
<div class="line"></div>
<div class="line">      var viewValue = modelValue;</div>
<div class="line">      <span class="keywordflow">while</span> (idx--) {</div>
<div class="line">        viewValue = formatters[idx](viewValue);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$viewValue !== viewValue) {</div>
<div class="line">        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;</div>
<div class="line">        ctrl.$render();</div>
<div class="line"></div>
<div class="line">        ctrl.$$runValidators(modelValue, viewValue, noop);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> modelValue;</div>
<div class="line">  });</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngModelDirective = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($rootScope) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;ngModel&#39;</span>, <span class="stringliteral">&#39;^?form&#39;</span>, <span class="stringliteral">&#39;^?ngModelOptions&#39;</span>],</div>
<div class="line">    controller: NgModelController,</div>
<div class="line">    <span class="comment">// Prelink needs to run before any input directive</span></div>
<div class="line">    <span class="comment">// so that we can set the NgModelOptions in NgModelController</span></div>
<div class="line">    <span class="comment">// before anyone else uses it.</span></div>
<div class="line">    priority: 1,</div>
<div class="line">    compile: <span class="keyword">function</span> ngModelCompile(element) {</div>
<div class="line">      <span class="comment">// Setup initial state of the control</span></div>
<div class="line">      element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        pre: <span class="keyword">function</span> ngModelPreLink(scope, element, attr, ctrls) {</div>
<div class="line">          var modelCtrl = ctrls[0],</div>
<div class="line">              formCtrl = ctrls[1] || nullFormCtrl;</div>
<div class="line"></div>
<div class="line">          modelCtrl.$$setOptions(ctrls[2] &amp;&amp; ctrls[2].$options);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// notify others, especially parent forms</span></div>
<div class="line">          formCtrl.$addControl(modelCtrl);</div>
<div class="line"></div>
<div class="line">          attr.$observe(<span class="stringliteral">&#39;name&#39;</span>, <span class="keyword">function</span>(newValue) {</div>
<div class="line">            <span class="keywordflow">if</span> (modelCtrl.$name !== newValue) {</div>
<div class="line">              formCtrl.$$renameControl(modelCtrl, newValue);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          scope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">            formCtrl.$removeControl(modelCtrl);</div>
<div class="line">          });</div>
<div class="line">        },</div>
<div class="line">        post: <span class="keyword">function</span> ngModelPostLink(scope, element, attr, ctrls) {</div>
<div class="line">          var modelCtrl = ctrls[0];</div>
<div class="line">          <span class="keywordflow">if</span> (modelCtrl.$options &amp;&amp; modelCtrl.$options.updateOn) {</div>
<div class="line">            element.on(modelCtrl.$options.updateOn, <span class="keyword">function</span>(ev) {</div>
<div class="line">              modelCtrl.$$debounceViewValueCommit(ev &amp;&amp; ev.type);</div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          element.on(<span class="stringliteral">&#39;blur&#39;</span>, <span class="keyword">function</span>(ev) {</div>
<div class="line">            <span class="keywordflow">if</span> (modelCtrl.$touched) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            if ($rootScope.$$phase) {</div>
<div class="line">              scope.$evalAsync(modelCtrl.$setTouched);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              scope.$apply(modelCtrl.$setTouched);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var DEFAULT_REGEXP = /(\s+|^)<span class="keywordflow">default</span>(\s+|$)/;</div>
<div class="line"></div>
<div class="line">var ngModelOptionsDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    controller: [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="keyword">function</span>($scope, $attrs) {</div>
<div class="line">      var that = <span class="keyword">this</span>;</div>
<div class="line">      this.$options = copy($scope.$eval($attrs.ngModelOptions));</div>
<div class="line">      <span class="comment">// Allow adding/overriding bound events</span></div>
<div class="line">      <span class="keywordflow">if</span> (this.$options.updateOn !== undefined) {</div>
<div class="line">        this.$options.updateOnDefault = <span class="keyword">false</span>;</div>
<div class="line">        <span class="comment">// extract &quot;default&quot; pseudo-event from list of events that can trigger a model update</span></div>
<div class="line">        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, <span class="keyword">function</span>() {</div>
<div class="line">          that.$options.updateOnDefault = true;</div>
<div class="line">          return <span class="stringliteral">&#39; &#39;</span>;</div>
<div class="line">        }));</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.$options.updateOnDefault = <span class="keyword">true</span>;</div>
<div class="line">      }</div>
<div class="line">    }]</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// helper methods</span></div>
<div class="line"><span class="keyword">function</span> addSetValidityMethod(context) {</div>
<div class="line">  var ctrl = context.ctrl,</div>
<div class="line">      $element = context.$element,</div>
<div class="line">      classCache = {},</div>
<div class="line">      set = context.set,</div>
<div class="line">      unset = context.unset,</div>
<div class="line">      parentForm = context.parentForm,</div>
<div class="line">      $animate = context.$animate;</div>
<div class="line"></div>
<div class="line">  classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));</div>
<div class="line"></div>
<div class="line">  ctrl.$setValidity = setValidity;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> setValidity(validationErrorKey, state, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (state === undefined) {</div>
<div class="line">      createAndSet(<span class="stringliteral">&#39;$pending&#39;</span>, validationErrorKey, controller);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      unsetAndCleanup(<span class="stringliteral">&#39;$pending&#39;</span>, validationErrorKey, controller);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!isBoolean(state)) {</div>
<div class="line">      unset(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">      unset(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (state) {</div>
<div class="line">        unset(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">        set(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        set(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">        unset(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pending) {</div>
<div class="line">      cachedToggleClass(PENDING_CLASS, <span class="keyword">true</span>);</div>
<div class="line">      ctrl.$valid = ctrl.$invalid = undefined;</div>
<div class="line">      toggleValidationCss(<span class="stringliteral">&#39;&#39;</span>, null);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      cachedToggleClass(PENDING_CLASS, <span class="keyword">false</span>);</div>
<div class="line">      ctrl.$valid = isObjectEmpty(ctrl.$error);</div>
<div class="line">      ctrl.$invalid = !ctrl.$valid;</div>
<div class="line">      toggleValidationCss(<span class="stringliteral">&#39;&#39;</span>, ctrl.$valid);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// re-read the state as the set/unset methods could have</span></div>
<div class="line">    <span class="comment">// combined state in ctrl.$error[validationError] (used for forms),</span></div>
<div class="line">    <span class="comment">// where setting/unsetting only increments/decrements the value,</span></div>
<div class="line">    <span class="comment">// and does not replace it.</span></div>
<div class="line">    var combinedState;</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pending &amp;&amp; ctrl.$pending[validationErrorKey]) {</div>
<div class="line">      combinedState = undefined;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctrl.$error[validationErrorKey]) {</div>
<div class="line">      combinedState = <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctrl.$$success[validationErrorKey]) {</div>
<div class="line">      combinedState = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      combinedState = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    toggleValidationCss(validationErrorKey, combinedState);</div>
<div class="line">    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> createAndSet(name, value, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl[name]) {</div>
<div class="line">      ctrl[name] = {};</div>
<div class="line">    }</div>
<div class="line">    set(ctrl[name], value, controller);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> unsetAndCleanup(name, value, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl[name]) {</div>
<div class="line">      unset(ctrl[name], value, controller);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObjectEmpty(ctrl[name])) {</div>
<div class="line">      ctrl[name] = undefined;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> cachedToggleClass(className, switchValue) {</div>
<div class="line">    <span class="keywordflow">if</span> (switchValue &amp;&amp; !classCache[className]) {</div>
<div class="line">      $animate.addClass($element, className);</div>
<div class="line">      classCache[className] = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!switchValue &amp;&amp; classCache[className]) {</div>
<div class="line">      $animate.removeClass($element, className);</div>
<div class="line">      classCache[className] = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> toggleValidationCss(validationErrorKey, isValid) {</div>
<div class="line">    validationErrorKey = validationErrorKey ? <span class="charliteral">&#39;-&#39;</span> + snake_case(validationErrorKey, <span class="charliteral">&#39;-&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === <span class="keyword">true</span>);</div>
<div class="line">    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isObjectEmpty(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">for</span> (var prop in obj) {</div>
<div class="line">      <span class="keywordflow">if</span> (obj.hasOwnProperty(prop)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngNonBindableDirective = ngDirective({ terminal: <span class="keyword">true</span>, priority: 1000 });</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global jqLiteRemove */</span></div>
<div class="line"></div>
<div class="line">var ngOptionsMinErr = minErr(<span class="stringliteral">&#39;ngOptions&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// jshint maxlen: false</span></div>
<div class="line"><span class="comment">//                     //00001111111111000000000002222222222000000000000000000000333333333300000000000000000000000004444444444400000000000005555555555555550000000006666666666666660000000777777777777777000000000000000888888888800000000000000000009999999999</span></div>
<div class="line">var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+<span class="keywordflow">for</span>\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;</div>
<div class="line">                        <span class="comment">// 1: value expression (valueFn)</span></div>
<div class="line">                        <span class="comment">// 2: label expression (displayFn)</span></div>
<div class="line">                        <span class="comment">// 3: group by expression (groupByFn)</span></div>
<div class="line">                        <span class="comment">// 4: disable when expression (disableWhenFn)</span></div>
<div class="line">                        <span class="comment">// 5: array item variable name</span></div>
<div class="line">                        <span class="comment">// 6: object item key variable name</span></div>
<div class="line">                        <span class="comment">// 7: object item value variable name</span></div>
<div class="line">                        <span class="comment">// 8: collection expression</span></div>
<div class="line">                        <span class="comment">// 9: track by expression</span></div>
<div class="line"><span class="comment">// jshint maxlen: 100</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngOptionsDirective = [<span class="stringliteral">&#39;$compile&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="keyword">function</span>($compile, $parse) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseOptionsExpression(optionsExp, selectElement, scope) {</div>
<div class="line"></div>
<div class="line">    var match = optionsExp.match(NG_OPTIONS_REGEXP);</div>
<div class="line">    <span class="keywordflow">if</span> (!(match)) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngOptionsMinErr(<span class="stringliteral">&#39;iexp&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Expected expression in form of &quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot;&#39;_select_ (as _label_)? for (_key_,)?_value_ in _collection_&#39;&quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot; but got &#39;{0}&#39;. Element: {1}&quot;</span>,</div>
<div class="line">        optionsExp, startingTag(selectElement));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Extract the parts from the ngOptions expression</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// The variable name for the value of the item in the collection</span></div>
<div class="line">    var valueName = match[5] || match[7];</div>
<div class="line">    <span class="comment">// The variable name for the key of the item in the collection</span></div>
<div class="line">    var keyName = match[6];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// An expression that generates the viewValue for an option if there is a label expression</span></div>
<div class="line">    var selectAs = / as /.test(match[0]) &amp;&amp; match[1];</div>
<div class="line">    <span class="comment">// An expression that is used to track the id of each object in the options collection</span></div>
<div class="line">    var trackBy = match[9];</div>
<div class="line">    <span class="comment">// An expression that generates the viewValue for an option if there is no label expression</span></div>
<div class="line">    var valueFn = $parse(match[2] ? match[1] : valueName);</div>
<div class="line">    var selectAsFn = selectAs &amp;&amp; $parse(selectAs);</div>
<div class="line">    var viewValueFn = selectAsFn || valueFn;</div>
<div class="line">    var trackByFn = trackBy &amp;&amp; $parse(trackBy);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the value by which we are going to track the option</span></div>
<div class="line">    <span class="comment">// if we have a trackFn then use that (passing scope and locals)</span></div>
<div class="line">    <span class="comment">// otherwise just hash the given viewValue</span></div>
<div class="line">    var getTrackByValueFn = trackBy ?</div>
<div class="line">                              <span class="keyword">function</span>(value, locals) { <span class="keywordflow">return</span> trackByFn(scope, locals); } :</div>
<div class="line">                              <span class="keyword">function</span> getHashOfValue(value) { <span class="keywordflow">return</span> hashKey(value); };</div>
<div class="line">    var getTrackByValue = <span class="keyword">function</span>(value, key) {</div>
<div class="line">      <span class="keywordflow">return</span> getTrackByValueFn(value, getLocals(value, key));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var displayFn = $parse(match[2] || match[1]);</div>
<div class="line">    var groupByFn = $parse(match[3] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    var disableWhenFn = $parse(match[4] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    var valuesFn = $parse(match[8]);</div>
<div class="line"></div>
<div class="line">    var locals = {};</div>
<div class="line">    var getLocals = keyName ? <span class="keyword">function</span>(value, key) {</div>
<div class="line">      locals[keyName] = key;</div>
<div class="line">      locals[valueName] = value;</div>
<div class="line">      <span class="keywordflow">return</span> locals;</div>
<div class="line">    } : <span class="keyword">function</span>(value) {</div>
<div class="line">      locals[valueName] = value;</div>
<div class="line">      <span class="keywordflow">return</span> locals;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> Option(selectValue, viewValue, label, group, disabled) {</div>
<div class="line">      this.selectValue = selectValue;</div>
<div class="line">      this.viewValue = viewValue;</div>
<div class="line">      this.label = label;</div>
<div class="line">      this.group = group;</div>
<div class="line">      this.disabled = disabled;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getOptionValuesKeys(optionValues) {</div>
<div class="line">      var optionValuesKeys;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!keyName &amp;&amp; isArrayLike(optionValues)) {</div>
<div class="line">        optionValuesKeys = optionValues;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// if object, extract keys, in enumeration order, unsorted</span></div>
<div class="line">        optionValuesKeys = [];</div>
<div class="line">        <span class="keywordflow">for</span> (var itemKey in optionValues) {</div>
<div class="line">          <span class="keywordflow">if</span> (optionValues.hasOwnProperty(itemKey) &amp;&amp; itemKey.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">            optionValuesKeys.push(itemKey);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> optionValuesKeys;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      trackBy: trackBy,</div>
<div class="line">      getTrackByValue: getTrackByValue,</div>
<div class="line">      getWatchables: $parse(valuesFn, <span class="keyword">function</span>(optionValues) {</div>
<div class="line">        <span class="comment">// Create a collection of things that we would like to watch (watchedArray)</span></div>
<div class="line">        <span class="comment">// so that they can all be watched using a single $watchCollection</span></div>
<div class="line">        <span class="comment">// that only runs the handler once if anything changes</span></div>
<div class="line">        var watchedArray = [];</div>
<div class="line">        optionValues = optionValues || [];</div>
<div class="line"></div>
<div class="line">        var optionValuesKeys = getOptionValuesKeys(optionValues);</div>
<div class="line">        var optionValuesLength = optionValuesKeys.length;</div>
<div class="line">        <span class="keywordflow">for</span> (var index = 0; index &lt; optionValuesLength; index++) {</div>
<div class="line">          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];</div>
<div class="line">          var value = optionValues[key];</div>
<div class="line"></div>
<div class="line">          var locals = getLocals(optionValues[key], key);</div>
<div class="line">          var selectValue = getTrackByValueFn(optionValues[key], locals);</div>
<div class="line">          watchedArray.push(selectValue);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Only need to watch the displayFn if there is a specific label expression</span></div>
<div class="line">          <span class="keywordflow">if</span> (match[2] || match[1]) {</div>
<div class="line">            var label = displayFn(scope, locals);</div>
<div class="line">            watchedArray.push(label);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Only need to watch the disableWhenFn if there is a specific disable expression</span></div>
<div class="line">          <span class="keywordflow">if</span> (match[4]) {</div>
<div class="line">            var disableWhen = disableWhenFn(scope, locals);</div>
<div class="line">            watchedArray.push(disableWhen);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> watchedArray;</div>
<div class="line">      }),</div>
<div class="line"></div>
<div class="line">      getOptions: <span class="keyword">function</span>() {</div>
<div class="line"></div>
<div class="line">        var optionItems = [];</div>
<div class="line">        var selectValueMap = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The option values were already computed in the `getWatchables` fn,</span></div>
<div class="line">        <span class="comment">// which must have been called to trigger `getOptions`</span></div>
<div class="line">        var optionValues = valuesFn(scope) || [];</div>
<div class="line">        var optionValuesKeys = getOptionValuesKeys(optionValues);</div>
<div class="line">        var optionValuesLength = optionValuesKeys.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (var index = 0; index &lt; optionValuesLength; index++) {</div>
<div class="line">          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];</div>
<div class="line">          var value = optionValues[key];</div>
<div class="line">          var locals = getLocals(value, key);</div>
<div class="line">          var viewValue = viewValueFn(scope, locals);</div>
<div class="line">          var selectValue = getTrackByValueFn(viewValue, locals);</div>
<div class="line">          var label = displayFn(scope, locals);</div>
<div class="line">          var group = groupByFn(scope, locals);</div>
<div class="line">          var disabled = disableWhenFn(scope, locals);</div>
<div class="line">          var optionItem = <span class="keyword">new</span> Option(selectValue, viewValue, label, group, disabled);</div>
<div class="line"></div>
<div class="line">          optionItems.push(optionItem);</div>
<div class="line">          selectValueMap[selectValue] = optionItem;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">          items: optionItems,</div>
<div class="line">          selectValueMap: selectValueMap,</div>
<div class="line">          getOptionFromViewValue: <span class="keyword">function</span>(value) {</div>
<div class="line">            <span class="keywordflow">return</span> selectValueMap[getTrackByValue(value)];</div>
<div class="line">          },</div>
<div class="line">          getViewValueFromOption: <span class="keyword">function</span>(option) {</div>
<div class="line">            <span class="comment">// If the viewValue could be an object that may be mutated by the application,</span></div>
<div class="line">            <span class="comment">// we need to make a copy and not return the reference to the value on the option.</span></div>
<div class="line">            <span class="keywordflow">return</span> trackBy ? angular.copy(option.viewValue) : option.viewValue;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// we can&#39;t just jqLite(&#39;&lt;option&gt;&#39;) since jqLite is not smart enough</span></div>
<div class="line">  <span class="comment">// to create it in &lt;select&gt; and IE barfs otherwise.</span></div>
<div class="line">  var optionTemplate = document.createElement(<span class="stringliteral">&#39;option&#39;</span>),</div>
<div class="line">      optGroupTemplate = document.createElement(<span class="stringliteral">&#39;optgroup&#39;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;select&#39;</span>, <span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    link: <span class="keyword">function</span>(scope, selectElement, attr, ctrls) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if ngModel is not defined, we don&#39;t need to do anything</span></div>
<div class="line">      var ngModelCtrl = ctrls[1];</div>
<div class="line">      <span class="keywordflow">if</span> (!ngModelCtrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var selectCtrl = ctrls[0];</div>
<div class="line">      var multiple = attr.multiple;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The emptyOption allows the application developer to provide their own custom &quot;empty&quot;</span></div>
<div class="line">      <span class="comment">// option when the viewValue does not match any of the option values.</span></div>
<div class="line">      var emptyOption;</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, children = selectElement.children(), ii = children.length; i &lt; ii; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (children[i].value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          emptyOption = children.eq(i);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var providedEmptyOption = !!emptyOption;</div>
<div class="line"></div>
<div class="line">      var unknownOption = jqLite(optionTemplate.cloneNode(<span class="keyword">false</span>));</div>
<div class="line">      unknownOption.val(<span class="charliteral">&#39;?&#39;</span>);</div>
<div class="line"></div>
<div class="line">      var options;</div>
<div class="line">      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      var renderEmptyOption = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!providedEmptyOption) {</div>
<div class="line">          selectElement.prepend(emptyOption);</div>
<div class="line">        }</div>
<div class="line">        selectElement.val(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        emptyOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// needed for IE</span></div>
<div class="line">        emptyOption.attr(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var removeEmptyOption = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!providedEmptyOption) {</div>
<div class="line">          emptyOption.remove();</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      var renderUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">        selectElement.prepend(unknownOption);</div>
<div class="line">        selectElement.val(<span class="charliteral">&#39;?&#39;</span>);</div>
<div class="line">        unknownOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// needed for IE</span></div>
<div class="line">        unknownOption.attr(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var removeUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">        unknownOption.remove();</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="comment">// Update the controller methods for multiple selectable options</span></div>
<div class="line">      <span class="keywordflow">if</span> (!multiple) {</div>
<div class="line"></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeNgOptionsValue(value) {</div>
<div class="line">          var option = options.getOptionFromViewValue(value);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) {</div>
<div class="line">            <span class="keywordflow">if</span> (selectElement[0].value !== option.selectValue) {</div>
<div class="line">              removeUnknownOption();</div>
<div class="line">              removeEmptyOption();</div>
<div class="line"></div>
<div class="line">              selectElement[0].value = option.selectValue;</div>
<div class="line">              option.element.selected = <span class="keyword">true</span>;</div>
<div class="line">              option.element.setAttribute(<span class="stringliteral">&#39;selected&#39;</span>, <span class="stringliteral">&#39;selected&#39;</span>);</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (value === null || providedEmptyOption) {</div>
<div class="line">              removeUnknownOption();</div>
<div class="line">              renderEmptyOption();</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              removeEmptyOption();</div>
<div class="line">              renderUnknownOption();</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readNgOptionsValue() {</div>
<div class="line"></div>
<div class="line">          var selectedOption = options.selectValueMap[selectElement.val()];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (selectedOption &amp;&amp; !selectedOption.disabled) {</div>
<div class="line">            removeEmptyOption();</div>
<div class="line">            removeUnknownOption();</div>
<div class="line">            <span class="keywordflow">return</span> options.getViewValueFromOption(selectedOption);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> null;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are using `track by` then we must watch the tracked value on the model</span></div>
<div class="line">        <span class="comment">// since ngModel only watches for object identity change</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngOptions.trackBy) {</div>
<div class="line">          scope.$watch(</div>
<div class="line">            <span class="keyword">function</span>() { <span class="keywordflow">return</span> ngOptions.getTrackByValue(ngModelCtrl.$viewValue); },</div>
<div class="line">            <span class="keyword">function</span>() { ngModelCtrl.$render(); }</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">        ngModelCtrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> !value || value.length === 0;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeNgOptionsMultiple(value) {</div>
<div class="line">          options.items.forEach(<span class="keyword">function</span>(option) {</div>
<div class="line">            option.element.selected = <span class="keyword">false</span>;</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (value) {</div>
<div class="line">            value.forEach(<span class="keyword">function</span>(item) {</div>
<div class="line">              var option = options.getOptionFromViewValue(item);</div>
<div class="line">              <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) option.element.selected = <span class="keyword">true</span>;</div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readNgOptionsMultiple() {</div>
<div class="line">          var selectedValues = selectElement.val() || [],</div>
<div class="line">              selections = [];</div>
<div class="line"></div>
<div class="line">          forEach(selectedValues, <span class="keyword">function</span>(value) {</div>
<div class="line">            var option = options.selectValueMap[value];</div>
<div class="line">            <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) selections.push(options.getViewValueFromOption(option));</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> selections;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are using `track by` then we must watch these tracked values on the model</span></div>
<div class="line">        <span class="comment">// since ngModel only watches for object identity change</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngOptions.trackBy) {</div>
<div class="line"></div>
<div class="line">          scope.$watchCollection(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isArray(ngModelCtrl.$viewValue)) {</div>
<div class="line">              return ngModelCtrl.$viewValue.map(function(value) {</div>
<div class="line">                return ngOptions.getTrackByValue(value);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          }, <span class="keyword">function</span>() {</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (providedEmptyOption) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we need to remove it before calling selectElement.empty() because otherwise IE will</span></div>
<div class="line">        <span class="comment">// remove the label from the element. wtf?</span></div>
<div class="line">        emptyOption.remove();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// compile the element since there might be bindings in it</span></div>
<div class="line">        $compile(emptyOption)(scope);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// remove the class, which is added automatically because we recompile the element and it</span></div>
<div class="line">        <span class="comment">// becomes the compilation root</span></div>
<div class="line">        emptyOption.removeClass(<span class="stringliteral">&#39;ng-scope&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        emptyOption = jqLite(optionTemplate.cloneNode(<span class="keyword">false</span>));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We need to do this here to ensure that the options object is defined</span></div>
<div class="line">      <span class="comment">// when we first hit it in writeNgOptionsValue</span></div>
<div class="line">      updateOptions();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We will re-render the option elements if the option values or labels change</span></div>
<div class="line">      scope.$watchCollection(ngOptions.getWatchables, updateOptions);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// ------------------------------------------------------------------ //</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateOptionElement(option, element) {</div>
<div class="line">        option.element = element;</div>
<div class="line">        element.disabled = option.disabled;</div>
<div class="line">        <span class="keywordflow">if</span> (option.value !== element.value) element.value = option.selectValue;</div>
<div class="line">        <span class="keywordflow">if</span> (option.label !== element.label) {</div>
<div class="line">          element.label = option.label;</div>
<div class="line">          element.textContent = option.label;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> addOrReuseElement(parent, current, type, templateElement) {</div>
<div class="line">        var element;</div>
<div class="line">        <span class="comment">// Check whether we can reuse the next element</span></div>
<div class="line">        <span class="keywordflow">if</span> (current &amp;&amp; lowercase(current.nodeName) === type) {</div>
<div class="line">          <span class="comment">// The next element is the right type so reuse it</span></div>
<div class="line">          element = current;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// The next element is not the right type so create a new one</span></div>
<div class="line">          element = templateElement.cloneNode(<span class="keyword">false</span>);</div>
<div class="line">          <span class="keywordflow">if</span> (!current) {</div>
<div class="line">            <span class="comment">// There are no more elements so just append it to the select</span></div>
<div class="line">            parent.appendChild(element);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// The next element is not a group so insert the new one</span></div>
<div class="line">            parent.insertBefore(element, current);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> element;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> removeExcessElements(current) {</div>
<div class="line">        var next;</div>
<div class="line">        <span class="keywordflow">while</span> (current) {</div>
<div class="line">          next = current.nextSibling;</div>
<div class="line">          jqLiteRemove(current);</div>
<div class="line">          current = next;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> skipEmptyAndUnknownOptions(current) {</div>
<div class="line">        var emptyOption_ = emptyOption &amp;&amp; emptyOption[0];</div>
<div class="line">        var unknownOption_ = unknownOption &amp;&amp; unknownOption[0];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (emptyOption_ || unknownOption_) {</div>
<div class="line">          <span class="keywordflow">while</span> (current &amp;&amp;</div>
<div class="line">                (current === emptyOption_ ||</div>
<div class="line">                current === unknownOption_)) {</div>
<div class="line">            current = current.nextSibling;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> current;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateOptions() {</div>
<div class="line"></div>
<div class="line">        var previousValue = options &amp;&amp; selectCtrl.readValue();</div>
<div class="line"></div>
<div class="line">        options = ngOptions.getOptions();</div>
<div class="line"></div>
<div class="line">        var groupMap = {};</div>
<div class="line">        var currentElement = selectElement[0].firstChild;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Ensure that the empty option is always there if it was explicitly provided</span></div>
<div class="line">        <span class="keywordflow">if</span> (providedEmptyOption) {</div>
<div class="line">          selectElement.prepend(emptyOption);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        currentElement = skipEmptyAndUnknownOptions(currentElement);</div>
<div class="line"></div>
<div class="line">        options.items.forEach(<span class="keyword">function</span> updateOption(option) {</div>
<div class="line">          var group;</div>
<div class="line">          var groupElement;</div>
<div class="line">          var optionElement;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (option.group) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This option is to live in a group</span></div>
<div class="line">            <span class="comment">// See if we have already created this group</span></div>
<div class="line">            group = groupMap[option.group];</div>
<div class="line"></div>
<div class="line">            if (!group) {</div>
<div class="line"></div>
<div class="line">              <span class="comment">// We have not already created this group</span></div>
<div class="line">              groupElement = addOrReuseElement(selectElement[0],</div>
<div class="line">                                               currentElement,</div>
<div class="line">                                               <span class="stringliteral">&#39;optgroup&#39;</span>,</div>
<div class="line">                                               optGroupTemplate);</div>
<div class="line">              <span class="comment">// Move to the next element</span></div>
<div class="line">              currentElement = groupElement.nextSibling;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Update the label on the group element</span></div>
<div class="line">              groupElement.label = option.group;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Store it for use later</span></div>
<div class="line">              group = groupMap[option.group] = {</div>
<div class="line">                groupElement: groupElement,</div>
<div class="line">                currentOptionElement: groupElement.firstChild</div>
<div class="line">              };</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// So now we have a group for this option we add the option to the group</span></div>
<div class="line">            optionElement = addOrReuseElement(group.groupElement,</div>
<div class="line">                                              group.currentOptionElement,</div>
<div class="line">                                              <span class="stringliteral">&#39;option&#39;</span>,</div>
<div class="line">                                              optionTemplate);</div>
<div class="line">            updateOptionElement(option, optionElement);</div>
<div class="line">            <span class="comment">// Move to the next element</span></div>
<div class="line">            group.currentOptionElement = optionElement.nextSibling;</div>
<div class="line"></div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This option is not in a group</span></div>
<div class="line">            optionElement = addOrReuseElement(selectElement[0],</div>
<div class="line">                                              currentElement,</div>
<div class="line">                                              <span class="stringliteral">&#39;option&#39;</span>,</div>
<div class="line">                                              optionTemplate);</div>
<div class="line">            updateOptionElement(option, optionElement);</div>
<div class="line">            <span class="comment">// Move to the next element</span></div>
<div class="line">            currentElement = optionElement.nextSibling;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Now remove all excess options and group</span></div>
<div class="line">        Object.keys(groupMap).forEach(<span class="keyword">function</span>(key) {</div>
<div class="line">          removeExcessElements(groupMap[key].currentOptionElement);</div>
<div class="line">        });</div>
<div class="line">        removeExcessElements(currentElement);</div>
<div class="line"></div>
<div class="line">        ngModelCtrl.$render();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check to see if the value has changed due to the update to the options</span></div>
<div class="line">        <span class="keywordflow">if</span> (!ngModelCtrl.$isEmpty(previousValue)) {</div>
<div class="line">          var nextValue = selectCtrl.readValue();</div>
<div class="line">          <span class="keywordflow">if</span> (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {</div>
<div class="line">            ngModelCtrl.$setViewValue(nextValue);</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngPluralizeDirective = [<span class="stringliteral">&#39;$locale&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$log&#39;</span>, <span class="keyword">function</span>($locale, $interpolate, $log) {</div>
<div class="line">  var BRACE = /{}/g,</div>
<div class="line">      IS_WHEN = /^when(Minus)?(.+)$/;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      var numberExp = attr.count,</div>
<div class="line">          whenExp = attr.$attr.when &amp;&amp; element.attr(attr.$attr.when), <span class="comment">// we have {{}} in attrs</span></div>
<div class="line">          offset = attr.offset || 0,</div>
<div class="line">          whens = scope.$eval(whenExp) || {},</div>
<div class="line">          whensExpFns = {},</div>
<div class="line">          startSymbol = $interpolate.startSymbol(),</div>
<div class="line">          endSymbol = $interpolate.endSymbol(),</div>
<div class="line">          braceReplacement = startSymbol + numberExp + <span class="charliteral">&#39;-&#39;</span> + offset + endSymbol,</div>
<div class="line">          watchRemover = angular.noop,</div>
<div class="line">          lastCount;</div>
<div class="line"></div>
<div class="line">      forEach(attr, <span class="keyword">function</span>(expression, attributeName) {</div>
<div class="line">        var tmpMatch = IS_WHEN.exec(attributeName);</div>
<div class="line">        <span class="keywordflow">if</span> (tmpMatch) {</div>
<div class="line">          var whenKey = (tmpMatch[1] ? <span class="charliteral">&#39;-&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + lowercase(tmpMatch[2]);</div>
<div class="line">          whens[whenKey] = element.attr(attr.$attr[attributeName]);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      forEach(whens, <span class="keyword">function</span>(expression, key) {</div>
<div class="line">        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));</div>
<div class="line"></div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      scope.$watch(numberExp, <span class="keyword">function</span> ngPluralizeWatchAction(newVal) {</div>
<div class="line">        var count = parseFloat(newVal);</div>
<div class="line">        var countIsNaN = isNaN(count);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!countIsNaN &amp;&amp; !(count in whens)) {</div>
<div class="line">          <span class="comment">// If an explicit number rule such as 1, 2, 3... is defined, just use it.</span></div>
<div class="line">          <span class="comment">// Otherwise, check it against pluralization rules in $locale service.</span></div>
<div class="line">          count = $locale.pluralCat(count - offset);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If both `count` and `lastCount` are NaN, we don&#39;t need to re-register a watch.</span></div>
<div class="line">        <span class="comment">// In JS `NaN !== NaN`, so we have to exlicitly check.</span></div>
<div class="line">        <span class="keywordflow">if</span> ((count !== lastCount) &amp;&amp; !(countIsNaN &amp;&amp; isNumber(lastCount) &amp;&amp; isNaN(lastCount))) {</div>
<div class="line">          watchRemover();</div>
<div class="line">          var whenExpFn = whensExpFns[count];</div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(whenExpFn)) {</div>
<div class="line">            <span class="keywordflow">if</span> (newVal != null) {</div>
<div class="line">              $log.debug(<span class="stringliteral">&quot;ngPluralize: no rule defined for &#39;&quot;</span> + count + <span class="stringliteral">&quot;&#39; in &quot;</span> + whenExp);</div>
<div class="line">            }</div>
<div class="line">            watchRemover = noop;</div>
<div class="line">            updateElementText();</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            watchRemover = scope.$watch(whenExpFn, updateElementText);</div>
<div class="line">          }</div>
<div class="line">          lastCount = count;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateElementText(newText) {</div>
<div class="line">        element.text(newText || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngRepeatDirective = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($parse, $animate) {</div>
<div class="line">  var NG_REMOVED = <span class="stringliteral">&#39;$$NG_REMOVED&#39;</span>;</div>
<div class="line">  var ngRepeatMinErr = minErr(<span class="stringliteral">&#39;ngRepeat&#39;</span>);</div>
<div class="line"></div>
<div class="line">  var updateScope = <span class="keyword">function</span>(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {</div>
<div class="line">    <span class="comment">// TODO(perf): generate setters to shave off ~40ms or 1-1.5%</span></div>
<div class="line">    scope[valueIdentifier] = value;</div>
<div class="line">    <span class="keywordflow">if</span> (keyIdentifier) scope[keyIdentifier] = key;</div>
<div class="line">    scope.$index = index;</div>
<div class="line">    scope.$first = (index === 0);</div>
<div class="line">    scope.$last = (index === (arrayLength - 1));</div>
<div class="line">    scope.$middle = !(scope.$first || scope.$last);</div>
<div class="line">    <span class="comment">// jshint bitwise: false</span></div>
<div class="line">    scope.$odd = !(scope.$even = (index&amp;1) === 0);</div>
<div class="line">    <span class="comment">// jshint bitwise: true</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var getBlockStart = <span class="keyword">function</span>(block) {</div>
<div class="line">    <span class="keywordflow">return</span> block.clone[0];</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var getBlockEnd = <span class="keyword">function</span>(block) {</div>
<div class="line">    <span class="keywordflow">return</span> block.clone[block.clone.length - 1];</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    priority: 1000,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    $$tlb: <span class="keyword">true</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngRepeatCompile($element, $attr) {</div>
<div class="line">      var expression = $attr.ngRepeat;</div>
<div class="line">      var ngRepeatEndComment = document.createComment(<span class="stringliteral">&#39; end ngRepeat: &#39;</span> + expression + <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"></div>
<div class="line">      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;iexp&#39;</span>, <span class="stringliteral">&quot;Expected expression in form of &#39;_item_ in _collection_[ track by _id_]&#39; but got &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">            expression);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var lhs = match[1];</div>
<div class="line">      var rhs = match[2];</div>
<div class="line">      var aliasAs = match[3];</div>
<div class="line">      var trackByExp = match[4];</div>
<div class="line"></div>
<div class="line">      match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;iidexp&#39;</span>, <span class="stringliteral">&quot;&#39;_item_&#39; in &#39;_item_ in _collection_&#39; should be an identifier or &#39;(_key_, _value_)&#39; expression, but got &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">            lhs);</div>
<div class="line">      }</div>
<div class="line">      var valueIdentifier = match[3] || match[1];</div>
<div class="line">      var keyIdentifier = match[2];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (aliasAs &amp;&amp; (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||</div>
<div class="line">          /^(null|undefined|<span class="keyword">this</span>|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;badident&#39;</span>, <span class="stringliteral">&quot;alias &#39;{0}&#39; is invalid --- must be a valid JS identifier which is not a reserved name.&quot;</span>,</div>
<div class="line">          aliasAs);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;</div>
<div class="line">      var hashFnLocals = {$id: hashKey};</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (trackByExp) {</div>
<div class="line">        trackByExpGetter = $parse(trackByExp);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        trackByIdArrayFn = <span class="keyword">function</span>(key, value) {</div>
<div class="line">          <span class="keywordflow">return</span> hashKey(value);</div>
<div class="line">        };</div>
<div class="line">        trackByIdObjFn = <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">return</span> key;</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (trackByExpGetter) {</div>
<div class="line">          trackByIdExpFn = <span class="keyword">function</span>(key, value, index) {</div>
<div class="line">            <span class="comment">// assign key, value, and $index to the locals so that they can be used in hash functions</span></div>
<div class="line">            <span class="keywordflow">if</span> (keyIdentifier) hashFnLocals[keyIdentifier] = key;</div>
<div class="line">            hashFnLocals[valueIdentifier] = value;</div>
<div class="line">            hashFnLocals.$index = index;</div>
<div class="line">            <span class="keywordflow">return</span> trackByExpGetter($scope, hashFnLocals);</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Store a list of elements from previous run. This is a hash where key is the item from the</span></div>
<div class="line">        <span class="comment">// iterator, and the value is objects with following properties.</span></div>
<div class="line">        <span class="comment">//   - scope: bound scope</span></div>
<div class="line">        <span class="comment">//   - element: previous element.</span></div>
<div class="line">        <span class="comment">//   - index: position</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// We are using no-proto object so that we don&#39;t need to guard against inherited props via</span></div>
<div class="line">        <span class="comment">// hasOwnProperty.</span></div>
<div class="line">        var lastBlockMap = createMap();</div>
<div class="line"></div>
<div class="line">        <span class="comment">//watch props</span></div>
<div class="line">        $scope.$watchCollection(rhs, <span class="keyword">function</span> ngRepeatAction(collection) {</div>
<div class="line">          var index, length,</div>
<div class="line">              previousNode = $element[0],     <span class="comment">// node that cloned nodes should be inserted after</span></div>
<div class="line">                                              <span class="comment">// initialized to the comment node anchor</span></div>
<div class="line">              nextNode,</div>
<div class="line">              <span class="comment">// Same as lastBlockMap but it has the current state. It will become the</span></div>
<div class="line">              <span class="comment">// lastBlockMap on the next iteration.</span></div>
<div class="line">              nextBlockMap = createMap(),</div>
<div class="line">              collectionLength,</div>
<div class="line">              key, value, <span class="comment">// key/value of iteration</span></div>
<div class="line">              trackById,</div>
<div class="line">              trackByIdFn,</div>
<div class="line">              collectionKeys,</div>
<div class="line">              block,       <span class="comment">// last object information {scope, element, id}</span></div>
<div class="line">              nextBlockOrder,</div>
<div class="line">              elementsToRemove;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (aliasAs) {</div>
<div class="line">            $scope[aliasAs] = collection;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (isArrayLike(collection)) {</div>
<div class="line">            collectionKeys = collection;</div>
<div class="line">            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            trackByIdFn = trackByIdExpFn || trackByIdObjFn;</div>
<div class="line">            <span class="comment">// if object, extract keys, in enumeration order, unsorted</span></div>
<div class="line">            collectionKeys = [];</div>
<div class="line">            <span class="keywordflow">for</span> (var itemKey in collection) {</div>
<div class="line">              <span class="keywordflow">if</span> (collection.hasOwnProperty(itemKey) &amp;&amp; itemKey.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">                collectionKeys.push(itemKey);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          collectionLength = collectionKeys.length;</div>
<div class="line">          nextBlockOrder = <span class="keyword">new</span> Array(collectionLength);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// locate existing items</span></div>
<div class="line">          <span class="keywordflow">for</span> (index = 0; index &lt; collectionLength; index++) {</div>
<div class="line">            key = (collection === collectionKeys) ? index : collectionKeys[index];</div>
<div class="line">            value = collection[key];</div>
<div class="line">            trackById = trackByIdFn(key, value, index);</div>
<div class="line">            <span class="keywordflow">if</span> (lastBlockMap[trackById]) {</div>
<div class="line">              <span class="comment">// found previously seen block</span></div>
<div class="line">              block = lastBlockMap[trackById];</div>
<div class="line">              <span class="keyword">delete</span> lastBlockMap[trackById];</div>
<div class="line">              nextBlockMap[trackById] = block;</div>
<div class="line">              nextBlockOrder[index] = block;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nextBlockMap[trackById]) {</div>
<div class="line">              <span class="comment">// if collision detected. restore lastBlockMap and throw an error</span></div>
<div class="line">              forEach(nextBlockOrder, <span class="keyword">function</span>(block) {</div>
<div class="line">                <span class="keywordflow">if</span> (block &amp;&amp; block.scope) lastBlockMap[block.id] = block;</div>
<div class="line">              });</div>
<div class="line">              <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;dupes&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Duplicates in a repeater are not allowed. Use &#39;track by&#39; expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}&quot;</span>,</div>
<div class="line">                  expression, trackById, value);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// new never before seen block</span></div>
<div class="line">              nextBlockOrder[index] = {<span class="keywordtype">id</span>: trackById, scope: undefined, clone: undefined};</div>
<div class="line">              nextBlockMap[trackById] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// remove leftover items</span></div>
<div class="line">          <span class="keywordflow">for</span> (var blockKey in lastBlockMap) {</div>
<div class="line">            block = lastBlockMap[blockKey];</div>
<div class="line">            elementsToRemove = getBlockNodes(block.clone);</div>
<div class="line">            $animate.leave(elementsToRemove);</div>
<div class="line">            <span class="keywordflow">if</span> (elementsToRemove[0].parentNode) {</div>
<div class="line">              <span class="comment">// if the element was not removed yet because of pending animation, mark it as deleted</span></div>
<div class="line">              <span class="comment">// so that we can ignore it later</span></div>
<div class="line">              <span class="keywordflow">for</span> (index = 0, length = elementsToRemove.length; index &lt; length; index++) {</div>
<div class="line">                elementsToRemove[index][NG_REMOVED] = <span class="keyword">true</span>;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            block.scope.$destroy();</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// we are not using forEach for perf reasons (trying to avoid #call)</span></div>
<div class="line">          <span class="keywordflow">for</span> (index = 0; index &lt; collectionLength; index++) {</div>
<div class="line">            key = (collection === collectionKeys) ? index : collectionKeys[index];</div>
<div class="line">            value = collection[key];</div>
<div class="line">            block = nextBlockOrder[index];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (block.scope) {</div>
<div class="line">              <span class="comment">// if we have already seen this object, then we need to reuse the</span></div>
<div class="line">              <span class="comment">// associated scope/element</span></div>
<div class="line"></div>
<div class="line">              nextNode = previousNode;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// skip nodes that are already pending removal via leave animation</span></div>
<div class="line">              <span class="keywordflow">do</span> {</div>
<div class="line">                nextNode = nextNode.nextSibling;</div>
<div class="line">              } <span class="keywordflow">while</span> (nextNode &amp;&amp; nextNode[NG_REMOVED]);</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">if</span> (getBlockStart(block) != nextNode) {</div>
<div class="line">                <span class="comment">// existing item which got moved</span></div>
<div class="line">                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));</div>
<div class="line">              }</div>
<div class="line">              previousNode = getBlockEnd(block);</div>
<div class="line">              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// new item which we don&#39;t know about</span></div>
<div class="line">              $transclude(<span class="keyword">function</span> ngRepeatTransclude(clone, scope) {</div>
<div class="line">                block.scope = scope;</div>
<div class="line">                <span class="comment">// http://jsperf.com/clone-vs-createcomment</span></div>
<div class="line">                var endNode = ngRepeatEndComment.cloneNode(<span class="keyword">false</span>);</div>
<div class="line">                clone[clone.length++] = endNode;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?</span></div>
<div class="line">                $animate.enter(clone, null, jqLite(previousNode));</div>
<div class="line">                previousNode = endNode;</div>
<div class="line">                <span class="comment">// Note: We only need the first/last node of the cloned nodes.</span></div>
<div class="line">                <span class="comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span></div>
<div class="line">                <span class="comment">// by a directive with templateUrl when its template arrives.</span></div>
<div class="line">                block.clone = clone;</div>
<div class="line">                nextBlockMap[block.id] = block;</div>
<div class="line">                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          lastBlockMap = nextBlockMap;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var NG_HIDE_CLASS = <span class="stringliteral">&#39;ng-hide&#39;</span>;</div>
<div class="line">var NG_HIDE_IN_PROGRESS_CLASS = <span class="stringliteral">&#39;ng-hide-animate&#39;</span>;</div>
<div class="line">var ngShowDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      scope.$watch(attr.ngShow, <span class="keyword">function</span> ngShowWatchAction(value) {</div>
<div class="line">        <span class="comment">// we&#39;re adding a temporary, animation-specific class for ng-hide since this way</span></div>
<div class="line">        <span class="comment">// we can control when the element is actually displayed on screen without having</span></div>
<div class="line">        <span class="comment">// to have a global/greedy CSS selector that breaks when other animations are run.</span></div>
<div class="line">        <span class="comment">// Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845</span></div>
<div class="line">        $animate[value ? <span class="stringliteral">&#39;removeClass&#39;</span> : <span class="stringliteral">&#39;addClass&#39;</span>](element, NG_HIDE_CLASS, {</div>
<div class="line">          tempClasses: NG_HIDE_IN_PROGRESS_CLASS</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngHideDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      scope.$watch(attr.ngHide, <span class="keyword">function</span> ngHideWatchAction(value) {</div>
<div class="line">        <span class="comment">// The comment inside of the ngShowDirective explains why we add and</span></div>
<div class="line">        <span class="comment">// remove a temporary class for the show/hide animation</span></div>
<div class="line">        $animate[value ? <span class="stringliteral">&#39;addClass&#39;</span> : <span class="stringliteral">&#39;removeClass&#39;</span>](element,NG_HIDE_CLASS, {</div>
<div class="line">          tempClasses: NG_HIDE_IN_PROGRESS_CLASS</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngStyleDirective = ngDirective(<span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">  scope.$watch(attr.ngStyle, <span class="keyword">function</span> ngStyleWatchAction(newStyles, oldStyles) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldStyles &amp;&amp; (newStyles !== oldStyles)) {</div>
<div class="line">      forEach(oldStyles, <span class="keyword">function</span>(val, style) { element.css(style, <span class="stringliteral">&#39;&#39;</span>);});</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (newStyles) element.css(newStyles);</div>
<div class="line">  }, <span class="keyword">true</span>);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngSwitchDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    require: <span class="stringliteral">&#39;ngSwitch&#39;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// asks for $scope to fool the BC controller module</span></div>
<div class="line">    controller: [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="keyword">function</span> ngSwitchController() {</div>
<div class="line">     this.cases = {};</div>
<div class="line">    }],</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ngSwitchController) {</div>
<div class="line">      var watchExpr = attr.ngSwitch || attr.on,</div>
<div class="line">          selectedTranscludes = [],</div>
<div class="line">          selectedElements = [],</div>
<div class="line">          previousLeaveAnimations = [],</div>
<div class="line">          selectedScopes = [];</div>
<div class="line"></div>
<div class="line">      var spliceFactory = <span class="keyword">function</span>(array, index) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() { array.splice(index, 1); };</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      scope.$watch(watchExpr, <span class="keyword">function</span> ngSwitchWatchAction(value) {</div>
<div class="line">        var i, ii;</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = previousLeaveAnimations.length; i &lt; ii; ++i) {</div>
<div class="line">          $animate.cancel(previousLeaveAnimations[i]);</div>
<div class="line">        }</div>
<div class="line">        previousLeaveAnimations.length = 0;</div>
<div class="line"></div>
<div class="line">        for (i = 0, ii = selectedScopes.length; i &lt; ii; ++i) {</div>
<div class="line">          var selected = getBlockNodes(selectedElements[i].clone);</div>
<div class="line">          selectedScopes[i].$destroy();</div>
<div class="line">          var promise = previousLeaveAnimations[i] = $animate.leave(selected);</div>
<div class="line">          promise.then(spliceFactory(previousLeaveAnimations, i));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        selectedElements.length = 0;</div>
<div class="line">        selectedScopes.length = 0;</div>
<div class="line"></div>
<div class="line">        if ((selectedTranscludes = ngSwitchController.cases[<span class="charliteral">&#39;!&#39;</span> + value] || ngSwitchController.cases[<span class="charliteral">&#39;?&#39;</span>])) {</div>
<div class="line">          forEach(selectedTranscludes, function(selectedTransclude) {</div>
<div class="line">            selectedTransclude.transclude(function(caseElement, selectedScope) {</div>
<div class="line">              selectedScopes.push(selectedScope);</div>
<div class="line">              var anchor = selectedTransclude.element;</div>
<div class="line">              caseElement[caseElement.length++] = document.createComment(<span class="stringliteral">&#39; end ngSwitchWhen: &#39;</span>);</div>
<div class="line">              var block = { clone: caseElement };</div>
<div class="line"></div>
<div class="line">              selectedElements.push(block);</div>
<div class="line">              $animate.enter(caseElement, anchor.parent(), anchor);</div>
<div class="line">            });</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngSwitchWhenDirective = ngDirective({</div>
<div class="line">  transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">  priority: 1200,</div>
<div class="line">  require: <span class="stringliteral">&#39;^ngSwitch&#39;</span>,</div>
<div class="line">  multiElement: <span class="keyword">true</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attrs, ctrl, $transclude) {</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen] = (ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen] || []);</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngSwitchDefaultDirective = ngDirective({</div>
<div class="line">  transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">  priority: 1200,</div>
<div class="line">  require: <span class="stringliteral">&#39;^ngSwitch&#39;</span>,</div>
<div class="line">  multiElement: <span class="keyword">true</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attr, ctrl, $transclude) {</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;?&#39;</span>] = (ctrl.cases[<span class="charliteral">&#39;?&#39;</span>] || []);</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;?&#39;</span>].push({ transclude: $transclude, element: element });</div>
<div class="line">   }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngTranscludeDirective = ngDirective({</div>
<div class="line">  restrict: <span class="stringliteral">&#39;EAC&#39;</span>,</div>
<div class="line">  link: <span class="keyword">function</span>($scope, $element, $attrs, controller, $transclude) {</div>
<div class="line">    <span class="keywordflow">if</span> (!$transclude) {</div>
<div class="line">      <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;ngTransclude&#39;</span>)(<span class="stringliteral">&#39;orphan&#39;</span>,</div>
<div class="line">       <span class="stringliteral">&#39;Illegal use of ngTransclude directive in the template! &#39;</span> +</div>
<div class="line">       <span class="stringliteral">&#39;No parent directive that requires a transclusion found. &#39;</span> +</div>
<div class="line">       <span class="stringliteral">&#39;Element: {0}&#39;</span>,</div>
<div class="line">       startingTag($element));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $transclude(<span class="keyword">function</span>(clone) {</div>
<div class="line">      $element.empty();</div>
<div class="line">      $element.append(clone);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var scriptDirective = [<span class="stringliteral">&#39;$templateCache&#39;</span>, <span class="keyword">function</span>($templateCache) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">      <span class="keywordflow">if</span> (attr.type == <span class="stringliteral">&#39;text/ng-template&#39;</span>) {</div>
<div class="line">        var templateUrl = attr.id,</div>
<div class="line">            text = element[0].text;</div>
<div class="line"></div>
<div class="line">        $templateCache.put(templateUrl, text);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var noopNgModelController = { $setViewValue: noop, $render: noop };</div>
<div class="line"></div>
<div class="line">var SelectController =</div>
<div class="line">        [<span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="keyword">function</span>($element, $scope, $attrs) {</div>
<div class="line"></div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">      optionsMap = <span class="keyword">new</span> HashMap();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If the ngModel doesn&#39;t get provided then provide a dummy noop version to prevent errors</span></div>
<div class="line">  <span class="keyword">self</span>.ngModelCtrl = noopNgModelController;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The &quot;unknown&quot; option is one that is prepended to the list if the viewValue</span></div>
<div class="line">  <span class="comment">// does not match any of the options. When it is rendered the value of the unknown</span></div>
<div class="line">  <span class="comment">// option is &#39;? XXX ?&#39; where XXX is the hashKey of the value that is not known.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// We can&#39;t just jqLite(&#39;&lt;option&gt;&#39;) since jqLite is not smart enough</span></div>
<div class="line">  <span class="comment">// to create it in &lt;select&gt; and IE barfs otherwise.</span></div>
<div class="line">  <span class="keyword">self</span>.unknownOption = jqLite(document.createElement(<span class="stringliteral">&#39;option&#39;</span>));</div>
<div class="line">  <span class="keyword">self</span>.renderUnknownOption = <span class="keyword">function</span>(val) {</div>
<div class="line">    var unknownVal = <span class="stringliteral">&#39;? &#39;</span> + hashKey(val) + <span class="stringliteral">&#39; ?&#39;</span>;</div>
<div class="line">    <span class="keyword">self</span>.unknownOption.val(unknownVal);</div>
<div class="line">    $element.prepend(<span class="keyword">self</span>.unknownOption);</div>
<div class="line">    $element.val(unknownVal);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  $scope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// disable unknown option so that we don&#39;t do work when the whole select is being destroyed</span></div>
<div class="line">    <span class="keyword">self</span>.renderUnknownOption = noop;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.removeUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">self</span>.unknownOption.parent()) <span class="keyword">self</span>.unknownOption.remove();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Read the value of the select control, the implementation of this changes depending</span></div>
<div class="line">  <span class="comment">// upon whether the select can have multiple values and whether ngOptions is at work.</span></div>
<div class="line">  <span class="keyword">self</span>.readValue = <span class="keyword">function</span> readSingleValue() {</div>
<div class="line">    <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">    <span class="keywordflow">return</span> $element.val();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Write the value to the select control, the implementation of this changes depending</span></div>
<div class="line">  <span class="comment">// upon whether the select can have multiple values and whether ngOptions is at work.</span></div>
<div class="line">  <span class="keyword">self</span>.writeValue = <span class="keyword">function</span> writeSingleValue(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">self</span>.hasOption(value)) {</div>
<div class="line">      <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">      $element.val(value);</div>
<div class="line">      <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) <span class="keyword">self</span>.emptyOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// to make IE9 happy</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (value == null &amp;&amp; <span class="keyword">self</span>.emptyOption) {</div>
<div class="line">        <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">        $element.val(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">self</span>.renderUnknownOption(value);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Tell the select control that an option, with the given value, has been added</span></div>
<div class="line">  <span class="keyword">self</span>.addOption = <span class="keyword">function</span>(value, element) {</div>
<div class="line">    assertNotHasOwnProperty(value, <span class="stringliteral">&#39;&quot;option value&quot;&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">      <span class="keyword">self</span>.emptyOption = element;</div>
<div class="line">    }</div>
<div class="line">    var count = optionsMap.get(value) || 0;</div>
<div class="line">    optionsMap.put(value, count + 1);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Tell the select control that an option, with the given value, has been removed</span></div>
<div class="line">  <span class="keyword">self</span>.removeOption = <span class="keyword">function</span>(value) {</div>
<div class="line">    var count = optionsMap.get(value);</div>
<div class="line">    <span class="keywordflow">if</span> (count) {</div>
<div class="line">      <span class="keywordflow">if</span> (count === 1) {</div>
<div class="line">        optionsMap.remove(value);</div>
<div class="line">        <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          <span class="keyword">self</span>.emptyOption = undefined;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        optionsMap.put(value, count - 1);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Check whether the select control has an option matching the given value</span></div>
<div class="line">  <span class="keyword">self</span>.hasOption = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> !!optionsMap.get(value);</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var selectDirective = <span class="keyword">function</span>() {</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;select&#39;</span>, <span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    controller: SelectController,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ctrls) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if ngModel is not defined, we don&#39;t need to do anything</span></div>
<div class="line">      var ngModelCtrl = ctrls[1];</div>
<div class="line">      <span class="keywordflow">if</span> (!ngModelCtrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var selectCtrl = ctrls[0];</div>
<div class="line"></div>
<div class="line">      selectCtrl.ngModelCtrl = ngModelCtrl;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We delegate rendering to the `writeValue` method, which can be changed</span></div>
<div class="line">      <span class="comment">// if the select can have multiple selected values or if the options are being</span></div>
<div class="line">      <span class="comment">// generated by `ngOptions`</span></div>
<div class="line">      ngModelCtrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">        selectCtrl.writeValue(ngModelCtrl.$viewValue);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// When the selected item(s) changes we delegate getting the value of the select control</span></div>
<div class="line">      <span class="comment">// to the `readValue` method, which can be changed if the select can have multiple</span></div>
<div class="line">      <span class="comment">// selected values or if the options are being generated by `ngOptions`</span></div>
<div class="line">      element.on(<span class="stringliteral">&#39;change&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">        scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">          ngModelCtrl.$setViewValue(selectCtrl.readValue());</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If the select allows multiple values then we need to modify how we read and write</span></div>
<div class="line">      <span class="comment">// values from and to the control; also what it means for the value to be empty and</span></div>
<div class="line">      <span class="comment">// we have to add an extra watch since ngModel doesn&#39;t work well with arrays - it</span></div>
<div class="line">      <span class="comment">// doesn&#39;t trigger rendering if only an item in the array changes.</span></div>
<div class="line">      <span class="keywordflow">if</span> (attr.multiple) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Read value now needs to check each option to see if it is selected</span></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readMultipleValue() {</div>
<div class="line">          var array = [];</div>
<div class="line">          forEach(element.find(<span class="stringliteral">&#39;option&#39;</span>), <span class="keyword">function</span>(option) {</div>
<div class="line">            <span class="keywordflow">if</span> (option.selected) {</div>
<div class="line">              array.push(option.value);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> array;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Write value now needs to set the selected property of each matching option</span></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeMultipleValue(value) {</div>
<div class="line">          var items = <span class="keyword">new</span> HashMap(value);</div>
<div class="line">          forEach(element.find(<span class="stringliteral">&#39;option&#39;</span>), <span class="keyword">function</span>(option) {</div>
<div class="line">            option.selected = isDefined(items.get(option.value));</div>
<div class="line">          });</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we have to do it on each watch since ngModel watches reference, but</span></div>
<div class="line">        <span class="comment">// we need to work of an array, so we need to see if anything was inserted/removed</span></div>
<div class="line">        var lastView, lastViewRef = NaN;</div>
<div class="line">        scope.$watch(<span class="keyword">function</span> selectMultipleWatch() {</div>
<div class="line">          <span class="keywordflow">if</span> (lastViewRef === ngModelCtrl.$viewValue &amp;&amp; !equals(lastView, ngModelCtrl.$viewValue)) {</div>
<div class="line">            lastView = shallowCopy(ngModelCtrl.$viewValue);</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          }</div>
<div class="line">          lastViewRef = ngModelCtrl.$viewValue;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are a multiple select then value is now a collection</span></div>
<div class="line">        <span class="comment">// so the meaning of $isEmpty changes</span></div>
<div class="line">        ngModelCtrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> !value || value.length === 0;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The option directive is purely designed to communicate the existence (or lack of)</span></div>
<div class="line"><span class="comment">// of dynamically created (and destroyed) option elements to their containing select</span></div>
<div class="line"><span class="comment">// directive via its controller.</span></div>
<div class="line">var optionDirective = [<span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="keyword">function</span>($interpolate) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> chromeHack(optionElement) {</div>
<div class="line">    <span class="comment">// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459</span></div>
<div class="line">    <span class="comment">// Adding an &lt;option selected=&quot;selected&quot;&gt; element to a &lt;select required=&quot;required&quot;&gt; should</span></div>
<div class="line">    <span class="comment">// automatically select the new element</span></div>
<div class="line">    <span class="keywordflow">if</span> (optionElement[0].hasAttribute(<span class="stringliteral">&#39;selected&#39;</span>)) {</div>
<div class="line">      optionElement[0].selected = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If the value attribute is not defined then we fall back to the</span></div>
<div class="line">      <span class="comment">// text content of the option element, which may be interpolated</span></div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(attr.value)) {</div>
<div class="line">        var interpolateFn = $interpolate(element.text(), <span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (!interpolateFn) {</div>
<div class="line">          attr.$set(<span class="stringliteral">&#39;value&#39;</span>, element.text());</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This is an optimization over using ^^ since we don&#39;t want to have to search</span></div>
<div class="line">        <span class="comment">// all the way to the root of the DOM for every single option element</span></div>
<div class="line">        var selectCtrlName = <span class="stringliteral">&#39;$selectController&#39;</span>,</div>
<div class="line">            parent = element.parent(),</div>
<div class="line">            selectCtrl = parent.data(selectCtrlName) ||</div>
<div class="line">              parent.parent().data(selectCtrlName); <span class="comment">// in case we are in optgroup</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Only update trigger option updates if this is an option within a `select`</span></div>
<div class="line">        <span class="comment">// that also has `ngModel` attached</span></div>
<div class="line">        <span class="keywordflow">if</span> (selectCtrl &amp;&amp; selectCtrl.ngModelCtrl) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (interpolateFn) {</div>
<div class="line">            scope.$watch(interpolateFn, <span class="keyword">function</span> interpolateWatchAction(newVal, oldVal) {</div>
<div class="line">              attr.$set(<span class="stringliteral">&#39;value&#39;</span>, newVal);</div>
<div class="line">              <span class="keywordflow">if</span> (oldVal !== newVal) {</div>
<div class="line">                selectCtrl.removeOption(oldVal);</div>
<div class="line">              }</div>
<div class="line">              selectCtrl.addOption(newVal, element);</div>
<div class="line">              selectCtrl.ngModelCtrl.$render();</div>
<div class="line">              chromeHack(element);</div>
<div class="line">            });</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            selectCtrl.addOption(attr.value, element);</div>
<div class="line">            selectCtrl.ngModelCtrl.$render();</div>
<div class="line">            chromeHack(element);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          element.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">            selectCtrl.removeOption(attr.value);</div>
<div class="line">            selectCtrl.ngModelCtrl.$render();</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var styleDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">  terminal: <span class="keyword">false</span></div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var requiredDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line">      attr.required = <span class="keyword">true</span>; <span class="comment">// force truthy in case we are on non input element</span></div>
<div class="line"></div>
<div class="line">      ctrl.$validators.required = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> !attr.required || !ctrl.$isEmpty(viewValue);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;required&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var patternDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var regexp, patternExp = attr.ngPattern || attr.pattern;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;pattern&#39;</span>, <span class="keyword">function</span>(regex) {</div>
<div class="line">        <span class="keywordflow">if</span> (isString(regex) &amp;&amp; regex.length &gt; 0) {</div>
<div class="line">          regex = new RegExp(<span class="stringliteral">&#39;^&#39;</span> + regex + <span class="stringliteral">&#39;$&#39;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        if (regex &amp;&amp; !regex.test) {</div>
<div class="line">          throw minErr(<span class="stringliteral">&#39;ngPattern&#39;</span>)(<span class="stringliteral">&#39;noregexp&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Expected {0} to be a RegExp but was {1}. Element: {2}&#39;</span>, patternExp,</div>
<div class="line">            regex, startingTag(elm));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        regexp = regex || undefined;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      ctrl.$validators.pattern = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var maxlengthDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var maxlength = -1;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;maxlength&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">        var intVal = toInt(value);</div>
<div class="line">        maxlength = isNaN(intVal) ? -1 : intVal;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">      ctrl.$validators.maxlength = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> (maxlength &lt; 0) || ctrl.$isEmpty(viewValue) || (viewValue.length &lt;= maxlength);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var minlengthDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var minlength = 0;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;minlength&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">        minlength = toInt(value) || 0;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">      ctrl.$validators.minlength = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> ctrl.$isEmpty(viewValue) || viewValue.length &gt;= minlength;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (window.angular.bootstrap) {</div>
<div class="line">  <span class="comment">//AngularJS is already loaded, so we can return here...</span></div>
<div class="line">  console.log(<span class="stringliteral">&#39;WARNING: Tried to load angular more than once.&#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//try to bind to jquery now so that one can write jqLite(document).ready()</span></div>
<div class="line"><span class="comment">//but we will rebind on bootstrap again.</span></div>
<div class="line">bindJQuery();</div>
<div class="line"></div>
<div class="line">publishExternalAPI(angular);</div>
<div class="line"></div>
<div class="line">angular.module(<span class="stringliteral">&quot;ngLocale&quot;</span>, [], [<span class="stringliteral">&quot;$provide&quot;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">var PLURAL_CATEGORY = {ZERO: <span class="stringliteral">&quot;zero&quot;</span>, ONE: <span class="stringliteral">&quot;one&quot;</span>, TWO: <span class="stringliteral">&quot;two&quot;</span>, FEW: <span class="stringliteral">&quot;few&quot;</span>, MANY: <span class="stringliteral">&quot;many&quot;</span>, OTHER: <span class="stringliteral">&quot;other&quot;</span>};</div>
<div class="line"><span class="keyword">function</span> getDecimals(n) {</div>
<div class="line">  n = n + <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  var i = n.indexOf(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> (i == -1) ? 0 : n.length - i - 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getVF(n, opt_precision) {</div>
<div class="line">  var v = opt_precision;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (undefined === v) {</div>
<div class="line">    v = Math.min(getDecimals(n), 3);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var base = Math.pow(10, v);</div>
<div class="line">  var f = ((n * base) | 0) % base;</div>
<div class="line">  <span class="keywordflow">return</span> {v: v, f: f};</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">$provide.value(<span class="stringliteral">&quot;$locale&quot;</span>, {</div>
<div class="line">  <span class="stringliteral">&quot;DATETIME_FORMATS&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;AMPMS&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;AM&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;PM&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;DAY&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Sunday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Monday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Tuesday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Wednesday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Thursday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Friday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Saturday&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;ERANAMES&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Before Christ&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Anno Domini&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;ERAS&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;BC&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;AD&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;FIRSTDAYOFWEEK&quot;</span>: 6,</div>
<div class="line">    <span class="stringliteral">&quot;MONTH&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;January&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;February&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;March&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;April&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;May&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;June&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;July&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;August&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;September&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;October&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;November&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;December&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;SHORTDAY&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Sun&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Mon&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Tue&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Wed&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Thu&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Fri&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Sat&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;SHORTMONTH&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Jan&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Feb&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Mar&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Apr&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;May&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Jun&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Jul&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Aug&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Sep&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Oct&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Nov&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Dec&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;WEEKENDRANGE&quot;</span>: [</div>
<div class="line">      5,</div>
<div class="line">      6</div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;fullDate&quot;</span>: <span class="stringliteral">&quot;EEEE, MMMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;longDate&quot;</span>: <span class="stringliteral">&quot;MMMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;medium&quot;</span>: <span class="stringliteral">&quot;MMM d, y h:mm:ss a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;mediumDate&quot;</span>: <span class="stringliteral">&quot;MMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;mediumTime&quot;</span>: <span class="stringliteral">&quot;h:mm:ss a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;short&quot;</span>: <span class="stringliteral">&quot;M/d/yy h:mm a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;shortDate&quot;</span>: <span class="stringliteral">&quot;M/d/yy&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;shortTime&quot;</span>: <span class="stringliteral">&quot;h:mm a&quot;</span></div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;NUMBER_FORMATS&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;CURRENCY_SYM&quot;</span>: <span class="stringliteral">&quot;$&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;DECIMAL_SEP&quot;</span>: <span class="stringliteral">&quot;.&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;GROUP_SEP&quot;</span>: <span class="stringliteral">&quot;,&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;PATTERNS&quot;</span>: [</div>
<div class="line">      {</div>
<div class="line">        <span class="stringliteral">&quot;gSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;lgSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;maxFrac&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;minFrac&quot;</span>: 0,</div>
<div class="line">        <span class="stringliteral">&quot;minInt&quot;</span>: 1,</div>
<div class="line">        <span class="stringliteral">&quot;negPre&quot;</span>: <span class="stringliteral">&quot;-&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;negSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posPre&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">      },</div>
<div class="line">      {</div>
<div class="line">        <span class="stringliteral">&quot;gSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;lgSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;maxFrac&quot;</span>: 2,</div>
<div class="line">        <span class="stringliteral">&quot;minFrac&quot;</span>: 2,</div>
<div class="line">        <span class="stringliteral">&quot;minInt&quot;</span>: 1,</div>
<div class="line">        <span class="stringliteral">&quot;negPre&quot;</span>: <span class="stringliteral">&quot;-\u00a4&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;negSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posPre&quot;</span>: <span class="stringliteral">&quot;\u00a4&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;en-us&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;pluralCat&quot;</span>: <span class="keyword">function</span>(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  <span class="keywordflow">if</span> (i == 1 &amp;&amp; vf.v == 0) {    <span class="keywordflow">return</span> PLURAL_CATEGORY.ONE;  }  <span class="keywordflow">return</span> PLURAL_CATEGORY.OTHER;}</div>
<div class="line">});</div>
<div class="line">}]);</div>
<div class="line"></div>
<div class="line">  jqLite(document).ready(<span class="keyword">function</span>() {</div>
<div class="line">    angularInit(document, bootstrap);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">})(window, document);</div>
<div class="line"></div>
<div class="line">!window.angular.$$csp().noInlineStyle &amp;&amp; window.angular.element(document.head).prepend(<span class="stringliteral">&#39;&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}&lt;/style&gt;&#39;</span>);</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
