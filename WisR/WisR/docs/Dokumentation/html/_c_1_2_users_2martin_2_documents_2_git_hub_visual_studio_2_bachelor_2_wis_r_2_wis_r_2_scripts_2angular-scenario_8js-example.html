<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>WisR web applikation: C:/Users/martin/Documents/GitHubVisualStudio/Bachelor/WisR/WisR/Scripts/angular-scenario.js</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WisR web applikation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/martin/Documents/GitHubVisualStudio/Bachelor/WisR/WisR/Scripts/angular-scenario.js</div>  </div>
</div><!--header-->
<div class="contents">
<p>&lt;file name="index.html"&gt; </p><div ng-controller="ExampleController"> &lt;form novalidate="" class="simple-form"&gt; Name: &lt;input type="text" ng-model="user.name"&gt;<br />
 E-mail: &lt;input type="email" ng-model="user.email"&gt;<br />
 Gender: &lt;input type="radio" ng-model="user.gender" value="male"&gt;male &lt;input type="radio" ng-model="user.gender" value="female"&gt;female<br />
 &lt;button ng-click="reset()"&gt;RESET&lt;/button&gt; &lt;button ng-click="update(user)"&gt;SAVE&lt;/button&gt; &lt;/form&gt; </p><pre>form = {{user | json}}</pre> <pre>master = {{master | json}}</pre> </div><p>&lt;script&gt; angular.module('copyExample', []) .controller('ExampleController', ['$scope', function($scope) { $scope.master= {};</p>
<p>$scope.update = function(user) { // Example with 1 argument $scope.master= angular.copy(user); };</p>
<p>$scope.reset = function() { // Example with 2 arguments angular.copy($scope.master, $scope.user); };</p>
<p>$scope.reset(); }]); &lt;/script&gt; &lt;/file&gt; </p>
<p>*/ function copy(source, destination, stackSource, stackDest) { if (isWindow(source) || isScope(source)) { throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported."); } if (isTypedArray(destination)) { throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated."); }</p>
<p>if (!destination) { destination = source; if (isObject(source)) { var index; if (stackSource &amp;&amp; (index = stackSource.indexOf(source)) !== -1) { return stackDest[index]; }</p>
<p>// TypedArray, Date and RegExp have specific copy functionality and must be // pushed onto the stack before returning. // Array and other objects create the base object and recurse to copy child // objects. The array/object will be pushed onto the stack when recursed. if (isArray(source)) { return copy(source, [], stackSource, stackDest); } else if (isTypedArray(source)) { destination = new source.constructor(source); } else if (isDate(source)) { destination = new Date(source.getTime()); } else if (isRegExp(source)) { destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]); destination.lastIndex = source.lastIndex; } else { var emptyObject = Object.create(getPrototypeOf(source)); return copy(source, emptyObject, stackSource, stackDest); }</p>
<p>if (stackDest) { stackSource.push(source); stackDest.push(destination); } } } else { if (source === destination) throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");</p>
<p>stackSource = stackSource || []; stackDest = stackDest || [];</p>
<p>if (isObject(source)) { stackSource.push(source); stackDest.push(destination); }</p>
<p>var result, key; if (isArray(source)) { destination.length = 0; for (var i = 0; i &lt; source.length; i++) { destination.push(copy(source[i], null, stackSource, stackDest)); } } else { var h = destination.$$hashKey; if (isArray(destination)) { destination.length = 0; } else { forEach(destination, function(value, key) { delete destination[key]; }); } if (isBlankObject(source)) { // createMap() fast path &mdash; Safe to avoid hasOwnProperty check because prototype chain is empty for (key in source) { destination[key] = copy(source[key], null, stackSource, stackDest); } } else if (source &amp;&amp; typeof source.hasOwnProperty === 'function') { // Slow path, which must rely on hasOwnProperty for (key in source) { if (source.hasOwnProperty(key)) { destination[key] = copy(source[key], null, stackSource, stackDest); } } } else { // Slowest path &mdash; hasOwnProperty can't be called as a method for (key in source) { if (hasOwnProperty.call(source, key)) { destination[key] = copy(source[key], null, stackSource, stackDest); } } } setHashKey(destination,h); } } return destination; }</p>
<p>/** Creates a shallow copy of an object, an array or a primitive.</p>
<p>Assumes that there are no proto properties for objects. */ function shallowCopy(src, dst) { if (isArray(src)) { dst = dst || [];</p>
<p>for (var i = 0, ii = src.length; i &lt; ii; i++) { dst[i] = src[i]; } } else if (isObject(src)) { dst = dst || {};</p>
<p>for (var key in src) { if (!(key.charAt(0) === '$' &amp;&amp; key.charAt(1) === '$')) { dst[key] = src[key]; } } }</p>
<p>return dst || src; }</p>
<p>/**  function</p>
<div class="fragment"><div class="line"></div>
<div class="line">(<span class="keyword">function</span>( global, factory ) {<span class="stringliteral">&#39;use strict&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( typeof module === <span class="stringliteral">&quot;object&quot;</span> &amp;&amp; typeof module.exports === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">        <span class="comment">// For CommonJS and CommonJS-like environments where a proper window is present,</span></div>
<div class="line">        <span class="comment">// execute the factory and get jQuery</span></div>
<div class="line">        <span class="comment">// For environments that do not inherently posses a window with a document</span></div>
<div class="line">        <span class="comment">// (such as Node.js), expose a jQuery-making factory as module.exports</span></div>
<div class="line">        <span class="comment">// This accentuates the need for the creation of a real window</span></div>
<div class="line">        <span class="comment">// e.g. var jQuery = require(&quot;jquery&quot;)(window);</span></div>
<div class="line">        <span class="comment">// See ticket #14549 for more info</span></div>
<div class="line">        module.exports = global.document ?</div>
<div class="line">            factory( global, <span class="keyword">true</span> ) :</div>
<div class="line">            <span class="keyword">function</span>( w ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !w.document ) {</div>
<div class="line">                    <span class="keywordflow">throw</span> <span class="keyword">new</span> Error( <span class="stringliteral">&quot;jQuery requires a window with a document&quot;</span> );</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> factory( w );</div>
<div class="line">            };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        factory( global );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="comment">// Pass this if window is not defined yet</span></div>
<div class="line">}(typeof window !== <span class="stringliteral">&quot;undefined&quot;</span> ? window : <span class="keyword">this</span>, <span class="keyword">function</span>( window, noGlobal ) {</div>
<div class="line"></div>
<div class="line"><span class="comment">// Can&#39;t do this because several apps including ASP.NET trace</span></div>
<div class="line"><span class="comment">// the stack via arguments.caller.callee and Firefox dies if</span></div>
<div class="line"><span class="comment">// you try to trace through &quot;use strict&quot; call chains. (#13335)</span></div>
<div class="line"><span class="comment">// Support: Firefox 18+</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line">var arr = [];</div>
<div class="line"></div>
<div class="line">var slice = arr.slice;</div>
<div class="line"></div>
<div class="line">var concat = arr.concat;</div>
<div class="line"></div>
<div class="line">var push = arr.push;</div>
<div class="line"></div>
<div class="line">var indexOf = arr.indexOf;</div>
<div class="line"></div>
<div class="line">var class2type = {};</div>
<div class="line"></div>
<div class="line">var toString = class2type.toString;</div>
<div class="line"></div>
<div class="line">var hasOwn = class2type.hasOwnProperty;</div>
<div class="line"></div>
<div class="line">var support = {};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    <span class="comment">// Use the correct document accordingly with window argument (sandbox)</span></div>
<div class="line">    document = window.document,</div>
<div class="line"></div>
<div class="line">    version = <span class="stringliteral">&quot;2.1.1&quot;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Define a local copy of jQuery</span></div>
<div class="line">    jQuery = <span class="keyword">function</span>( selector, context ) {</div>
<div class="line">        <span class="comment">// The jQuery object is actually just the init constructor &#39;enhanced&#39;</span></div>
<div class="line">        <span class="comment">// Need init if jQuery is called (just allow error to be thrown if not included)</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: Android&lt;4.1</span></div>
<div class="line">    <span class="comment">// Make sure we trim BOM and NBSP</span></div>
<div class="line">    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Matches dashed string for camelizing</span></div>
<div class="line">    rmsPrefix = /^-ms-/,</div>
<div class="line">    rdashAlpha = /-([\da-z])/gi,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Used by jQuery.camelCase as callback to replace()</span></div>
<div class="line">    fcamelCase = <span class="keyword">function</span>( all, letter ) {</div>
<div class="line">        <span class="keywordflow">return</span> letter.toUpperCase();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">jQuery.fn = jQuery.prototype = {</div>
<div class="line">    <span class="comment">// The current version of jQuery being used</span></div>
<div class="line">    jquery: version,</div>
<div class="line"></div>
<div class="line">    constructor: jQuery,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Start with an empty selector</span></div>
<div class="line">    selector: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The default length of a jQuery object is 0</span></div>
<div class="line">    length: 0,</div>
<div class="line"></div>
<div class="line">    toArray: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> slice.call( <span class="keyword">this</span> );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the Nth element in the matched element set OR</span></div>
<div class="line">    <span class="comment">// Get the whole matched element set as a clean array</span></div>
<div class="line">    <span class="keyword">get</span>: <span class="keyword">function</span>( num ) {</div>
<div class="line">        <span class="keywordflow">return</span> num != null ?</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return just the one element from the set</span></div>
<div class="line">            ( num &lt; 0 ? <span class="keyword">this</span>[ num + this.length ] : <span class="keyword">this</span>[ num ] ) :</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return all the elements in a clean array</span></div>
<div class="line">            slice.call( <span class="keyword">this</span> );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Take an array of elements and push it onto the stack</span></div>
<div class="line">    <span class="comment">// (returning the new matched element set)</span></div>
<div class="line">    pushStack: <span class="keyword">function</span>( elems ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Build a new jQuery matched element set</span></div>
<div class="line">        var ret = jQuery.merge( this.constructor(), elems );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add the old object onto the stack (as a reference)</span></div>
<div class="line">        ret.prevObject = <span class="keyword">this</span>;</div>
<div class="line">        ret.context = this.context;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return the newly-formed element set</span></div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Execute a callback for every element in the matched set.</span></div>
<div class="line">    <span class="comment">// (You can seed the arguments with an array of args, but this is</span></div>
<div class="line">    <span class="comment">// only used internally.)</span></div>
<div class="line">    each: <span class="keyword">function</span>( callback, args ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.each( <span class="keyword">this</span>, callback, args );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    map: <span class="keyword">function</span>( callback ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( jQuery.map(<span class="keyword">this</span>, <span class="keyword">function</span>( elem, i ) {</div>
<div class="line">            return callback.call( elem, i, elem );</div>
<div class="line">        }));</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    slice: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( slice.apply( <span class="keyword">this</span>, arguments ) );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    first: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.eq( 0 );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    last: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.eq( -1 );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    eq: <span class="keyword">function</span>( i ) {</div>
<div class="line">        var len = this.length,</div>
<div class="line">            j = +i + ( i &lt; 0 ? len : 0 );</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ <span class="keyword">this</span>[j] ] : [] );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    end: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.prevObject || this.constructor(null);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For internal use only.</span></div>
<div class="line">    <span class="comment">// Behaves like an Array&#39;s method, not like a jQuery method.</span></div>
<div class="line">    push: push,</div>
<div class="line">    sort: arr.sort,</div>
<div class="line">    splice: arr.splice</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.extend = jQuery.fn.extend = <span class="keyword">function</span>() {</div>
<div class="line">    var options, name, src, copy, copyIsArray, clone,</div>
<div class="line">        target = arguments[0] || {},</div>
<div class="line">        i = 1,</div>
<div class="line">        length = arguments.length,</div>
<div class="line">        deep = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle a deep copy situation</span></div>
<div class="line">    <span class="keywordflow">if</span> ( typeof target === <span class="stringliteral">&quot;boolean&quot;</span> ) {</div>
<div class="line">        deep = target;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// skip the boolean and the target</span></div>
<div class="line">        target = arguments[ i ] || {};</div>
<div class="line">        i++;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></div>
<div class="line">    <span class="keywordflow">if</span> ( typeof target !== <span class="stringliteral">&quot;object&quot;</span> &amp;&amp; !jQuery.isFunction(target) ) {</div>
<div class="line">        target = {};</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// extend jQuery itself if only one argument is passed</span></div>
<div class="line">    <span class="keywordflow">if</span> ( i === length ) {</div>
<div class="line">        target = <span class="keyword">this</span>;</div>
<div class="line">        i--;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">        <span class="comment">// Only deal with non-null/undefined values</span></div>
<div class="line">        <span class="keywordflow">if</span> ( (options = arguments[ i ]) != null ) {</div>
<div class="line">            <span class="comment">// Extend the base object</span></div>
<div class="line">            <span class="keywordflow">for</span> ( name in options ) {</div>
<div class="line">                src = target[ name ];</div>
<div class="line">                copy = options[ name ];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Prevent never-ending loop</span></div>
<div class="line">                <span class="keywordflow">if</span> ( target === copy ) {</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Recurse if we&#39;re merging plain objects or arrays</span></div>
<div class="line">                <span class="keywordflow">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( copyIsArray ) {</div>
<div class="line">                        copyIsArray = <span class="keyword">false</span>;</div>
<div class="line">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</div>
<div class="line"></div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Never move original objects, clone them</span></div>
<div class="line">                    target[ name ] = jQuery.extend( deep, clone, copy );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Don&#39;t bring in undefined values</span></div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( copy !== undefined ) {</div>
<div class="line">                    target[ name ] = copy;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the modified object</span></div>
<div class="line">    <span class="keywordflow">return</span> target;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    <span class="comment">// Unique for each copy of jQuery on the page</span></div>
<div class="line">    expando: <span class="stringliteral">&quot;jQuery&quot;</span> + ( version + Math.random() ).replace( /\D/g, <span class="stringliteral">&quot;&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Assume jQuery is ready without the ready module</span></div>
<div class="line">    isReady: <span class="keyword">true</span>,</div>
<div class="line"></div>
<div class="line">    error: <span class="keyword">function</span>( msg ) {</div>
<div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> Error( msg );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    noop: <span class="keyword">function</span>() {},</div>
<div class="line"></div>
<div class="line">    <span class="comment">// See test/unit/core.js for details concerning isFunction.</span></div>
<div class="line">    <span class="comment">// Since version 1.3, DOM methods and functions like alert</span></div>
<div class="line">    <span class="comment">// aren&#39;t supported. They return false on IE (#2968).</span></div>
<div class="line">    isFunction: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.type(obj) === <span class="stringliteral">&quot;function&quot;</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    isArray: Array.isArray,</div>
<div class="line"></div>
<div class="line">    isWindow: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        <span class="keywordflow">return</span> obj != null &amp;&amp; obj === obj.window;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    isNumeric: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        <span class="comment">// parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;)</span></div>
<div class="line">        <span class="comment">// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)</span></div>
<div class="line">        <span class="comment">// subtraction forces infinities to NaN</span></div>
<div class="line">        <span class="keywordflow">return</span> !jQuery.isArray( obj ) &amp;&amp; obj - parseFloat( obj ) &gt;= 0;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    isPlainObject: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        <span class="comment">// Not plain objects:</span></div>
<div class="line">        <span class="comment">// - Any object or value whose internal [[Class]] property is not &quot;[object Object]&quot;</span></div>
<div class="line">        <span class="comment">// - DOM nodes</span></div>
<div class="line">        <span class="comment">// - window</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.type( obj ) !== <span class="stringliteral">&quot;object&quot;</span> || obj.nodeType || jQuery.isWindow( obj ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( obj.constructor &amp;&amp;</div>
<div class="line">                !hasOwn.call( obj.constructor.prototype, <span class="stringliteral">&quot;isPrototypeOf&quot;</span> ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If the function hasn&#39;t returned already, we&#39;re confident that</span></div>
<div class="line">        <span class="comment">// |obj| is a plain object, created by {} or constructed with new Object</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    isEmptyObject: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        var name;</div>
<div class="line">        <span class="keywordflow">for</span> ( name in obj ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    type: <span class="keyword">function</span>( obj ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( obj == null ) {</div>
<div class="line">            <span class="keywordflow">return</span> obj + <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)</span></div>
<div class="line">        <span class="keywordflow">return</span> typeof obj === <span class="stringliteral">&quot;object&quot;</span> || typeof obj === <span class="stringliteral">&quot;function&quot;</span> ?</div>
<div class="line">            class2type[ toString.call(obj) ] || <span class="stringliteral">&quot;object&quot;</span> :</div>
<div class="line">            typeof obj;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Evaluates a script in a global context</span></div>
<div class="line">    globalEval: <span class="keyword">function</span>( code ) {</div>
<div class="line">        var script,</div>
<div class="line">            indirect = eval;</div>
<div class="line"></div>
<div class="line">        code = jQuery.trim( code );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( code ) {</div>
<div class="line">            <span class="comment">// If the code includes a valid, prologue position</span></div>
<div class="line">            <span class="comment">// strict mode pragma, execute code by injecting a</span></div>
<div class="line">            <span class="comment">// script tag into the document.</span></div>
<div class="line">            <span class="keywordflow">if</span> ( code.indexOf(<span class="stringliteral">&quot;use strict&quot;</span>) === 1 ) {</div>
<div class="line">                script = document.createElement(<span class="stringliteral">&quot;script&quot;</span>);</div>
<div class="line">                script.text = code;</div>
<div class="line">                document.head.appendChild( script ).parentNode.removeChild( script );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Otherwise, avoid the DOM node creation, insertion</span></div>
<div class="line">            <span class="comment">// and removal by using an indirect global eval</span></div>
<div class="line">                indirect( code );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert dashed to camelCase; used by the css and data modules</span></div>
<div class="line">    <span class="comment">// Microsoft forgot to hump their vendor prefix (#9572)</span></div>
<div class="line">    camelCase: <span class="keyword">function</span>( string ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">string</span>.replace( rmsPrefix, <span class="stringliteral">&quot;ms-&quot;</span> ).replace( rdashAlpha, fcamelCase );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    nodeName: <span class="keyword">function</span>( elem, name ) {</div>
<div class="line">        <span class="keywordflow">return</span> elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// args is for internal usage only</span></div>
<div class="line">    each: <span class="keyword">function</span>( obj, callback, args ) {</div>
<div class="line">        var value,</div>
<div class="line">            i = 0,</div>
<div class="line">            length = obj.length,</div>
<div class="line">            isArray = isArraylike( obj );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( args ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( isArray ) {</div>
<div class="line">                <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">                    value = callback.apply( obj[ i ], args );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( value === <span class="keyword">false</span> ) {</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">for</span> ( i in obj ) {</div>
<div class="line">                    value = callback.apply( obj[ i ], args );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( value === <span class="keyword">false</span> ) {</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// A special, fast, case for the most common use of each</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> ( isArray ) {</div>
<div class="line">                <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">                    value = callback.call( obj[ i ], i, obj[ i ] );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( value === <span class="keyword">false</span> ) {</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">for</span> ( i in obj ) {</div>
<div class="line">                    value = callback.call( obj[ i ], i, obj[ i ] );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( value === <span class="keyword">false</span> ) {</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> obj;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: Android&lt;4.1</span></div>
<div class="line">    trim: <span class="keyword">function</span>( text ) {</div>
<div class="line">        <span class="keywordflow">return</span> text == null ?</div>
<div class="line">            <span class="stringliteral">&quot;&quot;</span> :</div>
<div class="line">            ( text + <span class="stringliteral">&quot;&quot;</span> ).replace( rtrim, <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// results is for internal usage only</span></div>
<div class="line">    makeArray: <span class="keyword">function</span>( arr, results ) {</div>
<div class="line">        var ret = results || [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( arr != null ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( isArraylike( Object(arr) ) ) {</div>
<div class="line">                jQuery.merge( ret,</div>
<div class="line">                    typeof arr === <span class="stringliteral">&quot;string&quot;</span> ?</div>
<div class="line">                    [ arr ] : arr</div>
<div class="line">                );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                push.call( ret, arr );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    inArray: <span class="keyword">function</span>( elem, arr, i ) {</div>
<div class="line">        <span class="keywordflow">return</span> arr == null ? -1 : indexOf.call( arr, elem, i );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    merge: <span class="keyword">function</span>( first, second ) {</div>
<div class="line">        var len = +second.length,</div>
<div class="line">            j = 0,</div>
<div class="line">            i = first.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; j &lt; len; j++ ) {</div>
<div class="line">            first[ i++ ] = second[ j ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        first.length = i;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> first;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    grep: <span class="keyword">function</span>( elems, callback, invert ) {</div>
<div class="line">        var callbackInverse,</div>
<div class="line">            matches = [],</div>
<div class="line">            i = 0,</div>
<div class="line">            length = elems.length,</div>
<div class="line">            callbackExpect = !invert;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Go through the array, only saving the items</span></div>
<div class="line">        <span class="comment">// that pass the validator function</span></div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">            callbackInverse = !callback( elems[ i ], i );</div>
<div class="line">            <span class="keywordflow">if</span> ( callbackInverse !== callbackExpect ) {</div>
<div class="line">                matches.push( elems[ i ] );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> matches;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// arg is for internal usage only</span></div>
<div class="line">    map: <span class="keyword">function</span>( elems, callback, arg ) {</div>
<div class="line">        var value,</div>
<div class="line">            i = 0,</div>
<div class="line">            length = elems.length,</div>
<div class="line">            isArray = isArraylike( elems ),</div>
<div class="line">            ret = [];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Go through the array, translating each of the items to their new values</span></div>
<div class="line">        <span class="keywordflow">if</span> ( isArray ) {</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">                value = callback( elems[ i ], i, arg );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( value != null ) {</div>
<div class="line">                    ret.push( value );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Go through every key on the object,</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">for</span> ( i in elems ) {</div>
<div class="line">                value = callback( elems[ i ], i, arg );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( value != null ) {</div>
<div class="line">                    ret.push( value );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Flatten any nested arrays</span></div>
<div class="line">        <span class="keywordflow">return</span> concat.apply( [], ret );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A global GUID counter for objects</span></div>
<div class="line">    guid: 1,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Bind a function to a context, optionally partially applying any</span></div>
<div class="line">    <span class="comment">// arguments.</span></div>
<div class="line">    proxy: <span class="keyword">function</span>( fn, context ) {</div>
<div class="line">        var tmp, args, proxy;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof context === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            tmp = fn[ context ];</div>
<div class="line">            context = fn;</div>
<div class="line">            fn = tmp;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Quick check to determine if target is callable, in the spec</span></div>
<div class="line">        <span class="comment">// this throws a TypeError, but we will just return undefined.</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !jQuery.isFunction( fn ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> undefined;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Simulated bind</span></div>
<div class="line">        args = slice.call( arguments, 2 );</div>
<div class="line">        proxy = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> fn.apply( context || <span class="keyword">this</span>, args.concat( slice.call( arguments ) ) );</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the guid of unique handler to the same of original handler, so it can be removed</span></div>
<div class="line">        proxy.guid = fn.guid = fn.guid || jQuery.guid++;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> proxy;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    now: Date.now,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// jQuery.support is not used in Core but other projects attach their</span></div>
<div class="line">    <span class="comment">// properties to it so it needs to exist.</span></div>
<div class="line">    support: support</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Populate the class2type map</span></div>
<div class="line">jQuery.each(<span class="stringliteral">&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</span>.split(<span class="stringliteral">&quot; &quot;</span>), <span class="keyword">function</span>(i, name) {</div>
<div class="line">    class2type[ <span class="stringliteral">&quot;[object &quot;</span> + name + <span class="stringliteral">&quot;]&quot;</span> ] = name.toLowerCase();</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isArraylike( obj ) {</div>
<div class="line">    var length = obj.length,</div>
<div class="line">        type = jQuery.type( obj );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;function&quot;</span> || jQuery.isWindow( obj ) ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( obj.nodeType === 1 &amp;&amp; length ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> type === <span class="stringliteral">&quot;array&quot;</span> || length === 0 ||</div>
<div class="line">        typeof length === <span class="stringliteral">&quot;number&quot;</span> &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;</div>
<div class="line">}</div>
<div class="line">var Sizzle =</div>
<div class="line">(<span class="keyword">function</span>( window ) {</div>
<div class="line"></div>
<div class="line">var i,</div>
<div class="line">    support,</div>
<div class="line">    Expr,</div>
<div class="line">    getText,</div>
<div class="line">    isXML,</div>
<div class="line">    tokenize,</div>
<div class="line">    compile,</div>
<div class="line">    select,</div>
<div class="line">    outermostContext,</div>
<div class="line">    sortInput,</div>
<div class="line">    hasDuplicate,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Local document vars</span></div>
<div class="line">    setDocument,</div>
<div class="line">    document,</div>
<div class="line">    docElem,</div>
<div class="line">    documentIsHTML,</div>
<div class="line">    rbuggyQSA,</div>
<div class="line">    rbuggyMatches,</div>
<div class="line">    matches,</div>
<div class="line">    contains,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Instance-specific data</span></div>
<div class="line">    expando = <span class="stringliteral">&quot;sizzle&quot;</span> + -(<span class="keyword">new</span> Date()),</div>
<div class="line">    preferredDoc = window.document,</div>
<div class="line">    dirruns = 0,</div>
<div class="line">    done = 0,</div>
<div class="line">    classCache = createCache(),</div>
<div class="line">    tokenCache = createCache(),</div>
<div class="line">    compilerCache = createCache(),</div>
<div class="line">    sortOrder = <span class="keyword">function</span>( a, b ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( a === b ) {</div>
<div class="line">            hasDuplicate = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// General-purpose constants</span></div>
<div class="line">    strundefined = typeof undefined,</div>
<div class="line">    MAX_NEGATIVE = 1 &lt;&lt; 31,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Instance methods</span></div>
<div class="line">    hasOwn = ({}).hasOwnProperty,</div>
<div class="line">    arr = [],</div>
<div class="line">    pop = arr.pop,</div>
<div class="line">    push_native = arr.push,</div>
<div class="line">    push = arr.push,</div>
<div class="line">    slice = arr.slice,</div>
<div class="line">    <span class="comment">// Use a stripped-down indexOf if we can&#39;t use a native one</span></div>
<div class="line">    indexOf = arr.indexOf || <span class="keyword">function</span>( elem ) {</div>
<div class="line">        var i = 0,</div>
<div class="line">            len = this.length;</div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( <span class="keyword">this</span>[i] === elem ) {</div>
<div class="line">                <span class="keywordflow">return</span> i;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    booleans = <span class="stringliteral">&quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Regular expressions</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace</span></div>
<div class="line">    whitespace = <span class="stringliteral">&quot;[\\x20\\t\\r\\n\\f]&quot;</span>,</div>
<div class="line">    <span class="comment">// http://www.w3.org/TR/css3-syntax/#characters</span></div>
<div class="line">    characterEncoding = <span class="stringliteral">&quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loosely modeled on CSS identifier characters</span></div>
<div class="line">    <span class="comment">// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors</span></div>
<div class="line">    <span class="comment">// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</span></div>
<div class="line">    identifier = characterEncoding.replace( <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;w#&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors</span></div>
<div class="line">    attributes = <span class="stringliteral">&quot;\\[&quot;</span> + whitespace + <span class="stringliteral">&quot;*(&quot;</span> + characterEncoding + <span class="stringliteral">&quot;)(?:&quot;</span> + whitespace +</div>
<div class="line">        <span class="comment">// Operator (capture 2)</span></div>
<div class="line">        <span class="stringliteral">&quot;*([*^$|!~]?=)&quot;</span> + whitespace +</div>
<div class="line">        <span class="comment">// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;*(?:&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot;</span> + identifier + <span class="stringliteral">&quot;))|)&quot;</span> + whitespace +</div>
<div class="line">        <span class="stringliteral">&quot;*\\]&quot;</span>,</div>
<div class="line"></div>
<div class="line">    pseudos = <span class="stringliteral">&quot;:(&quot;</span> + characterEncoding + <span class="stringliteral">&quot;)(?:\\((&quot;</span> +</div>
<div class="line">        <span class="comment">// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:</span></div>
<div class="line">        <span class="comment">// 1. quoted (capture 3; capture 4 or capture 5)</span></div>
<div class="line">        <span class="stringliteral">&quot;(&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot;</span> +</div>
<div class="line">        <span class="comment">// 2. simple (capture 6)</span></div>
<div class="line">        <span class="stringliteral">&quot;((?:\\\\.|[^\\\\()[\\]]|&quot;</span> + attributes + <span class="stringliteral">&quot;)*)|&quot;</span> +</div>
<div class="line">        <span class="comment">// 3. anything else (capture 2)</span></div>
<div class="line">        <span class="stringliteral">&quot;.*&quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot;)\\)|)&quot;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</span></div>
<div class="line">    rtrim = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + whitespace + <span class="stringliteral">&quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot;</span> + whitespace + <span class="stringliteral">&quot;+$&quot;</span>, <span class="stringliteral">&quot;g&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    rcomma = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + whitespace + <span class="stringliteral">&quot;*,&quot;</span> + whitespace + <span class="stringliteral">&quot;*&quot;</span> ),</div>
<div class="line">    rcombinators = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + whitespace + <span class="stringliteral">&quot;*([&gt;+~]|&quot;</span> + whitespace + <span class="stringliteral">&quot;)&quot;</span> + whitespace + <span class="stringliteral">&quot;*&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    rattributeQuotes = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;=&quot;</span> + whitespace + <span class="stringliteral">&quot;*([^\\]&#39;\&quot;]*?)&quot;</span> + whitespace + <span class="stringliteral">&quot;*\\]&quot;</span>, <span class="stringliteral">&quot;g&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    rpseudo = <span class="keyword">new</span> RegExp( pseudos ),</div>
<div class="line">    ridentifier = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + identifier + <span class="stringliteral">&quot;$&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    matchExpr = {</div>
<div class="line">        <span class="stringliteral">&quot;ID&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^#(&quot;</span> + characterEncoding + <span class="stringliteral">&quot;)&quot;</span> ),</div>
<div class="line">        <span class="stringliteral">&quot;CLASS&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^\\.(&quot;</span> + characterEncoding + <span class="stringliteral">&quot;)&quot;</span> ),</div>
<div class="line">        <span class="stringliteral">&quot;TAG&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^(&quot;</span> + characterEncoding.replace( <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;w*&quot;</span> ) + <span class="stringliteral">&quot;)&quot;</span> ),</div>
<div class="line">        <span class="stringliteral">&quot;ATTR&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + attributes ),</div>
<div class="line">        <span class="stringliteral">&quot;PSEUDO&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + pseudos ),</div>
<div class="line">        <span class="stringliteral">&quot;CHILD&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot;</span> + whitespace +</div>
<div class="line">            <span class="stringliteral">&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot;</span> + whitespace + <span class="stringliteral">&quot;*(?:([+-]|)&quot;</span> + whitespace +</div>
<div class="line">            <span class="stringliteral">&quot;*(\\d+)|))&quot;</span> + whitespace + <span class="stringliteral">&quot;*\\)|)&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> ),</div>
<div class="line">        <span class="stringliteral">&quot;bool&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^(?:&quot;</span> + booleans + <span class="stringliteral">&quot;)$&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> ),</div>
<div class="line">        <span class="comment">// For use in libraries implementing .is()</span></div>
<div class="line">        <span class="comment">// We use this for POS matching in `select`</span></div>
<div class="line">        <span class="stringliteral">&quot;needsContext&quot;</span>: <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^&quot;</span> + whitespace + <span class="stringliteral">&quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot;</span> +</div>
<div class="line">            whitespace + <span class="stringliteral">&quot;*((?:-\\d)?\\d*)&quot;</span> + whitespace + <span class="stringliteral">&quot;*\\)|)(?=[^-]|$)&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> )</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    rinputs = /^(?:input|select|textarea|button)$/i,</div>
<div class="line">    rheader = /^h\d$/i,</div>
<div class="line"></div>
<div class="line">    rnative = /^[^{]+\{\s*\[native \w/,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Easily-parseable/retrievable ID or TAG or CLASS selectors</span></div>
<div class="line">    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,</div>
<div class="line"></div>
<div class="line">    rsibling = /[+~]/,</div>
<div class="line">    rescape = /<span class="stringliteral">&#39;|\\/g,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</span></div>
<div class="line"><span class="stringliteral">    runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),</span></div>
<div class="line"><span class="stringliteral">    funescape = function( _, escaped, escapedWhitespace ) {</span></div>
<div class="line"><span class="stringliteral">        var high = &quot;0x&quot; + escaped - 0x10000;</span></div>
<div class="line"><span class="stringliteral">        // NaN means non-codepoint</span></div>
<div class="line"><span class="stringliteral">        // Support: Firefox&lt;24</span></div>
<div class="line"><span class="stringliteral">        // Workaround erroneous numeric interpretation of +&quot;0x&quot;</span></div>
<div class="line"><span class="stringliteral">        return high !== high || escapedWhitespace ?</span></div>
<div class="line"><span class="stringliteral">            escaped :</span></div>
<div class="line"><span class="stringliteral">            high &lt; 0 ?</span></div>
<div class="line"><span class="stringliteral">                // BMP codepoint</span></div>
<div class="line"><span class="stringliteral">                String.fromCharCode( high + 0x10000 ) :</span></div>
<div class="line"><span class="stringliteral">                // Supplemental Plane codepoint (surrogate pair)</span></div>
<div class="line"><span class="stringliteral">                String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );</span></div>
<div class="line"><span class="stringliteral">    };</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">// Optimize for push.apply( _, NodeList )</span></div>
<div class="line"><span class="stringliteral">try {</span></div>
<div class="line"><span class="stringliteral">    push.apply(</span></div>
<div class="line"><span class="stringliteral">        (arr = slice.call( preferredDoc.childNodes )),</span></div>
<div class="line"><span class="stringliteral">        preferredDoc.childNodes</span></div>
<div class="line"><span class="stringliteral">    );</span></div>
<div class="line"><span class="stringliteral">    // Support: Android&lt;4.0</span></div>
<div class="line"><span class="stringliteral">    // Detect silently failing push.apply</span></div>
<div class="line"><span class="stringliteral">    arr[ preferredDoc.childNodes.length ].nodeType;</span></div>
<div class="line"><span class="stringliteral">} catch ( e ) {</span></div>
<div class="line"><span class="stringliteral">    push = { apply: arr.length ?</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">        // Leverage slice if possible</span></div>
<div class="line"><span class="stringliteral">        function( target, els ) {</span></div>
<div class="line"><span class="stringliteral">            push_native.apply( target, slice.call(els) );</span></div>
<div class="line"><span class="stringliteral">        } :</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">        // Support: IE&lt;9</span></div>
<div class="line"><span class="stringliteral">        // Otherwise append directly</span></div>
<div class="line"><span class="stringliteral">        function( target, els ) {</span></div>
<div class="line"><span class="stringliteral">            var j = target.length,</span></div>
<div class="line"><span class="stringliteral">                i = 0;</span></div>
<div class="line"><span class="stringliteral">            // Can&#39;</span>t trust NodeList.length</div>
<div class="line">            <span class="keywordflow">while</span> ( (target[j++] = els[i++]) ) {}</div>
<div class="line">            target.length = j - 1;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Sizzle( selector, context, results, seed ) {</div>
<div class="line">    var match, elem, m, nodeType,</div>
<div class="line">        <span class="comment">// QSA vars</span></div>
<div class="line">        i, groups, old, nid, newContext, newSelector;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {</div>
<div class="line">        setDocument( context );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    context = context || document;</div>
<div class="line">    results = results || [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !selector || typeof selector !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">        <span class="keywordflow">return</span> results;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {</div>
<div class="line">        <span class="keywordflow">return</span> [];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( documentIsHTML &amp;&amp; !seed ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Shortcuts</span></div>
<div class="line">        <span class="keywordflow">if</span> ( (match = rquickExpr.exec( selector )) ) {</div>
<div class="line">            <span class="comment">// Speed-up: Sizzle(&quot;#ID&quot;)</span></div>
<div class="line">            <span class="keywordflow">if</span> ( (m = match[1]) ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( nodeType === 9 ) {</div>
<div class="line">                    elem = context.getElementById( m );</div>
<div class="line">                    <span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span></div>
<div class="line">                    <span class="comment">// nodes that are no longer in the document (jQuery #6963)</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( elem &amp;&amp; elem.parentNode ) {</div>
<div class="line">                        <span class="comment">// Handle the case where IE, Opera, and Webkit return items</span></div>
<div class="line">                        <span class="comment">// by name instead of ID</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( elem.id === m ) {</div>
<div class="line">                            results.push( elem );</div>
<div class="line">                            <span class="keywordflow">return</span> results;</div>
<div class="line">                        }</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        <span class="keywordflow">return</span> results;</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// Context is not a document</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;</div>
<div class="line">                        contains( context, elem ) &amp;&amp; elem.id === m ) {</div>
<div class="line">                        results.push( elem );</div>
<div class="line">                        <span class="keywordflow">return</span> results;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Speed-up: Sizzle(&quot;TAG&quot;)</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( match[2] ) {</div>
<div class="line">                push.apply( results, context.getElementsByTagName( selector ) );</div>
<div class="line">                <span class="keywordflow">return</span> results;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Speed-up: Sizzle(&quot;.CLASS&quot;)</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName ) {</div>
<div class="line">                push.apply( results, context.getElementsByClassName( m ) );</div>
<div class="line">                <span class="keywordflow">return</span> results;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// QSA path</span></div>
<div class="line">        <span class="keywordflow">if</span> ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {</div>
<div class="line">            nid = old = expando;</div>
<div class="line">            newContext = context;</div>
<div class="line">            newSelector = nodeType === 9 &amp;&amp; selector;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// qSA works strangely on Element-rooted queries</span></div>
<div class="line">            <span class="comment">// We can work around this by specifying an extra ID on the root</span></div>
<div class="line">            <span class="comment">// and working up from there (Thanks to Andrew Dupont for the technique)</span></div>
<div class="line">            <span class="comment">// IE 8 doesn&#39;t work on object elements</span></div>
<div class="line">            <span class="keywordflow">if</span> ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">                groups = tokenize( selector );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( (old = context.getAttribute(<span class="stringliteral">&quot;id&quot;</span>)) ) {</div>
<div class="line">                    nid = old.replace( rescape, <span class="stringliteral">&quot;\\$&amp;&quot;</span> );</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    context.setAttribute( <span class="stringliteral">&quot;id&quot;</span>, nid );</div>
<div class="line">                }</div>
<div class="line">                nid = <span class="stringliteral">&quot;[id=&#39;&quot;</span> + nid + <span class="stringliteral">&quot;&#39;] &quot;</span>;</div>
<div class="line"></div>
<div class="line">                i = groups.length;</div>
<div class="line">                <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                    groups[i] = nid + toSelector( groups[i] );</div>
<div class="line">                }</div>
<div class="line">                newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context;</div>
<div class="line">                newSelector = groups.join(<span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( newSelector ) {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    push.apply( results,</div>
<div class="line">                        newContext.querySelectorAll( newSelector )</div>
<div class="line">                    );</div>
<div class="line">                    <span class="keywordflow">return</span> results;</div>
<div class="line">                } <span class="keywordflow">catch</span>(qsaError) {</div>
<div class="line">                } <span class="keywordflow">finally</span> {</div>
<div class="line">                    <span class="keywordflow">if</span> ( !old ) {</div>
<div class="line">                        context.removeAttribute(<span class="stringliteral">&quot;id&quot;</span>);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// All others</span></div>
<div class="line">    <span class="keywordflow">return</span> select( selector.replace( rtrim, <span class="stringliteral">&quot;$1&quot;</span> ), context, results, seed );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createCache() {</div>
<div class="line">    var keys = [];</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> cache( key, value ) {</div>
<div class="line">        <span class="comment">// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( keys.push( key + <span class="stringliteral">&quot; &quot;</span> ) &gt; Expr.cacheLength ) {</div>
<div class="line">            <span class="comment">// Only keep the most recent entries</span></div>
<div class="line">            <span class="keyword">delete</span> cache[ keys.shift() ];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> (cache[ key + <span class="stringliteral">&quot; &quot;</span> ] = value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> cache;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> markFunction( fn ) {</div>
<div class="line">    fn[ expando ] = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assert( fn ) {</div>
<div class="line">    var div = document.createElement(<span class="stringliteral">&quot;div&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> !!fn( div );</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">finally</span> {</div>
<div class="line">        <span class="comment">// Remove from its parent by default</span></div>
<div class="line">        <span class="keywordflow">if</span> ( div.parentNode ) {</div>
<div class="line">            div.parentNode.removeChild( div );</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// release memory in IE</span></div>
<div class="line">        div = null;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> addHandle( attrs, handler ) {</div>
<div class="line">    var arr = attrs.split(<span class="stringliteral">&quot;|&quot;</span>),</div>
<div class="line">        i = attrs.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">        Expr.attrHandle[ arr[i] ] = handler;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> siblingCheck( a, b ) {</div>
<div class="line">    var cur = b &amp;&amp; a,</div>
<div class="line">        diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;</div>
<div class="line">            ( ~b.sourceIndex || MAX_NEGATIVE ) -</div>
<div class="line">            ( ~a.sourceIndex || MAX_NEGATIVE );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use IE sourceIndex if available on both nodes</span></div>
<div class="line">    <span class="keywordflow">if</span> ( diff ) {</div>
<div class="line">        <span class="keywordflow">return</span> diff;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if b follows a</span></div>
<div class="line">    <span class="keywordflow">if</span> ( cur ) {</div>
<div class="line">        <span class="keywordflow">while</span> ( (cur = cur.nextSibling) ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( cur === b ) {</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> a ? 1 : -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createInputPseudo( type ) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">        var name = elem.nodeName.toLowerCase();</div>
<div class="line">        <span class="keywordflow">return</span> name === <span class="stringliteral">&quot;input&quot;</span> &amp;&amp; elem.type === type;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createButtonPseudo( type ) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">        var name = elem.nodeName.toLowerCase();</div>
<div class="line">        <span class="keywordflow">return</span> (name === <span class="stringliteral">&quot;input&quot;</span> || name === <span class="stringliteral">&quot;button&quot;</span>) &amp;&amp; elem.type === type;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createPositionalPseudo( fn ) {</div>
<div class="line">    <span class="keywordflow">return</span> markFunction(<span class="keyword">function</span>( argument ) {</div>
<div class="line">        argument = +argument;</div>
<div class="line">        <span class="keywordflow">return</span> markFunction(<span class="keyword">function</span>( seed, matches ) {</div>
<div class="line">            var j,</div>
<div class="line">                matchIndexes = fn( [], seed.length, argument ),</div>
<div class="line">                i = matchIndexes.length;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Match elements found at the specified indexes</span></div>
<div class="line">            <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( seed[ (j = matchIndexes[i]) ] ) {</div>
<div class="line">                    seed[j] = !(matches[j] = seed[j]);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> testContext( context ) {</div>
<div class="line">    <span class="keywordflow">return</span> context &amp;&amp; typeof context.getElementsByTagName !== strundefined &amp;&amp; context;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Expose support vars for convenience</span></div>
<div class="line">support = Sizzle.support = {};</div>
<div class="line"></div>
<div class="line">isXML = Sizzle.isXML = <span class="keyword">function</span>( elem ) {</div>
<div class="line">    <span class="comment">// documentElement is verified for cases where it doesn&#39;t yet exist</span></div>
<div class="line">    <span class="comment">// (such as loading iframes in IE - #4833)</span></div>
<div class="line">    var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;</div>
<div class="line">    <span class="keywordflow">return</span> documentElement ? documentElement.nodeName !== <span class="stringliteral">&quot;HTML&quot;</span> : <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">setDocument = Sizzle.setDocument = <span class="keyword">function</span>( node ) {</div>
<div class="line">    var hasCompare,</div>
<div class="line">        doc = node ? node.ownerDocument || node : preferredDoc,</div>
<div class="line">        parent = doc.defaultView;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If no document and documentElement is available, return</span></div>
<div class="line">    <span class="keywordflow">if</span> ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {</div>
<div class="line">        <span class="keywordflow">return</span> document;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set our document</span></div>
<div class="line">    document = doc;</div>
<div class="line">    docElem = doc.documentElement;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support tests</span></div>
<div class="line">    documentIsHTML = !isXML( doc );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: IE&gt;8</span></div>
<div class="line">    <span class="comment">// If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,</span></div>
<div class="line">    <span class="comment">// IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936</span></div>
<div class="line">    <span class="comment">// IE6-8 do not support the defaultView property so parent will be undefined</span></div>
<div class="line">    <span class="keywordflow">if</span> ( parent &amp;&amp; parent !== parent.top ) {</div>
<div class="line">        <span class="comment">// IE11 does not have attachEvent, so all must suffer</span></div>
<div class="line">        <span class="keywordflow">if</span> ( parent.addEventListener ) {</div>
<div class="line">            parent.addEventListener( <span class="stringliteral">&quot;unload&quot;</span>, <span class="keyword">function</span>() {</div>
<div class="line">                setDocument();</div>
<div class="line">            }, false );</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( parent.attachEvent ) {</div>
<div class="line">            parent.attachEvent( <span class="stringliteral">&quot;onunload&quot;</span>, <span class="keyword">function</span>() {</div>
<div class="line">                setDocument();</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Attributes</span></div>
<div class="line"><span class="comment">    ---------------------------------------------------------------------- */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: IE&lt;8</span></div>
<div class="line">    <span class="comment">// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)</span></div>
<div class="line">    support.attributes = assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">        div.className = <span class="stringliteral">&quot;i&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> !div.getAttribute(<span class="stringliteral">&quot;className&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* getElement(s)By*</span></div>
<div class="line"><span class="comment">    ---------------------------------------------------------------------- */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if getElementsByTagName(&quot;*&quot;) returns only elements</span></div>
<div class="line">    support.getElementsByTagName = assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">        div.appendChild( doc.createComment(<span class="stringliteral">&quot;&quot;</span>) );</div>
<div class="line">        <span class="keywordflow">return</span> !div.getElementsByTagName(<span class="stringliteral">&quot;*&quot;</span>).length;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if getElementsByClassName can be trusted</span></div>
<div class="line">    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) &amp;&amp; assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">        div.innerHTML = <span class="stringliteral">&quot;&lt;div class=&#39;a&#39;&gt;&lt;/div&gt;&lt;div class=&#39;a i&#39;&gt;&lt;/div&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: Safari&lt;4</span></div>
<div class="line">        <span class="comment">// Catch class over-caching</span></div>
<div class="line">        div.firstChild.className = <span class="stringliteral">&quot;i&quot;</span>;</div>
<div class="line">        <span class="comment">// Support: Opera&lt;10</span></div>
<div class="line">        <span class="comment">// Catch gEBCN failure to find non-leading classes</span></div>
<div class="line">        <span class="keywordflow">return</span> div.getElementsByClassName(<span class="stringliteral">&quot;i&quot;</span>).length === 2;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: IE&lt;10</span></div>
<div class="line">    <span class="comment">// Check if getElementById returns elements by name</span></div>
<div class="line">    <span class="comment">// The broken getElementById methods don&#39;t pick up programatically-set names,</span></div>
<div class="line">    <span class="comment">// so use a roundabout getElementsByName test</span></div>
<div class="line">    support.getById = assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">        docElem.appendChild( div ).id = expando;</div>
<div class="line">        <span class="keywordflow">return</span> !doc.getElementsByName || !doc.getElementsByName( expando ).length;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ID find and filter</span></div>
<div class="line">    <span class="keywordflow">if</span> ( support.getById ) {</div>
<div class="line">        Expr.find[<span class="stringliteral">&quot;ID&quot;</span>] = <span class="keyword">function</span>( id, context ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML ) {</div>
<div class="line">                var m = context.getElementById( <span class="keywordtype">id</span> );</div>
<div class="line">                <span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span></div>
<div class="line">                <span class="comment">// nodes that are no longer in the document #6963</span></div>
<div class="line">                <span class="keywordflow">return</span> m &amp;&amp; m.parentNode ? [ m ] : [];</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">        Expr.filter[<span class="stringliteral">&quot;ID&quot;</span>] = <span class="keyword">function</span>( id ) {</div>
<div class="line">            var attrId = <span class="keywordtype">id</span>.replace( runescape, funescape );</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                <span class="keywordflow">return</span> elem.getAttribute(<span class="stringliteral">&quot;id&quot;</span>) === attrId;</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Support: IE6/7</span></div>
<div class="line">        <span class="comment">// getElementById is not reliable as a find shortcut</span></div>
<div class="line">        <span class="keyword">delete</span> Expr.find[<span class="stringliteral">&quot;ID&quot;</span>];</div>
<div class="line"></div>
<div class="line">        Expr.filter[<span class="stringliteral">&quot;ID&quot;</span>] =  <span class="keyword">function</span>( id ) {</div>
<div class="line">            var attrId = <span class="keywordtype">id</span>.replace( runescape, funescape );</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(<span class="stringliteral">&quot;id&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span> node &amp;&amp; node.value === attrId;</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Tag</span></div>
<div class="line">    Expr.find[<span class="stringliteral">&quot;TAG&quot;</span>] = support.getElementsByTagName ?</div>
<div class="line">        <span class="keyword">function</span>( tag, context ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( typeof context.getElementsByTagName !== strundefined ) {</div>
<div class="line">                <span class="keywordflow">return</span> context.getElementsByTagName( tag );</div>
<div class="line">            }</div>
<div class="line">        } :</div>
<div class="line">        <span class="keyword">function</span>( tag, context ) {</div>
<div class="line">            var elem,</div>
<div class="line">                tmp = [],</div>
<div class="line">                i = 0,</div>
<div class="line">                results = context.getElementsByTagName( tag );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Filter out possible comments</span></div>
<div class="line">            <span class="keywordflow">if</span> ( tag === <span class="stringliteral">&quot;*&quot;</span> ) {</div>
<div class="line">                <span class="keywordflow">while</span> ( (elem = results[i++]) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.nodeType === 1 ) {</div>
<div class="line">                        tmp.push( elem );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> tmp;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> results;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Class</span></div>
<div class="line">    Expr.find[<span class="stringliteral">&quot;CLASS&quot;</span>] = support.getElementsByClassName &amp;&amp; <span class="keyword">function</span>( className, context ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML ) {</div>
<div class="line">            <span class="keywordflow">return</span> context.getElementsByClassName( className );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* QSA/matchesSelector</span></div>
<div class="line"><span class="comment">    ---------------------------------------------------------------------- */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// QSA and matchesSelector support</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// matchesSelector(:active) reports false when true (IE9/Opera 11.5)</span></div>
<div class="line">    rbuggyMatches = [];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// qSa(:focus) reports false when true (Chrome 21)</span></div>
<div class="line">    <span class="comment">// We allow this because of a bug in IE8/9 that throws an error</span></div>
<div class="line">    <span class="comment">// whenever `document.activeElement` is accessed on an iframe</span></div>
<div class="line">    <span class="comment">// So, we allow :focus to pass through QSA all the time to avoid the IE error</span></div>
<div class="line">    <span class="comment">// See http://bugs.jquery.com/ticket/13378</span></div>
<div class="line">    rbuggyQSA = [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {</div>
<div class="line">        <span class="comment">// Build QSA regex</span></div>
<div class="line">        <span class="comment">// Regex strategy adopted from Diego Perini</span></div>
<div class="line">        assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">            <span class="comment">// Select is set to empty string on purpose</span></div>
<div class="line">            <span class="comment">// This is to test IE&#39;s treatment of not explicitly</span></div>
<div class="line">            <span class="comment">// setting a boolean content attribute,</span></div>
<div class="line">            <span class="comment">// since its presence should be enough</span></div>
<div class="line">            <span class="comment">// http://bugs.jquery.com/ticket/12359</span></div>
<div class="line">            div.innerHTML = <span class="stringliteral">&quot;&lt;select msallowclip=&#39;&#39;&gt;&lt;option selected=&#39;&#39;&gt;&lt;/option&gt;&lt;/select&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: IE8, Opera 11-12.16</span></div>
<div class="line">            <span class="comment">// Nothing should be selected when empty strings follow ^= or $= or *=</span></div>
<div class="line">            <span class="comment">// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT</span></div>
<div class="line">            <span class="comment">// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</span></div>
<div class="line">            <span class="keywordflow">if</span> ( div.querySelectorAll(<span class="stringliteral">&quot;[msallowclip^=&#39;&#39;]&quot;</span>).length ) {</div>
<div class="line">                rbuggyQSA.push( <span class="stringliteral">&quot;[*^$]=&quot;</span> + whitespace + <span class="stringliteral">&quot;*(?:&#39;&#39;|\&quot;\&quot;)&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: IE8</span></div>
<div class="line">            <span class="comment">// Boolean attributes and &quot;value&quot; are not treated correctly</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !div.querySelectorAll(<span class="stringliteral">&quot;[selected]&quot;</span>).length ) {</div>
<div class="line">                rbuggyQSA.push( <span class="stringliteral">&quot;\\[&quot;</span> + whitespace + <span class="stringliteral">&quot;*(?:value|&quot;</span> + booleans + <span class="stringliteral">&quot;)&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Webkit/Opera - :checked should return selected option elements</span></div>
<div class="line">            <span class="comment">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span></div>
<div class="line">            <span class="comment">// IE8 throws error here and will not see later tests</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !div.querySelectorAll(<span class="stringliteral">&quot;:checked&quot;</span>).length ) {</div>
<div class="line">                rbuggyQSA.push(<span class="stringliteral">&quot;:checked&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">            <span class="comment">// Support: Windows 8 Native Apps</span></div>
<div class="line">            <span class="comment">// The type and name attributes are restricted during .innerHTML assignment</span></div>
<div class="line">            var input = doc.createElement(<span class="stringliteral">&quot;input&quot;</span>);</div>
<div class="line">            input.setAttribute( <span class="stringliteral">&quot;type&quot;</span>, <span class="stringliteral">&quot;hidden&quot;</span> );</div>
<div class="line">            div.appendChild( input ).setAttribute( <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;D&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: IE8</span></div>
<div class="line">            <span class="comment">// Enforce case-sensitivity of name attribute</span></div>
<div class="line">            <span class="keywordflow">if</span> ( div.querySelectorAll(<span class="stringliteral">&quot;[name=d]&quot;</span>).length ) {</div>
<div class="line">                rbuggyQSA.push( <span class="stringliteral">&quot;name&quot;</span> + whitespace + <span class="stringliteral">&quot;*[*^$|!~]?=&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)</span></div>
<div class="line">            <span class="comment">// IE8 throws error here and will not see later tests</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !div.querySelectorAll(<span class="stringliteral">&quot;:enabled&quot;</span>).length ) {</div>
<div class="line">                rbuggyQSA.push( <span class="stringliteral">&quot;:enabled&quot;</span>, <span class="stringliteral">&quot;:disabled&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Opera 10-11 does not throw on post-comma invalid pseudos</span></div>
<div class="line">            div.querySelectorAll(<span class="stringliteral">&quot;*,:x&quot;</span>);</div>
<div class="line">            rbuggyQSA.push(<span class="stringliteral">&quot;,.*:&quot;</span>);</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||</div>
<div class="line">        docElem.webkitMatchesSelector ||</div>
<div class="line">        docElem.mozMatchesSelector ||</div>
<div class="line">        docElem.oMatchesSelector ||</div>
<div class="line">        docElem.msMatchesSelector) )) ) {</div>
<div class="line"></div>
<div class="line">        assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">            <span class="comment">// Check to see if it&#39;s possible to do matchesSelector</span></div>
<div class="line">            <span class="comment">// on a disconnected node (IE 9)</span></div>
<div class="line">            support.disconnectedMatch = matches.call( div, <span class="stringliteral">&quot;div&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This should fail with an exception</span></div>
<div class="line">            <span class="comment">// Gecko does not error, returns false instead</span></div>
<div class="line">            matches.call( div, <span class="stringliteral">&quot;[s!=&#39;&#39;]:x&quot;</span> );</div>
<div class="line">            rbuggyMatches.push( <span class="stringliteral">&quot;!=&quot;</span>, pseudos );</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    rbuggyQSA = rbuggyQSA.length &amp;&amp; <span class="keyword">new</span> RegExp( rbuggyQSA.join(<span class="stringliteral">&quot;|&quot;</span>) );</div>
<div class="line">    rbuggyMatches = rbuggyMatches.length &amp;&amp; <span class="keyword">new</span> RegExp( rbuggyMatches.join(<span class="stringliteral">&quot;|&quot;</span>) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Contains</span></div>
<div class="line"><span class="comment">    ---------------------------------------------------------------------- */</span></div>
<div class="line">    hasCompare = rnative.test( docElem.compareDocumentPosition );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Element contains another</span></div>
<div class="line">    <span class="comment">// Purposefully does not implement inclusive descendent</span></div>
<div class="line">    <span class="comment">// As in, an element does not contain itself</span></div>
<div class="line">    contains = hasCompare || rnative.test( docElem.contains ) ?</div>
<div class="line">        <span class="keyword">function</span>( a, b ) {</div>
<div class="line">            var adown = a.nodeType === 9 ? a.documentElement : a,</div>
<div class="line">                bup = b &amp;&amp; b.parentNode;</div>
<div class="line">            <span class="keywordflow">return</span> a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (</div>
<div class="line">                adown.contains ?</div>
<div class="line">                    adown.contains( bup ) :</div>
<div class="line">                    a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16</div>
<div class="line">            ));</div>
<div class="line">        } :</div>
<div class="line">        <span class="keyword">function</span>( a, b ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( b ) {</div>
<div class="line">                <span class="keywordflow">while</span> ( (b = b.parentNode) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( b === a ) {</div>
<div class="line">                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Sorting</span></div>
<div class="line"><span class="comment">    ---------------------------------------------------------------------- */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Document order sorting</span></div>
<div class="line">    sortOrder = hasCompare ?</div>
<div class="line">    <span class="keyword">function</span>( a, b ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Flag for duplicate removal</span></div>
<div class="line">        <span class="keywordflow">if</span> ( a === b ) {</div>
<div class="line">            hasDuplicate = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sort on method existence if only one input has compareDocumentPosition</span></div>
<div class="line">        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;</div>
<div class="line">        <span class="keywordflow">if</span> ( compare ) {</div>
<div class="line">            <span class="keywordflow">return</span> compare;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Calculate position if both inputs belong to the same document</span></div>
<div class="line">        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?</div>
<div class="line">            a.compareDocumentPosition( b ) :</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Otherwise we know they are disconnected</span></div>
<div class="line">            1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Disconnected nodes</span></div>
<div class="line">        <span class="keywordflow">if</span> ( compare &amp; 1 ||</div>
<div class="line">            (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Choose the first element that is related to our preferred document</span></div>
<div class="line">            <span class="keywordflow">if</span> ( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {</div>
<div class="line">                <span class="keywordflow">return</span> -1;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> ( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {</div>
<div class="line">                <span class="keywordflow">return</span> 1;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Maintain original order</span></div>
<div class="line">            <span class="keywordflow">return</span> sortInput ?</div>
<div class="line">                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :</div>
<div class="line">                0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> compare &amp; 4 ? -1 : 1;</div>
<div class="line">    } :</div>
<div class="line">    <span class="keyword">function</span>( a, b ) {</div>
<div class="line">        <span class="comment">// Exit early if the nodes are identical</span></div>
<div class="line">        <span class="keywordflow">if</span> ( a === b ) {</div>
<div class="line">            hasDuplicate = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var cur,</div>
<div class="line">            i = 0,</div>
<div class="line">            aup = a.parentNode,</div>
<div class="line">            bup = b.parentNode,</div>
<div class="line">            ap = [ a ],</div>
<div class="line">            bp = [ b ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Parentless nodes are either documents or disconnected</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !aup || !bup ) {</div>
<div class="line">            <span class="keywordflow">return</span> a === doc ? -1 :</div>
<div class="line">                b === doc ? 1 :</div>
<div class="line">                aup ? -1 :</div>
<div class="line">                bup ? 1 :</div>
<div class="line">                sortInput ?</div>
<div class="line">                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :</div>
<div class="line">                0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If the nodes are siblings, we can do a quick check</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( aup === bup ) {</div>
<div class="line">            <span class="keywordflow">return</span> siblingCheck( a, b );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Otherwise we need full lists of their ancestors for comparison</span></div>
<div class="line">        cur = a;</div>
<div class="line">        <span class="keywordflow">while</span> ( (cur = cur.parentNode) ) {</div>
<div class="line">            ap.unshift( cur );</div>
<div class="line">        }</div>
<div class="line">        cur = b;</div>
<div class="line">        <span class="keywordflow">while</span> ( (cur = cur.parentNode) ) {</div>
<div class="line">            bp.unshift( cur );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Walk down the tree looking for a discrepancy</span></div>
<div class="line">        <span class="keywordflow">while</span> ( ap[i] === bp[i] ) {</div>
<div class="line">            i++;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> i ?</div>
<div class="line">            <span class="comment">// Do a sibling check if the nodes have a common ancestor</span></div>
<div class="line">            siblingCheck( ap[i], bp[i] ) :</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Otherwise nodes in our document sort first</span></div>
<div class="line">            ap[i] === preferredDoc ? -1 :</div>
<div class="line">            bp[i] === preferredDoc ? 1 :</div>
<div class="line">            0;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> doc;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.matches = <span class="keyword">function</span>( expr, elements ) {</div>
<div class="line">    <span class="keywordflow">return</span> Sizzle( expr, null, null, elements );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.matchesSelector = <span class="keyword">function</span>( elem, expr ) {</div>
<div class="line">    <span class="comment">// Set document vars if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> ( ( elem.ownerDocument || elem ) !== document ) {</div>
<div class="line">        setDocument( elem );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Make sure that attribute selectors are quoted</span></div>
<div class="line">    expr = expr.replace( rattributeQuotes, <span class="stringliteral">&quot;=&#39;$1&#39;]&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;</div>
<div class="line">        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;</div>
<div class="line">        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            var ret = matches.call( elem, expr );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// IE 9&#39;s matchesSelector returns false on disconnected nodes</span></div>
<div class="line">            <span class="keywordflow">if</span> ( ret || support.disconnectedMatch ||</div>
<div class="line">                    <span class="comment">// As well, disconnected nodes are said to be in a document</span></div>
<div class="line">                    <span class="comment">// fragment in IE 9</span></div>
<div class="line">                    elem.document &amp;&amp; elem.document.nodeType !== 11 ) {</div>
<div class="line">                <span class="keywordflow">return</span> ret;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">catch</span>(e) {}</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> Sizzle( expr, document, null, [ elem ] ).length &gt; 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.contains = <span class="keyword">function</span>( context, elem ) {</div>
<div class="line">    <span class="comment">// Set document vars if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> ( ( context.ownerDocument || context ) !== document ) {</div>
<div class="line">        setDocument( context );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> contains( context, elem );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.attr = <span class="keyword">function</span>( elem, name ) {</div>
<div class="line">    <span class="comment">// Set document vars if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> ( ( elem.ownerDocument || elem ) !== document ) {</div>
<div class="line">        setDocument( elem );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var fn = Expr.attrHandle[ name.toLowerCase() ],</div>
<div class="line">        <span class="comment">// Don&#39;t get fooled by Object.prototype properties (jQuery #13807)</span></div>
<div class="line">        val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?</div>
<div class="line">            fn( elem, name, !documentIsHTML ) :</div>
<div class="line">            undefined;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> val !== undefined ?</div>
<div class="line">        val :</div>
<div class="line">        support.attributes || !documentIsHTML ?</div>
<div class="line">            elem.getAttribute( name ) :</div>
<div class="line">            (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?</div>
<div class="line">                val.value :</div>
<div class="line">                null;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.error = <span class="keyword">function</span>( msg ) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Error( <span class="stringliteral">&quot;Syntax error, unrecognized expression: &quot;</span> + msg );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Sizzle.uniqueSort = <span class="keyword">function</span>( results ) {</div>
<div class="line">    var elem,</div>
<div class="line">        duplicates = [],</div>
<div class="line">        j = 0,</div>
<div class="line">        i = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Unless we *know* we can detect duplicates, assume their presence</span></div>
<div class="line">    hasDuplicate = !support.detectDuplicates;</div>
<div class="line">    sortInput = !support.sortStable &amp;&amp; results.slice( 0 );</div>
<div class="line">    results.sort( sortOrder );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( hasDuplicate ) {</div>
<div class="line">        <span class="keywordflow">while</span> ( (elem = results[i++]) ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( elem === results[ i ] ) {</div>
<div class="line">                j = duplicates.push( i );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">while</span> ( j-- ) {</div>
<div class="line">            results.splice( duplicates[ j ], 1 );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Clear input after sorting to release objects</span></div>
<div class="line">    <span class="comment">// See https://github.com/jquery/sizzle/pull/225</span></div>
<div class="line">    sortInput = null;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> results;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">getText = Sizzle.getText = <span class="keyword">function</span>( elem ) {</div>
<div class="line">    var node,</div>
<div class="line">        ret = <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        i = 0,</div>
<div class="line">        nodeType = elem.nodeType;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !nodeType ) {</div>
<div class="line">        <span class="comment">// If no nodeType, this is expected to be an array</span></div>
<div class="line">        <span class="keywordflow">while</span> ( (node = elem[i++]) ) {</div>
<div class="line">            <span class="comment">// Do not traverse comment nodes</span></div>
<div class="line">            ret += getText( node );</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {</div>
<div class="line">        <span class="comment">// Use textContent for elements</span></div>
<div class="line">        <span class="comment">// innerText usage removed for consistency of new lines (jQuery #11153)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof elem.textContent === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem.textContent;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Traverse its children</span></div>
<div class="line">            <span class="keywordflow">for</span> ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {</div>
<div class="line">                ret += getText( elem );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( nodeType === 3 || nodeType === 4 ) {</div>
<div class="line">        <span class="keywordflow">return</span> elem.nodeValue;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do not include comment or processing instruction nodes</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Expr = Sizzle.selectors = {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Can be adjusted by the user</span></div>
<div class="line">    cacheLength: 50,</div>
<div class="line"></div>
<div class="line">    createPseudo: markFunction,</div>
<div class="line"></div>
<div class="line">    match: matchExpr,</div>
<div class="line"></div>
<div class="line">    attrHandle: {},</div>
<div class="line"></div>
<div class="line">    find: {},</div>
<div class="line"></div>
<div class="line">    relative: {</div>
<div class="line">        <span class="stringliteral">&quot;&gt;&quot;</span>: { dir: <span class="stringliteral">&quot;parentNode&quot;</span>, first: <span class="keyword">true</span> },</div>
<div class="line">        <span class="stringliteral">&quot; &quot;</span>: { dir: <span class="stringliteral">&quot;parentNode&quot;</span> },</div>
<div class="line">        <span class="stringliteral">&quot;+&quot;</span>: { dir: <span class="stringliteral">&quot;previousSibling&quot;</span>, first: <span class="keyword">true</span> },</div>
<div class="line">        <span class="stringliteral">&quot;~&quot;</span>: { dir: <span class="stringliteral">&quot;previousSibling&quot;</span> }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    preFilter: {</div>
<div class="line">        <span class="stringliteral">&quot;ATTR&quot;</span>: <span class="keyword">function</span>( match ) {</div>
<div class="line">            match[1] = match[1].replace( runescape, funescape );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Move the given value to match[3] whether quoted or unquoted</span></div>
<div class="line">            match[3] = ( match[3] || match[4] || match[5] || <span class="stringliteral">&quot;&quot;</span> ).replace( runescape, funescape );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( match[2] === <span class="stringliteral">&quot;~=&quot;</span> ) {</div>
<div class="line">                match[3] = <span class="stringliteral">&quot; &quot;</span> + match[3] + <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> match.slice( 0, 4 );</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;CHILD&quot;</span>: <span class="keyword">function</span>( match ) {</div>
<div class="line">            <span class="comment">/* matches from matchExpr[&quot;CHILD&quot;]</span></div>
<div class="line"><span class="comment">                1 type (only|nth|...)</span></div>
<div class="line"><span class="comment">                2 what (child|of-type)</span></div>
<div class="line"><span class="comment">                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)</span></div>
<div class="line"><span class="comment">                4 xn-component of xn+y argument ([+-]?\d*n|)</span></div>
<div class="line"><span class="comment">                5 sign of xn-component</span></div>
<div class="line"><span class="comment">                6 x of xn-component</span></div>
<div class="line"><span class="comment">                7 sign of y-component</span></div>
<div class="line"><span class="comment">                8 y of y-component</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">            match[1] = match[1].toLowerCase();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( match[1].slice( 0, 3 ) === <span class="stringliteral">&quot;nth&quot;</span> ) {</div>
<div class="line">                <span class="comment">// nth-* requires argument</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !match[3] ) {</div>
<div class="line">                    Sizzle.error( match[0] );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// numeric x and y parameters for Expr.filter.CHILD</span></div>
<div class="line">                <span class="comment">// remember that false/true cast respectively to 0/1</span></div>
<div class="line">                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === <span class="stringliteral">&quot;even&quot;</span> || match[3] === <span class="stringliteral">&quot;odd&quot;</span> ) );</div>
<div class="line">                match[5] = +( ( match[7] + match[8] ) || match[3] === <span class="stringliteral">&quot;odd&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// other types prohibit arguments</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( match[3] ) {</div>
<div class="line">                Sizzle.error( match[0] );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> match;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;PSEUDO&quot;</span>: <span class="keyword">function</span>( match ) {</div>
<div class="line">            var excess,</div>
<div class="line">                unquoted = !match[6] &amp;&amp; match[2];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( matchExpr[<span class="stringliteral">&quot;CHILD&quot;</span>].test( match[0] ) ) {</div>
<div class="line">                <span class="keywordflow">return</span> null;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Accept quoted arguments as-is</span></div>
<div class="line">            <span class="keywordflow">if</span> ( match[3] ) {</div>
<div class="line">                match[2] = match[4] || match[5] || <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Strip excess characters from unquoted arguments</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;</div>
<div class="line">                <span class="comment">// Get excess from tokenize (recursively)</span></div>
<div class="line">                (excess = tokenize( unquoted, <span class="keyword">true</span> )) &amp;&amp;</div>
<div class="line">                <span class="comment">// advance to the next closing parenthesis</span></div>
<div class="line">                (excess = unquoted.indexOf( <span class="stringliteral">&quot;)&quot;</span>, unquoted.length - excess ) - unquoted.length) ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// excess is a negative index</span></div>
<div class="line">                match[0] = match[0].slice( 0, excess );</div>
<div class="line">                match[2] = unquoted.slice( 0, excess );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return only captures needed by the pseudo filter method (type and argument)</span></div>
<div class="line">            <span class="keywordflow">return</span> match.slice( 0, 3 );</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    filter: {</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;TAG&quot;</span>: <span class="keyword">function</span>( nodeNameSelector ) {</div>
<div class="line">            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();</div>
<div class="line">            <span class="keywordflow">return</span> nodeNameSelector === <span class="stringliteral">&quot;*&quot;</span> ?</div>
<div class="line">                <span class="keyword">function</span>() { <span class="keywordflow">return</span> <span class="keyword">true</span>; } :</div>
<div class="line">                <span class="keyword">function</span>( elem ) {</div>
<div class="line">                    <span class="keywordflow">return</span> elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;</div>
<div class="line">                };</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;CLASS&quot;</span>: <span class="keyword">function</span>( className ) {</div>
<div class="line">            var pattern = classCache[ className + <span class="stringliteral">&quot; &quot;</span> ];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> pattern ||</div>
<div class="line">                (pattern = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;(^|&quot;</span> + whitespace + <span class="stringliteral">&quot;)&quot;</span> + className + <span class="stringliteral">&quot;(&quot;</span> + whitespace + <span class="stringliteral">&quot;|$)&quot;</span> )) &amp;&amp;</div>
<div class="line">                classCache( className, <span class="keyword">function</span>( elem ) {</div>
<div class="line">                    <span class="keywordflow">return</span> pattern.test( typeof elem.className === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(<span class="stringliteral">&quot;class&quot;</span>) || <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">                });</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;ATTR&quot;</span>: <span class="keyword">function</span>( name, <span class="keyword">operator</span>, check ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                var result = Sizzle.attr( elem, name );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( result == null ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">operator</span> === <span class="stringliteral">&quot;!=&quot;</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> ( !<span class="keyword">operator</span> ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                result += <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">operator</span> === <span class="stringliteral">&quot;=&quot;</span> ? result === check :</div>
<div class="line">                    <span class="keyword">operator</span> === <span class="stringliteral">&quot;!=&quot;</span> ? result !== check :</div>
<div class="line">                    <span class="keyword">operator</span> === <span class="stringliteral">&quot;^=&quot;</span> ? check &amp;&amp; result.indexOf( check ) === 0 :</div>
<div class="line">                    <span class="keyword">operator</span> === <span class="stringliteral">&quot;*=&quot;</span> ? check &amp;&amp; result.indexOf( check ) &gt; -1 :</div>
<div class="line">                    <span class="keyword">operator</span> === <span class="stringliteral">&quot;$=&quot;</span> ? check &amp;&amp; result.slice( -check.length ) === check :</div>
<div class="line">                    operator === &quot;~=&quot; ? ( <span class="stringliteral">&quot; &quot;</span> + result + <span class="stringliteral">&quot; &quot;</span> ).indexOf( check ) &gt; -1 :</div>
<div class="line">                    <span class="keyword">operator</span> === <span class="stringliteral">&quot;|=&quot;</span> ? result === check || result.slice( 0, check.length + 1 ) === check + <span class="stringliteral">&quot;-&quot;</span> :</div>
<div class="line">                    <span class="keyword">false</span>;</div>
<div class="line">            };</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;CHILD&quot;</span>: <span class="keyword">function</span>( type, what, argument, first, last ) {</div>
<div class="line">            var simple = type.slice( 0, 3 ) !== <span class="stringliteral">&quot;nth&quot;</span>,</div>
<div class="line">                forward = type.slice( -4 ) !== <span class="stringliteral">&quot;last&quot;</span>,</div>
<div class="line">                ofType = what === <span class="stringliteral">&quot;of-type&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> first === 1 &amp;&amp; last === 0 ?</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Shortcut for :nth-*(n)</span></div>
<div class="line">                <span class="keyword">function</span>( elem ) {</div>
<div class="line">                    <span class="keywordflow">return</span> !!elem.parentNode;</div>
<div class="line">                } :</div>
<div class="line"></div>
<div class="line">                <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">                    var cache, outerCache, node, diff, nodeIndex, start,</div>
<div class="line">                        dir = simple !== forward ? <span class="stringliteral">&quot;nextSibling&quot;</span> : <span class="stringliteral">&quot;previousSibling&quot;</span>,</div>
<div class="line">                        parent = elem.parentNode,</div>
<div class="line">                        name = ofType &amp;&amp; elem.nodeName.toLowerCase(),</div>
<div class="line">                        useCache = !xml &amp;&amp; !ofType;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( parent ) {</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// :(first|last|only)-(child|of-type)</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( simple ) {</div>
<div class="line">                            <span class="keywordflow">while</span> ( dir ) {</div>
<div class="line">                                node = elem;</div>
<div class="line">                                <span class="keywordflow">while</span> ( (node = node[ dir ]) ) {</div>
<div class="line">                                    <span class="keywordflow">if</span> ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {</div>
<div class="line">                                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                                <span class="comment">// Reverse direction for :only-* (if we haven&#39;t yet done so)</span></div>
<div class="line">                                start = dir = type === <span class="stringliteral">&quot;only&quot;</span> &amp;&amp; !start &amp;&amp; <span class="stringliteral">&quot;nextSibling&quot;</span>;</div>
<div class="line">                            }</div>
<div class="line">                            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line"></div>
<div class="line">                        start = [ forward ? parent.firstChild : parent.lastChild ];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// non-xml :nth-child(...) stores cache data on `parent`</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( forward &amp;&amp; useCache ) {</div>
<div class="line">                            <span class="comment">// Seek `elem` from a previously-cached index</span></div>
<div class="line">                            outerCache = parent[ expando ] || (parent[ expando ] = {});</div>
<div class="line">                            cache = outerCache[ type ] || [];</div>
<div class="line">                            nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];</div>
<div class="line">                            diff = cache[0] === dirruns &amp;&amp; cache[2];</div>
<div class="line">                            node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];</div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">while</span> ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||</div>
<div class="line"></div>
<div class="line">                                <span class="comment">// Fallback to seeking `elem` from the start</span></div>
<div class="line">                                (diff = nodeIndex = 0) || start.pop()) ) {</div>
<div class="line"></div>
<div class="line">                                <span class="comment">// When found, cache indexes on `parent` and break</span></div>
<div class="line">                                <span class="keywordflow">if</span> ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {</div>
<div class="line">                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Use previously-cached element index if available</span></div>
<div class="line">                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {</div>
<div class="line">                            diff = cache[1];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)</span></div>
<div class="line">                        } <span class="keywordflow">else</span> {</div>
<div class="line">                            <span class="comment">// Use the same loop as above to seek `elem` from the start</span></div>
<div class="line">                            <span class="keywordflow">while</span> ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||</div>
<div class="line">                                (diff = nodeIndex = 0) || start.pop()) ) {</div>
<div class="line"></div>
<div class="line">                                <span class="keywordflow">if</span> ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {</div>
<div class="line">                                    <span class="comment">// Cache the index of each encountered element</span></div>
<div class="line">                                    <span class="keywordflow">if</span> ( useCache ) {</div>
<div class="line">                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];</div>
<div class="line">                                    }</div>
<div class="line"></div>
<div class="line">                                    <span class="keywordflow">if</span> ( node === elem ) {</div>
<div class="line">                                        <span class="keywordflow">break</span>;</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Incorporate the offset, then check against cycle size</span></div>
<div class="line">                        diff -= last;</div>
<div class="line">                        <span class="keywordflow">return</span> diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );</div>
<div class="line">                    }</div>
<div class="line">                };</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;PSEUDO&quot;</span>: <span class="keyword">function</span>( pseudo, argument ) {</div>
<div class="line">            <span class="comment">// pseudo-class names are case-insensitive</span></div>
<div class="line">            <span class="comment">// http://www.w3.org/TR/selectors/#pseudo-classes</span></div>
<div class="line">            <span class="comment">// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters</span></div>
<div class="line">            <span class="comment">// Remember that setFilters inherits from pseudos</span></div>
<div class="line">            var args,</div>
<div class="line">                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||</div>
<div class="line">                    Sizzle.error( <span class="stringliteral">&quot;unsupported pseudo: &quot;</span> + pseudo );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The user may use createPseudo to indicate that</span></div>
<div class="line">            <span class="comment">// arguments are needed to create the filter function</span></div>
<div class="line">            <span class="comment">// just as Sizzle does</span></div>
<div class="line">            <span class="keywordflow">if</span> ( fn[ expando ] ) {</div>
<div class="line">                <span class="keywordflow">return</span> fn( argument );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// But maintain support for old signatures</span></div>
<div class="line">            <span class="keywordflow">if</span> ( fn.length &gt; 1 ) {</div>
<div class="line">                args = [ pseudo, pseudo, <span class="stringliteral">&quot;&quot;</span>, argument ];</div>
<div class="line">                <span class="keywordflow">return</span> Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?</div>
<div class="line">                    markFunction(<span class="keyword">function</span>( seed, matches ) {</div>
<div class="line">                        var idx,</div>
<div class="line">                            matched = fn( seed, argument ),</div>
<div class="line">                            i = matched.length;</div>
<div class="line">                        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                            idx = indexOf.call( seed, matched[i] );</div>
<div class="line">                            seed[ idx ] = !( matches[ idx ] = matched[i] );</div>
<div class="line">                        }</div>
<div class="line">                    }) :</div>
<div class="line">                    <span class="keyword">function</span>( elem ) {</div>
<div class="line">                        <span class="keywordflow">return</span> fn( elem, 0, args );</div>
<div class="line">                    };</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> fn;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    pseudos: {</div>
<div class="line">        <span class="comment">// Potentially complex pseudos</span></div>
<div class="line">        <span class="stringliteral">&quot;not&quot;</span>: markFunction(<span class="keyword">function</span>( selector ) {</div>
<div class="line">            <span class="comment">// Trim the selector passed to compile</span></div>
<div class="line">            <span class="comment">// to avoid treating leading and trailing</span></div>
<div class="line">            <span class="comment">// spaces as combinators</span></div>
<div class="line">            var input = [],</div>
<div class="line">                results = [],</div>
<div class="line">                matcher = compile( selector.replace( rtrim, <span class="stringliteral">&quot;$1&quot;</span> ) );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> matcher[ expando ] ?</div>
<div class="line">                markFunction(<span class="keyword">function</span>( seed, matches, context, xml ) {</div>
<div class="line">                    var elem,</div>
<div class="line">                        unmatched = matcher( seed, null, xml, [] ),</div>
<div class="line">                        i = seed.length;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Match elements unmatched by `matcher`</span></div>
<div class="line">                    <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( (elem = unmatched[i]) ) {</div>
<div class="line">                            seed[i] = !(matches[i] = elem);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }) :</div>
<div class="line">                <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">                    input[0] = elem;</div>
<div class="line">                    matcher( input, null, xml, results );</div>
<div class="line">                    <span class="keywordflow">return</span> !results.pop();</div>
<div class="line">                };</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;has&quot;</span>: markFunction(<span class="keyword">function</span>( selector ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                <span class="keywordflow">return</span> Sizzle( selector, elem ).length &gt; 0;</div>
<div class="line">            };</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;contains&quot;</span>: markFunction(<span class="keyword">function</span>( text ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                <span class="keywordflow">return</span> ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;</div>
<div class="line">            };</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="comment">// &quot;Whether an element is represented by a :lang() selector</span></div>
<div class="line">        <span class="comment">// is based solely on the element&#39;s language value</span></div>
<div class="line">        <span class="comment">// being equal to the identifier C,</span></div>
<div class="line">        <span class="comment">// or beginning with the identifier C immediately followed by &quot;-&quot;.</span></div>
<div class="line">        <span class="comment">// The matching of C against the element&#39;s language value is performed case-insensitively.</span></div>
<div class="line">        <span class="comment">// The identifier C does not have to be a valid language name.&quot;</span></div>
<div class="line">        <span class="comment">// http://www.w3.org/TR/selectors/#lang-pseudo</span></div>
<div class="line">        <span class="stringliteral">&quot;lang&quot;</span>: markFunction( <span class="keyword">function</span>( lang ) {</div>
<div class="line">            <span class="comment">// lang value must be a valid identifier</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !ridentifier.test(lang || <span class="stringliteral">&quot;&quot;</span>) ) {</div>
<div class="line">                Sizzle.error( <span class="stringliteral">&quot;unsupported lang: &quot;</span> + lang );</div>
<div class="line">            }</div>
<div class="line">            lang = lang.replace( runescape, funescape ).toLowerCase();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span>( elem ) {</div>
<div class="line">                var elemLang;</div>
<div class="line">                <span class="keywordflow">do</span> {</div>
<div class="line">                    <span class="keywordflow">if</span> ( (elemLang = documentIsHTML ?</div>
<div class="line">                        elem.lang :</div>
<div class="line">                        elem.getAttribute(<span class="stringliteral">&quot;xml:lang&quot;</span>) || elem.getAttribute(<span class="stringliteral">&quot;lang&quot;</span>)) ) {</div>
<div class="line"></div>
<div class="line">                        elemLang = elemLang.toLowerCase();</div>
<div class="line">                        <span class="keywordflow">return</span> elemLang === lang || elemLang.indexOf( lang + <span class="stringliteral">&quot;-&quot;</span> ) === 0;</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">while</span> ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            };</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Miscellaneous</span></div>
<div class="line">        <span class="stringliteral">&quot;target&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            var hash = window.location &amp;&amp; window.location.hash;</div>
<div class="line">            <span class="keywordflow">return</span> hash &amp;&amp; hash.slice( 1 ) === elem.id;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;root&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem === docElem;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;focus&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Boolean properties</span></div>
<div class="line">        <span class="stringliteral">&quot;enabled&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem.disabled === <span class="keyword">false</span>;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;disabled&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem.disabled === <span class="keyword">true</span>;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;checked&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="comment">// In CSS3, :checked should return both checked and selected elements</span></div>
<div class="line">            <span class="comment">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span></div>
<div class="line">            var nodeName = elem.nodeName.toLowerCase();</div>
<div class="line">            <span class="keywordflow">return</span> (nodeName === <span class="stringliteral">&quot;input&quot;</span> &amp;&amp; !!elem.checked) || (nodeName === <span class="stringliteral">&quot;option&quot;</span> &amp;&amp; !!elem.selected);</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;selected&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="comment">// Accessing this property makes selected-by-default</span></div>
<div class="line">            <span class="comment">// options in Safari work properly</span></div>
<div class="line">            <span class="keywordflow">if</span> ( elem.parentNode ) {</div>
<div class="line">                elem.parentNode.selectedIndex;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> elem.selected === <span class="keyword">true</span>;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Contents</span></div>
<div class="line">        <span class="stringliteral">&quot;empty&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="comment">// http://www.w3.org/TR/selectors/#empty-pseudo</span></div>
<div class="line">            <span class="comment">// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),</span></div>
<div class="line">            <span class="comment">//   but not by others (comment: 8; processing instruction: 7; etc.)</span></div>
<div class="line">            <span class="comment">// nodeType &lt; 6 works because attributes (2) do not appear as children</span></div>
<div class="line">            <span class="keywordflow">for</span> ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( elem.nodeType &lt; 6 ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;parent&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> !Expr.pseudos[<span class="stringliteral">&quot;empty&quot;</span>]( elem );</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Element/input types</span></div>
<div class="line">        <span class="stringliteral">&quot;header&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> rheader.test( elem.nodeName );</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;input&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> rinputs.test( elem.nodeName );</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;button&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            var name = elem.nodeName.toLowerCase();</div>
<div class="line">            <span class="keywordflow">return</span> name === <span class="stringliteral">&quot;input&quot;</span> &amp;&amp; elem.type === <span class="stringliteral">&quot;button&quot;</span> || name === <span class="stringliteral">&quot;button&quot;</span>;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;text&quot;</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            var attr;</div>
<div class="line">            <span class="keywordflow">return</span> elem.nodeName.toLowerCase() === <span class="stringliteral">&quot;input&quot;</span> &amp;&amp;</div>
<div class="line">                elem.type === <span class="stringliteral">&quot;text&quot;</span> &amp;&amp;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Support: IE&lt;8</span></div>
<div class="line">                <span class="comment">// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;</span></div>
<div class="line">                ( (attr = elem.getAttribute(<span class="stringliteral">&quot;type&quot;</span>)) == null || attr.toLowerCase() === <span class="stringliteral">&quot;text&quot;</span> );</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Position-in-collection</span></div>
<div class="line">        <span class="stringliteral">&quot;first&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> [ 0 ];</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;last&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length ) {</div>
<div class="line">            <span class="keywordflow">return</span> [ length - 1 ];</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;eq&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length, argument ) {</div>
<div class="line">            <span class="keywordflow">return</span> [ argument &lt; 0 ? argument + length : argument ];</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;even&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length ) {</div>
<div class="line">            var i = 0;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; length; i += 2 ) {</div>
<div class="line">                matchIndexes.push( i );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> matchIndexes;</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;odd&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length ) {</div>
<div class="line">            var i = 1;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; length; i += 2 ) {</div>
<div class="line">                matchIndexes.push( i );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> matchIndexes;</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;lt&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length, argument ) {</div>
<div class="line">            var i = argument &lt; 0 ? argument + length : argument;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; --i &gt;= 0; ) {</div>
<div class="line">                matchIndexes.push( i );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> matchIndexes;</div>
<div class="line">        }),</div>
<div class="line"></div>
<div class="line">        <span class="stringliteral">&quot;gt&quot;</span>: createPositionalPseudo(<span class="keyword">function</span>( matchIndexes, length, argument ) {</div>
<div class="line">            var i = argument &lt; 0 ? argument + length : argument;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; ++i &lt; length; ) {</div>
<div class="line">                matchIndexes.push( i );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> matchIndexes;</div>
<div class="line">        })</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Expr.pseudos[<span class="stringliteral">&quot;nth&quot;</span>] = Expr.pseudos[<span class="stringliteral">&quot;eq&quot;</span>];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add button/input type pseudos</span></div>
<div class="line"><span class="keywordflow">for</span> ( i in { radio: <span class="keyword">true</span>, checkbox: <span class="keyword">true</span>, file: <span class="keyword">true</span>, password: <span class="keyword">true</span>, image: <span class="keyword">true</span> } ) {</div>
<div class="line">    Expr.pseudos[ i ] = createInputPseudo( i );</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> ( i in { submit: <span class="keyword">true</span>, reset: <span class="keyword">true</span> } ) {</div>
<div class="line">    Expr.pseudos[ i ] = createButtonPseudo( i );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Easy API for creating new setFilters</span></div>
<div class="line"><span class="keyword">function</span> setFilters() {}</div>
<div class="line">setFilters.prototype = Expr.filters = Expr.pseudos;</div>
<div class="line">Expr.setFilters = <span class="keyword">new</span> setFilters();</div>
<div class="line"></div>
<div class="line">tokenize = Sizzle.tokenize = <span class="keyword">function</span>( selector, parseOnly ) {</div>
<div class="line">    var matched, match, tokens, type,</div>
<div class="line">        soFar, groups, preFilters,</div>
<div class="line">        cached = tokenCache[ selector + <span class="stringliteral">&quot; &quot;</span> ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( cached ) {</div>
<div class="line">        <span class="keywordflow">return</span> parseOnly ? 0 : cached.slice( 0 );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    soFar = selector;</div>
<div class="line">    groups = [];</div>
<div class="line">    preFilters = Expr.preFilter;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> ( soFar ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Comma and first run</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !matched || (match = rcomma.exec( soFar )) ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( match ) {</div>
<div class="line">                <span class="comment">// Don&#39;t consume trailing commas as valid</span></div>
<div class="line">                soFar = soFar.slice( match[0].length ) || soFar;</div>
<div class="line">            }</div>
<div class="line">            groups.push( (tokens = []) );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        matched = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Combinators</span></div>
<div class="line">        <span class="keywordflow">if</span> ( (match = rcombinators.exec( soFar )) ) {</div>
<div class="line">            matched = match.shift();</div>
<div class="line">            tokens.push({</div>
<div class="line">                value: matched,</div>
<div class="line">                <span class="comment">// Cast descendant combinators to space</span></div>
<div class="line">                type: match[0].replace( rtrim, <span class="stringliteral">&quot; &quot;</span> )</div>
<div class="line">            });</div>
<div class="line">            soFar = soFar.slice( matched.length );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Filters</span></div>
<div class="line">        <span class="keywordflow">for</span> ( type in Expr.filter ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||</div>
<div class="line">                (match = preFilters[ type ]( match ))) ) {</div>
<div class="line">                matched = match.shift();</div>
<div class="line">                tokens.push({</div>
<div class="line">                    value: matched,</div>
<div class="line">                    type: type,</div>
<div class="line">                    matches: match</div>
<div class="line">                });</div>
<div class="line">                soFar = soFar.slice( matched.length );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !matched ) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the length of the invalid excess</span></div>
<div class="line">    <span class="comment">// if we&#39;re just parsing</span></div>
<div class="line">    <span class="comment">// Otherwise, throw an error or return tokens</span></div>
<div class="line">    <span class="keywordflow">return</span> parseOnly ?</div>
<div class="line">        soFar.length :</div>
<div class="line">        soFar ?</div>
<div class="line">            Sizzle.error( selector ) :</div>
<div class="line">            <span class="comment">// Cache the tokens</span></div>
<div class="line">            tokenCache( selector, groups ).slice( 0 );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toSelector( tokens ) {</div>
<div class="line">    var i = 0,</div>
<div class="line">        len = tokens.length,</div>
<div class="line">        selector = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">        selector += tokens[i].value;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> selector;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> addCombinator( matcher, combinator, base ) {</div>
<div class="line">    var dir = combinator.dir,</div>
<div class="line">        checkNonElements = base &amp;&amp; dir === <span class="stringliteral">&quot;parentNode&quot;</span>,</div>
<div class="line">        doneName = done++;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> combinator.first ?</div>
<div class="line">        <span class="comment">// Check against closest ancestor/preceding element</span></div>
<div class="line">        <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">            <span class="keywordflow">while</span> ( (elem = elem[ dir ]) ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( elem.nodeType === 1 || checkNonElements ) {</div>
<div class="line">                    <span class="keywordflow">return</span> matcher( elem, context, xml );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } :</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check against all ancestor/preceding elements</span></div>
<div class="line">        <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">            var oldCache, outerCache,</div>
<div class="line">                newCache = [ dirruns, doneName ];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// We can&#39;t set arbitrary data on XML nodes, so they don&#39;t benefit from dir caching</span></div>
<div class="line">            <span class="keywordflow">if</span> ( xml ) {</div>
<div class="line">                <span class="keywordflow">while</span> ( (elem = elem[ dir ]) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.nodeType === 1 || checkNonElements ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( matcher( elem, context, xml ) ) {</div>
<div class="line">                            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">while</span> ( (elem = elem[ dir ]) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.nodeType === 1 || checkNonElements ) {</div>
<div class="line">                        outerCache = elem[ expando ] || (elem[ expando ] = {});</div>
<div class="line">                        <span class="keywordflow">if</span> ( (oldCache = outerCache[ dir ]) &amp;&amp;</div>
<div class="line">                            oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// Assign to newCache so results back-propagate to previous elements</span></div>
<div class="line">                            <span class="keywordflow">return</span> (newCache[ 2 ] = oldCache[ 2 ]);</div>
<div class="line">                        } <span class="keywordflow">else</span> {</div>
<div class="line">                            <span class="comment">// Reuse newcache so results back-propagate to previous elements</span></div>
<div class="line">                            outerCache[ dir ] = newCache;</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// A match means we&#39;re done; a fail means we have to keep checking</span></div>
<div class="line">                            <span class="keywordflow">if</span> ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {</div>
<div class="line">                                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> elementMatcher( matchers ) {</div>
<div class="line">    <span class="keywordflow">return</span> matchers.length &gt; 1 ?</div>
<div class="line">        <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">            var i = matchers.length;</div>
<div class="line">            <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !matchers[i]( elem, context, xml ) ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        } :</div>
<div class="line">        matchers[0];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> multipleContexts( selector, contexts, results ) {</div>
<div class="line">    var i = 0,</div>
<div class="line">        len = contexts.length;</div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">        Sizzle( selector, contexts[i], results );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> results;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> condense( unmatched, map, filter, context, xml ) {</div>
<div class="line">    var elem,</div>
<div class="line">        newUnmatched = [],</div>
<div class="line">        i = 0,</div>
<div class="line">        len = unmatched.length,</div>
<div class="line">        mapped = map != null;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( (elem = unmatched[i]) ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( !filter || filter( elem, context, xml ) ) {</div>
<div class="line">                newUnmatched.push( elem );</div>
<div class="line">                <span class="keywordflow">if</span> ( mapped ) {</div>
<div class="line">                    map.push( i );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> newUnmatched;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( postFilter &amp;&amp; !postFilter[ expando ] ) {</div>
<div class="line">        postFilter = setMatcher( postFilter );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> ( postFinder &amp;&amp; !postFinder[ expando ] ) {</div>
<div class="line">        postFinder = setMatcher( postFinder, postSelector );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> markFunction(<span class="keyword">function</span>( seed, results, context, xml ) {</div>
<div class="line">        var temp, i, elem,</div>
<div class="line">            preMap = [],</div>
<div class="line">            postMap = [],</div>
<div class="line">            preexisting = results.length,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get initial elements from seed or context</span></div>
<div class="line">            elems = seed || multipleContexts( selector || <span class="stringliteral">&quot;*&quot;</span>, context.nodeType ? [ context ] : context, [] ),</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Prefilter to get matcher input, preserving a map for seed-results synchronization</span></div>
<div class="line">            matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?</div>
<div class="line">                condense( elems, preMap, preFilter, context, xml ) :</div>
<div class="line">                elems,</div>
<div class="line"></div>
<div class="line">            matcherOut = matcher ?</div>
<div class="line">                <span class="comment">// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</span></div>
<div class="line">                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// ...intermediate processing is necessary</span></div>
<div class="line">                    [] :</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// ...otherwise use results directly</span></div>
<div class="line">                    results :</div>
<div class="line">                matcherIn;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Find primary matches</span></div>
<div class="line">        <span class="keywordflow">if</span> ( matcher ) {</div>
<div class="line">            matcher( matcherIn, matcherOut, context, xml );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Apply postFilter</span></div>
<div class="line">        <span class="keywordflow">if</span> ( postFilter ) {</div>
<div class="line">            temp = condense( matcherOut, postMap );</div>
<div class="line">            postFilter( temp, [], context, xml );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Un-match failing elements by moving them back to matcherIn</span></div>
<div class="line">            i = temp.length;</div>
<div class="line">            <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( (elem = temp[i]) ) {</div>
<div class="line">                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( seed ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( postFinder || preFilter ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( postFinder ) {</div>
<div class="line">                    <span class="comment">// Get the final matcherOut by condensing this intermediate into postFinder contexts</span></div>
<div class="line">                    temp = [];</div>
<div class="line">                    i = matcherOut.length;</div>
<div class="line">                    <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( (elem = matcherOut[i]) ) {</div>
<div class="line">                            <span class="comment">// Restore matcherIn since elem is not yet a final match</span></div>
<div class="line">                            temp.push( (matcherIn[i] = elem) );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    postFinder( null, (matcherOut = []), temp, xml );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Move matched elements from seed to results to keep them synchronized</span></div>
<div class="line">                i = matcherOut.length;</div>
<div class="line">                <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( (elem = matcherOut[i]) &amp;&amp;</div>
<div class="line">                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {</div>
<div class="line"></div>
<div class="line">                        seed[temp] = !(results[temp] = elem);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add elements to results, through postFinder if defined</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            matcherOut = condense(</div>
<div class="line">                matcherOut === results ?</div>
<div class="line">                    matcherOut.splice( preexisting, matcherOut.length ) :</div>
<div class="line">                    matcherOut</div>
<div class="line">            );</div>
<div class="line">            <span class="keywordflow">if</span> ( postFinder ) {</div>
<div class="line">                postFinder( null, results, matcherOut, xml );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                push.apply( results, matcherOut );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> matcherFromTokens( tokens ) {</div>
<div class="line">    var checkContext, matcher, j,</div>
<div class="line">        len = tokens.length,</div>
<div class="line">        leadingRelative = Expr.relative[ tokens[0].type ],</div>
<div class="line">        implicitRelative = leadingRelative || Expr.relative[<span class="stringliteral">&quot; &quot;</span>],</div>
<div class="line">        i = leadingRelative ? 1 : 0,</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The foundational matcher ensures that elements are reachable from top-level context(s)</span></div>
<div class="line">        matchContext = addCombinator( <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem === checkContext;</div>
<div class="line">        }, implicitRelative, true ),</div>
<div class="line">        matchAnyContext = addCombinator( <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> indexOf.call( checkContext, elem ) &gt; -1;</div>
<div class="line">        }, implicitRelative, true ),</div>
<div class="line">        matchers = [ <span class="keyword">function</span>( elem, context, xml ) {</div>
<div class="line">            <span class="keywordflow">return</span> ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (</div>
<div class="line">                (checkContext = context).nodeType ?</div>
<div class="line">                    matchContext( elem, context, xml ) :</div>
<div class="line">                    matchAnyContext( elem, context, xml ) );</div>
<div class="line">        } ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( (matcher = Expr.relative[ tokens[i].type ]) ) {</div>
<div class="line">            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Return special upon seeing a positional matcher</span></div>
<div class="line">            <span class="keywordflow">if</span> ( matcher[ expando ] ) {</div>
<div class="line">                <span class="comment">// Find the next relative operator (if any) for proper handling</span></div>
<div class="line">                j = ++i;</div>
<div class="line">                <span class="keywordflow">for</span> ( ; j &lt; len; j++ ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( Expr.relative[ tokens[j].type ] ) {</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> setMatcher(</div>
<div class="line">                    i &gt; 1 &amp;&amp; elementMatcher( matchers ),</div>
<div class="line">                    i &gt; 1 &amp;&amp; toSelector(</div>
<div class="line">                        <span class="comment">// If the preceding token was a descendant combinator, insert an implicit any-element `*`</span></div>
<div class="line">                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === <span class="stringliteral">&quot; &quot;</span> ? <span class="stringliteral">&quot;*&quot;</span> : <span class="stringliteral">&quot;&quot;</span> })</div>
<div class="line">                    ).replace( rtrim, <span class="stringliteral">&quot;$1&quot;</span> ),</div>
<div class="line">                    matcher,</div>
<div class="line">                    i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),</div>
<div class="line">                    j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),</div>
<div class="line">                    j &lt; len &amp;&amp; toSelector( tokens )</div>
<div class="line">                );</div>
<div class="line">            }</div>
<div class="line">            matchers.push( matcher );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> elementMatcher( matchers );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> matcherFromGroupMatchers( elementMatchers, setMatchers ) {</div>
<div class="line">    var bySet = setMatchers.length &gt; 0,</div>
<div class="line">        byElement = elementMatchers.length &gt; 0,</div>
<div class="line">        superMatcher = <span class="keyword">function</span>( seed, context, xml, results, outermost ) {</div>
<div class="line">            var elem, j, matcher,</div>
<div class="line">                matchedCount = 0,</div>
<div class="line">                i = <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">                unmatched = seed &amp;&amp; [],</div>
<div class="line">                setMatched = [],</div>
<div class="line">                contextBackup = outermostContext,</div>
<div class="line">                <span class="comment">// We must always have either seed elements or outermost context</span></div>
<div class="line">                elems = seed || byElement &amp;&amp; Expr.find[<span class="stringliteral">&quot;TAG&quot;</span>]( <span class="stringliteral">&quot;*&quot;</span>, outermost ),</div>
<div class="line">                <span class="comment">// Use integer dirruns iff this is the outermost matcher</span></div>
<div class="line">                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),</div>
<div class="line">                len = elems.length;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( outermost ) {</div>
<div class="line">                outermostContext = context !== document &amp;&amp; context;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add elements passing elementMatchers directly to results</span></div>
<div class="line">            <span class="comment">// Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below</span></div>
<div class="line">            <span class="comment">// Support: IE&lt;9, Safari</span></div>
<div class="line">            <span class="comment">// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id</span></div>
<div class="line">            <span class="keywordflow">for</span> ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( byElement &amp;&amp; elem ) {</div>
<div class="line">                    j = 0;</div>
<div class="line">                    <span class="keywordflow">while</span> ( (matcher = elementMatchers[j++]) ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( matcher( elem, context, xml ) ) {</div>
<div class="line">                            results.push( elem );</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> ( outermost ) {</div>
<div class="line">                        dirruns = dirrunsUnique;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Track unmatched elements for set filters</span></div>
<div class="line">                <span class="keywordflow">if</span> ( bySet ) {</div>
<div class="line">                    <span class="comment">// They will have gone through all possible matchers</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( (elem = !matcher &amp;&amp; elem) ) {</div>
<div class="line">                        matchedCount--;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Lengthen the array for every element, matched or not</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( seed ) {</div>
<div class="line">                        unmatched.push( elem );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Apply set filters to unmatched elements</span></div>
<div class="line">            matchedCount += i;</div>
<div class="line">            <span class="keywordflow">if</span> ( bySet &amp;&amp; i !== matchedCount ) {</div>
<div class="line">                j = 0;</div>
<div class="line">                <span class="keywordflow">while</span> ( (matcher = setMatchers[j++]) ) {</div>
<div class="line">                    matcher( unmatched, setMatched, context, xml );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( seed ) {</div>
<div class="line">                    <span class="comment">// Reintegrate element matches to eliminate the need for sorting</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( matchedCount &gt; 0 ) {</div>
<div class="line">                        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                            <span class="keywordflow">if</span> ( !(unmatched[i] || setMatched[i]) ) {</div>
<div class="line">                                setMatched[i] = pop.call( results );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Discard index placeholder values to get only actual matches</span></div>
<div class="line">                    setMatched = condense( setMatched );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Add matches to results</span></div>
<div class="line">                push.apply( results, setMatched );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Seedless set matches succeeding multiple successful matchers stipulate sorting</span></div>
<div class="line">                <span class="keywordflow">if</span> ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;</div>
<div class="line">                    ( matchedCount + setMatchers.length ) &gt; 1 ) {</div>
<div class="line"></div>
<div class="line">                    Sizzle.uniqueSort( results );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Override manipulation of globals by nested matchers</span></div>
<div class="line">            <span class="keywordflow">if</span> ( outermost ) {</div>
<div class="line">                dirruns = dirrunsUnique;</div>
<div class="line">                outermostContext = contextBackup;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> unmatched;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bySet ?</div>
<div class="line">        markFunction( superMatcher ) :</div>
<div class="line">        superMatcher;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">compile = Sizzle.compile = <span class="keyword">function</span>( selector, match <span class="comment">/* Internal Use Only */</span> ) {</div>
<div class="line">    var i,</div>
<div class="line">        setMatchers = [],</div>
<div class="line">        elementMatchers = [],</div>
<div class="line">        cached = compilerCache[ selector + <span class="stringliteral">&quot; &quot;</span> ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !cached ) {</div>
<div class="line">        <span class="comment">// Generate a function of recursive functions that can be used to check each element</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !match ) {</div>
<div class="line">            match = tokenize( selector );</div>
<div class="line">        }</div>
<div class="line">        i = match.length;</div>
<div class="line">        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">            cached = matcherFromTokens( match[i] );</div>
<div class="line">            <span class="keywordflow">if</span> ( cached[ expando ] ) {</div>
<div class="line">                setMatchers.push( cached );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                elementMatchers.push( cached );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Cache the compiled function</span></div>
<div class="line">        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Save selector and tokenization</span></div>
<div class="line">        cached.selector = selector;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> cached;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">select = Sizzle.select = <span class="keyword">function</span>( selector, context, results, seed ) {</div>
<div class="line">    var i, tokens, token, type, find,</div>
<div class="line">        compiled = typeof selector === <span class="stringliteral">&quot;function&quot;</span> &amp;&amp; selector,</div>
<div class="line">        match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );</div>
<div class="line"></div>
<div class="line">    results = results || [];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Try to minimize operations if there is no seed and only one group</span></div>
<div class="line">    <span class="keywordflow">if</span> ( match.length === 1 ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Take a shortcut and set the context if the root selector is an ID</span></div>
<div class="line">        tokens = match[0] = match[0].slice( 0 );</div>
<div class="line">        <span class="keywordflow">if</span> ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === <span class="stringliteral">&quot;ID&quot;</span> &amp;&amp;</div>
<div class="line">                support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;</div>
<div class="line">                Expr.relative[ tokens[1].type ] ) {</div>
<div class="line"></div>
<div class="line">            context = ( Expr.find[<span class="stringliteral">&quot;ID&quot;</span>]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];</div>
<div class="line">            <span class="keywordflow">if</span> ( !context ) {</div>
<div class="line">                <span class="keywordflow">return</span> results;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Precompiled matchers will still verify ancestry, so step up a level</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( compiled ) {</div>
<div class="line">                context = context.parentNode;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            selector = selector.slice( tokens.shift().value.length );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Fetch a seed set for right-to-left matching</span></div>
<div class="line">        i = matchExpr[<span class="stringliteral">&quot;needsContext&quot;</span>].test( selector ) ? 0 : tokens.length;</div>
<div class="line">        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">            token = tokens[i];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Abort if we hit a combinator</span></div>
<div class="line">            <span class="keywordflow">if</span> ( Expr.relative[ (type = token.type) ] ) {</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> ( (find = Expr.find[ type ]) ) {</div>
<div class="line">                <span class="comment">// Search, expanding context for leading sibling combinators</span></div>
<div class="line">                <span class="keywordflow">if</span> ( (seed = find(</div>
<div class="line">                    token.matches[0].replace( runescape, funescape ),</div>
<div class="line">                    rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context</div>
<div class="line">                )) ) {</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// If seed is empty or no tokens remain, we can return early</span></div>
<div class="line">                    tokens.splice( i, 1 );</div>
<div class="line">                    selector = seed.length &amp;&amp; toSelector( tokens );</div>
<div class="line">                    <span class="keywordflow">if</span> ( !selector ) {</div>
<div class="line">                        push.apply( results, seed );</div>
<div class="line">                        <span class="keywordflow">return</span> results;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compile and execute a filtering function if one is not provided</span></div>
<div class="line">    <span class="comment">// Provide `match` to avoid retokenization if we modified the selector above</span></div>
<div class="line">    ( compiled || compile( selector, match ) )(</div>
<div class="line">        seed,</div>
<div class="line">        context,</div>
<div class="line">        !documentIsHTML,</div>
<div class="line">        results,</div>
<div class="line">        rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> results;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// One-time assignments</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Sort stability</span></div>
<div class="line">support.sortStable = expando.split(<span class="stringliteral">&quot;&quot;</span>).sort( sortOrder ).join(<span class="stringliteral">&quot;&quot;</span>) === expando;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: Chrome&lt;14</span></div>
<div class="line"><span class="comment">// Always assume duplicates if they aren&#39;t passed to the comparison function</span></div>
<div class="line">support.detectDuplicates = !!hasDuplicate;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize against the default document</span></div>
<div class="line">setDocument();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)</span></div>
<div class="line"><span class="comment">// Detached nodes confoundingly follow *each other*</span></div>
<div class="line">support.sortDetached = assert(<span class="keyword">function</span>( div1 ) {</div>
<div class="line">    <span class="comment">// Should return 1, but returns 4 (following)</span></div>
<div class="line">    <span class="keywordflow">return</span> div1.compareDocumentPosition( document.createElement(<span class="stringliteral">&quot;div&quot;</span>) ) &amp; 1;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE&lt;8</span></div>
<div class="line"><span class="comment">// Prevent attribute/property &quot;interpolation&quot;</span></div>
<div class="line"><span class="comment">// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</span></div>
<div class="line"><span class="keywordflow">if</span> ( !assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">    div.innerHTML = <span class="stringliteral">&quot;&lt;a href=&#39;#&#39;&gt;&lt;/a&gt;&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> div.firstChild.getAttribute(<span class="stringliteral">&quot;href&quot;</span>) === <span class="stringliteral">&quot;#&quot;</span> ;</div>
<div class="line">}) ) {</div>
<div class="line">    addHandle( <span class="stringliteral">&quot;type|href|height|width&quot;</span>, <span class="keyword">function</span>( elem, name, isXML ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( !isXML ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem.getAttribute( name, name.toLowerCase() === <span class="stringliteral">&quot;type&quot;</span> ? 1 : 2 );</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE&lt;9</span></div>
<div class="line"><span class="comment">// Use defaultValue in place of getAttribute(&quot;value&quot;)</span></div>
<div class="line"><span class="keywordflow">if</span> ( !support.attributes || !assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">    div.innerHTML = <span class="stringliteral">&quot;&lt;input/&gt;&quot;</span>;</div>
<div class="line">    div.firstChild.setAttribute( <span class="stringliteral">&quot;value&quot;</span>, <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">    <span class="keywordflow">return</span> div.firstChild.getAttribute( <span class="stringliteral">&quot;value&quot;</span> ) === <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">}) ) {</div>
<div class="line">    addHandle( <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">function</span>( elem, name, isXML ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === <span class="stringliteral">&quot;input&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem.defaultValue;</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE&lt;9</span></div>
<div class="line"><span class="comment">// Use getAttributeNode to fetch booleans when getAttribute lies</span></div>
<div class="line"><span class="keywordflow">if</span> ( !assert(<span class="keyword">function</span>( div ) {</div>
<div class="line">    <span class="keywordflow">return</span> div.getAttribute(<span class="stringliteral">&quot;disabled&quot;</span>) == null;</div>
<div class="line">}) ) {</div>
<div class="line">    addHandle( booleans, <span class="keyword">function</span>( elem, name, isXML ) {</div>
<div class="line">        var val;</div>
<div class="line">        <span class="keywordflow">if</span> ( !isXML ) {</div>
<div class="line">            <span class="keywordflow">return</span> elem[ name ] === <span class="keyword">true</span> ? name.toLowerCase() :</div>
<div class="line">                    (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?</div>
<div class="line">                    val.value :</div>
<div class="line">                null;</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">return</span> Sizzle;</div>
<div class="line"></div>
<div class="line">})( window );</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.find = Sizzle;</div>
<div class="line">jQuery.expr = Sizzle.selectors;</div>
<div class="line">jQuery.expr[<span class="stringliteral">&quot;:&quot;</span>] = jQuery.expr.pseudos;</div>
<div class="line">jQuery.unique = Sizzle.uniqueSort;</div>
<div class="line">jQuery.text = Sizzle.getText;</div>
<div class="line">jQuery.isXMLDoc = Sizzle.isXML;</div>
<div class="line">jQuery.contains = Sizzle.contains;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var rneedsContext = jQuery.expr.match.needsContext;</div>
<div class="line"></div>
<div class="line">var rsingleTag = (/^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var risSimple = /^.[^:#\[\.,]*$/;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implement the identical functionality for filter and not</span></div>
<div class="line"><span class="keyword">function</span> winnow( elements, qualifier, not ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.isFunction( qualifier ) ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.grep( elements, <span class="keyword">function</span>( elem, i ) {</div>
<div class="line">            <span class="comment">/* jshint -W018 */</span></div>
<div class="line">            <span class="keywordflow">return</span> !!qualifier.call( elem, i, elem ) !== not;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( qualifier.nodeType ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.grep( elements, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> ( elem === qualifier ) !== not;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( typeof qualifier === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( risSimple.test( qualifier ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> jQuery.filter( qualifier, elements, not );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        qualifier = jQuery.filter( qualifier, elements );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> jQuery.grep( elements, <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> ( indexOf.call( qualifier, elem ) &gt;= 0 ) !== not;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.filter = <span class="keyword">function</span>( expr, elems, not ) {</div>
<div class="line">    var elem = elems[ 0 ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( not ) {</div>
<div class="line">        expr = <span class="stringliteral">&quot;:not(&quot;</span> + expr + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> elems.length === 1 &amp;&amp; elem.nodeType === 1 ?</div>
<div class="line">        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :</div>
<div class="line">        jQuery.find.matches( expr, jQuery.grep( elems, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            return elem.nodeType === 1;</div>
<div class="line">        }));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    find: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        var i,</div>
<div class="line">            len = this.length,</div>
<div class="line">            ret = [],</div>
<div class="line">            <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof selector !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.pushStack( jQuery( selector ).filter(<span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">for</span> ( i = 0; i &lt; len; i++ ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( jQuery.contains( <span class="keyword">self</span>[ i ], <span class="keyword">this</span> ) ) {</div>
<div class="line">                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }) );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( i = 0; i &lt; len; i++ ) {</div>
<div class="line">            jQuery.find( selector, <span class="keyword">self</span>[ i ], ret );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Needed because $( selector, context ) becomes $( context ).find( selector )</span></div>
<div class="line">        ret = this.pushStack( len &gt; 1 ? jQuery.unique( ret ) : ret );</div>
<div class="line">        ret.selector = this.selector ? this.selector + <span class="stringliteral">&quot; &quot;</span> + selector : selector;</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    },</div>
<div class="line">    filter: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( winnow(<span class="keyword">this</span>, selector || [], <span class="keyword">false</span>) );</div>
<div class="line">    },</div>
<div class="line">    not: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( winnow(<span class="keyword">this</span>, selector || [], <span class="keyword">true</span>) );</div>
<div class="line">    },</div>
<div class="line">    is: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        <span class="keywordflow">return</span> !!winnow(</div>
<div class="line">            <span class="keyword">this</span>,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If this is a positional/relative selector, check membership in the returned set</span></div>
<div class="line">            <span class="comment">// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#39;t return true for a doc with two &quot;p&quot;.</span></div>
<div class="line">            typeof selector === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; rneedsContext.test( selector ) ?</div>
<div class="line">                jQuery( selector ) :</div>
<div class="line">                selector || [],</div>
<div class="line">            false</div>
<div class="line">        ).length;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize a jQuery object</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// A central reference to the root jQuery(document)</span></div>
<div class="line">var rootjQuery,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A simple way to check for HTML strings</span></div>
<div class="line">    <span class="comment">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span></div>
<div class="line">    <span class="comment">// Strict HTML recognition (#11290: must start with &lt;)</span></div>
<div class="line">    rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,</div>
<div class="line"></div>
<div class="line">    init = jQuery.fn.init = <span class="keyword">function</span>( selector, context ) {</div>
<div class="line">        var match, elem;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !selector ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Handle HTML strings</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof selector === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( selector[0] === <span class="stringliteral">&quot;&lt;&quot;</span> &amp;&amp; selector[ selector.length - 1 ] === <span class="stringliteral">&quot;&gt;&quot;</span> &amp;&amp; selector.length &gt;= 3 ) {</div>
<div class="line">                <span class="comment">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span></div>
<div class="line">                match = [ null, selector, null ];</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                match = rquickExpr.exec( selector );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Match html or make sure no context is specified for #id</span></div>
<div class="line">            <span class="keywordflow">if</span> ( match &amp;&amp; (match[1] || !context) ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// HANDLE: $(html) -&gt; $(array)</span></div>
<div class="line">                <span class="keywordflow">if</span> ( match[1] ) {</div>
<div class="line">                    context = context instanceof jQuery ? context[0] : context;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// scripts is true for back-compat</span></div>
<div class="line">                    <span class="comment">// Intentionally let the error be thrown if parseHTML is not present</span></div>
<div class="line">                    jQuery.merge( <span class="keyword">this</span>, jQuery.parseHTML(</div>
<div class="line">                        match[1],</div>
<div class="line">                        context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,</div>
<div class="line">                        <span class="keyword">true</span></div>
<div class="line">                    ) );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// HANDLE: $(html, props)</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {</div>
<div class="line">                        <span class="keywordflow">for</span> ( match in context ) {</div>
<div class="line">                            <span class="comment">// Properties of context are called as methods if possible</span></div>
<div class="line">                            <span class="keywordflow">if</span> ( jQuery.isFunction( <span class="keyword">this</span>[ match ] ) ) {</div>
<div class="line">                                <span class="keyword">this</span>[ match ]( context[ match ] );</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// ...and otherwise set as attributes</span></div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                this.attr( match, context[ match ] );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// HANDLE: $(#id)</span></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    elem = document.getElementById( match[2] );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span></div>
<div class="line">                    <span class="comment">// nodes that are no longer in the document #6963</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( elem &amp;&amp; elem.parentNode ) {</div>
<div class="line">                        <span class="comment">// Inject the element directly into the jQuery object</span></div>
<div class="line">                        this.length = 1;</div>
<div class="line">                        <span class="keyword">this</span>[0] = elem;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    this.context = document;</div>
<div class="line">                    this.selector = selector;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// HANDLE: $(expr, $(...))</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !context || context.jquery ) {</div>
<div class="line">                <span class="keywordflow">return</span> ( context || rootjQuery ).find( selector );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// HANDLE: $(expr, context)</span></div>
<div class="line">            <span class="comment">// (which is just equivalent to: $(context).find(expr)</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">return</span> this.constructor( context ).find( selector );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// HANDLE: $(DOMElement)</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( selector.nodeType ) {</div>
<div class="line">            this.context = <span class="keyword">this</span>[0] = selector;</div>
<div class="line">            this.length = 1;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// HANDLE: $(function)</span></div>
<div class="line">        <span class="comment">// Shortcut for document ready</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( jQuery.isFunction( selector ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> typeof rootjQuery.ready !== <span class="stringliteral">&quot;undefined&quot;</span> ?</div>
<div class="line">                rootjQuery.ready( selector ) :</div>
<div class="line">                <span class="comment">// Execute immediately if ready is not present</span></div>
<div class="line">                selector( jQuery );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( selector.selector !== undefined ) {</div>
<div class="line">            this.selector = selector.selector;</div>
<div class="line">            this.context = selector.context;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> jQuery.makeArray( selector, <span class="keyword">this</span> );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Give the init function the jQuery prototype for later instantiation</span></div>
<div class="line">init.prototype = jQuery.fn;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize central reference</span></div>
<div class="line">rootjQuery = jQuery( document );</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var rparentsprev = /^(?:parents|prev(?:Until|All))/,</div>
<div class="line">    <span class="comment">// methods guaranteed to produce a unique set when starting from a unique set</span></div>
<div class="line">    guaranteedUnique = {</div>
<div class="line">        children: <span class="keyword">true</span>,</div>
<div class="line">        contents: <span class="keyword">true</span>,</div>
<div class="line">        next: <span class="keyword">true</span>,</div>
<div class="line">        prev: <span class="keyword">true</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    dir: <span class="keyword">function</span>( elem, dir, until ) {</div>
<div class="line">        var matched = [],</div>
<div class="line">            truncate = until !== undefined;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> ( (elem = elem[ dir ]) &amp;&amp; elem.nodeType !== 9 ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( elem.nodeType === 1 ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                matched.push( elem );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> matched;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    sibling: <span class="keyword">function</span>( n, elem ) {</div>
<div class="line">        var matched = [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; n; n = n.nextSibling ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( n.nodeType === 1 &amp;&amp; n !== elem ) {</div>
<div class="line">                matched.push( n );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> matched;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    has: <span class="keyword">function</span>( target ) {</div>
<div class="line">        var targets = jQuery( target, <span class="keyword">this</span> ),</div>
<div class="line">            l = targets.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.filter(<span class="keyword">function</span>() {</div>
<div class="line">            var i = 0;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( jQuery.contains( <span class="keyword">this</span>, targets[i] ) ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    closest: <span class="keyword">function</span>( selectors, context ) {</div>
<div class="line">        var cur,</div>
<div class="line">            i = 0,</div>
<div class="line">            l = this.length,</div>
<div class="line">            matched = [],</div>
<div class="line">            pos = rneedsContext.test( selectors ) || typeof selectors !== <span class="stringliteral">&quot;string&quot;</span> ?</div>
<div class="line">                jQuery( selectors, context || this.context ) :</div>
<div class="line">                0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">            <span class="keywordflow">for</span> ( cur = <span class="keyword">this</span>[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {</div>
<div class="line">                <span class="comment">// Always skip document fragments</span></div>
<div class="line">                <span class="keywordflow">if</span> ( cur.nodeType &lt; 11 &amp;&amp; (pos ?</div>
<div class="line">                    pos.index(cur) &gt; -1 :</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Don&#39;t pass non-elements to Sizzle</span></div>
<div class="line">                    cur.nodeType === 1 &amp;&amp;</div>
<div class="line">                        jQuery.find.matchesSelector(cur, selectors)) ) {</div>
<div class="line"></div>
<div class="line">                    matched.push( cur );</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( matched.length &gt; 1 ? jQuery.unique( matched ) : matched );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Determine the position of an element within</span></div>
<div class="line">    <span class="comment">// the matched set of elements</span></div>
<div class="line">    index: <span class="keyword">function</span>( elem ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// No argument, return index in parent</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> ( <span class="keyword">this</span>[ 0 ] &amp;&amp; <span class="keyword">this</span>[ 0 ].parentNode ) ? this.first().prevAll().length : -1;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// index in selector</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof elem === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> indexOf.call( jQuery( elem ), <span class="keyword">this</span>[ 0 ] );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Locate the position of the desired element</span></div>
<div class="line">        <span class="keywordflow">return</span> indexOf.call( <span class="keyword">this</span>,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If it receives a jQuery object, the first element is used</span></div>
<div class="line">            elem.jquery ? elem[ 0 ] : elem</div>
<div class="line">        );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    add: <span class="keyword">function</span>( selector, context ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack(</div>
<div class="line">            jQuery.unique(</div>
<div class="line">                jQuery.merge( <span class="keyword">this</span>.get(), jQuery( selector, context ) )</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    addBack: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.add( selector == null ?</div>
<div class="line">            this.prevObject : this.prevObject.filter(selector)</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> sibling( cur, dir ) {</div>
<div class="line">    <span class="keywordflow">while</span> ( (cur = cur[dir]) &amp;&amp; cur.nodeType !== 1 ) {}</div>
<div class="line">    <span class="keywordflow">return</span> cur;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.each({</div>
<div class="line">    parent: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        var parent = elem.parentNode;</div>
<div class="line">        <span class="keywordflow">return</span> parent &amp;&amp; parent.nodeType !== 11 ? parent : null;</div>
<div class="line">    },</div>
<div class="line">    parents: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;parentNode&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    parentsUntil: <span class="keyword">function</span>( elem, i, until ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;parentNode&quot;</span>, until );</div>
<div class="line">    },</div>
<div class="line">    next: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> sibling( elem, <span class="stringliteral">&quot;nextSibling&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    prev: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> sibling( elem, <span class="stringliteral">&quot;previousSibling&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    nextAll: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;nextSibling&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    prevAll: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;previousSibling&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    nextUntil: <span class="keyword">function</span>( elem, i, until ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;nextSibling&quot;</span>, until );</div>
<div class="line">    },</div>
<div class="line">    prevUntil: <span class="keyword">function</span>( elem, i, until ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.dir( elem, <span class="stringliteral">&quot;previousSibling&quot;</span>, until );</div>
<div class="line">    },</div>
<div class="line">    siblings: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );</div>
<div class="line">    },</div>
<div class="line">    children: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.sibling( elem.firstChild );</div>
<div class="line">    },</div>
<div class="line">    contents: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> elem.contentDocument || jQuery.merge( [], elem.childNodes );</div>
<div class="line">    }</div>
<div class="line">}, <span class="keyword">function</span>( name, fn ) {</div>
<div class="line">    jQuery.fn[ name ] = <span class="keyword">function</span>( until, selector ) {</div>
<div class="line">        var matched = jQuery.map( <span class="keyword">this</span>, fn, until );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( name.slice( -5 ) !== <span class="stringliteral">&quot;Until&quot;</span> ) {</div>
<div class="line">            selector = until;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( selector &amp;&amp; typeof selector === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            matched = jQuery.filter( selector, matched );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( this.length &gt; 1 ) {</div>
<div class="line">            <span class="comment">// Remove duplicates</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !guaranteedUnique[ name ] ) {</div>
<div class="line">                jQuery.unique( matched );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Reverse order for parents* and prev-derivatives</span></div>
<div class="line">            <span class="keywordflow">if</span> ( rparentsprev.test( name ) ) {</div>
<div class="line">                matched.reverse();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( matched );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line">var rnotwhite = (/\S+/g);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// String to Object options format cache</span></div>
<div class="line">var optionsCache = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Convert String-formatted options into Object-formatted ones and store in cache</span></div>
<div class="line"><span class="keyword">function</span> createOptions( options ) {</div>
<div class="line">    var <span class="keywordtype">object</span> = optionsCache[ options ] = {};</div>
<div class="line">    jQuery.each( options.match( rnotwhite ) || [], <span class="keyword">function</span>( _, flag ) {</div>
<div class="line">        <span class="keywordtype">object</span>[ flag ] = <span class="keyword">true</span>;</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> object;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Create a callback list using the following parameters:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  options: an optional list of space-separated options that will change how</span></div>
<div class="line"><span class="comment"> *          the callback list behaves or a more traditional option object</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * By default a callback list will act like an event callback list and can be</span></div>
<div class="line"><span class="comment"> * &quot;fired&quot; multiple times.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Possible options:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  once:           will ensure the callback list can only be fired once (like a Deferred)</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  memory:         will keep track of previous values and will call any callback added</span></div>
<div class="line"><span class="comment"> *                  after the list has been fired right away with the latest &quot;memorized&quot;</span></div>
<div class="line"><span class="comment"> *                  values (like a Deferred)</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  unique:         will ensure a callback can only be added once (no duplicate in the list)</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *  stopOnFalse:    interrupt callings when a callback returns false</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">jQuery.Callbacks = <span class="keyword">function</span>( options ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert options from String-formatted to Object-formatted if needed</span></div>
<div class="line">    <span class="comment">// (we check in cache first)</span></div>
<div class="line">    options = typeof options === <span class="stringliteral">&quot;string&quot;</span> ?</div>
<div class="line">        ( optionsCache[ options ] || createOptions( options ) ) :</div>
<div class="line">        jQuery.extend( {}, options );</div>
<div class="line"></div>
<div class="line">    var <span class="comment">// Last fire value (for non-forgettable lists)</span></div>
<div class="line">        memory,</div>
<div class="line">        <span class="comment">// Flag to know if list was already fired</span></div>
<div class="line">        fired,</div>
<div class="line">        <span class="comment">// Flag to know if list is currently firing</span></div>
<div class="line">        firing,</div>
<div class="line">        <span class="comment">// First callback to fire (used internally by add and fireWith)</span></div>
<div class="line">        firingStart,</div>
<div class="line">        <span class="comment">// End of the loop when firing</span></div>
<div class="line">        firingLength,</div>
<div class="line">        <span class="comment">// Index of currently firing callback (modified by remove if needed)</span></div>
<div class="line">        firingIndex,</div>
<div class="line">        <span class="comment">// Actual callback list</span></div>
<div class="line">        list = [],</div>
<div class="line">        <span class="comment">// Stack of fire calls for repeatable lists</span></div>
<div class="line">        stack = !options.once &amp;&amp; [],</div>
<div class="line">        <span class="comment">// Fire callbacks</span></div>
<div class="line">        fire = <span class="keyword">function</span>( data ) {</div>
<div class="line">            memory = options.memory &amp;&amp; data;</div>
<div class="line">            fired = <span class="keyword">true</span>;</div>
<div class="line">            firingIndex = firingStart || 0;</div>
<div class="line">            firingStart = 0;</div>
<div class="line">            firingLength = list.length;</div>
<div class="line">            firing = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">for</span> ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === <span class="keyword">false</span> &amp;&amp; options.stopOnFalse ) {</div>
<div class="line">                    memory = <span class="keyword">false</span>; <span class="comment">// To prevent further calls using add</span></div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            firing = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span> ( list ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( stack ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( stack.length ) {</div>
<div class="line">                        fire( stack.shift() );</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( memory ) {</div>
<div class="line">                    list = [];</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keyword">self</span>.disable();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        <span class="comment">// Actual Callbacks object</span></div>
<div class="line">        <span class="keyword">self</span> = {</div>
<div class="line">            <span class="comment">// Add a callback or a collection of callbacks to the list</span></div>
<div class="line">            add: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( list ) {</div>
<div class="line">                    <span class="comment">// First, we save the current length</span></div>
<div class="line">                    var start = list.length;</div>
<div class="line">                    (<span class="keyword">function</span> add( args ) {</div>
<div class="line">                        jQuery.each( args, <span class="keyword">function</span>( _, arg ) {</div>
<div class="line">                            var type = jQuery.type( arg );</div>
<div class="line">                            <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;function&quot;</span> ) {</div>
<div class="line">                                <span class="keywordflow">if</span> ( !options.unique || !<span class="keyword">self</span>.has( arg ) ) {</div>
<div class="line">                                    list.push( arg );</div>
<div class="line">                                }</div>
<div class="line">                            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( arg &amp;&amp; arg.length &amp;&amp; type !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">                                <span class="comment">// Inspect recursively</span></div>
<div class="line">                                add( arg );</div>
<div class="line">                            }</div>
<div class="line">                        });</div>
<div class="line">                    })( arguments );</div>
<div class="line">                    <span class="comment">// Do we need to add the callbacks to the</span></div>
<div class="line">                    <span class="comment">// current firing batch?</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( firing ) {</div>
<div class="line">                        firingLength = list.length;</div>
<div class="line">                    <span class="comment">// With memory, if we&#39;re not firing then</span></div>
<div class="line">                    <span class="comment">// we should call right away</span></div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( memory ) {</div>
<div class="line">                        firingStart = start;</div>
<div class="line">                        fire( memory );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Remove a callback from the list</span></div>
<div class="line">            <span class="keyword">remove</span>: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( list ) {</div>
<div class="line">                    jQuery.each( arguments, <span class="keyword">function</span>( _, arg ) {</div>
<div class="line">                        var index;</div>
<div class="line">                        <span class="keywordflow">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {</div>
<div class="line">                            list.splice( index, 1 );</div>
<div class="line">                            <span class="comment">// Handle firing indexes</span></div>
<div class="line">                            <span class="keywordflow">if</span> ( firing ) {</div>
<div class="line">                                <span class="keywordflow">if</span> ( index &lt;= firingLength ) {</div>
<div class="line">                                    firingLength--;</div>
<div class="line">                                }</div>
<div class="line">                                <span class="keywordflow">if</span> ( index &lt;= firingIndex ) {</div>
<div class="line">                                    firingIndex--;</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    });</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Check if a given callback is in the list.</span></div>
<div class="line">            <span class="comment">// If no argument is given, return whether or not list has callbacks attached.</span></div>
<div class="line">            has: <span class="keyword">function</span>( fn ) {</div>
<div class="line">                <span class="keywordflow">return</span> fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Remove all callbacks from the list</span></div>
<div class="line">            empty: <span class="keyword">function</span>() {</div>
<div class="line">                list = [];</div>
<div class="line">                firingLength = 0;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Have the list do nothing anymore</span></div>
<div class="line">            disable: <span class="keyword">function</span>() {</div>
<div class="line">                list = stack = memory = undefined;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Is it disabled?</span></div>
<div class="line">            disabled: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">return</span> !list;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Lock the list in its current state</span></div>
<div class="line">            lock: <span class="keyword">function</span>() {</div>
<div class="line">                stack = undefined;</div>
<div class="line">                <span class="keywordflow">if</span> ( !memory ) {</div>
<div class="line">                    <span class="keyword">self</span>.disable();</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Is it locked?</span></div>
<div class="line">            locked: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">return</span> !stack;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Call all callbacks with the given context and arguments</span></div>
<div class="line">            fireWith: <span class="keyword">function</span>( context, args ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( list &amp;&amp; ( !fired || stack ) ) {</div>
<div class="line">                    args = args || [];</div>
<div class="line">                    args = [ context, args.slice ? args.slice() : args ];</div>
<div class="line">                    <span class="keywordflow">if</span> ( firing ) {</div>
<div class="line">                        stack.push( args );</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        fire( args );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// Call all the callbacks with the given arguments</span></div>
<div class="line">            fire: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keyword">self</span>.fireWith( <span class="keyword">this</span>, arguments );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            },</div>
<div class="line">            <span class="comment">// To know if the callbacks have already been called at least once</span></div>
<div class="line">            fired: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">return</span> !!fired;</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">self</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line"></div>
<div class="line">    Deferred: <span class="keyword">function</span>( func ) {</div>
<div class="line">        var tuples = [</div>
<div class="line">                <span class="comment">// action, add listener, listener list, final state</span></div>
<div class="line">                [ <span class="stringliteral">&quot;resolve&quot;</span>, <span class="stringliteral">&quot;done&quot;</span>, jQuery.Callbacks(<span class="stringliteral">&quot;once memory&quot;</span>), <span class="stringliteral">&quot;resolved&quot;</span> ],</div>
<div class="line">                [ <span class="stringliteral">&quot;reject&quot;</span>, <span class="stringliteral">&quot;fail&quot;</span>, jQuery.Callbacks(<span class="stringliteral">&quot;once memory&quot;</span>), <span class="stringliteral">&quot;rejected&quot;</span> ],</div>
<div class="line">                [ <span class="stringliteral">&quot;notify&quot;</span>, <span class="stringliteral">&quot;progress&quot;</span>, jQuery.Callbacks(<span class="stringliteral">&quot;memory&quot;</span>) ]</div>
<div class="line">            ],</div>
<div class="line">            state = <span class="stringliteral">&quot;pending&quot;</span>,</div>
<div class="line">            promise = {</div>
<div class="line">                state: <span class="keyword">function</span>() {</div>
<div class="line">                    <span class="keywordflow">return</span> state;</div>
<div class="line">                },</div>
<div class="line">                always: <span class="keyword">function</span>() {</div>
<div class="line">                    deferred.done( arguments ).fail( arguments );</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                },</div>
<div class="line">                then: <span class="keyword">function</span>( <span class="comment">/* fnDone, fnFail, fnProgress */</span> ) {</div>
<div class="line">                    var fns = arguments;</div>
<div class="line">                    <span class="keywordflow">return</span> jQuery.Deferred(<span class="keyword">function</span>( newDefer ) {</div>
<div class="line">                        jQuery.each( tuples, <span class="keyword">function</span>( i, tuple ) {</div>
<div class="line">                            var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];</div>
<div class="line">                            <span class="comment">// deferred[ done | fail | progress ] for forwarding actions to newDefer</span></div>
<div class="line">                            deferred[ tuple[1] ](<span class="keyword">function</span>() {</div>
<div class="line">                                var returned = fn &amp;&amp; fn.apply( <span class="keyword">this</span>, arguments );</div>
<div class="line">                                <span class="keywordflow">if</span> ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {</div>
<div class="line">                                    returned.promise()</div>
<div class="line">                                        .done( newDefer.resolve )</div>
<div class="line">                                        .fail( newDefer.reject )</div>
<div class="line">                                        .progress( newDefer.notify );</div>
<div class="line">                                } <span class="keywordflow">else</span> {</div>
<div class="line">                                    newDefer[ tuple[ 0 ] + <span class="stringliteral">&quot;With&quot;</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : arguments );</div>
<div class="line">                                }</div>
<div class="line">                            });</div>
<div class="line">                        });</div>
<div class="line">                        fns = null;</div>
<div class="line">                    }).promise();</div>
<div class="line">                },</div>
<div class="line">                <span class="comment">// Get a promise for this deferred</span></div>
<div class="line">                <span class="comment">// If obj is provided, the promise aspect is added to the object</span></div>
<div class="line">                promise: <span class="keyword">function</span>( obj ) {</div>
<div class="line">                    <span class="keywordflow">return</span> obj != null ? jQuery.extend( obj, promise ) : promise;</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line">            deferred = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Keep pipe for back-compat</span></div>
<div class="line">        promise.pipe = promise.then;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add list-specific methods</span></div>
<div class="line">        jQuery.each( tuples, <span class="keyword">function</span>( i, tuple ) {</div>
<div class="line">            var list = tuple[ 2 ],</div>
<div class="line">                stateString = tuple[ 3 ];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// promise[ done | fail | progress ] = list.add</span></div>
<div class="line">            promise[ tuple[1] ] = list.add;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Handle state</span></div>
<div class="line">            <span class="keywordflow">if</span> ( stateString ) {</div>
<div class="line">                list.add(<span class="keyword">function</span>() {</div>
<div class="line">                    <span class="comment">// state = [ resolved | rejected ]</span></div>
<div class="line">                    state = stateString;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span></div>
<div class="line">                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// deferred[ resolve | reject | notify ]</span></div>
<div class="line">            deferred[ tuple[0] ] = <span class="keyword">function</span>() {</div>
<div class="line">                deferred[ tuple[0] + <span class="stringliteral">&quot;With&quot;</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, arguments );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            };</div>
<div class="line">            deferred[ tuple[0] + <span class="stringliteral">&quot;With&quot;</span> ] = list.fireWith;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make the deferred a promise</span></div>
<div class="line">        promise.promise( deferred );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Call given func if any</span></div>
<div class="line">        <span class="keywordflow">if</span> ( func ) {</div>
<div class="line">            func.call( deferred, deferred );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// All done!</span></div>
<div class="line">        <span class="keywordflow">return</span> deferred;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Deferred helper</span></div>
<div class="line">    when: <span class="keyword">function</span>( subordinate <span class="comment">/* , ..., subordinateN */</span> ) {</div>
<div class="line">        var i = 0,</div>
<div class="line">            resolveValues = slice.call( arguments ),</div>
<div class="line">            length = resolveValues.length,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// the count of uncompleted subordinates</span></div>
<div class="line">            remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// the master Deferred. If resolveValues consist of only a single Deferred, just use that.</span></div>
<div class="line">            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Update function for both resolve and progress values</span></div>
<div class="line">            updateFunc = <span class="keyword">function</span>( i, contexts, values ) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">function</span>( value ) {</div>
<div class="line">                    contexts[ i ] = <span class="keyword">this</span>;</div>
<div class="line">                    values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;</div>
<div class="line">                    <span class="keywordflow">if</span> ( values === progressValues ) {</div>
<div class="line">                        deferred.notifyWith( contexts, values );</div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !( --remaining ) ) {</div>
<div class="line">                        deferred.resolveWith( contexts, values );</div>
<div class="line">                    }</div>
<div class="line">                };</div>
<div class="line">            },</div>
<div class="line"></div>
<div class="line">            progressValues, progressContexts, resolveContexts;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// add listeners to Deferred subordinates; treat others as resolved</span></div>
<div class="line">        <span class="keywordflow">if</span> ( length &gt; 1 ) {</div>
<div class="line">            progressValues = <span class="keyword">new</span> Array( length );</div>
<div class="line">            progressContexts = <span class="keyword">new</span> Array( length );</div>
<div class="line">            resolveContexts = <span class="keyword">new</span> Array( length );</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; length; i++ ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {</div>
<div class="line">                    resolveValues[ i ].promise()</div>
<div class="line">                        .done( updateFunc( i, resolveContexts, resolveValues ) )</div>
<div class="line">                        .fail( deferred.reject )</div>
<div class="line">                        .progress( updateFunc( i, progressContexts, progressValues ) );</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    --remaining;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// if we&#39;re not waiting on anything, resolve the master</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !remaining ) {</div>
<div class="line">            deferred.resolveWith( resolveContexts, resolveValues );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> deferred.promise();</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The deferred used on DOM ready</span></div>
<div class="line">var readyList;</div>
<div class="line"></div>
<div class="line">jQuery.fn.ready = <span class="keyword">function</span>( fn ) {</div>
<div class="line">    <span class="comment">// Add the callback</span></div>
<div class="line">    jQuery.ready.promise().done( fn );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    <span class="comment">// Is the DOM ready to be used? Set to true once it occurs.</span></div>
<div class="line">    isReady: <span class="keyword">false</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A counter to track how many items to wait for before</span></div>
<div class="line">    <span class="comment">// the ready event fires. See #6781</span></div>
<div class="line">    readyWait: 1,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Hold (or release) the ready event</span></div>
<div class="line">    holdReady: <span class="keyword">function</span>( hold ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( hold ) {</div>
<div class="line">            jQuery.readyWait++;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            jQuery.ready( <span class="keyword">true</span> );</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle when the DOM is ready</span></div>
<div class="line">    ready: <span class="keyword">function</span>( wait ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Abort if there are pending holds or we&#39;re already ready</span></div>
<div class="line">        <span class="keywordflow">if</span> ( wait === <span class="keyword">true</span> ? --jQuery.readyWait : jQuery.isReady ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remember that the DOM is ready</span></div>
<div class="line">        jQuery.isReady = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If a normal DOM Ready event fired, decrement, and wait if need be</span></div>
<div class="line">        <span class="keywordflow">if</span> ( wait !== <span class="keyword">true</span> &amp;&amp; --jQuery.readyWait &gt; 0 ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If there are functions bound, to execute</span></div>
<div class="line">        readyList.resolveWith( document, [ jQuery ] );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Trigger any bound ready events</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.fn.triggerHandler ) {</div>
<div class="line">            jQuery( document ).triggerHandler( <span class="stringliteral">&quot;ready&quot;</span> );</div>
<div class="line">            jQuery( document ).off( <span class="stringliteral">&quot;ready&quot;</span> );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> completed() {</div>
<div class="line">    document.removeEventListener( <span class="stringliteral">&quot;DOMContentLoaded&quot;</span>, completed, <span class="keyword">false</span> );</div>
<div class="line">    window.removeEventListener( <span class="stringliteral">&quot;load&quot;</span>, completed, <span class="keyword">false</span> );</div>
<div class="line">    jQuery.ready();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.ready.promise = <span class="keyword">function</span>( obj ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( !readyList ) {</div>
<div class="line"></div>
<div class="line">        readyList = jQuery.Deferred();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Catch cases where $(document).ready() is called after the browser event has already occurred.</span></div>
<div class="line">        <span class="comment">// we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one</span></div>
<div class="line">        <span class="comment">// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15</span></div>
<div class="line">        <span class="keywordflow">if</span> ( document.readyState === <span class="stringliteral">&quot;complete&quot;</span> ) {</div>
<div class="line">            <span class="comment">// Handle it asynchronously to allow scripts the opportunity to delay ready</span></div>
<div class="line">            setTimeout( jQuery.ready );</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Use the handy event callback</span></div>
<div class="line">            document.addEventListener( <span class="stringliteral">&quot;DOMContentLoaded&quot;</span>, completed, <span class="keyword">false</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// A fallback to window.onload, that will always work</span></div>
<div class="line">            window.addEventListener( <span class="stringliteral">&quot;load&quot;</span>, completed, <span class="keyword">false</span> );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> readyList.promise( obj );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Kick off the DOM ready check even if the user does not</span></div>
<div class="line">jQuery.ready.promise();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Multifunctional method to get and set values of a collection</span></div>
<div class="line"><span class="comment">// The value/s can optionally be executed if it&#39;s a function</span></div>
<div class="line">var access = jQuery.access = <span class="keyword">function</span>( elems, fn, key, value, chainable, emptyGet, raw ) {</div>
<div class="line">    var i = 0,</div>
<div class="line">        len = elems.length,</div>
<div class="line">        bulk = key == null;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Sets many values</span></div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.type( key ) === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">        chainable = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> ( i in key ) {</div>
<div class="line">            jQuery.access( elems, fn, i, key[i], <span class="keyword">true</span>, emptyGet, raw );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Sets one value</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( value !== undefined ) {</div>
<div class="line">        chainable = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !jQuery.isFunction( value ) ) {</div>
<div class="line">            raw = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( bulk ) {</div>
<div class="line">            <span class="comment">// Bulk operations run against the entire set</span></div>
<div class="line">            <span class="keywordflow">if</span> ( raw ) {</div>
<div class="line">                fn.call( elems, value );</div>
<div class="line">                fn = null;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// ...except when executing function values</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                bulk = fn;</div>
<div class="line">                fn = <span class="keyword">function</span>( elem, key, value ) {</div>
<div class="line">                    <span class="keywordflow">return</span> bulk.call( jQuery( elem ), value );</div>
<div class="line">                };</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( fn ) {</div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> chainable ?</div>
<div class="line">        elems :</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Gets</span></div>
<div class="line">        bulk ?</div>
<div class="line">            fn.call( elems ) :</div>
<div class="line">            len ? fn( elems[0], key ) : emptyGet;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.acceptData = <span class="keyword">function</span>( owner ) {</div>
<div class="line">    <span class="comment">// Accepts only:</span></div>
<div class="line">    <span class="comment">//  - Node</span></div>
<div class="line">    <span class="comment">//    - Node.ELEMENT_NODE</span></div>
<div class="line">    <span class="comment">//    - Node.DOCUMENT_NODE</span></div>
<div class="line">    <span class="comment">//  - Object</span></div>
<div class="line">    <span class="comment">//    - Any</span></div>
<div class="line">    <span class="comment">/* jshint -W018 */</span></div>
<div class="line">    <span class="keywordflow">return</span> owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Data() {</div>
<div class="line">    <span class="comment">// Support: Android &lt; 4,</span></div>
<div class="line">    <span class="comment">// Old WebKit does not have Object.preventExtensions/freeze method,</span></div>
<div class="line">    <span class="comment">// return new empty object instead with no [[set]] accessor</span></div>
<div class="line">    Object.defineProperty( this.cache = {}, 0, {</div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    this.expando = jQuery.expando + Math.random();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Data.uid = 1;</div>
<div class="line">Data.accepts = jQuery.acceptData;</div>
<div class="line"></div>
<div class="line">Data.prototype = {</div>
<div class="line">    key: <span class="keyword">function</span>( owner ) {</div>
<div class="line">        <span class="comment">// We can accept data for non-element nodes in modern browsers,</span></div>
<div class="line">        <span class="comment">// but we should not, see #8335.</span></div>
<div class="line">        <span class="comment">// Always return the key for a frozen object.</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !Data.accepts( owner ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var descriptor = {},</div>
<div class="line">            <span class="comment">// Check if the owner object already has a cache key</span></div>
<div class="line">            unlock = owner[ this.expando ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If not, create one</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !unlock ) {</div>
<div class="line">            unlock = Data.uid++;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Secure it in a non-enumerable, non-writable property</span></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                descriptor[ this.expando ] = { value: unlock };</div>
<div class="line">                Object.defineProperties( owner, descriptor );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: Android &lt; 4</span></div>
<div class="line">            <span class="comment">// Fallback to a less secure definition</span></div>
<div class="line">            } <span class="keywordflow">catch</span> ( e ) {</div>
<div class="line">                descriptor[ this.expando ] = unlock;</div>
<div class="line">                jQuery.extend( owner, descriptor );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Ensure the cache object</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !this.cache[ unlock ] ) {</div>
<div class="line">            this.cache[ unlock ] = {};</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> unlock;</div>
<div class="line">    },</div>
<div class="line">    set: <span class="keyword">function</span>( owner, data, value ) {</div>
<div class="line">        var prop,</div>
<div class="line">            <span class="comment">// There may be an unlock assigned to this node,</span></div>
<div class="line">            <span class="comment">// if there is no entry for this &quot;owner&quot;, create one inline</span></div>
<div class="line">            <span class="comment">// and set the unlock as though an owner entry had always existed</span></div>
<div class="line">            unlock = this.key( owner ),</div>
<div class="line">            cache = this.cache[ unlock ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Handle: [ owner, key, value ] args</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof data === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            cache[ data ] = value;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Handle: [ owner, { properties } ] args</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Fresh assignments by object are shallow copied</span></div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.isEmptyObject( cache ) ) {</div>
<div class="line">                jQuery.extend( this.cache[ unlock ], data );</div>
<div class="line">            <span class="comment">// Otherwise, copy the properties one-by-one to the cache object</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">for</span> ( prop in data ) {</div>
<div class="line">                    cache[ prop ] = data[ prop ];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> cache;</div>
<div class="line">    },</div>
<div class="line">    <span class="keyword">get</span>: <span class="keyword">function</span>( owner, key ) {</div>
<div class="line">        <span class="comment">// Either a valid cache is found, or will be created.</span></div>
<div class="line">        <span class="comment">// New caches will be created and the unlock returned,</span></div>
<div class="line">        <span class="comment">// allowing direct access to the newly created</span></div>
<div class="line">        <span class="comment">// empty data object. A valid owner object must be provided.</span></div>
<div class="line">        var cache = this.cache[ this.key( owner ) ];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> key === undefined ?</div>
<div class="line">            cache : cache[ key ];</div>
<div class="line">    },</div>
<div class="line">    access: <span class="keyword">function</span>( owner, key, value ) {</div>
<div class="line">        var stored;</div>
<div class="line">        <span class="comment">// In cases where either:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//   1. No key was specified</span></div>
<div class="line">        <span class="comment">//   2. A string key was specified, but no value provided</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Take the &quot;read&quot; path and allow the get method to determine</span></div>
<div class="line">        <span class="comment">// which value to return, respectively either:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//   1. The entire cache object</span></div>
<div class="line">        <span class="comment">//   2. The data stored at the key</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> ( key === undefined ||</div>
<div class="line">                ((key &amp;&amp; typeof key === <span class="stringliteral">&quot;string&quot;</span>) &amp;&amp; value === undefined) ) {</div>
<div class="line"></div>
<div class="line">            stored = this.<span class="keyword">get</span>( owner, key );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> stored !== undefined ?</div>
<div class="line">                stored : this.<span class="keyword">get</span>( owner, jQuery.camelCase(key) );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// [*]When the key is not a string, or both a key and value</span></div>
<div class="line">        <span class="comment">// are specified, set or extend (existing objects) with either:</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">//   1. An object of properties</span></div>
<div class="line">        <span class="comment">//   2. A key and value</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        this.set( owner, key, value );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Since the &quot;set&quot; path can have two possible entry points</span></div>
<div class="line">        <span class="comment">// return the expected data based on which path was taken[*]</span></div>
<div class="line">        <span class="keywordflow">return</span> value !== undefined ? value : key;</div>
<div class="line">    },</div>
<div class="line">    <span class="keyword">remove</span>: <span class="keyword">function</span>( owner, key ) {</div>
<div class="line">        var i, name, camel,</div>
<div class="line">            unlock = this.key( owner ),</div>
<div class="line">            cache = this.cache[ unlock ];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( key === undefined ) {</div>
<div class="line">            this.cache[ unlock ] = {};</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Support array or space separated string of keys</span></div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.isArray( key ) ) {</div>
<div class="line">                <span class="comment">// If &quot;name&quot; is an array of keys...</span></div>
<div class="line">                <span class="comment">// When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,</span></div>
<div class="line">                <span class="comment">// keys will be converted to camelCase.</span></div>
<div class="line">                <span class="comment">// Since there is no way to tell _how_ a key was added, remove</span></div>
<div class="line">                <span class="comment">// both plain key and camelCase key. #12786</span></div>
<div class="line">                <span class="comment">// This will only penalize the array argument path.</span></div>
<div class="line">                name = key.concat( key.map( jQuery.camelCase ) );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                camel = jQuery.camelCase( key );</div>
<div class="line">                <span class="comment">// Try the string as a key before any manipulation</span></div>
<div class="line">                <span class="keywordflow">if</span> ( key in cache ) {</div>
<div class="line">                    name = [ key, camel ];</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// If a key with the spaces exists, use it.</span></div>
<div class="line">                    <span class="comment">// Otherwise, create an array by matching non-whitespace</span></div>
<div class="line">                    name = camel;</div>
<div class="line">                    name = name in cache ?</div>
<div class="line">                        [ name ] : ( name.match( rnotwhite ) || [] );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            i = name.length;</div>
<div class="line">            <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                <span class="keyword">delete</span> cache[ name[ i ] ];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    hasData: <span class="keyword">function</span>( owner ) {</div>
<div class="line">        <span class="keywordflow">return</span> !jQuery.isEmptyObject(</div>
<div class="line">            this.cache[ owner[ this.expando ] ] || {}</div>
<div class="line">        );</div>
<div class="line">    },</div>
<div class="line">    discard: <span class="keyword">function</span>( owner ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( owner[ this.expando ] ) {</div>
<div class="line">            <span class="keyword">delete</span> this.cache[ owner[ this.expando ] ];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">var data_priv = <span class="keyword">new</span> Data();</div>
<div class="line"></div>
<div class="line">var data_user = <span class="keyword">new</span> Data();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    Implementation Summary</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    1. Enforce API surface and semantic compatibility with 1.9.x branch</span></div>
<div class="line"><span class="comment">    2. Improve the module&#39;s maintainability by reducing the storage</span></div>
<div class="line"><span class="comment">        paths to a single mechanism.</span></div>
<div class="line"><span class="comment">    3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.</span></div>
<div class="line"><span class="comment">    4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)</span></div>
<div class="line"><span class="comment">    5. Avoid exposing implementation details on user objects (eg. expando properties)</span></div>
<div class="line"><span class="comment">    6. Provide a clear path for implementation upgrade to WeakMap in 2014</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,</div>
<div class="line">    rmultiDash = /([A-Z])/g;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> dataAttr( elem, key, data ) {</div>
<div class="line">    var name;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If nothing was found internally, try to fetch any</span></div>
<div class="line">    <span class="comment">// data from the HTML5 data-* attribute</span></div>
<div class="line">    <span class="keywordflow">if</span> ( data === undefined &amp;&amp; elem.nodeType === 1 ) {</div>
<div class="line">        name = <span class="stringliteral">&quot;data-&quot;</span> + key.replace( rmultiDash, <span class="stringliteral">&quot;-$1&quot;</span> ).toLowerCase();</div>
<div class="line">        data = elem.getAttribute( name );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof data === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                data = data === <span class="stringliteral">&quot;true&quot;</span> ? <span class="keyword">true</span> :</div>
<div class="line">                    data === <span class="stringliteral">&quot;false&quot;</span> ? <span class="keyword">false</span> :</div>
<div class="line">                    data === <span class="stringliteral">&quot;null&quot;</span> ? null :</div>
<div class="line">                    <span class="comment">// Only convert to a number if it doesn&#39;t change the string</span></div>
<div class="line">                    +data + <span class="stringliteral">&quot;&quot;</span> === data ? +data :</div>
<div class="line">                    rbrace.test( data ) ? jQuery.parseJSON( data ) :</div>
<div class="line">                    data;</div>
<div class="line">            } <span class="keywordflow">catch</span>( e ) {}</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Make sure we set the data so it isn&#39;t changed later</span></div>
<div class="line">            data_user.set( elem, key, data );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            data = undefined;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> data;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    hasData: <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> data_user.hasData( elem ) || data_priv.hasData( elem );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    data: <span class="keyword">function</span>( elem, name, data ) {</div>
<div class="line">        <span class="keywordflow">return</span> data_user.access( elem, name, data );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeData: <span class="keyword">function</span>( elem, name ) {</div>
<div class="line">        data_user.remove( elem, name );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// TODO: Now that all calls to _data and _removeData have been replaced</span></div>
<div class="line">    <span class="comment">// with direct calls to data_priv methods, these can be deprecated.</span></div>
<div class="line">    _data: <span class="keyword">function</span>( elem, name, data ) {</div>
<div class="line">        <span class="keywordflow">return</span> data_priv.access( elem, name, data );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    _removeData: <span class="keyword">function</span>( elem, name ) {</div>
<div class="line">        data_priv.remove( elem, name );</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    data: <span class="keyword">function</span>( key, value ) {</div>
<div class="line">        var i, name, data,</div>
<div class="line">            elem = <span class="keyword">this</span>[ 0 ],</div>
<div class="line">            attrs = elem &amp;&amp; elem.attributes;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Gets all values</span></div>
<div class="line">        <span class="keywordflow">if</span> ( key === undefined ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( this.length ) {</div>
<div class="line">                data = data_user.get( elem );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, <span class="stringliteral">&quot;hasDataAttrs&quot;</span> ) ) {</div>
<div class="line">                    i = attrs.length;</div>
<div class="line">                    <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Support: IE11+</span></div>
<div class="line">                        <span class="comment">// The attrs elements can be null (#14894)</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( attrs[ i ] ) {</div>
<div class="line">                            name = attrs[ i ].name;</div>
<div class="line">                            <span class="keywordflow">if</span> ( name.indexOf( <span class="stringliteral">&quot;data-&quot;</span> ) === 0 ) {</div>
<div class="line">                                name = jQuery.camelCase( name.slice(5) );</div>
<div class="line">                                dataAttr( elem, name, data[ name ] );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    data_priv.set( elem, <span class="stringliteral">&quot;hasDataAttrs&quot;</span>, <span class="keyword">true</span> );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> data;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Sets multiple values</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof key === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">                data_user.set( <span class="keyword">this</span>, key );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( value ) {</div>
<div class="line">            var data,</div>
<div class="line">                camelKey = jQuery.camelCase( key );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The calling jQuery object (element matches) is not empty</span></div>
<div class="line">            <span class="comment">// (and therefore has an element appears at this[ 0 ]) and the</span></div>
<div class="line">            <span class="comment">// `value` parameter was not undefined. An empty jQuery object</span></div>
<div class="line">            <span class="comment">// will result in `undefined` for elem = this[ 0 ] which will</span></div>
<div class="line">            <span class="comment">// throw an exception if an attempt to read a data cache is made.</span></div>
<div class="line">            <span class="keywordflow">if</span> ( elem &amp;&amp; value === undefined ) {</div>
<div class="line">                <span class="comment">// Attempt to get data from the cache</span></div>
<div class="line">                <span class="comment">// with the key as-is</span></div>
<div class="line">                data = data_user.get( elem, key );</div>
<div class="line">                <span class="keywordflow">if</span> ( data !== undefined ) {</div>
<div class="line">                    <span class="keywordflow">return</span> data;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Attempt to get data from the cache</span></div>
<div class="line">                <span class="comment">// with the key camelized</span></div>
<div class="line">                data = data_user.get( elem, camelKey );</div>
<div class="line">                <span class="keywordflow">if</span> ( data !== undefined ) {</div>
<div class="line">                    <span class="keywordflow">return</span> data;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Attempt to &quot;discover&quot; the data in</span></div>
<div class="line">                <span class="comment">// HTML5 custom data-* attrs</span></div>
<div class="line">                data = dataAttr( elem, camelKey, undefined );</div>
<div class="line">                <span class="keywordflow">if</span> ( data !== undefined ) {</div>
<div class="line">                    <span class="keywordflow">return</span> data;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// We tried really hard, but the data doesn&#39;t exist.</span></div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set the data...</span></div>
<div class="line">            this.each(<span class="keyword">function</span>() {</div>
<div class="line">                <span class="comment">// First, attempt to store a copy or reference of any</span></div>
<div class="line">                <span class="comment">// data that might&#39;ve been store with a camelCased key.</span></div>
<div class="line">                var data = data_user.get( <span class="keyword">this</span>, camelKey );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// For HTML5 data-* attribute interop, we have to</span></div>
<div class="line">                <span class="comment">// store property names with dashes in a camelCase form.</span></div>
<div class="line">                <span class="comment">// This might not apply to all properties...*</span></div>
<div class="line">                data_user.set( <span class="keyword">this</span>, camelKey, value );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// *... In the case of properties that might _actually_</span></div>
<div class="line">                <span class="comment">// have dashes, we need to also store a copy of that</span></div>
<div class="line">                <span class="comment">// unchanged property.</span></div>
<div class="line">                <span class="keywordflow">if</span> ( key.indexOf(<span class="stringliteral">&quot;-&quot;</span>) !== -1 &amp;&amp; data !== undefined ) {</div>
<div class="line">                    data_user.set( <span class="keyword">this</span>, key, value );</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }, null, value, arguments.length &gt; 1, null, true );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeData: <span class="keyword">function</span>( key ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            data_user.remove( <span class="keyword">this</span>, key );</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    queue: <span class="keyword">function</span>( elem, type, data ) {</div>
<div class="line">        var queue;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( elem ) {</div>
<div class="line">            type = ( type || <span class="stringliteral">&quot;fx&quot;</span> ) + <span class="stringliteral">&quot;queue&quot;</span>;</div>
<div class="line">            queue = data_priv.get( elem, type );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Speed up dequeue by getting out quickly if this is just a lookup</span></div>
<div class="line">            <span class="keywordflow">if</span> ( data ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !queue || jQuery.isArray( data ) ) {</div>
<div class="line">                    queue = data_priv.access( elem, type, jQuery.makeArray(data) );</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    queue.push( data );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> queue || [];</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    dequeue: <span class="keyword">function</span>( elem, type ) {</div>
<div class="line">        type = type || <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line"></div>
<div class="line">        var queue = jQuery.queue( elem, type ),</div>
<div class="line">            startLength = queue.length,</div>
<div class="line">            fn = queue.shift(),</div>
<div class="line">            hooks = jQuery._queueHooks( elem, type ),</div>
<div class="line">            next = <span class="keyword">function</span>() {</div>
<div class="line">                jQuery.dequeue( elem, type );</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If the fx queue is dequeued, always remove the progress sentinel</span></div>
<div class="line">        <span class="keywordflow">if</span> ( fn === <span class="stringliteral">&quot;inprogress&quot;</span> ) {</div>
<div class="line">            fn = queue.shift();</div>
<div class="line">            startLength--;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( fn ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add a progress sentinel to prevent the fx queue from being</span></div>
<div class="line">            <span class="comment">// automatically dequeued</span></div>
<div class="line">            <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;fx&quot;</span> ) {</div>
<div class="line">                queue.unshift( <span class="stringliteral">&quot;inprogress&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// clear up the last queue stop function</span></div>
<div class="line">            <span class="keyword">delete</span> hooks.stop;</div>
<div class="line">            fn.call( elem, next, hooks );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !startLength &amp;&amp; hooks ) {</div>
<div class="line">            hooks.empty.fire();</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// not intended for public consumption - generates a queueHooks object, or returns the current one</span></div>
<div class="line">    _queueHooks: <span class="keyword">function</span>( elem, type ) {</div>
<div class="line">        var key = type + <span class="stringliteral">&quot;queueHooks&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> data_priv.get( elem, key ) || data_priv.access( elem, key, {</div>
<div class="line">            empty: jQuery.Callbacks(<span class="stringliteral">&quot;once memory&quot;</span>).add(<span class="keyword">function</span>() {</div>
<div class="line">                data_priv.remove( elem, [ type + <span class="stringliteral">&quot;queue&quot;</span>, key ] );</div>
<div class="line">            })</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    queue: <span class="keyword">function</span>( type, data ) {</div>
<div class="line">        var setter = 2;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof type !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            data = type;</div>
<div class="line">            type = <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line">            setter--;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( arguments.length &lt; setter ) {</div>
<div class="line">            <span class="keywordflow">return</span> jQuery.queue( <span class="keyword">this</span>[0], type );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> data === undefined ?</div>
<div class="line">            <span class="keyword">this</span> :</div>
<div class="line">            this.each(<span class="keyword">function</span>() {</div>
<div class="line">                var queue = jQuery.queue( <span class="keyword">this</span>, type, data );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// ensure a hooks for this queue</span></div>
<div class="line">                jQuery._queueHooks( <span class="keyword">this</span>, type );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;fx&quot;</span> &amp;&amp; queue[0] !== <span class="stringliteral">&quot;inprogress&quot;</span> ) {</div>
<div class="line">                    jQuery.dequeue( <span class="keyword">this</span>, type );</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">    },</div>
<div class="line">    dequeue: <span class="keyword">function</span>( type ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            jQuery.dequeue( <span class="keyword">this</span>, type );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line">    clearQueue: <span class="keyword">function</span>( type ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.queue( type || <span class="stringliteral">&quot;fx&quot;</span>, [] );</div>
<div class="line">    },</div>
<div class="line">    <span class="comment">// Get a promise resolved when queues of a certain type</span></div>
<div class="line">    <span class="comment">// are emptied (fx is the type by default)</span></div>
<div class="line">    promise: <span class="keyword">function</span>( type, obj ) {</div>
<div class="line">        var tmp,</div>
<div class="line">            count = 1,</div>
<div class="line">            defer = jQuery.Deferred(),</div>
<div class="line">            elements = <span class="keyword">this</span>,</div>
<div class="line">            i = this.length,</div>
<div class="line">            resolve = <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( !( --count ) ) {</div>
<div class="line">                    defer.resolveWith( elements, [ elements ] );</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof type !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            obj = type;</div>
<div class="line">            type = undefined;</div>
<div class="line">        }</div>
<div class="line">        type = type || <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">            tmp = data_priv.get( elements[ i ], type + <span class="stringliteral">&quot;queueHooks&quot;</span> );</div>
<div class="line">            <span class="keywordflow">if</span> ( tmp &amp;&amp; tmp.empty ) {</div>
<div class="line">                count++;</div>
<div class="line">                tmp.empty.add( resolve );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        resolve();</div>
<div class="line">        <span class="keywordflow">return</span> defer.promise( obj );</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line">var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;</div>
<div class="line"></div>
<div class="line">var cssExpand = [ <span class="stringliteral">&quot;Top&quot;</span>, <span class="stringliteral">&quot;Right&quot;</span>, <span class="stringliteral">&quot;Bottom&quot;</span>, <span class="stringliteral">&quot;Left&quot;</span> ];</div>
<div class="line"></div>
<div class="line">var isHidden = <span class="keyword">function</span>( elem, el ) {</div>
<div class="line">        <span class="comment">// isHidden might be called from jQuery#filter function;</span></div>
<div class="line">        <span class="comment">// in that case, element will be second argument</span></div>
<div class="line">        elem = el || elem;</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.css( elem, <span class="stringliteral">&quot;display&quot;</span> ) === <span class="stringliteral">&quot;none&quot;</span> || !jQuery.contains( elem.ownerDocument, elem );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">var rcheckableType = (/^(?:checkbox|radio)$/i);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>() {</div>
<div class="line">    var fragment = document.createDocumentFragment(),</div>
<div class="line">        div = fragment.appendChild( document.createElement( <span class="stringliteral">&quot;div&quot;</span> ) ),</div>
<div class="line">        input = document.createElement( <span class="stringliteral">&quot;input&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// #11217 - WebKit loses check when the name is after the checked attribute</span></div>
<div class="line">    <span class="comment">// Support: Windows Web Apps (WWA)</span></div>
<div class="line">    <span class="comment">// `name` and `type` need .setAttribute for WWA</span></div>
<div class="line">    input.setAttribute( <span class="stringliteral">&quot;type&quot;</span>, <span class="stringliteral">&quot;radio&quot;</span> );</div>
<div class="line">    input.setAttribute( <span class="stringliteral">&quot;checked&quot;</span>, <span class="stringliteral">&quot;checked&quot;</span> );</div>
<div class="line">    input.setAttribute( <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;t&quot;</span> );</div>
<div class="line"></div>
<div class="line">    div.appendChild( input );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3</span></div>
<div class="line">    <span class="comment">// old WebKit doesn&#39;t clone checked state correctly in fragments</span></div>
<div class="line">    support.checkClone = div.cloneNode( <span class="keyword">true</span> ).cloneNode( <span class="keyword">true</span> ).lastChild.checked;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Make sure textarea (and checkbox) defaultValue is properly cloned</span></div>
<div class="line">    <span class="comment">// Support: IE9-IE11+</span></div>
<div class="line">    div.innerHTML = <span class="stringliteral">&quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;</span>;</div>
<div class="line">    support.noCloneChecked = !!div.cloneNode( <span class="keyword">true</span> ).lastChild.defaultValue;</div>
<div class="line">})();</div>
<div class="line">var strundefined = typeof undefined;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">support.focusinBubbles = <span class="stringliteral">&quot;onfocusin&quot;</span> in window;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    rkeyEvent = /^key/,</div>
<div class="line">    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,</div>
<div class="line">    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,</div>
<div class="line">    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> returnTrue() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> returnFalse() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> safeActiveElement() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> document.activeElement;</div>
<div class="line">    } <span class="keywordflow">catch</span> ( err ) { }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Helper functions for managing events -- not part of the public interface.</span></div>
<div class="line"><span class="comment"> * Props to Dean Edwards&#39; addEvent library for many of the ideas.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">jQuery.event = {</div>
<div class="line"></div>
<div class="line">    global: {},</div>
<div class="line"></div>
<div class="line">    add: <span class="keyword">function</span>( elem, types, handler, data, selector ) {</div>
<div class="line"></div>
<div class="line">        var handleObjIn, eventHandle, tmp,</div>
<div class="line">            events, t, handleObj,</div>
<div class="line">            special, handlers, type, namespaces, origType,</div>
<div class="line">            elemData = data_priv.get( elem );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Don&#39;t attach events to noData or text/comment nodes (but allow plain objects)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !elemData ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Caller can pass in an object of custom data in lieu of the handler</span></div>
<div class="line">        <span class="keywordflow">if</span> ( handler.handler ) {</div>
<div class="line">            handleObjIn = handler;</div>
<div class="line">            handler = handleObjIn.handler;</div>
<div class="line">            selector = handleObjIn.selector;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure that the handler has a unique ID, used to find/remove it later</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !handler.guid ) {</div>
<div class="line">            handler.guid = jQuery.guid++;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Init the element&#39;s event structure and main handler, if this is the first</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !(events = elemData.events) ) {</div>
<div class="line">            events = elemData.events = {};</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( !(eventHandle = elemData.handle) ) {</div>
<div class="line">            eventHandle = elemData.handle = <span class="keyword">function</span>( e ) {</div>
<div class="line">                <span class="comment">// Discard the second event of a jQuery.event.trigger() and</span></div>
<div class="line">                <span class="comment">// when an event is called after a page has unloaded</span></div>
<div class="line">                <span class="keywordflow">return</span> typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?</div>
<div class="line">                    jQuery.event.dispatch.apply( elem, arguments ) : undefined;</div>
<div class="line">            };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Handle multiple events separated by a space</span></div>
<div class="line">        types = ( types || <span class="stringliteral">&quot;&quot;</span> ).match( rnotwhite ) || [ <span class="stringliteral">&quot;&quot;</span> ];</div>
<div class="line">        t = types.length;</div>
<div class="line">        <span class="keywordflow">while</span> ( t-- ) {</div>
<div class="line">            tmp = rtypenamespace.exec( types[t] ) || [];</div>
<div class="line">            type = origType = tmp[1];</div>
<div class="line">            namespaces = ( tmp[2] || <span class="stringliteral">&quot;&quot;</span> ).split( <span class="stringliteral">&quot;.&quot;</span> ).sort();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// There *must* be a type, no attaching namespace-only handlers</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !type ) {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If event changes its type, use the special event handlers for the changed type</span></div>
<div class="line">            special = jQuery.event.special[ type ] || {};</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If selector defined, determine special event api type, otherwise given type</span></div>
<div class="line">            type = ( selector ? special.delegateType : special.bindType ) || type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Update special based on newly reset type</span></div>
<div class="line">            special = jQuery.event.special[ type ] || {};</div>
<div class="line"></div>
<div class="line">            <span class="comment">// handleObj is passed to all event handlers</span></div>
<div class="line">            handleObj = jQuery.extend({</div>
<div class="line">                type: type,</div>
<div class="line">                origType: origType,</div>
<div class="line">                data: data,</div>
<div class="line">                handler: handler,</div>
<div class="line">                guid: handler.guid,</div>
<div class="line">                selector: selector,</div>
<div class="line">                needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),</div>
<div class="line">                <span class="keyword">namespace</span>: namespaces.join(<span class="stringliteral">&quot;.&quot;</span>)</div>
<div class="line">            }, handleObjIn );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Init the event handler queue if we&#39;re the first</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !(handlers = events[ type ]) ) {</div>
<div class="line">                handlers = events[ type ] = [];</div>
<div class="line">                handlers.delegateCount = 0;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Only use addEventListener if the special events handler returns false</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.addEventListener ) {</div>
<div class="line">                        elem.addEventListener( type, eventHandle, <span class="keyword">false</span> );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( special.add ) {</div>
<div class="line">                special.add.call( elem, handleObj );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( !handleObj.handler.guid ) {</div>
<div class="line">                    handleObj.handler.guid = handler.guid;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add to the element&#39;s handler list, delegates in front</span></div>
<div class="line">            <span class="keywordflow">if</span> ( selector ) {</div>
<div class="line">                handlers.splice( handlers.delegateCount++, 0, handleObj );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                handlers.push( handleObj );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Keep track of which events have ever been used, for event optimization</span></div>
<div class="line">            jQuery.event.global[ type ] = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Detach an event or set of events from an element</span></div>
<div class="line">    <span class="keyword">remove</span>: <span class="keyword">function</span>( elem, types, handler, selector, mappedTypes ) {</div>
<div class="line"></div>
<div class="line">        var j, origCount, tmp,</div>
<div class="line">            events, t, handleObj,</div>
<div class="line">            special, handlers, type, namespaces, origType,</div>
<div class="line">            elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !elemData || !(events = elemData.events) ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Once for each type.namespace in types; type may be omitted</span></div>
<div class="line">        types = ( types || <span class="stringliteral">&quot;&quot;</span> ).match( rnotwhite ) || [ <span class="stringliteral">&quot;&quot;</span> ];</div>
<div class="line">        t = types.length;</div>
<div class="line">        <span class="keywordflow">while</span> ( t-- ) {</div>
<div class="line">            tmp = rtypenamespace.exec( types[t] ) || [];</div>
<div class="line">            type = origType = tmp[1];</div>
<div class="line">            namespaces = ( tmp[2] || <span class="stringliteral">&quot;&quot;</span> ).split( <span class="stringliteral">&quot;.&quot;</span> ).sort();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Unbind all events (on this namespace, if provided) for the element</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !type ) {</div>
<div class="line">                <span class="keywordflow">for</span> ( type in events ) {</div>
<div class="line">                    jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="keyword">true</span> );</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            special = jQuery.event.special[ type ] || {};</div>
<div class="line">            type = ( selector ? special.delegateType : special.bindType ) || type;</div>
<div class="line">            handlers = events[ type ] || [];</div>
<div class="line">            tmp = tmp[2] &amp;&amp; <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;(^|\\.)&quot;</span> + namespaces.join(<span class="stringliteral">&quot;\\.(?:.*\\.|)&quot;</span>) + <span class="stringliteral">&quot;(\\.|$)&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Remove matching events</span></div>
<div class="line">            origCount = j = handlers.length;</div>
<div class="line">            <span class="keywordflow">while</span> ( j-- ) {</div>
<div class="line">                handleObj = handlers[ j ];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;</div>
<div class="line">                    ( !handler || handler.guid === handleObj.guid ) &amp;&amp;</div>
<div class="line">                    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;</div>
<div class="line">                    ( !selector || selector === handleObj.selector || selector === <span class="stringliteral">&quot;**&quot;</span> &amp;&amp; handleObj.selector ) ) {</div>
<div class="line">                    handlers.splice( j, 1 );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( handleObj.selector ) {</div>
<div class="line">                        handlers.delegateCount--;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> ( special.remove ) {</div>
<div class="line">                        special.remove.call( elem, handleObj );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Remove generic event handler if we removed something and no more handlers exist</span></div>
<div class="line">            <span class="comment">// (avoids potential for endless recursion during removal of special event handlers)</span></div>
<div class="line">            <span class="keywordflow">if</span> ( origCount &amp;&amp; !handlers.length ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {</div>
<div class="line">                    jQuery.removeEvent( elem, type, elemData.handle );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keyword">delete</span> events[ type ];</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove the expando if it&#39;s no longer used</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isEmptyObject( events ) ) {</div>
<div class="line">            <span class="keyword">delete</span> elemData.handle;</div>
<div class="line">            data_priv.remove( elem, <span class="stringliteral">&quot;events&quot;</span> );</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    trigger: <span class="keyword">function</span>( event, data, elem, onlyHandlers ) {</div>
<div class="line"></div>
<div class="line">        var i, cur, tmp, bubbleType, ontype, handle, special,</div>
<div class="line">            eventPath = [ elem || document ],</div>
<div class="line">            type = hasOwn.call( event, <span class="stringliteral">&quot;type&quot;</span> ) ? <span class="keyword">event</span>.type : event,</div>
<div class="line">            namespaces = hasOwn.call( event, <span class="stringliteral">&quot;namespace&quot;</span> ) ? <span class="keyword">event</span>.namespace.split(<span class="stringliteral">&quot;.&quot;</span>) : [];</div>
<div class="line"></div>
<div class="line">        cur = tmp = elem = elem || document;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Don&#39;t do events on text and comment nodes</span></div>
<div class="line">        <span class="keywordflow">if</span> ( elem.nodeType === 3 || elem.nodeType === 8 ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// focus/blur morphs to focusin/out; ensure we&#39;re not firing them right now</span></div>
<div class="line">        <span class="keywordflow">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( type.indexOf(<span class="stringliteral">&quot;.&quot;</span>) &gt;= 0 ) {</div>
<div class="line">            <span class="comment">// Namespaced trigger; create a regexp to match event type in handle()</span></div>
<div class="line">            namespaces = type.split(<span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="line">            type = namespaces.shift();</div>
<div class="line">            namespaces.sort();</div>
<div class="line">        }</div>
<div class="line">        ontype = type.indexOf(<span class="stringliteral">&quot;:&quot;</span>) &lt; 0 &amp;&amp; <span class="stringliteral">&quot;on&quot;</span> + type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Caller can pass in a jQuery.Event object, Object, or just an event type string</span></div>
<div class="line">        <span class="keyword">event</span> = <span class="keyword">event</span>[ jQuery.expando ] ?</div>
<div class="line">            <span class="keyword">event</span> :</div>
<div class="line">            <span class="keyword">new</span> jQuery.Event( type, typeof event === <span class="stringliteral">&quot;object&quot;</span> &amp;&amp; event );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)</span></div>
<div class="line">        <span class="keyword">event</span>.isTrigger = onlyHandlers ? 2 : 3;</div>
<div class="line">        <span class="keyword">event</span>.namespace = namespaces.join(<span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="line">        <span class="keyword">event</span>.namespace_re = <span class="keyword">event</span>.namespace ?</div>
<div class="line">            <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;(^|\\.)&quot;</span> + namespaces.join(<span class="stringliteral">&quot;\\.(?:.*\\.|)&quot;</span>) + <span class="stringliteral">&quot;(\\.|$)&quot;</span> ) :</div>
<div class="line">            null;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clean up the event in case it is being reused</span></div>
<div class="line">        <span class="keyword">event</span>.result = undefined;</div>
<div class="line">        <span class="keywordflow">if</span> ( !event.target ) {</div>
<div class="line">            <span class="keyword">event</span>.target = elem;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clone any incoming data and prepend the event, creating the handler arg list</span></div>
<div class="line">        data = data == null ?</div>
<div class="line">            [ event ] :</div>
<div class="line">            jQuery.makeArray( data, [ event ] );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allow special events to draw outside the lines</span></div>
<div class="line">        special = jQuery.event.special[ type ] || {};</div>
<div class="line">        <span class="keywordflow">if</span> ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Determine event propagation path in advance, per W3C events spec (#9951)</span></div>
<div class="line">        <span class="comment">// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {</div>
<div class="line"></div>
<div class="line">            bubbleType = special.delegateType || type;</div>
<div class="line">            <span class="keywordflow">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {</div>
<div class="line">                cur = cur.parentNode;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span> ( ; cur; cur = cur.parentNode ) {</div>
<div class="line">                eventPath.push( cur );</div>
<div class="line">                tmp = cur;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span></div>
<div class="line">            <span class="keywordflow">if</span> ( tmp === (elem.ownerDocument || document) ) {</div>
<div class="line">                eventPath.push( tmp.defaultView || tmp.parentWindow || window );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Fire handlers on the event path</span></div>
<div class="line">        i = 0;</div>
<div class="line">        <span class="keywordflow">while</span> ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {</div>
<div class="line"></div>
<div class="line">            <span class="keyword">event</span>.type = i &gt; 1 ?</div>
<div class="line">                bubbleType :</div>
<div class="line">                special.bindType || type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// jQuery handler</span></div>
<div class="line">            handle = ( data_priv.get( cur, <span class="stringliteral">&quot;events&quot;</span> ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, <span class="stringliteral">&quot;handle&quot;</span> );</div>
<div class="line">            <span class="keywordflow">if</span> ( handle ) {</div>
<div class="line">                handle.apply( cur, data );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Native handler</span></div>
<div class="line">            handle = ontype &amp;&amp; cur[ ontype ];</div>
<div class="line">            <span class="keywordflow">if</span> ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {</div>
<div class="line">                <span class="keyword">event</span>.result = handle.apply( cur, data );</div>
<div class="line">                <span class="keywordflow">if</span> ( event.result === <span class="keyword">false</span> ) {</div>
<div class="line">                    <span class="keyword">event</span>.preventDefault();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">event</span>.type = type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If nobody prevented the default action, do it now</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="keyword">false</span>) &amp;&amp;</div>
<div class="line">                jQuery.acceptData( elem ) ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Call a native DOM method on the target with the same name name as the event.</span></div>
<div class="line">                <span class="comment">// Don&#39;t do default actions on window, that&#39;s where global variables be (#6170)</span></div>
<div class="line">                <span class="keywordflow">if</span> ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Don&#39;t re-trigger an onFOO event when we call its FOO() method</span></div>
<div class="line">                    tmp = elem[ ontype ];</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( tmp ) {</div>
<div class="line">                        elem[ ontype ] = null;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Prevent re-triggering of the same event, since we already bubbled it above</span></div>
<div class="line">                    jQuery.event.triggered = type;</div>
<div class="line">                    elem[ type ]();</div>
<div class="line">                    jQuery.event.triggered = undefined;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( tmp ) {</div>
<div class="line">                        elem[ ontype ] = tmp;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">event</span>.result;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    dispatch: <span class="keyword">function</span>( event ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make a writable jQuery.Event from the native event object</span></div>
<div class="line">        <span class="keyword">event</span> = jQuery.event.fix( event );</div>
<div class="line"></div>
<div class="line">        var i, j, ret, matched, handleObj,</div>
<div class="line">            handlerQueue = [],</div>
<div class="line">            args = slice.call( arguments ),</div>
<div class="line">            handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="stringliteral">&quot;events&quot;</span> ) || {} )[ event.type ] || [],</div>
<div class="line">            special = jQuery.event.special[ event.type ] || {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Use the fix-ed jQuery.Event rather than the (read-only) native event</span></div>
<div class="line">        args[0] = event;</div>
<div class="line">        <span class="keyword">event</span>.delegateTarget = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Call the preDispatch hook for the mapped type, and let it bail if desired</span></div>
<div class="line">        <span class="keywordflow">if</span> ( special.preDispatch &amp;&amp; special.preDispatch.call( <span class="keyword">this</span>, event ) === false ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Determine handlers</span></div>
<div class="line">        handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Run delegates first; they may want to stop propagation beneath us</span></div>
<div class="line">        i = 0;</div>
<div class="line">        <span class="keywordflow">while</span> ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {</div>
<div class="line">            <span class="keyword">event</span>.currentTarget = matched.elem;</div>
<div class="line"></div>
<div class="line">            j = 0;</div>
<div class="line">            <span class="keywordflow">while</span> ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !<span class="keyword">event</span>.isImmediatePropagationStopped() ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Triggered event must either 1) have no namespace, or</span></div>
<div class="line">                <span class="comment">// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {</div>
<div class="line"></div>
<div class="line">                    <span class="keyword">event</span>.handleObj = handleObj;</div>
<div class="line">                    <span class="keyword">event</span>.data = handleObj.data;</div>
<div class="line"></div>
<div class="line">                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )</div>
<div class="line">                            .apply( matched.elem, args );</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( ret !== undefined ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( (event.result = ret) === <span class="keyword">false</span> ) {</div>
<div class="line">                            <span class="keyword">event</span>.preventDefault();</div>
<div class="line">                            <span class="keyword">event</span>.stopPropagation();</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Call the postDispatch hook for the mapped type</span></div>
<div class="line">        <span class="keywordflow">if</span> ( special.postDispatch ) {</div>
<div class="line">            special.postDispatch.call( <span class="keyword">this</span>, event );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">event</span>.result;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    handlers: <span class="keyword">function</span>( event, handlers ) {</div>
<div class="line">        var i, matches, sel, handleObj,</div>
<div class="line">            handlerQueue = [],</div>
<div class="line">            delegateCount = handlers.delegateCount,</div>
<div class="line">            cur = <span class="keyword">event</span>.target;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Find delegate handlers</span></div>
<div class="line">        <span class="comment">// Black-hole SVG &lt;use&gt; instance trees (#13180)</span></div>
<div class="line">        <span class="comment">// Avoid non-left-click bubbling in Firefox (#3861)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== <span class="stringliteral">&quot;click&quot;</span>) ) {</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || this ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Don&#39;t process clicks on disabled elements (#6911, #8165, #11382, #11764)</span></div>
<div class="line">                <span class="keywordflow">if</span> ( cur.disabled !== <span class="keyword">true</span> || event.type !== <span class="stringliteral">&quot;click&quot;</span> ) {</div>
<div class="line">                    matches = [];</div>
<div class="line">                    <span class="keywordflow">for</span> ( i = 0; i &lt; delegateCount; i++ ) {</div>
<div class="line">                        handleObj = handlers[ i ];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Don&#39;t conflict with Object.prototype properties (#13203)</span></div>
<div class="line">                        sel = handleObj.selector + <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"></div>
<div class="line">                        <span class="keywordflow">if</span> ( matches[ sel ] === undefined ) {</div>
<div class="line">                            matches[ sel ] = handleObj.needsContext ?</div>
<div class="line">                                jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= 0 :</div>
<div class="line">                                jQuery.find( sel, <span class="keyword">this</span>, null, [ cur ] ).length;</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> ( matches[ sel ] ) {</div>
<div class="line">                            matches.push( handleObj );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> ( matches.length ) {</div>
<div class="line">                        handlerQueue.push({ elem: cur, handlers: matches });</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add the remaining (directly-bound) handlers</span></div>
<div class="line">        <span class="keywordflow">if</span> ( delegateCount &lt; handlers.length ) {</div>
<div class="line">            handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> handlerQueue;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Includes some event props shared by KeyEvent and MouseEvent</span></div>
<div class="line">    props: <span class="stringliteral">&quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;</span>.split(<span class="stringliteral">&quot; &quot;</span>),</div>
<div class="line"></div>
<div class="line">    fixHooks: {},</div>
<div class="line"></div>
<div class="line">    keyHooks: {</div>
<div class="line">        props: <span class="stringliteral">&quot;char charCode key keyCode&quot;</span>.split(<span class="stringliteral">&quot; &quot;</span>),</div>
<div class="line">        filter: <span class="keyword">function</span>( event, original ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add which for key events</span></div>
<div class="line">            <span class="keywordflow">if</span> ( event.which == null ) {</div>
<div class="line">                <span class="keyword">event</span>.which = original.charCode != null ? original.charCode : original.keyCode;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> event;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    mouseHooks: {</div>
<div class="line">        props: <span class="stringliteral">&quot;button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement&quot;</span>.split(<span class="stringliteral">&quot; &quot;</span>),</div>
<div class="line">        filter: <span class="keyword">function</span>( event, original ) {</div>
<div class="line">            var eventDoc, doc, body,</div>
<div class="line">                button = original.button;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Calculate pageX/Y if missing and clientX/Y available</span></div>
<div class="line">            <span class="keywordflow">if</span> ( event.pageX == null &amp;&amp; original.clientX != null ) {</div>
<div class="line">                eventDoc = <span class="keyword">event</span>.target.ownerDocument || document;</div>
<div class="line">                doc = eventDoc.documentElement;</div>
<div class="line">                body = eventDoc.body;</div>
<div class="line"></div>
<div class="line">                <span class="keyword">event</span>.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );</div>
<div class="line">                <span class="keyword">event</span>.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add which for click: 1 === left; 2 === middle; 3 === right</span></div>
<div class="line">            <span class="comment">// Note: button is not normalized, so don&#39;t use it</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !event.which &amp;&amp; button !== undefined ) {</div>
<div class="line">                <span class="keyword">event</span>.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> event;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    fix: <span class="keyword">function</span>( event ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( event[ jQuery.expando ] ) {</div>
<div class="line">            <span class="keywordflow">return</span> event;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create a writable copy of the event object and normalize some properties</span></div>
<div class="line">        var i, prop, copy,</div>
<div class="line">            type = <span class="keyword">event</span>.type,</div>
<div class="line">            originalEvent = event,</div>
<div class="line">            fixHook = this.fixHooks[ type ];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !fixHook ) {</div>
<div class="line">            this.fixHooks[ type ] = fixHook =</div>
<div class="line">                rmouseEvent.test( type ) ? this.mouseHooks :</div>
<div class="line">                rkeyEvent.test( type ) ? this.keyHooks :</div>
<div class="line">                {};</div>
<div class="line">        }</div>
<div class="line">        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">event</span> = <span class="keyword">new</span> jQuery.Event( originalEvent );</div>
<div class="line"></div>
<div class="line">        i = copy.length;</div>
<div class="line">        <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">            prop = copy[ i ];</div>
<div class="line">            <span class="keyword">event</span>[ prop ] = originalEvent[ prop ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: Cordova 2.5 (WebKit) (#13255)</span></div>
<div class="line">        <span class="comment">// All events should have a target; Cordova deviceready doesn&#39;t</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !event.target ) {</div>
<div class="line">            <span class="keyword">event</span>.target = document;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: Safari 6.0+, Chrome &lt; 28</span></div>
<div class="line">        <span class="comment">// Target should not be a text node (#504, #13143)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( event.target.nodeType === 3 ) {</div>
<div class="line">            <span class="keyword">event</span>.target = <span class="keyword">event</span>.target.parentNode;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> fixHook.filter ? fixHook.filter( event, originalEvent ) : event;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    special: {</div>
<div class="line">        load: {</div>
<div class="line">            <span class="comment">// Prevent triggered image.load events from bubbling to window.load</span></div>
<div class="line">            noBubble: <span class="keyword">true</span></div>
<div class="line">        },</div>
<div class="line">        focus: {</div>
<div class="line">            <span class="comment">// Fire native event if possible so blur/focus sequence is correct</span></div>
<div class="line">            trigger: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( <span class="keyword">this</span> !== safeActiveElement() &amp;&amp; this.focus ) {</div>
<div class="line">                    this.focus();</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line">            delegateType: <span class="stringliteral">&quot;focusin&quot;</span></div>
<div class="line">        },</div>
<div class="line">        blur: {</div>
<div class="line">            trigger: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( <span class="keyword">this</span> === safeActiveElement() &amp;&amp; this.blur ) {</div>
<div class="line">                    this.blur();</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line">            delegateType: <span class="stringliteral">&quot;focusout&quot;</span></div>
<div class="line">        },</div>
<div class="line">        click: {</div>
<div class="line">            <span class="comment">// For checkbox, fire native event so checked state will be right</span></div>
<div class="line">            trigger: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( this.type === <span class="stringliteral">&quot;checkbox&quot;</span> &amp;&amp; this.click &amp;&amp; jQuery.nodeName( <span class="keyword">this</span>, <span class="stringliteral">&quot;input&quot;</span> ) ) {</div>
<div class="line">                    this.click();</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line"></div>
<div class="line">            <span class="comment">// For cross-browser consistency, don&#39;t fire native .click() on links</span></div>
<div class="line">            _default: <span class="keyword">function</span>( event ) {</div>
<div class="line">                <span class="keywordflow">return</span> jQuery.nodeName( event.target, <span class="stringliteral">&quot;a&quot;</span> );</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        beforeunload: {</div>
<div class="line">            postDispatch: <span class="keyword">function</span>( event ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Support: Firefox 20+</span></div>
<div class="line">                <span class="comment">// Firefox doesn&#39;t alert if the returnValue field is not set.</span></div>
<div class="line">                <span class="keywordflow">if</span> ( event.result !== undefined &amp;&amp; event.originalEvent ) {</div>
<div class="line">                    <span class="keyword">event</span>.originalEvent.returnValue = <span class="keyword">event</span>.result;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    simulate: <span class="keyword">function</span>( type, elem, event, bubble ) {</div>
<div class="line">        <span class="comment">// Piggyback on a donor event to simulate a different one.</span></div>
<div class="line">        <span class="comment">// Fake originalEvent to avoid donor&#39;s stopPropagation, but if the</span></div>
<div class="line">        <span class="comment">// simulated event prevents default then we do the same on the donor.</span></div>
<div class="line">        var e = jQuery.extend(</div>
<div class="line">            <span class="keyword">new</span> jQuery.Event(),</div>
<div class="line">            event,</div>
<div class="line">            {</div>
<div class="line">                type: type,</div>
<div class="line">                isSimulated: <span class="keyword">true</span>,</div>
<div class="line">                originalEvent: {}</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        <span class="keywordflow">if</span> ( bubble ) {</div>
<div class="line">            jQuery.event.trigger( e, null, elem );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            jQuery.event.dispatch.call( elem, e );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( e.isDefaultPrevented() ) {</div>
<div class="line">            <span class="keyword">event</span>.preventDefault();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.removeEvent = <span class="keyword">function</span>( elem, type, handle ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( elem.removeEventListener ) {</div>
<div class="line">        elem.removeEventListener( type, handle, <span class="keyword">false</span> );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.Event = <span class="keyword">function</span>( src, props ) {</div>
<div class="line">    <span class="comment">// Allow instantiation without the &#39;new&#39; keyword</span></div>
<div class="line">    <span class="keywordflow">if</span> ( !(<span class="keyword">this</span> instanceof jQuery.Event) ) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> jQuery.Event( src, props );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Event object</span></div>
<div class="line">    <span class="keywordflow">if</span> ( src &amp;&amp; src.type ) {</div>
<div class="line">        this.originalEvent = src;</div>
<div class="line">        this.type = src.type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Events bubbling up the document may have been marked as prevented</span></div>
<div class="line">        <span class="comment">// by a handler lower down the tree; reflect the correct value.</span></div>
<div class="line">        this.isDefaultPrevented = src.defaultPrevented ||</div>
<div class="line">                src.defaultPrevented === undefined &amp;&amp;</div>
<div class="line">                <span class="comment">// Support: Android &lt; 4.0</span></div>
<div class="line">                src.returnValue === <span class="keyword">false</span> ?</div>
<div class="line">            returnTrue :</div>
<div class="line">            returnFalse;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Event type</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        this.type = src;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Put explicitly provided properties onto the event object</span></div>
<div class="line">    <span class="keywordflow">if</span> ( props ) {</div>
<div class="line">        jQuery.extend( <span class="keyword">this</span>, props );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a timestamp if incoming event doesn&#39;t have one</span></div>
<div class="line">    this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Mark it as fixed</span></div>
<div class="line">    <span class="keyword">this</span>[ jQuery.expando ] = <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding</span></div>
<div class="line"><span class="comment">// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</span></div>
<div class="line">jQuery.Event.prototype = {</div>
<div class="line">    isDefaultPrevented: returnFalse,</div>
<div class="line">    isPropagationStopped: returnFalse,</div>
<div class="line">    isImmediatePropagationStopped: returnFalse,</div>
<div class="line"></div>
<div class="line">    preventDefault: <span class="keyword">function</span>() {</div>
<div class="line">        var e = this.originalEvent;</div>
<div class="line"></div>
<div class="line">        this.isDefaultPrevented = returnTrue;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( e &amp;&amp; e.preventDefault ) {</div>
<div class="line">            e.preventDefault();</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    stopPropagation: <span class="keyword">function</span>() {</div>
<div class="line">        var e = this.originalEvent;</div>
<div class="line"></div>
<div class="line">        this.isPropagationStopped = returnTrue;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( e &amp;&amp; e.stopPropagation ) {</div>
<div class="line">            e.stopPropagation();</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    stopImmediatePropagation: <span class="keyword">function</span>() {</div>
<div class="line">        var e = this.originalEvent;</div>
<div class="line"></div>
<div class="line">        this.isImmediatePropagationStopped = returnTrue;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( e &amp;&amp; e.stopImmediatePropagation ) {</div>
<div class="line">            e.stopImmediatePropagation();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        this.stopPropagation();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create mouseenter/leave events using mouseover/out and event-time checks</span></div>
<div class="line"><span class="comment">// Support: Chrome 15+</span></div>
<div class="line">jQuery.each({</div>
<div class="line">    mouseenter: <span class="stringliteral">&quot;mouseover&quot;</span>,</div>
<div class="line">    mouseleave: <span class="stringliteral">&quot;mouseout&quot;</span>,</div>
<div class="line">    pointerenter: <span class="stringliteral">&quot;pointerover&quot;</span>,</div>
<div class="line">    pointerleave: <span class="stringliteral">&quot;pointerout&quot;</span></div>
<div class="line">}, <span class="keyword">function</span>( orig, fix ) {</div>
<div class="line">    jQuery.event.special[ orig ] = {</div>
<div class="line">        delegateType: fix,</div>
<div class="line">        bindType: fix,</div>
<div class="line"></div>
<div class="line">        handle: <span class="keyword">function</span>( event ) {</div>
<div class="line">            var ret,</div>
<div class="line">                target = <span class="keyword">this</span>,</div>
<div class="line">                related = <span class="keyword">event</span>.relatedTarget,</div>
<div class="line">                handleObj = <span class="keyword">event</span>.handleObj;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// For mousenter/leave call the handler if related is outside the target.</span></div>
<div class="line">            <span class="comment">// NB: No relatedTarget if the mouse left/entered the browser window</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {</div>
<div class="line">                <span class="keyword">event</span>.type = handleObj.origType;</div>
<div class="line">                ret = handleObj.handler.apply( <span class="keyword">this</span>, arguments );</div>
<div class="line">                <span class="keyword">event</span>.type = fix;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> ret;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create &quot;bubbling&quot; focus and blur events</span></div>
<div class="line"><span class="comment">// Support: Firefox, Chrome, Safari</span></div>
<div class="line"><span class="keywordflow">if</span> ( !support.focusinBubbles ) {</div>
<div class="line">    jQuery.each({ focus: <span class="stringliteral">&quot;focusin&quot;</span>, blur: <span class="stringliteral">&quot;focusout&quot;</span> }, <span class="keyword">function</span>( orig, fix ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Attach a single capturing handler on the document while someone wants focusin/focusout</span></div>
<div class="line">        var handler = <span class="keyword">function</span>( event ) {</div>
<div class="line">                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        jQuery.event.special[ fix ] = {</div>
<div class="line">            setup: <span class="keyword">function</span>() {</div>
<div class="line">                var doc = this.ownerDocument || <span class="keyword">this</span>,</div>
<div class="line">                    attaches = data_priv.access( doc, fix );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( !attaches ) {</div>
<div class="line">                    doc.addEventListener( orig, handler, <span class="keyword">true</span> );</div>
<div class="line">                }</div>
<div class="line">                data_priv.access( doc, fix, ( attaches || 0 ) + 1 );</div>
<div class="line">            },</div>
<div class="line">            teardown: <span class="keyword">function</span>() {</div>
<div class="line">                var doc = this.ownerDocument || <span class="keyword">this</span>,</div>
<div class="line">                    attaches = data_priv.access( doc, fix ) - 1;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( !attaches ) {</div>
<div class="line">                    doc.removeEventListener( orig, handler, <span class="keyword">true</span> );</div>
<div class="line">                    data_priv.remove( doc, fix );</div>
<div class="line"></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    data_priv.access( doc, fix, attaches );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line"></div>
<div class="line">    on: <span class="keyword">function</span>( types, selector, data, fn, <span class="comment">/*INTERNAL*/</span> one ) {</div>
<div class="line">        var origFn, type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Types can be a map of types/handlers</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof types === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">            <span class="comment">// ( types-Object, selector, data )</span></div>
<div class="line">            <span class="keywordflow">if</span> ( typeof selector !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">                <span class="comment">// ( types-Object, data )</span></div>
<div class="line">                data = data || selector;</div>
<div class="line">                selector = undefined;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span> ( type in types ) {</div>
<div class="line">                this.on( type, selector, data, types[ type ], one );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( data == null &amp;&amp; fn == null ) {</div>
<div class="line">            <span class="comment">// ( types, fn )</span></div>
<div class="line">            fn = selector;</div>
<div class="line">            data = selector = undefined;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( fn == null ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( typeof selector === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">                <span class="comment">// ( types, selector, fn )</span></div>
<div class="line">                fn = data;</div>
<div class="line">                data = undefined;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// ( types, data, fn )</span></div>
<div class="line">                fn = data;</div>
<div class="line">                data = selector;</div>
<div class="line">                selector = undefined;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( fn === <span class="keyword">false</span> ) {</div>
<div class="line">            fn = returnFalse;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !fn ) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( one === 1 ) {</div>
<div class="line">            origFn = fn;</div>
<div class="line">            fn = <span class="keyword">function</span>( event ) {</div>
<div class="line">                <span class="comment">// Can use an empty set, since event contains the info</span></div>
<div class="line">                jQuery().off( event );</div>
<div class="line">                <span class="keywordflow">return</span> origFn.apply( <span class="keyword">this</span>, arguments );</div>
<div class="line">            };</div>
<div class="line">            <span class="comment">// Use same guid so caller can remove using origFn</span></div>
<div class="line">            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> this.each( <span class="keyword">function</span>() {</div>
<div class="line">            jQuery.event.add( <span class="keyword">this</span>, types, fn, data, selector );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line">    one: <span class="keyword">function</span>( types, selector, data, fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.on( types, selector, data, fn, 1 );</div>
<div class="line">    },</div>
<div class="line">    off: <span class="keyword">function</span>( types, selector, fn ) {</div>
<div class="line">        var handleObj, type;</div>
<div class="line">        <span class="keywordflow">if</span> ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {</div>
<div class="line">            <span class="comment">// ( event )  dispatched jQuery.Event</span></div>
<div class="line">            handleObj = types.handleObj;</div>
<div class="line">            jQuery( types.delegateTarget ).off(</div>
<div class="line">                handleObj.namespace ? handleObj.origType + <span class="stringliteral">&quot;.&quot;</span> + handleObj.namespace : handleObj.origType,</div>
<div class="line">                handleObj.selector,</div>
<div class="line">                handleObj.handler</div>
<div class="line">            );</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( typeof types === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">            <span class="comment">// ( types-object [, selector] )</span></div>
<div class="line">            <span class="keywordflow">for</span> ( type in types ) {</div>
<div class="line">                this.off( type, selector, types[ type ] );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( selector === <span class="keyword">false</span> || typeof selector === <span class="stringliteral">&quot;function&quot;</span> ) {</div>
<div class="line">            <span class="comment">// ( types [, fn] )</span></div>
<div class="line">            fn = selector;</div>
<div class="line">            selector = undefined;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( fn === <span class="keyword">false</span> ) {</div>
<div class="line">            fn = returnFalse;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            jQuery.event.remove( <span class="keyword">this</span>, types, fn, selector );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    trigger: <span class="keyword">function</span>( type, data ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            jQuery.event.trigger( type, data, <span class="keyword">this</span> );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line">    triggerHandler: <span class="keyword">function</span>( type, data ) {</div>
<div class="line">        var elem = <span class="keyword">this</span>[0];</div>
<div class="line">        <span class="keywordflow">if</span> ( elem ) {</div>
<div class="line">            <span class="keywordflow">return</span> jQuery.event.trigger( type, data, elem, <span class="keyword">true</span> );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,</div>
<div class="line">    rtagName = /&lt;([\w:]+)/,</div>
<div class="line">    rhtml = /&lt;|&amp;#?\w+;/,</div>
<div class="line">    rnoInnerhtml = /&lt;(?:script|style|link)/i,</div>
<div class="line">    <span class="comment">// checked=&quot;checked&quot; or checked</span></div>
<div class="line">    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,</div>
<div class="line">    rscriptType = /^$|\/(?:java|ecma)script/i,</div>
<div class="line">    rscriptTypeMasked = /^<span class="keyword">true</span>\/(.*)/,</div>
<div class="line">    rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We have to close these tags to support XHTML (#13200)</span></div>
<div class="line">    wrapMap = {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: IE 9</span></div>
<div class="line">        option: [ 1, <span class="stringliteral">&quot;&lt;select multiple=&#39;multiple&#39;&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/select&gt;&quot;</span> ],</div>
<div class="line"></div>
<div class="line">        thead: [ 1, <span class="stringliteral">&quot;&lt;table&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/table&gt;&quot;</span> ],</div>
<div class="line">        col: [ 2, <span class="stringliteral">&quot;&lt;table&gt;&lt;colgroup&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/colgroup&gt;&lt;/table&gt;&quot;</span> ],</div>
<div class="line">        tr: [ 2, <span class="stringliteral">&quot;&lt;table&gt;&lt;tbody&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/tbody&gt;&lt;/table&gt;&quot;</span> ],</div>
<div class="line">        td: [ 3, <span class="stringliteral">&quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;</span>, <span class="stringliteral">&quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot;</span> ],</div>
<div class="line"></div>
<div class="line">        _default: [ 0, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span> ]</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE 9</span></div>
<div class="line">wrapMap.optgroup = wrapMap.option;</div>
<div class="line"></div>
<div class="line">wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;</div>
<div class="line">wrapMap.th = wrapMap.td;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: 1.x compatibility</span></div>
<div class="line"><span class="comment">// Manipulating tables requires a tbody</span></div>
<div class="line"><span class="keyword">function</span> manipulationTarget( elem, content ) {</div>
<div class="line">    <span class="keywordflow">return</span> jQuery.nodeName( elem, <span class="stringliteral">&quot;table&quot;</span> ) &amp;&amp;</div>
<div class="line">        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, <span class="stringliteral">&quot;tr&quot;</span> ) ?</div>
<div class="line"></div>
<div class="line">        elem.getElementsByTagName(<span class="stringliteral">&quot;tbody&quot;</span>)[0] ||</div>
<div class="line">            elem.appendChild( elem.ownerDocument.createElement(<span class="stringliteral">&quot;tbody&quot;</span>) ) :</div>
<div class="line">        elem;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Replace/restore the type attribute of script elements for safe DOM manipulation</span></div>
<div class="line"><span class="keyword">function</span> disableScript( elem ) {</div>
<div class="line">    elem.type = (elem.getAttribute(<span class="stringliteral">&quot;type&quot;</span>) !== null) + <span class="stringliteral">&quot;/&quot;</span> + elem.type;</div>
<div class="line">    <span class="keywordflow">return</span> elem;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">function</span> restoreScript( elem ) {</div>
<div class="line">    var match = rscriptTypeMasked.exec( elem.type );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( match ) {</div>
<div class="line">        elem.type = match[ 1 ];</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        elem.removeAttribute(<span class="stringliteral">&quot;type&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> elem;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Mark scripts as having already been evaluated</span></div>
<div class="line"><span class="keyword">function</span> setGlobalEval( elems, refElements ) {</div>
<div class="line">    var i = 0,</div>
<div class="line">        l = elems.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">        data_priv.set(</div>
<div class="line">            elems[ i ], <span class="stringliteral">&quot;globalEval&quot;</span>, !refElements || data_priv.get( refElements[ i ], <span class="stringliteral">&quot;globalEval&quot;</span> )</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> cloneCopyEvent( src, dest ) {</div>
<div class="line">    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( dest.nodeType !== 1 ) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 1. Copy private data: events, handlers, etc.</span></div>
<div class="line">    <span class="keywordflow">if</span> ( data_priv.hasData( src ) ) {</div>
<div class="line">        pdataOld = data_priv.access( src );</div>
<div class="line">        pdataCur = data_priv.set( dest, pdataOld );</div>
<div class="line">        events = pdataOld.events;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( events ) {</div>
<div class="line">            <span class="keyword">delete</span> pdataCur.handle;</div>
<div class="line">            pdataCur.events = {};</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( type in events ) {</div>
<div class="line">                <span class="keywordflow">for</span> ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {</div>
<div class="line">                    jQuery.event.add( dest, type, events[ type ][ i ] );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 2. Copy user data</span></div>
<div class="line">    <span class="keywordflow">if</span> ( data_user.hasData( src ) ) {</div>
<div class="line">        udataOld = data_user.access( src );</div>
<div class="line">        udataCur = jQuery.extend( {}, udataOld );</div>
<div class="line"></div>
<div class="line">        data_user.set( dest, udataCur );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getAll( context, tag ) {</div>
<div class="line">    var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || <span class="stringliteral">&quot;*&quot;</span> ) :</div>
<div class="line">            context.querySelectorAll ? context.querySelectorAll( tag || <span class="stringliteral">&quot;*&quot;</span> ) :</div>
<div class="line">            [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> tag === undefined || tag &amp;&amp; jQuery.nodeName( context, tag ) ?</div>
<div class="line">        jQuery.merge( [ context ], ret ) :</div>
<div class="line">        ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE &gt;= 9</span></div>
<div class="line"><span class="keyword">function</span> fixInput( src, dest ) {</div>
<div class="line">    var nodeName = dest.nodeName.toLowerCase();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fails to persist the checked state of a cloned checkbox or radio button.</span></div>
<div class="line">    <span class="keywordflow">if</span> ( nodeName === <span class="stringliteral">&quot;input&quot;</span> &amp;&amp; rcheckableType.test( src.type ) ) {</div>
<div class="line">        dest.checked = src.checked;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Fails to return the selected option to the default selected state when cloning options</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( nodeName === <span class="stringliteral">&quot;input&quot;</span> || nodeName === <span class="stringliteral">&quot;textarea&quot;</span> ) {</div>
<div class="line">        dest.defaultValue = src.defaultValue;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    clone: <span class="keyword">function</span>( elem, dataAndEvents, deepDataAndEvents ) {</div>
<div class="line">        var i, l, srcElements, destElements,</div>
<div class="line">            clone = elem.cloneNode( <span class="keyword">true</span> ),</div>
<div class="line">            inPage = jQuery.contains( elem.ownerDocument, elem );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: IE &gt;= 9</span></div>
<div class="line">        <span class="comment">// Fix Cloning issues</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;</div>
<div class="line">                !jQuery.isXMLDoc( elem ) ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2</span></div>
<div class="line">            destElements = getAll( clone );</div>
<div class="line">            srcElements = getAll( elem );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( i = 0, l = srcElements.length; i &lt; l; i++ ) {</div>
<div class="line">                fixInput( srcElements[ i ], destElements[ i ] );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy the events from the original to the clone</span></div>
<div class="line">        <span class="keywordflow">if</span> ( dataAndEvents ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( deepDataAndEvents ) {</div>
<div class="line">                srcElements = srcElements || getAll( elem );</div>
<div class="line">                destElements = destElements || getAll( clone );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> ( i = 0, l = srcElements.length; i &lt; l; i++ ) {</div>
<div class="line">                    cloneCopyEvent( srcElements[ i ], destElements[ i ] );</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                cloneCopyEvent( elem, clone );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Preserve script evaluation history</span></div>
<div class="line">        destElements = getAll( clone, <span class="stringliteral">&quot;script&quot;</span> );</div>
<div class="line">        <span class="keywordflow">if</span> ( destElements.length &gt; 0 ) {</div>
<div class="line">            setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, <span class="stringliteral">&quot;script&quot;</span> ) );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return the cloned set</span></div>
<div class="line">        <span class="keywordflow">return</span> clone;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    buildFragment: <span class="keyword">function</span>( elems, context, scripts, selection ) {</div>
<div class="line">        var elem, tmp, tag, wrap, contains, j,</div>
<div class="line">            fragment = context.createDocumentFragment(),</div>
<div class="line">            nodes = [],</div>
<div class="line">            i = 0,</div>
<div class="line">            l = elems.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">            elem = elems[ i ];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( elem || elem === 0 ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Add nodes directly</span></div>
<div class="line">                <span class="keywordflow">if</span> ( jQuery.type( elem ) === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">                    <span class="comment">// Support: QtWebKit</span></div>
<div class="line">                    <span class="comment">// jQuery.merge because push.apply(_, arraylike) throws</span></div>
<div class="line">                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Convert non-html into a text node</span></div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !rhtml.test( elem ) ) {</div>
<div class="line">                    nodes.push( context.createTextNode( elem ) );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Convert html into DOM nodes</span></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    tmp = tmp || fragment.appendChild( context.createElement(<span class="stringliteral">&quot;div&quot;</span>) );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Deserialize a standard representation</span></div>
<div class="line">                    tag = ( rtagName.exec( elem ) || [ <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span> ] )[ 1 ].toLowerCase();</div>
<div class="line">                    wrap = wrapMap[ tag ] || wrapMap._default;</div>
<div class="line">                    tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, <span class="stringliteral">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span> ) + wrap[ 2 ];</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Descend through wrappers to the right content</span></div>
<div class="line">                    j = wrap[ 0 ];</div>
<div class="line">                    <span class="keywordflow">while</span> ( j-- ) {</div>
<div class="line">                        tmp = tmp.lastChild;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Support: QtWebKit</span></div>
<div class="line">                    <span class="comment">// jQuery.merge because push.apply(_, arraylike) throws</span></div>
<div class="line">                    jQuery.merge( nodes, tmp.childNodes );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Remember the top-level container</span></div>
<div class="line">                    tmp = fragment.firstChild;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Fixes #12346</span></div>
<div class="line">                    <span class="comment">// Support: Webkit, IE</span></div>
<div class="line">                    tmp.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove wrapper from fragment</span></div>
<div class="line">        fragment.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">        i = 0;</div>
<div class="line">        <span class="keywordflow">while</span> ( (elem = nodes[ i++ ]) ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// #4087 - If origin and destination elements are the same, and this is</span></div>
<div class="line">            <span class="comment">// that element, do not do anything</span></div>
<div class="line">            <span class="keywordflow">if</span> ( selection &amp;&amp; jQuery.inArray( elem, selection ) !== -1 ) {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            contains = jQuery.contains( elem.ownerDocument, elem );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Append to fragment</span></div>
<div class="line">            tmp = getAll( fragment.appendChild( elem ), <span class="stringliteral">&quot;script&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Preserve script evaluation history</span></div>
<div class="line">            <span class="keywordflow">if</span> ( contains ) {</div>
<div class="line">                setGlobalEval( tmp );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Capture executables</span></div>
<div class="line">            <span class="keywordflow">if</span> ( scripts ) {</div>
<div class="line">                j = 0;</div>
<div class="line">                <span class="keywordflow">while</span> ( (elem = tmp[ j++ ]) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( rscriptType.test( elem.type || <span class="stringliteral">&quot;&quot;</span> ) ) {</div>
<div class="line">                        scripts.push( elem );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> fragment;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    cleanData: <span class="keyword">function</span>( elems ) {</div>
<div class="line">        var data, elem, type, key,</div>
<div class="line">            special = jQuery.event.special,</div>
<div class="line">            i = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; (elem = elems[ i ]) !== undefined; i++ ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.acceptData( elem ) ) {</div>
<div class="line">                key = elem[ data_priv.expando ];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( key &amp;&amp; (data = data_priv.cache[ key ]) ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( data.events ) {</div>
<div class="line">                        <span class="keywordflow">for</span> ( type in data.events ) {</div>
<div class="line">                            <span class="keywordflow">if</span> ( special[ type ] ) {</div>
<div class="line">                                jQuery.event.remove( elem, type );</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// This is a shortcut to avoid jQuery.event.remove&#39;s overhead</span></div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                jQuery.removeEvent( elem, type, data.handle );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> ( data_priv.cache[ key ] ) {</div>
<div class="line">                        <span class="comment">// Discard any remaining `private` data</span></div>
<div class="line">                        <span class="keyword">delete</span> data_priv.cache[ key ];</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// Discard any remaining `user` data</span></div>
<div class="line">            <span class="keyword">delete</span> data_user.cache[ elem[ data_user.expando ] ];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    text: <span class="keyword">function</span>( value ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( value ) {</div>
<div class="line">            <span class="keywordflow">return</span> value === undefined ?</div>
<div class="line">                jQuery.text( <span class="keyword">this</span> ) :</div>
<div class="line">                this.empty().each(<span class="keyword">function</span>() {</div>
<div class="line">                    <span class="keywordflow">if</span> ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {</div>
<div class="line">                        this.textContent = value;</div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">        }, null, value, arguments.length );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    append: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.domManip( arguments, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {</div>
<div class="line">                var target = manipulationTarget( <span class="keyword">this</span>, elem );</div>
<div class="line">                target.appendChild( elem );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    prepend: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.domManip( arguments, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {</div>
<div class="line">                var target = manipulationTarget( <span class="keyword">this</span>, elem );</div>
<div class="line">                target.insertBefore( elem, target.firstChild );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    before: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.domManip( arguments, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( this.parentNode ) {</div>
<div class="line">                this.parentNode.insertBefore( elem, <span class="keyword">this</span> );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    after: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.domManip( arguments, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( this.parentNode ) {</div>
<div class="line">                this.parentNode.insertBefore( elem, this.nextSibling );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="keyword">remove</span>: <span class="keyword">function</span>( selector, keepData <span class="comment">/* Internal Use Only */</span> ) {</div>
<div class="line">        var elem,</div>
<div class="line">            elems = selector ? jQuery.filter( selector, <span class="keyword">this</span> ) : <span class="keyword">this</span>,</div>
<div class="line">            i = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; (elem = elems[i]) != null; i++ ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( !keepData &amp;&amp; elem.nodeType === 1 ) {</div>
<div class="line">                jQuery.cleanData( getAll( elem ) );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( elem.parentNode ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( keepData &amp;&amp; jQuery.contains( elem.ownerDocument, elem ) ) {</div>
<div class="line">                    setGlobalEval( getAll( elem, <span class="stringliteral">&quot;script&quot;</span> ) );</div>
<div class="line">                }</div>
<div class="line">                elem.parentNode.removeChild( elem );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    empty: <span class="keyword">function</span>() {</div>
<div class="line">        var elem,</div>
<div class="line">            i = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; (elem = <span class="keyword">this</span>[i]) != null; i++ ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( elem.nodeType === 1 ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Prevent memory leaks</span></div>
<div class="line">                jQuery.cleanData( getAll( elem, <span class="keyword">false</span> ) );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Remove any remaining nodes</span></div>
<div class="line">                elem.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    clone: <span class="keyword">function</span>( dataAndEvents, deepDataAndEvents ) {</div>
<div class="line">        dataAndEvents = dataAndEvents == null ? <span class="keyword">false</span> : dataAndEvents;</div>
<div class="line">        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.map(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> jQuery.clone( <span class="keyword">this</span>, dataAndEvents, deepDataAndEvents );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    html: <span class="keyword">function</span>( value ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( value ) {</div>
<div class="line">            var elem = <span class="keyword">this</span>[ 0 ] || {},</div>
<div class="line">                i = 0,</div>
<div class="line">                l = this.length;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( value === undefined &amp;&amp; elem.nodeType === 1 ) {</div>
<div class="line">                return elem.innerHTML;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// See if we can take a shortcut and just use innerHTML</span></div>
<div class="line">            if ( typeof value === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;</div>
<div class="line">                !wrapMap[ ( rtagName.exec( value ) || [ <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span> ] )[ 1 ].toLowerCase() ] ) {</div>
<div class="line"></div>
<div class="line">                value = value.replace( rxhtmlTag, <span class="stringliteral">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span> );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">                        elem = <span class="keyword">this</span>[ i ] || {};</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Remove element nodes and prevent memory leaks</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( elem.nodeType === 1 ) {</div>
<div class="line">                            jQuery.cleanData( getAll( elem, <span class="keyword">false</span> ) );</div>
<div class="line">                            elem.innerHTML = value;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    elem = 0;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If using innerHTML throws an exception, use the fallback method</span></div>
<div class="line">                } <span class="keywordflow">catch</span>( e ) {}</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( elem ) {</div>
<div class="line">                this.empty().append( value );</div>
<div class="line">            }</div>
<div class="line">        }, null, value, arguments.length );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    replaceWith: <span class="keyword">function</span>() {</div>
<div class="line">        var arg = arguments[ 0 ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make the changes, replacing each context element with the new content</span></div>
<div class="line">        this.domManip( arguments, <span class="keyword">function</span>( elem ) {</div>
<div class="line">            arg = this.parentNode;</div>
<div class="line"></div>
<div class="line">            jQuery.cleanData( getAll( <span class="keyword">this</span> ) );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( arg ) {</div>
<div class="line">                arg.replaceChild( elem, <span class="keyword">this</span> );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Force removal if there was no new content (e.g., from empty arguments)</span></div>
<div class="line">        <span class="keywordflow">return</span> arg &amp;&amp; (arg.length || arg.nodeType) ? <span class="keyword">this</span> : this.<span class="keyword">remove</span>();</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    detach: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.<span class="keyword">remove</span>( selector, true );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    domManip: <span class="keyword">function</span>( args, callback ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Flatten any nested arrays</span></div>
<div class="line">        args = concat.apply( [], args );</div>
<div class="line"></div>
<div class="line">        var fragment, first, scripts, hasScripts, node, doc,</div>
<div class="line">            i = 0,</div>
<div class="line">            l = this.length,</div>
<div class="line">            set = <span class="keyword">this</span>,</div>
<div class="line">            iNoClone = l - 1,</div>
<div class="line">            value = args[ 0 ],</div>
<div class="line">            isFunction = jQuery.isFunction( value );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We can&#39;t cloneNode fragments that contain checked, in WebKit</span></div>
<div class="line">        <span class="keywordflow">if</span> ( isFunction ||</div>
<div class="line">                ( l &gt; 1 &amp;&amp; typeof value === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp;</div>
<div class="line">                    !support.checkClone &amp;&amp; rchecked.test( value ) ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( index ) {</div>
<div class="line">                var <span class="keyword">self</span> = set.eq( index );</div>
<div class="line">                <span class="keywordflow">if</span> ( isFunction ) {</div>
<div class="line">                    args[ 0 ] = value.call( <span class="keyword">this</span>, index, <span class="keyword">self</span>.html() );</div>
<div class="line">                }</div>
<div class="line">                <span class="keyword">self</span>.domManip( args, callback );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( l ) {</div>
<div class="line">            fragment = jQuery.buildFragment( args, <span class="keyword">this</span>[ 0 ].ownerDocument, <span class="keyword">false</span>, <span class="keyword">this</span> );</div>
<div class="line">            first = fragment.firstChild;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( fragment.childNodes.length === 1 ) {</div>
<div class="line">                fragment = first;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( first ) {</div>
<div class="line">                scripts = jQuery.map( getAll( fragment, <span class="stringliteral">&quot;script&quot;</span> ), disableScript );</div>
<div class="line">                hasScripts = scripts.length;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Use the original fragment for the last item instead of the first because it can end up</span></div>
<div class="line">                <span class="comment">// being emptied incorrectly in certain situations (#8070).</span></div>
<div class="line">                <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">                    node = fragment;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> ( i !== iNoClone ) {</div>
<div class="line">                        node = jQuery.clone( node, <span class="keyword">true</span>, <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Keep references to cloned scripts for later restoration</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( hasScripts ) {</div>
<div class="line">                            <span class="comment">// Support: QtWebKit</span></div>
<div class="line">                            <span class="comment">// jQuery.merge because push.apply(_, arraylike) throws</span></div>
<div class="line">                            jQuery.merge( scripts, getAll( node, <span class="stringliteral">&quot;script&quot;</span> ) );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    callback.call( <span class="keyword">this</span>[ i ], node, i );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( hasScripts ) {</div>
<div class="line">                    doc = scripts[ scripts.length - 1 ].ownerDocument;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Reenable scripts</span></div>
<div class="line">                    jQuery.map( scripts, restoreScript );</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Evaluate executable scripts on first document insertion</span></div>
<div class="line">                    <span class="keywordflow">for</span> ( i = 0; i &lt; hasScripts; i++ ) {</div>
<div class="line">                        node = scripts[ i ];</div>
<div class="line">                        <span class="keywordflow">if</span> ( rscriptType.test( node.type || <span class="stringliteral">&quot;&quot;</span> ) &amp;&amp;</div>
<div class="line">                            !data_priv.access( node, <span class="stringliteral">&quot;globalEval&quot;</span> ) &amp;&amp; jQuery.contains( doc, node ) ) {</div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">if</span> ( node.src ) {</div>
<div class="line">                                <span class="comment">// Optional AJAX dependency, but won&#39;t run scripts if not present</span></div>
<div class="line">                                <span class="keywordflow">if</span> ( jQuery._evalUrl ) {</div>
<div class="line">                                    jQuery._evalUrl( node.src );</div>
<div class="line">                                }</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                jQuery.globalEval( node.textContent.replace( rcleanScript, <span class="stringliteral">&quot;&quot;</span> ) );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.each({</div>
<div class="line">    appendTo: <span class="stringliteral">&quot;append&quot;</span>,</div>
<div class="line">    prependTo: <span class="stringliteral">&quot;prepend&quot;</span>,</div>
<div class="line">    insertBefore: <span class="stringliteral">&quot;before&quot;</span>,</div>
<div class="line">    insertAfter: <span class="stringliteral">&quot;after&quot;</span>,</div>
<div class="line">    replaceAll: <span class="stringliteral">&quot;replaceWith&quot;</span></div>
<div class="line">}, <span class="keyword">function</span>( name, original ) {</div>
<div class="line">    jQuery.fn[ name ] = <span class="keyword">function</span>( selector ) {</div>
<div class="line">        var elems,</div>
<div class="line">            ret = [],</div>
<div class="line">            insert = jQuery( selector ),</div>
<div class="line">            last = insert.length - 1,</div>
<div class="line">            i = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt;= last; i++ ) {</div>
<div class="line">            elems = i === last ? <span class="keyword">this</span> : this.clone( <span class="keyword">true</span> );</div>
<div class="line">            jQuery( insert[ i ] )[ original ]( elems );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: QtWebKit</span></div>
<div class="line">            <span class="comment">// .get() because push.apply(_, arraylike) throws</span></div>
<div class="line">            push.apply( ret, elems.get() );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.pushStack( ret );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var iframe,</div>
<div class="line">    elemdisplay = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Called only from within defaultDisplay</span></div>
<div class="line"><span class="keyword">function</span> actualDisplay( name, doc ) {</div>
<div class="line">    var style,</div>
<div class="line">        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),</div>
<div class="line"></div>
<div class="line">        <span class="comment">// getDefaultComputedStyle might be reliably used only on attached element</span></div>
<div class="line">        display = window.getDefaultComputedStyle &amp;&amp; ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Use of this method is a temporary fix (more like optmization) until something better comes along,</span></div>
<div class="line">            <span class="comment">// since it was removed from specification and supported only in FF</span></div>
<div class="line">            style.display : jQuery.css( elem[ 0 ], <span class="stringliteral">&quot;display&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We don&#39;t have any data stored on the element,</span></div>
<div class="line">    <span class="comment">// so use &quot;detach&quot; method as fast way to get rid of the element</span></div>
<div class="line">    elem.detach();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> display;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> defaultDisplay( nodeName ) {</div>
<div class="line">    var doc = document,</div>
<div class="line">        display = elemdisplay[ nodeName ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !display ) {</div>
<div class="line">        display = actualDisplay( nodeName, doc );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If the simple way fails, read from inside an iframe</span></div>
<div class="line">        <span class="keywordflow">if</span> ( display === <span class="stringliteral">&quot;none&quot;</span> || !display ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Use the already-created iframe if possible</span></div>
<div class="line">            iframe = (iframe || jQuery( <span class="stringliteral">&quot;&lt;iframe frameborder=&#39;0&#39; width=&#39;0&#39; height=&#39;0&#39;/&gt;&quot;</span> )).appendTo( doc.documentElement );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Always write a new HTML skeleton so Webkit and Firefox don&#39;t choke on reuse</span></div>
<div class="line">            doc = iframe[ 0 ].contentDocument;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Support: IE</span></div>
<div class="line">            doc.write();</div>
<div class="line">            doc.close();</div>
<div class="line"></div>
<div class="line">            display = actualDisplay( nodeName, doc );</div>
<div class="line">            iframe.detach();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Store the correct default display</span></div>
<div class="line">        elemdisplay[ nodeName ] = display;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> display;</div>
<div class="line">}</div>
<div class="line">var rmargin = (/^margin/);</div>
<div class="line"></div>
<div class="line">var rnumnonpx = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^(&quot;</span> + pnum + <span class="stringliteral">&quot;)(?!px)[a-z%]+$&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> );</div>
<div class="line"></div>
<div class="line">var getStyles = <span class="keyword">function</span>( elem ) {</div>
<div class="line">        <span class="keywordflow">return</span> elem.ownerDocument.defaultView.getComputedStyle( elem, null );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> curCSS( elem, name, computed ) {</div>
<div class="line">    var width, minWidth, maxWidth, ret,</div>
<div class="line">        style = elem.style;</div>
<div class="line"></div>
<div class="line">    computed = computed || getStyles( elem );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: IE9</span></div>
<div class="line">    <span class="comment">// getPropertyValue is only needed for .css(&#39;filter&#39;) in IE9, see #12537</span></div>
<div class="line">    <span class="keywordflow">if</span> ( computed ) {</div>
<div class="line">        ret = computed.getPropertyValue( name ) || computed[ name ];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( computed ) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( ret === <span class="stringliteral">&quot;&quot;</span> &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {</div>
<div class="line">            ret = jQuery.style( elem, name );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Support: iOS &lt; 6</span></div>
<div class="line">        <span class="comment">// A tribute to the &quot;awesome hack by Dean Edwards&quot;</span></div>
<div class="line">        <span class="comment">// iOS &lt; 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels</span></div>
<div class="line">        <span class="comment">// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values</span></div>
<div class="line">        <span class="keywordflow">if</span> ( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Remember the original values</span></div>
<div class="line">            width = style.width;</div>
<div class="line">            minWidth = style.minWidth;</div>
<div class="line">            maxWidth = style.maxWidth;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Put in the new values to get a computed value out</span></div>
<div class="line">            style.minWidth = style.maxWidth = style.width = ret;</div>
<div class="line">            ret = computed.width;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Revert the changed values</span></div>
<div class="line">            style.width = width;</div>
<div class="line">            style.minWidth = minWidth;</div>
<div class="line">            style.maxWidth = maxWidth;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> ret !== undefined ?</div>
<div class="line">        <span class="comment">// Support: IE</span></div>
<div class="line">        <span class="comment">// IE returns zIndex value as an integer.</span></div>
<div class="line">        ret + <span class="stringliteral">&quot;&quot;</span> :</div>
<div class="line">        ret;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> addGetHookIf( conditionFn, hookFn ) {</div>
<div class="line">    <span class="comment">// Define the hook, we&#39;ll check on the first run if it&#39;s really needed.</span></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( conditionFn() ) {</div>
<div class="line">                <span class="comment">// Hook not needed (or it&#39;s not possible to use it due to missing dependency),</span></div>
<div class="line">                <span class="comment">// remove it.</span></div>
<div class="line">                <span class="comment">// Since there are no other hooks for marginRight, remove the whole object.</span></div>
<div class="line">                <span class="keyword">delete</span> this.<span class="keyword">get</span>;</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Hook needed; redefine it so that the support test is not executed again.</span></div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> (this.<span class="keyword">get</span> = hookFn).apply( <span class="keyword">this</span>, arguments );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>() {</div>
<div class="line">    var pixelPositionVal, boxSizingReliableVal,</div>
<div class="line">        docElem = document.documentElement,</div>
<div class="line">        container = document.createElement( <span class="stringliteral">&quot;div&quot;</span> ),</div>
<div class="line">        div = document.createElement( <span class="stringliteral">&quot;div&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !div.style ) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    div.style.backgroundClip = <span class="stringliteral">&quot;content-box&quot;</span>;</div>
<div class="line">    div.cloneNode( <span class="keyword">true</span> ).style.backgroundClip = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    support.clearCloneStyle = div.style.backgroundClip === <span class="stringliteral">&quot;content-box&quot;</span>;</div>
<div class="line"></div>
<div class="line">    container.style.cssText = <span class="stringliteral">&quot;border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;&quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot;position:absolute&quot;</span>;</div>
<div class="line">    container.appendChild( div );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout</span></div>
<div class="line">    <span class="comment">// so they&#39;re executed at the same time to save the second computation.</span></div>
<div class="line">    <span class="keyword">function</span> computePixelPositionAndBoxSizingReliable() {</div>
<div class="line">        div.style.cssText =</div>
<div class="line">            <span class="comment">// Support: Firefox&lt;29, Android 2.3</span></div>
<div class="line">            <span class="comment">// Vendor-prefix box-sizing</span></div>
<div class="line">            <span class="stringliteral">&quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot;box-sizing:border-box;display:block;margin-top:1%;top:1%;&quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot;border:1px;padding:1px;width:4px;position:absolute&quot;</span>;</div>
<div class="line">        div.innerHTML = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        docElem.appendChild( container );</div>
<div class="line"></div>
<div class="line">        var divStyle = window.getComputedStyle( div, null );</div>
<div class="line">        pixelPositionVal = divStyle.top !== <span class="stringliteral">&quot;1%&quot;</span>;</div>
<div class="line">        boxSizingReliableVal = divStyle.width === <span class="stringliteral">&quot;4px&quot;</span>;</div>
<div class="line"></div>
<div class="line">        docElem.removeChild( container );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: node.js jsdom</span></div>
<div class="line">    <span class="comment">// Don&#39;t assume that getComputedStyle is a property of the global object</span></div>
<div class="line">    <span class="keywordflow">if</span> ( window.getComputedStyle ) {</div>
<div class="line">        jQuery.extend( support, {</div>
<div class="line">            pixelPosition: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="comment">// This test is executed only once but we still do memoizing</span></div>
<div class="line">                <span class="comment">// since we can use the boxSizingReliable pre-computing.</span></div>
<div class="line">                <span class="comment">// No need to check if the test was already performed, though.</span></div>
<div class="line">                computePixelPositionAndBoxSizingReliable();</div>
<div class="line">                <span class="keywordflow">return</span> pixelPositionVal;</div>
<div class="line">            },</div>
<div class="line">            boxSizingReliable: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( boxSizingReliableVal == null ) {</div>
<div class="line">                    computePixelPositionAndBoxSizingReliable();</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> boxSizingReliableVal;</div>
<div class="line">            },</div>
<div class="line">            reliableMarginRight: <span class="keyword">function</span>() {</div>
<div class="line">                <span class="comment">// Support: Android 2.3</span></div>
<div class="line">                <span class="comment">// Check if div with explicit width and no margin-right incorrectly</span></div>
<div class="line">                <span class="comment">// gets computed margin-right based on width of container. (#3333)</span></div>
<div class="line">                <span class="comment">// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span></div>
<div class="line">                <span class="comment">// This support function is only executed once so no memoizing is needed.</span></div>
<div class="line">                var ret,</div>
<div class="line">                    marginDiv = div.appendChild( document.createElement( <span class="stringliteral">&quot;div&quot;</span> ) );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Reset CSS: box-sizing; display; margin; border; padding</span></div>
<div class="line">                marginDiv.style.cssText = div.style.cssText =</div>
<div class="line">                    <span class="comment">// Support: Firefox&lt;29, Android 2.3</span></div>
<div class="line">                    <span class="comment">// Vendor-prefix box-sizing</span></div>
<div class="line">                    <span class="stringliteral">&quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot;</span> +</div>
<div class="line">                    <span class="stringliteral">&quot;box-sizing:content-box;display:block;margin:0;border:0;padding:0&quot;</span>;</div>
<div class="line">                marginDiv.style.marginRight = marginDiv.style.width = <span class="stringliteral">&quot;0&quot;</span>;</div>
<div class="line">                div.style.width = <span class="stringliteral">&quot;1px&quot;</span>;</div>
<div class="line">                docElem.appendChild( container );</div>
<div class="line"></div>
<div class="line">                ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );</div>
<div class="line"></div>
<div class="line">                docElem.removeChild( container );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> ret;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">})();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// A method for quickly swapping in/out CSS properties to get correct calculations.</span></div>
<div class="line">jQuery.swap = <span class="keyword">function</span>( elem, options, callback, args ) {</div>
<div class="line">    var ret, name,</div>
<div class="line">        old = {};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Remember the old values, and insert the new ones</span></div>
<div class="line">    <span class="keywordflow">for</span> ( name in options ) {</div>
<div class="line">        old[ name ] = elem.style[ name ];</div>
<div class="line">        elem.style[ name ] = options[ name ];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ret = callback.apply( elem, args || [] );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Revert the old values</span></div>
<div class="line">    <span class="keywordflow">for</span> ( name in options ) {</div>
<div class="line">        elem.style[ name ] = old[ name ];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    <span class="comment">// swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;</span></div>
<div class="line">    <span class="comment">// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display</span></div>
<div class="line">    rdisplayswap = /^(none|table(?!-c[ea]).+)/,</div>
<div class="line">    rnumsplit = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^(&quot;</span> + pnum + <span class="stringliteral">&quot;)(.*)$&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> ),</div>
<div class="line">    rrelNum = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^([+-])=(&quot;</span> + pnum + <span class="stringliteral">&quot;)&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> ),</div>
<div class="line"></div>
<div class="line">    cssShow = { position: <span class="stringliteral">&quot;absolute&quot;</span>, visibility: <span class="stringliteral">&quot;hidden&quot;</span>, display: <span class="stringliteral">&quot;block&quot;</span> },</div>
<div class="line">    cssNormalTransform = {</div>
<div class="line">        letterSpacing: <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">        fontWeight: <span class="stringliteral">&quot;400&quot;</span></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    cssPrefixes = [ <span class="stringliteral">&quot;Webkit&quot;</span>, <span class="stringliteral">&quot;O&quot;</span>, <span class="stringliteral">&quot;Moz&quot;</span>, <span class="stringliteral">&quot;ms&quot;</span> ];</div>
<div class="line"></div>
<div class="line"><span class="comment">// return a css property mapped to a potentially vendor prefixed property</span></div>
<div class="line"><span class="keyword">function</span> vendorPropName( style, name ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// shortcut for names that are not vendor prefixed</span></div>
<div class="line">    <span class="keywordflow">if</span> ( name in style ) {</div>
<div class="line">        <span class="keywordflow">return</span> name;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for vendor prefixed names</span></div>
<div class="line">    var capName = name[0].toUpperCase() + name.slice(1),</div>
<div class="line">        origName = name,</div>
<div class="line">        i = cssPrefixes.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">        name = cssPrefixes[ i ] + capName;</div>
<div class="line">        <span class="keywordflow">if</span> ( name in style ) {</div>
<div class="line">            <span class="keywordflow">return</span> name;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> origName;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setPositiveNumber( elem, value, subtract ) {</div>
<div class="line">    var matches = rnumsplit.exec( value );</div>
<div class="line">    <span class="keywordflow">return</span> matches ?</div>
<div class="line">        <span class="comment">// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks</span></div>
<div class="line">        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || <span class="stringliteral">&quot;px&quot;</span> ) :</div>
<div class="line">        value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {</div>
<div class="line">    var i = extra === ( isBorderBox ? <span class="stringliteral">&quot;border&quot;</span> : <span class="stringliteral">&quot;content&quot;</span> ) ?</div>
<div class="line">        <span class="comment">// If we already have the right measurement, avoid augmentation</span></div>
<div class="line">        4 :</div>
<div class="line">        <span class="comment">// Otherwise initialize for horizontal or vertical properties</span></div>
<div class="line">        name === <span class="stringliteral">&quot;width&quot;</span> ? 1 : 0,</div>
<div class="line"></div>
<div class="line">        val = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; 4; i += 2 ) {</div>
<div class="line">        <span class="comment">// both box models exclude margin, so add it if we want it</span></div>
<div class="line">        <span class="keywordflow">if</span> ( extra === <span class="stringliteral">&quot;margin&quot;</span> ) {</div>
<div class="line">            val += jQuery.css( elem, extra + cssExpand[ i ], <span class="keyword">true</span>, styles );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( isBorderBox ) {</div>
<div class="line">            <span class="comment">// border-box includes padding, so remove it if we want content</span></div>
<div class="line">            <span class="keywordflow">if</span> ( extra === <span class="stringliteral">&quot;content&quot;</span> ) {</div>
<div class="line">                val -= jQuery.css( elem, <span class="stringliteral">&quot;padding&quot;</span> + cssExpand[ i ], <span class="keyword">true</span>, styles );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// at this point, extra isn&#39;t border nor margin, so remove border</span></div>
<div class="line">            <span class="keywordflow">if</span> ( extra !== <span class="stringliteral">&quot;margin&quot;</span> ) {</div>
<div class="line">                val -= jQuery.css( elem, <span class="stringliteral">&quot;border&quot;</span> + cssExpand[ i ] + <span class="stringliteral">&quot;Width&quot;</span>, <span class="keyword">true</span>, styles );</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// at this point, extra isn&#39;t content, so add padding</span></div>
<div class="line">            val += jQuery.css( elem, <span class="stringliteral">&quot;padding&quot;</span> + cssExpand[ i ], <span class="keyword">true</span>, styles );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// at this point, extra isn&#39;t content nor padding, so add border</span></div>
<div class="line">            <span class="keywordflow">if</span> ( extra !== <span class="stringliteral">&quot;padding&quot;</span> ) {</div>
<div class="line">                val += jQuery.css( elem, <span class="stringliteral">&quot;border&quot;</span> + cssExpand[ i ] + <span class="stringliteral">&quot;Width&quot;</span>, <span class="keyword">true</span>, styles );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getWidthOrHeight( elem, name, extra ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Start with offset property, which is equivalent to the border-box value</span></div>
<div class="line">    var valueIsBorderBox = <span class="keyword">true</span>,</div>
<div class="line">        val = name === <span class="stringliteral">&quot;width&quot;</span> ? elem.offsetWidth : elem.offsetHeight,</div>
<div class="line">        styles = getStyles( elem ),</div>
<div class="line">        isBorderBox = jQuery.css( elem, <span class="stringliteral">&quot;boxSizing&quot;</span>, <span class="keyword">false</span>, styles ) === <span class="stringliteral">&quot;border-box&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// some non-html elements return undefined for offsetWidth, so check for null/undefined</span></div>
<div class="line">    <span class="comment">// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285</span></div>
<div class="line">    <span class="comment">// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668</span></div>
<div class="line">    <span class="keywordflow">if</span> ( val &lt;= 0 || val == null ) {</div>
<div class="line">        <span class="comment">// Fall back to computed then uncomputed css if necessary</span></div>
<div class="line">        val = curCSS( elem, name, styles );</div>
<div class="line">        <span class="keywordflow">if</span> ( val &lt; 0 || val == null ) {</div>
<div class="line">            val = elem.style[ name ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Computed unit is not pixels. Stop here and return.</span></div>
<div class="line">        <span class="keywordflow">if</span> ( rnumnonpx.test(val) ) {</div>
<div class="line">            <span class="keywordflow">return</span> val;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we need the check for style in case a browser which returns unreliable values</span></div>
<div class="line">        <span class="comment">// for getComputedStyle silently falls back to the reliable elem.style</span></div>
<div class="line">        valueIsBorderBox = isBorderBox &amp;&amp;</div>
<div class="line">            ( support.boxSizingReliable() || val === elem.style[ name ] );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Normalize &quot;&quot;, auto, and prepare for extra</span></div>
<div class="line">        val = parseFloat( val ) || 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use the active box-sizing model to add/subtract irrelevant styles</span></div>
<div class="line">    <span class="keywordflow">return</span> ( val +</div>
<div class="line">        augmentWidthOrHeight(</div>
<div class="line">            elem,</div>
<div class="line">            name,</div>
<div class="line">            extra || ( isBorderBox ? <span class="stringliteral">&quot;border&quot;</span> : <span class="stringliteral">&quot;content&quot;</span> ),</div>
<div class="line">            valueIsBorderBox,</div>
<div class="line">            styles</div>
<div class="line">        )</div>
<div class="line">    ) + <span class="stringliteral">&quot;px&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> showHide( elements, show ) {</div>
<div class="line">    var display, elem, hidden,</div>
<div class="line">        values = [],</div>
<div class="line">        index = 0,</div>
<div class="line">        length = elements.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; index &lt; length; index++ ) {</div>
<div class="line">        elem = elements[ index ];</div>
<div class="line">        <span class="keywordflow">if</span> ( !elem.style ) {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        values[ index ] = data_priv.get( elem, <span class="stringliteral">&quot;olddisplay&quot;</span> );</div>
<div class="line">        display = elem.style.display;</div>
<div class="line">        <span class="keywordflow">if</span> ( show ) {</div>
<div class="line">            <span class="comment">// Reset the inline display of this element to learn if it is</span></div>
<div class="line">            <span class="comment">// being hidden by cascaded rules or not</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !values[ index ] &amp;&amp; display === <span class="stringliteral">&quot;none&quot;</span> ) {</div>
<div class="line">                elem.style.display = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set elements which have been overridden with display: none</span></div>
<div class="line">            <span class="comment">// in a stylesheet to whatever the default browser style is</span></div>
<div class="line">            <span class="comment">// for such an element</span></div>
<div class="line">            <span class="keywordflow">if</span> ( elem.style.display === <span class="stringliteral">&quot;&quot;</span> &amp;&amp; isHidden( elem ) ) {</div>
<div class="line">                values[ index ] = data_priv.access( elem, <span class="stringliteral">&quot;olddisplay&quot;</span>, defaultDisplay(elem.nodeName) );</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            hidden = isHidden( elem );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( display !== <span class="stringliteral">&quot;none&quot;</span> || !hidden ) {</div>
<div class="line">                data_priv.set( elem, <span class="stringliteral">&quot;olddisplay&quot;</span>, hidden ? display : jQuery.css( elem, <span class="stringliteral">&quot;display&quot;</span> ) );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the display of most of the elements in a second loop</span></div>
<div class="line">    <span class="comment">// to avoid the constant reflow</span></div>
<div class="line">    <span class="keywordflow">for</span> ( index = 0; index &lt; length; index++ ) {</div>
<div class="line">        elem = elements[ index ];</div>
<div class="line">        <span class="keywordflow">if</span> ( !elem.style ) {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( !show || elem.style.display === <span class="stringliteral">&quot;none&quot;</span> || elem.style.display === <span class="stringliteral">&quot;&quot;</span> ) {</div>
<div class="line">            elem.style.display = show ? values[ index ] || <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;none&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> elements;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    <span class="comment">// Add in style property hooks for overriding the default</span></div>
<div class="line">    <span class="comment">// behavior of getting and setting a style property</span></div>
<div class="line">    cssHooks: {</div>
<div class="line">        opacity: {</div>
<div class="line">            <span class="keyword">get</span>: <span class="keyword">function</span>( elem, computed ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( computed ) {</div>
<div class="line">                    <span class="comment">// We should always get a number back from opacity</span></div>
<div class="line">                    var ret = curCSS( elem, <span class="stringliteral">&quot;opacity&quot;</span> );</div>
<div class="line">                    <span class="keywordflow">return</span> ret === <span class="stringliteral">&quot;&quot;</span> ? <span class="stringliteral">&quot;1&quot;</span> : ret;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Don&#39;t automatically add &quot;px&quot; to these possibly-unitless properties</span></div>
<div class="line">    cssNumber: {</div>
<div class="line">        <span class="stringliteral">&quot;columnCount&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;fillOpacity&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;flexGrow&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;flexShrink&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;fontWeight&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;lineHeight&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;opacity&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;order&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;orphans&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;widows&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;zIndex&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;zoom&quot;</span>: <span class="keyword">true</span></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add in properties whose names you wish to fix before</span></div>
<div class="line">    <span class="comment">// setting or getting the value</span></div>
<div class="line">    cssProps: {</div>
<div class="line">        <span class="comment">// normalize float css property</span></div>
<div class="line">        <span class="stringliteral">&quot;float&quot;</span>: <span class="stringliteral">&quot;cssFloat&quot;</span></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get and set the style property on a DOM Node</span></div>
<div class="line">    style: <span class="keyword">function</span>( elem, name, value, extra ) {</div>
<div class="line">        <span class="comment">// Don&#39;t set styles on text and comment nodes</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure that we&#39;re working with the right name</span></div>
<div class="line">        var ret, type, hooks,</div>
<div class="line">            origName = jQuery.camelCase( name ),</div>
<div class="line">            style = elem.style;</div>
<div class="line"></div>
<div class="line">        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// gets hook for the prefixed version</span></div>
<div class="line">        <span class="comment">// followed by the unprefixed version</span></div>
<div class="line">        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if we&#39;re setting a value</span></div>
<div class="line">        <span class="keywordflow">if</span> ( value !== undefined ) {</div>
<div class="line">            type = typeof value;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// convert relative number strings (+= or -=) to relative numbers. #7345</span></div>
<div class="line">            <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; (ret = rrelNum.exec( value )) ) {</div>
<div class="line">                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );</div>
<div class="line">                <span class="comment">// Fixes bug #9237</span></div>
<div class="line">                type = <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Make sure that null and NaN values aren&#39;t set. See: #7116</span></div>
<div class="line">            <span class="keywordflow">if</span> ( value == null || value !== value ) {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If a number was passed in, add &#39;px&#39; to the (except for certain CSS properties)</span></div>
<div class="line">            <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;number&quot;</span> &amp;&amp; !jQuery.cssNumber[ origName ] ) {</div>
<div class="line">                value += <span class="stringliteral">&quot;px&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,</span></div>
<div class="line">            <span class="comment">// but it would mean to define eight (for every problematic property) identical functions</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !support.clearCloneStyle &amp;&amp; value === <span class="stringliteral">&quot;&quot;</span> &amp;&amp; name.indexOf( <span class="stringliteral">&quot;background&quot;</span> ) === 0 ) {</div>
<div class="line">                style[ name ] = <span class="stringliteral">&quot;inherit&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If a hook was provided, use that value, otherwise just set the specified value</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !hooks || !(<span class="stringliteral">&quot;set&quot;</span> in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {</div>
<div class="line">                style[ name ] = value;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// If a hook was provided get the non-computed value from there</span></div>
<div class="line">            <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;get&quot;</span> in hooks &amp;&amp; (ret = hooks.get( elem, <span class="keyword">false</span>, extra )) !== undefined ) {</div>
<div class="line">                <span class="keywordflow">return</span> ret;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Otherwise just get the value from the style object</span></div>
<div class="line">            <span class="keywordflow">return</span> style[ name ];</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    css: <span class="keyword">function</span>( elem, name, extra, styles ) {</div>
<div class="line">        var val, num, hooks,</div>
<div class="line">            origName = jQuery.camelCase( name );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure that we&#39;re working with the right name</span></div>
<div class="line">        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// gets hook for the prefixed version</span></div>
<div class="line">        <span class="comment">// followed by the unprefixed version</span></div>
<div class="line">        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If a hook was provided get the computed value from there</span></div>
<div class="line">        <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;get&quot;</span> in hooks ) {</div>
<div class="line">            val = hooks.get( elem, <span class="keyword">true</span>, extra );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Otherwise, if a way to get the computed value exists, use that</span></div>
<div class="line">        <span class="keywordflow">if</span> ( val === undefined ) {</div>
<div class="line">            val = curCSS( elem, name, styles );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//convert &quot;normal&quot; to computed value</span></div>
<div class="line">        <span class="keywordflow">if</span> ( val === <span class="stringliteral">&quot;normal&quot;</span> &amp;&amp; name in cssNormalTransform ) {</div>
<div class="line">            val = cssNormalTransform[ name ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return, converting to number if forced or a qualifier was provided and val looks numeric</span></div>
<div class="line">        <span class="keywordflow">if</span> ( extra === <span class="stringliteral">&quot;&quot;</span> || extra ) {</div>
<div class="line">            num = parseFloat( val );</div>
<div class="line">            <span class="keywordflow">return</span> extra === <span class="keyword">true</span> || jQuery.isNumeric( num ) ? num || 0 : val;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> val;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.each([ <span class="stringliteral">&quot;height&quot;</span>, <span class="stringliteral">&quot;width&quot;</span> ], <span class="keyword">function</span>( i, name ) {</div>
<div class="line">    jQuery.cssHooks[ name ] = {</div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>( elem, computed, extra ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( computed ) {</div>
<div class="line">                <span class="comment">// certain elements can have dimension info if we invisibly show them</span></div>
<div class="line">                <span class="comment">// however, it must have a current display style that would benefit from this</span></div>
<div class="line">                <span class="keywordflow">return</span> rdisplayswap.test( jQuery.css( elem, <span class="stringliteral">&quot;display&quot;</span> ) ) &amp;&amp; elem.offsetWidth === 0 ?</div>
<div class="line">                    jQuery.swap( elem, cssShow, <span class="keyword">function</span>() {</div>
<div class="line">                        return getWidthOrHeight( elem, name, extra );</div>
<div class="line">                    }) :</div>
<div class="line">                    getWidthOrHeight( elem, name, extra );</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        set: <span class="keyword">function</span>( elem, value, extra ) {</div>
<div class="line">            var styles = extra &amp;&amp; getStyles( elem );</div>
<div class="line">            <span class="keywordflow">return</span> setPositiveNumber( elem, value, extra ?</div>
<div class="line">                augmentWidthOrHeight(</div>
<div class="line">                    elem,</div>
<div class="line">                    name,</div>
<div class="line">                    extra,</div>
<div class="line">                    jQuery.css( elem, <span class="stringliteral">&quot;boxSizing&quot;</span>, <span class="keyword">false</span>, styles ) === <span class="stringliteral">&quot;border-box&quot;</span>,</div>
<div class="line">                    styles</div>
<div class="line">                ) : 0</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: Android 2.3</span></div>
<div class="line">jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,</div>
<div class="line">    <span class="keyword">function</span>( elem, computed ) {</div>
<div class="line">        if ( computed ) {</div>
<div class="line">            <span class="comment">// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span></div>
<div class="line">            <span class="comment">// Work around by temporarily setting element display to inline-block</span></div>
<div class="line">            return jQuery.swap( elem, { <span class="stringliteral">&quot;display&quot;</span>: <span class="stringliteral">&quot;inline-block&quot;</span> },</div>
<div class="line">                curCSS, [ elem, <span class="stringliteral">&quot;marginRight&quot;</span> ] );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// These hooks are used by animate to expand properties</span></div>
<div class="line">jQuery.each({</div>
<div class="line">    margin: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">    padding: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">    border: <span class="stringliteral">&quot;Width&quot;</span></div>
<div class="line">}, <span class="keyword">function</span>( prefix, suffix ) {</div>
<div class="line">    jQuery.cssHooks[ prefix + suffix ] = {</div>
<div class="line">        expand: <span class="keyword">function</span>( value ) {</div>
<div class="line">            var i = 0,</div>
<div class="line">                expanded = {},</div>
<div class="line"></div>
<div class="line">                <span class="comment">// assumes a single number if not a string</span></div>
<div class="line">                parts = typeof value === <span class="stringliteral">&quot;string&quot;</span> ? value.split(<span class="stringliteral">&quot; &quot;</span>) : [ value ];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; 4; i++ ) {</div>
<div class="line">                expanded[ prefix + cssExpand[ i ] + suffix ] =</div>
<div class="line">                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> expanded;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !rmargin.test( prefix ) ) {</div>
<div class="line">        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    css: <span class="keyword">function</span>( name, value ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( elem, name, value ) {</div>
<div class="line">            var styles, len,</div>
<div class="line">                map = {},</div>
<div class="line">                i = 0;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.isArray( name ) ) {</div>
<div class="line">                styles = getStyles( elem );</div>
<div class="line">                len = name.length;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], <span class="keyword">false</span>, styles );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> map;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> value !== undefined ?</div>
<div class="line">                jQuery.style( elem, name, value ) :</div>
<div class="line">                jQuery.css( elem, name );</div>
<div class="line">        }, name, value, arguments.length &gt; 1 );</div>
<div class="line">    },</div>
<div class="line">    show: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> showHide( <span class="keyword">this</span>, <span class="keyword">true</span> );</div>
<div class="line">    },</div>
<div class="line">    hide: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> showHide( <span class="keyword">this</span> );</div>
<div class="line">    },</div>
<div class="line">    toggle: <span class="keyword">function</span>( state ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( typeof state === <span class="stringliteral">&quot;boolean&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> state ? this.show() : this.hide();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( isHidden( <span class="keyword">this</span> ) ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).show();</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).hide();</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Tween( elem, options, prop, end, easing ) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Tween.prototype.init( elem, options, prop, end, easing );</div>
<div class="line">}</div>
<div class="line">jQuery.Tween = Tween;</div>
<div class="line"></div>
<div class="line">Tween.prototype = {</div>
<div class="line">    constructor: Tween,</div>
<div class="line">    init: <span class="keyword">function</span>( elem, options, prop, end, easing, unit ) {</div>
<div class="line">        this.elem = elem;</div>
<div class="line">        this.prop = prop;</div>
<div class="line">        this.easing = easing || <span class="stringliteral">&quot;swing&quot;</span>;</div>
<div class="line">        this.options = options;</div>
<div class="line">        this.start = this.now = this.cur();</div>
<div class="line">        this.end = end;</div>
<div class="line">        this.unit = unit || ( jQuery.cssNumber[ prop ] ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;px&quot;</span> );</div>
<div class="line">    },</div>
<div class="line">    cur: <span class="keyword">function</span>() {</div>
<div class="line">        var hooks = Tween.propHooks[ this.prop ];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> hooks &amp;&amp; hooks.get ?</div>
<div class="line">            hooks.get( <span class="keyword">this</span> ) :</div>
<div class="line">            Tween.propHooks._default.get( <span class="keyword">this</span> );</div>
<div class="line">    },</div>
<div class="line">    run: <span class="keyword">function</span>( percent ) {</div>
<div class="line">        var eased,</div>
<div class="line">            hooks = Tween.propHooks[ this.prop ];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( this.options.duration ) {</div>
<div class="line">            this.pos = eased = jQuery.easing[ this.easing ](</div>
<div class="line">                percent, this.options.duration * percent, 0, 1, this.options.duration</div>
<div class="line">            );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            this.pos = eased = percent;</div>
<div class="line">        }</div>
<div class="line">        this.now = ( this.end - this.start ) * eased + this.start;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( this.options.step ) {</div>
<div class="line">            this.options.step.call( this.elem, this.now, <span class="keyword">this</span> );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( hooks &amp;&amp; hooks.set ) {</div>
<div class="line">            hooks.set( <span class="keyword">this</span> );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            Tween.propHooks._default.set( <span class="keyword">this</span> );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Tween.prototype.init.prototype = Tween.prototype;</div>
<div class="line"></div>
<div class="line">Tween.propHooks = {</div>
<div class="line">    _default: {</div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>( tween ) {</div>
<div class="line">            var result;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( tween.elem[ tween.prop ] != null &amp;&amp;</div>
<div class="line">                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {</div>
<div class="line">                <span class="keywordflow">return</span> tween.elem[ tween.prop ];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// passing an empty string as a 3rd parameter to .css will automatically</span></div>
<div class="line">            <span class="comment">// attempt a parseFloat and fallback to a string if the parse fails</span></div>
<div class="line">            <span class="comment">// so, simple values such as &quot;10px&quot; are parsed to Float.</span></div>
<div class="line">            <span class="comment">// complex values such as &quot;rotate(1rad)&quot; are returned as is.</span></div>
<div class="line">            result = jQuery.css( tween.elem, tween.prop, <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">            <span class="comment">// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.</span></div>
<div class="line">            <span class="keywordflow">return</span> !result || result === <span class="stringliteral">&quot;auto&quot;</span> ? 0 : result;</div>
<div class="line">        },</div>
<div class="line">        set: <span class="keyword">function</span>( tween ) {</div>
<div class="line">            <span class="comment">// use step hook for back compat - use cssHook if its there - use .style if its</span></div>
<div class="line">            <span class="comment">// available and use plain properties where available</span></div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.fx.step[ tween.prop ] ) {</div>
<div class="line">                jQuery.fx.step[ tween.prop ]( tween );</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {</div>
<div class="line">                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                tween.elem[ tween.prop ] = tween.now;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE9</span></div>
<div class="line"><span class="comment">// Panic based approach to setting things on disconnected nodes</span></div>
<div class="line"></div>
<div class="line">Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {</div>
<div class="line">    set: <span class="keyword">function</span>( tween ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {</div>
<div class="line">            tween.elem[ tween.prop ] = tween.now;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.easing = {</div>
<div class="line">    linear: <span class="keyword">function</span>( p ) {</div>
<div class="line">        <span class="keywordflow">return</span> p;</div>
<div class="line">    },</div>
<div class="line">    swing: <span class="keyword">function</span>( p ) {</div>
<div class="line">        <span class="keywordflow">return</span> 0.5 - Math.cos( p * Math.PI ) / 2;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fx = Tween.prototype.init;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Back Compat &lt;1.8 extension point</span></div>
<div class="line">jQuery.fx.step = {};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    fxNow, timerId,</div>
<div class="line">    rfxtypes = /^(?:toggle|show|hide)$/,</div>
<div class="line">    rfxnum = <span class="keyword">new</span> RegExp( <span class="stringliteral">&quot;^(?:([+-])=|)(&quot;</span> + pnum + <span class="stringliteral">&quot;)([a-z%]*)$&quot;</span>, <span class="stringliteral">&quot;i&quot;</span> ),</div>
<div class="line">    rrun = /queueHooks$/,</div>
<div class="line">    animationPrefilters = [ defaultPrefilter ],</div>
<div class="line">    tweeners = {</div>
<div class="line">        <span class="stringliteral">&quot;*&quot;</span>: [ <span class="keyword">function</span>( prop, value ) {</div>
<div class="line">            var tween = this.createTween( prop, value ),</div>
<div class="line">                target = tween.cur(),</div>
<div class="line">                parts = rfxnum.exec( value ),</div>
<div class="line">                unit = parts &amp;&amp; parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;px&quot;</span> ),</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Starting value computation is required for potential unit mismatches</span></div>
<div class="line">                start = ( jQuery.cssNumber[ prop ] || unit !== <span class="stringliteral">&quot;px&quot;</span> &amp;&amp; +target ) &amp;&amp;</div>
<div class="line">                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),</div>
<div class="line">                scale = 1,</div>
<div class="line">                maxIterations = 20;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( start &amp;&amp; start[ 3 ] !== unit ) {</div>
<div class="line">                <span class="comment">// Trust units reported by jQuery.css</span></div>
<div class="line">                unit = unit || start[ 3 ];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Make sure we update the tween properties later on</span></div>
<div class="line">                parts = parts || [];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Iteratively approximate from a nonzero starting point</span></div>
<div class="line">                start = +target || 1;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">do</span> {</div>
<div class="line">                    <span class="comment">// If previous iteration zeroed out, double until we get *something*</span></div>
<div class="line">                    <span class="comment">// Use a string for doubling factor so we don&#39;t accidentally see scale as unchanged below</span></div>
<div class="line">                    scale = scale || <span class="stringliteral">&quot;.5&quot;</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Adjust and apply</span></div>
<div class="line">                    start = start / scale;</div>
<div class="line">                    jQuery.style( tween.elem, prop, start + unit );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Update scale, tolerating zero or NaN from tween.cur()</span></div>
<div class="line">                <span class="comment">// And breaking the loop if scale is unchanged or perfect, or if we&#39;ve just had enough</span></div>
<div class="line">                } <span class="keywordflow">while</span> ( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Update tween properties</span></div>
<div class="line">            <span class="keywordflow">if</span> ( parts ) {</div>
<div class="line">                start = tween.start = +start || +target || 0;</div>
<div class="line">                tween.unit = unit;</div>
<div class="line">                <span class="comment">// If a +=/-= token was provided, we&#39;re doing a relative animation</span></div>
<div class="line">                tween.end = parts[ 1 ] ?</div>
<div class="line">                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :</div>
<div class="line">                    +parts[ 2 ];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> tween;</div>
<div class="line">        } ]</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Animations created synchronously will run synchronously</span></div>
<div class="line"><span class="keyword">function</span> createFxNow() {</div>
<div class="line">    setTimeout(<span class="keyword">function</span>() {</div>
<div class="line">        fxNow = undefined;</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> ( fxNow = jQuery.now() );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate parameters to create a standard animation</span></div>
<div class="line"><span class="keyword">function</span> genFx( type, includeWidth ) {</div>
<div class="line">    var which,</div>
<div class="line">        i = 0,</div>
<div class="line">        attrs = { height: type };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if we include width, step value is 1 to do all cssExpand values,</span></div>
<div class="line">    <span class="comment">// if we don&#39;t include width, step value is 2 to skip over Left and Right</span></div>
<div class="line">    includeWidth = includeWidth ? 1 : 0;</div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; 4 ; i += 2 - includeWidth ) {</div>
<div class="line">        which = cssExpand[ i ];</div>
<div class="line">        attrs[ <span class="stringliteral">&quot;margin&quot;</span> + which ] = attrs[ <span class="stringliteral">&quot;padding&quot;</span> + which ] = type;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( includeWidth ) {</div>
<div class="line">        attrs.opacity = attrs.width = type;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> attrs;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createTween( value, prop, animation ) {</div>
<div class="line">    var tween,</div>
<div class="line">        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ <span class="stringliteral">&quot;*&quot;</span> ] ),</div>
<div class="line">        index = 0,</div>
<div class="line">        length = collection.length;</div>
<div class="line">    <span class="keywordflow">for</span> ( ; index &lt; length; index++ ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( (tween = collection[ index ].call( animation, prop, value )) ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// we&#39;re done with this property</span></div>
<div class="line">            <span class="keywordflow">return</span> tween;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> defaultPrefilter( elem, props, opts ) {</div>
<div class="line">    <span class="comment">/* jshint validthis: true */</span></div>
<div class="line">    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,</div>
<div class="line">        anim = <span class="keyword">this</span>,</div>
<div class="line">        orig = {},</div>
<div class="line">        style = elem.style,</div>
<div class="line">        hidden = elem.nodeType &amp;&amp; isHidden( elem ),</div>
<div class="line">        dataShow = data_priv.get( elem, <span class="stringliteral">&quot;fxshow&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle queue: false promises</span></div>
<div class="line">    <span class="keywordflow">if</span> ( !opts.queue ) {</div>
<div class="line">        hooks = jQuery._queueHooks( elem, <span class="stringliteral">&quot;fx&quot;</span> );</div>
<div class="line">        <span class="keywordflow">if</span> ( hooks.unqueued == null ) {</div>
<div class="line">            hooks.unqueued = 0;</div>
<div class="line">            oldfire = hooks.empty.fire;</div>
<div class="line">            hooks.empty.fire = <span class="keyword">function</span>() {</div>
<div class="line">                <span class="keywordflow">if</span> ( !hooks.unqueued ) {</div>
<div class="line">                    oldfire();</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line">        }</div>
<div class="line">        hooks.unqueued++;</div>
<div class="line"></div>
<div class="line">        anim.always(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="comment">// doing this makes sure that the complete handler will be called</span></div>
<div class="line">            <span class="comment">// before this completes</span></div>
<div class="line">            anim.always(<span class="keyword">function</span>() {</div>
<div class="line">                hooks.unqueued--;</div>
<div class="line">                <span class="keywordflow">if</span> ( !jQuery.queue( elem, <span class="stringliteral">&quot;fx&quot;</span> ).length ) {</div>
<div class="line">                    hooks.empty.fire();</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// height/width overflow pass</span></div>
<div class="line">    <span class="keywordflow">if</span> ( elem.nodeType === 1 &amp;&amp; ( <span class="stringliteral">&quot;height&quot;</span> in props || <span class="stringliteral">&quot;width&quot;</span> in props ) ) {</div>
<div class="line">        <span class="comment">// Make sure that nothing sneaks out</span></div>
<div class="line">        <span class="comment">// Record all 3 overflow attributes because IE9-10 do not</span></div>
<div class="line">        <span class="comment">// change the overflow attribute when overflowX and</span></div>
<div class="line">        <span class="comment">// overflowY are set to the same value</span></div>
<div class="line">        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set display property to inline-block for height/width</span></div>
<div class="line">        <span class="comment">// animations on inline elements that are having width/height animated</span></div>
<div class="line">        display = jQuery.css( elem, <span class="stringliteral">&quot;display&quot;</span> );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Test default display if display is currently &quot;none&quot;</span></div>
<div class="line">        checkDisplay = display === <span class="stringliteral">&quot;none&quot;</span> ?</div>
<div class="line">            data_priv.get( elem, <span class="stringliteral">&quot;olddisplay&quot;</span> ) || defaultDisplay( elem.nodeName ) : display;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( checkDisplay === <span class="stringliteral">&quot;inline&quot;</span> &amp;&amp; jQuery.css( elem, <span class="stringliteral">&quot;float&quot;</span> ) === <span class="stringliteral">&quot;none&quot;</span> ) {</div>
<div class="line">            style.display = <span class="stringliteral">&quot;inline-block&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( opts.overflow ) {</div>
<div class="line">        style.overflow = <span class="stringliteral">&quot;hidden&quot;</span>;</div>
<div class="line">        anim.always(<span class="keyword">function</span>() {</div>
<div class="line">            style.overflow = opts.overflow[ 0 ];</div>
<div class="line">            style.overflowX = opts.overflow[ 1 ];</div>
<div class="line">            style.overflowY = opts.overflow[ 2 ];</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// show/hide pass</span></div>
<div class="line">    <span class="keywordflow">for</span> ( prop in props ) {</div>
<div class="line">        value = props[ prop ];</div>
<div class="line">        <span class="keywordflow">if</span> ( rfxtypes.exec( value ) ) {</div>
<div class="line">            <span class="keyword">delete</span> props[ prop ];</div>
<div class="line">            toggle = toggle || value === <span class="stringliteral">&quot;toggle&quot;</span>;</div>
<div class="line">            <span class="keywordflow">if</span> ( value === ( hidden ? <span class="stringliteral">&quot;hide&quot;</span> : <span class="stringliteral">&quot;show&quot;</span> ) ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden</span></div>
<div class="line">                <span class="keywordflow">if</span> ( value === <span class="stringliteral">&quot;show&quot;</span> &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {</div>
<div class="line">                    hidden = <span class="keyword">true</span>;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Any non-fx value stops us from restoring the original display value</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            display = undefined;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !jQuery.isEmptyObject( orig ) ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( dataShow ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( <span class="stringliteral">&quot;hidden&quot;</span> in dataShow ) {</div>
<div class="line">                hidden = dataShow.hidden;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            dataShow = data_priv.access( elem, <span class="stringliteral">&quot;fxshow&quot;</span>, {} );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// store state if its toggle - enables .stop().toggle() to &quot;reverse&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> ( toggle ) {</div>
<div class="line">            dataShow.hidden = !hidden;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( hidden ) {</div>
<div class="line">            jQuery( elem ).show();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            anim.done(<span class="keyword">function</span>() {</div>
<div class="line">                jQuery( elem ).hide();</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">        anim.done(<span class="keyword">function</span>() {</div>
<div class="line">            var prop;</div>
<div class="line"></div>
<div class="line">            data_priv.remove( elem, <span class="stringliteral">&quot;fxshow&quot;</span> );</div>
<div class="line">            <span class="keywordflow">for</span> ( prop in orig ) {</div>
<div class="line">                jQuery.style( elem, prop, orig[ prop ] );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">for</span> ( prop in orig ) {</div>
<div class="line">            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( !( prop in dataShow ) ) {</div>
<div class="line">                dataShow[ prop ] = tween.start;</div>
<div class="line">                <span class="keywordflow">if</span> ( hidden ) {</div>
<div class="line">                    tween.end = tween.start;</div>
<div class="line">                    tween.start = prop === <span class="stringliteral">&quot;width&quot;</span> || prop === <span class="stringliteral">&quot;height&quot;</span> ? 1 : 0;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If this is a noop like .hide().hide(), restore an overwritten display value</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (display === <span class="stringliteral">&quot;none&quot;</span> ? defaultDisplay( elem.nodeName ) : display) === <span class="stringliteral">&quot;inline&quot;</span> ) {</div>
<div class="line">        style.display = display;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> propFilter( props, specialEasing ) {</div>
<div class="line">    var index, name, easing, value, hooks;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// camelCase, specialEasing and expand cssHook pass</span></div>
<div class="line">    <span class="keywordflow">for</span> ( index in props ) {</div>
<div class="line">        name = jQuery.camelCase( index );</div>
<div class="line">        easing = specialEasing[ name ];</div>
<div class="line">        value = props[ index ];</div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isArray( value ) ) {</div>
<div class="line">            easing = value[ 1 ];</div>
<div class="line">            value = props[ index ] = value[ 0 ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( index !== name ) {</div>
<div class="line">            props[ name ] = value;</div>
<div class="line">            <span class="keyword">delete</span> props[ index ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        hooks = jQuery.cssHooks[ name ];</div>
<div class="line">        <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;expand&quot;</span> in hooks ) {</div>
<div class="line">            value = hooks.expand( value );</div>
<div class="line">            <span class="keyword">delete</span> props[ name ];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// not quite $.extend, this wont overwrite keys already present.</span></div>
<div class="line">            <span class="comment">// also - reusing &#39;index&#39; from above because we have the correct &quot;name&quot;</span></div>
<div class="line">            <span class="keywordflow">for</span> ( index in value ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !( index in props ) ) {</div>
<div class="line">                    props[ index ] = value[ index ];</div>
<div class="line">                    specialEasing[ index ] = easing;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            specialEasing[ name ] = easing;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Animation( elem, properties, options ) {</div>
<div class="line">    var result,</div>
<div class="line">        stopped,</div>
<div class="line">        index = 0,</div>
<div class="line">        length = animationPrefilters.length,</div>
<div class="line">        deferred = jQuery.Deferred().always( <span class="keyword">function</span>() {</div>
<div class="line">            <span class="comment">// don&#39;t match elem in the :animated selector</span></div>
<div class="line">            <span class="keyword">delete</span> tick.elem;</div>
<div class="line">        }),</div>
<div class="line">        tick = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( stopped ) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">            var currentTime = fxNow || createFxNow(),</div>
<div class="line">                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),</div>
<div class="line">                <span class="comment">// archaic crash bug won&#39;t allow us to use 1 - ( 0.5 || 0 ) (#12497)</span></div>
<div class="line">                temp = remaining / animation.duration || 0,</div>
<div class="line">                percent = 1 - temp,</div>
<div class="line">                index = 0,</div>
<div class="line">                length = animation.tweens.length;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( ; index &lt; length ; index++ ) {</div>
<div class="line">                animation.tweens[ index ].run( percent );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            deferred.notifyWith( elem, [ animation, percent, remaining ]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( percent &lt; 1 &amp;&amp; length ) {</div>
<div class="line">                <span class="keywordflow">return</span> remaining;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                deferred.resolveWith( elem, [ animation ] );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        animation = deferred.promise({</div>
<div class="line">            elem: elem,</div>
<div class="line">            props: jQuery.extend( {}, properties ),</div>
<div class="line">            opts: jQuery.extend( <span class="keyword">true</span>, { specialEasing: {} }, options ),</div>
<div class="line">            originalProperties: properties,</div>
<div class="line">            originalOptions: options,</div>
<div class="line">            startTime: fxNow || createFxNow(),</div>
<div class="line">            duration: options.duration,</div>
<div class="line">            tweens: [],</div>
<div class="line">            createTween: <span class="keyword">function</span>( prop, end ) {</div>
<div class="line">                var tween = jQuery.Tween( elem, animation.opts, prop, end,</div>
<div class="line">                        animation.opts.specialEasing[ prop ] || animation.opts.easing );</div>
<div class="line">                animation.tweens.push( tween );</div>
<div class="line">                <span class="keywordflow">return</span> tween;</div>
<div class="line">            },</div>
<div class="line">            stop: <span class="keyword">function</span>( gotoEnd ) {</div>
<div class="line">                var index = 0,</div>
<div class="line">                    <span class="comment">// if we are going to the end, we want to run all the tweens</span></div>
<div class="line">                    <span class="comment">// otherwise we skip this part</span></div>
<div class="line">                    length = gotoEnd ? animation.tweens.length : 0;</div>
<div class="line">                <span class="keywordflow">if</span> ( stopped ) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                }</div>
<div class="line">                stopped = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">for</span> ( ; index &lt; length ; index++ ) {</div>
<div class="line">                    animation.tweens[ index ].run( 1 );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// resolve when we played the last frame</span></div>
<div class="line">                <span class="comment">// otherwise, reject</span></div>
<div class="line">                <span class="keywordflow">if</span> ( gotoEnd ) {</div>
<div class="line">                    deferred.resolveWith( elem, [ animation, gotoEnd ] );</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    deferred.rejectWith( elem, [ animation, gotoEnd ] );</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">            }</div>
<div class="line">        }),</div>
<div class="line">        props = animation.props;</div>
<div class="line"></div>
<div class="line">    propFilter( props, animation.opts.specialEasing );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; index &lt; length ; index++ ) {</div>
<div class="line">        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );</div>
<div class="line">        <span class="keywordflow">if</span> ( result ) {</div>
<div class="line">            <span class="keywordflow">return</span> result;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    jQuery.map( props, createTween, animation );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.isFunction( animation.opts.start ) ) {</div>
<div class="line">        animation.opts.start.call( elem, animation );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    jQuery.fx.timer(</div>
<div class="line">        jQuery.extend( tick, {</div>
<div class="line">            elem: elem,</div>
<div class="line">            anim: animation,</div>
<div class="line">            queue: animation.opts.queue</div>
<div class="line">        })</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// attach callbacks from options</span></div>
<div class="line">    <span class="keywordflow">return</span> animation.progress( animation.opts.progress )</div>
<div class="line">        .done( animation.opts.done, animation.opts.complete )</div>
<div class="line">        .fail( animation.opts.fail )</div>
<div class="line">        .always( animation.opts.always );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.Animation = jQuery.extend( Animation, {</div>
<div class="line"></div>
<div class="line">    tweener: <span class="keyword">function</span>( props, callback ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( props ) ) {</div>
<div class="line">            callback = props;</div>
<div class="line">            props = [ <span class="stringliteral">&quot;*&quot;</span> ];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            props = props.split(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var prop,</div>
<div class="line">            index = 0,</div>
<div class="line">            length = props.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> ( ; index &lt; length ; index++ ) {</div>
<div class="line">            prop = props[ index ];</div>
<div class="line">            tweeners[ prop ] = tweeners[ prop ] || [];</div>
<div class="line">            tweeners[ prop ].unshift( callback );</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    prefilter: <span class="keyword">function</span>( callback, prepend ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( prepend ) {</div>
<div class="line">            animationPrefilters.unshift( callback );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            animationPrefilters.push( callback );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.speed = <span class="keyword">function</span>( speed, easing, fn ) {</div>
<div class="line">    var opt = speed &amp;&amp; typeof speed === <span class="stringliteral">&quot;object&quot;</span> ? jQuery.extend( {}, speed ) : {</div>
<div class="line">        complete: fn || !fn &amp;&amp; easing ||</div>
<div class="line">            jQuery.isFunction( speed ) &amp;&amp; speed,</div>
<div class="line">        duration: speed,</div>
<div class="line">        easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === <span class="stringliteral">&quot;number&quot;</span> ? opt.duration :</div>
<div class="line">        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;</span></div>
<div class="line">    <span class="keywordflow">if</span> ( opt.queue == null || opt.queue === <span class="keyword">true</span> ) {</div>
<div class="line">        opt.queue = <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Queueing</span></div>
<div class="line">    opt.old = opt.complete;</div>
<div class="line"></div>
<div class="line">    opt.complete = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( opt.old ) ) {</div>
<div class="line">            opt.old.call( <span class="keyword">this</span> );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( opt.queue ) {</div>
<div class="line">            jQuery.dequeue( <span class="keyword">this</span>, opt.queue );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> opt;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    fadeTo: <span class="keyword">function</span>( speed, to, easing, callback ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// show any hidden elements after setting opacity to 0</span></div>
<div class="line">        <span class="keywordflow">return</span> this.filter( isHidden ).css( <span class="stringliteral">&quot;opacity&quot;</span>, 0 ).show()</div>
<div class="line"></div>
<div class="line">            <span class="comment">// animate to the value specified</span></div>
<div class="line">            .end().animate({ opacity: to }, speed, easing, callback );</div>
<div class="line">    },</div>
<div class="line">    animate: <span class="keyword">function</span>( prop, speed, easing, callback ) {</div>
<div class="line">        var empty = jQuery.isEmptyObject( prop ),</div>
<div class="line">            optall = jQuery.speed( speed, easing, callback ),</div>
<div class="line">            doAnimation = <span class="keyword">function</span>() {</div>
<div class="line">                <span class="comment">// Operate on a copy of prop so per-property easing won&#39;t be lost</span></div>
<div class="line">                var anim = Animation( <span class="keyword">this</span>, jQuery.extend( {}, prop ), optall );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Empty animations, or finishing resolves immediately</span></div>
<div class="line">                <span class="keywordflow">if</span> ( empty || data_priv.get( <span class="keyword">this</span>, <span class="stringliteral">&quot;finish&quot;</span> ) ) {</div>
<div class="line">                    anim.stop( <span class="keyword">true</span> );</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line">            doAnimation.finish = doAnimation;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> empty || optall.queue === <span class="keyword">false</span> ?</div>
<div class="line">            this.each( doAnimation ) :</div>
<div class="line">            this.queue( optall.queue, doAnimation );</div>
<div class="line">    },</div>
<div class="line">    stop: <span class="keyword">function</span>( type, clearQueue, gotoEnd ) {</div>
<div class="line">        var stopQueue = <span class="keyword">function</span>( hooks ) {</div>
<div class="line">            var stop = hooks.stop;</div>
<div class="line">            <span class="keyword">delete</span> hooks.stop;</div>
<div class="line">            stop( gotoEnd );</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof type !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            gotoEnd = clearQueue;</div>
<div class="line">            clearQueue = type;</div>
<div class="line">            type = undefined;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( clearQueue &amp;&amp; type !== <span class="keyword">false</span> ) {</div>
<div class="line">            this.queue( type || <span class="stringliteral">&quot;fx&quot;</span>, [] );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            var dequeue = <span class="keyword">true</span>,</div>
<div class="line">                index = type != null &amp;&amp; type + <span class="stringliteral">&quot;queueHooks&quot;</span>,</div>
<div class="line">                timers = jQuery.timers,</div>
<div class="line">                data = data_priv.get( <span class="keyword">this</span> );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( index ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( data[ index ] &amp;&amp; data[ index ].stop ) {</div>
<div class="line">                    stopQueue( data[ index ] );</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">for</span> ( index in data ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {</div>
<div class="line">                        stopQueue( data[ index ] );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( index = timers.length; index--; ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( timers[ index ].elem === <span class="keyword">this</span> &amp;&amp; (type == null || timers[ index ].queue === type) ) {</div>
<div class="line">                    timers[ index ].anim.stop( gotoEnd );</div>
<div class="line">                    dequeue = <span class="keyword">false</span>;</div>
<div class="line">                    timers.splice( index, 1 );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// start the next in the queue if the last step wasn&#39;t forced</span></div>
<div class="line">            <span class="comment">// timers currently will call their complete callbacks, which will dequeue</span></div>
<div class="line">            <span class="comment">// but only if they were gotoEnd</span></div>
<div class="line">            <span class="keywordflow">if</span> ( dequeue || !gotoEnd ) {</div>
<div class="line">                jQuery.dequeue( <span class="keyword">this</span>, type );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line">    finish: <span class="keyword">function</span>( type ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( type !== <span class="keyword">false</span> ) {</div>
<div class="line">            type = type || <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            var index,</div>
<div class="line">                data = data_priv.get( <span class="keyword">this</span> ),</div>
<div class="line">                queue = data[ type + <span class="stringliteral">&quot;queue&quot;</span> ],</div>
<div class="line">                hooks = data[ type + <span class="stringliteral">&quot;queueHooks&quot;</span> ],</div>
<div class="line">                timers = jQuery.timers,</div>
<div class="line">                length = queue ? queue.length : 0;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// enable finishing flag on private data</span></div>
<div class="line">            data.finish = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// empty the queue first</span></div>
<div class="line">            jQuery.queue( <span class="keyword">this</span>, type, [] );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( hooks &amp;&amp; hooks.stop ) {</div>
<div class="line">                hooks.stop.call( <span class="keyword">this</span>, <span class="keyword">true</span> );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// look for any active animations, and finish them</span></div>
<div class="line">            <span class="keywordflow">for</span> ( index = timers.length; index--; ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( timers[ index ].elem === <span class="keyword">this</span> &amp;&amp; timers[ index ].queue === type ) {</div>
<div class="line">                    timers[ index ].anim.stop( <span class="keyword">true</span> );</div>
<div class="line">                    timers.splice( index, 1 );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// look for any animations in the old queue and finish them</span></div>
<div class="line">            <span class="keywordflow">for</span> ( index = 0; index &lt; length; index++ ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( queue[ index ] &amp;&amp; queue[ index ].finish ) {</div>
<div class="line">                    queue[ index ].finish.call( <span class="keyword">this</span> );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// turn off finishing flag</span></div>
<div class="line">            <span class="keyword">delete</span> data.finish;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.each([ <span class="stringliteral">&quot;toggle&quot;</span>, <span class="stringliteral">&quot;show&quot;</span>, <span class="stringliteral">&quot;hide&quot;</span> ], <span class="keyword">function</span>( i, name ) {</div>
<div class="line">    var cssFn = jQuery.fn[ name ];</div>
<div class="line">    jQuery.fn[ name ] = <span class="keyword">function</span>( speed, easing, callback ) {</div>
<div class="line">        <span class="keywordflow">return</span> speed == null || typeof speed === <span class="stringliteral">&quot;boolean&quot;</span> ?</div>
<div class="line">            cssFn.apply( <span class="keyword">this</span>, arguments ) :</div>
<div class="line">            this.animate( genFx( name, <span class="keyword">true</span> ), speed, easing, callback );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate shortcuts for custom animations</span></div>
<div class="line">jQuery.each({</div>
<div class="line">    slideDown: genFx(<span class="stringliteral">&quot;show&quot;</span>),</div>
<div class="line">    slideUp: genFx(<span class="stringliteral">&quot;hide&quot;</span>),</div>
<div class="line">    slideToggle: genFx(<span class="stringliteral">&quot;toggle&quot;</span>),</div>
<div class="line">    fadeIn: { opacity: <span class="stringliteral">&quot;show&quot;</span> },</div>
<div class="line">    fadeOut: { opacity: <span class="stringliteral">&quot;hide&quot;</span> },</div>
<div class="line">    fadeToggle: { opacity: <span class="stringliteral">&quot;toggle&quot;</span> }</div>
<div class="line">}, <span class="keyword">function</span>( name, props ) {</div>
<div class="line">    jQuery.fn[ name ] = <span class="keyword">function</span>( speed, easing, callback ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.animate( props, speed, easing, callback );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.timers = [];</div>
<div class="line">jQuery.fx.tick = <span class="keyword">function</span>() {</div>
<div class="line">    var timer,</div>
<div class="line">        i = 0,</div>
<div class="line">        timers = jQuery.timers;</div>
<div class="line"></div>
<div class="line">    fxNow = jQuery.now();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( ; i &lt; timers.length; i++ ) {</div>
<div class="line">        timer = timers[ i ];</div>
<div class="line">        <span class="comment">// Checks the timer has not already been removed</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !timer() &amp;&amp; timers[ i ] === timer ) {</div>
<div class="line">            timers.splice( i--, 1 );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !timers.length ) {</div>
<div class="line">        jQuery.fx.stop();</div>
<div class="line">    }</div>
<div class="line">    fxNow = undefined;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fx.timer = <span class="keyword">function</span>( timer ) {</div>
<div class="line">    jQuery.timers.push( timer );</div>
<div class="line">    <span class="keywordflow">if</span> ( timer() ) {</div>
<div class="line">        jQuery.fx.start();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        jQuery.timers.pop();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fx.interval = 13;</div>
<div class="line"></div>
<div class="line">jQuery.fx.start = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> ( !timerId ) {</div>
<div class="line">        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fx.stop = <span class="keyword">function</span>() {</div>
<div class="line">    clearInterval( timerId );</div>
<div class="line">    timerId = null;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fx.speeds = {</div>
<div class="line">    slow: 600,</div>
<div class="line">    fast: 200,</div>
<div class="line">    <span class="comment">// Default speed</span></div>
<div class="line">    _default: 400</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Based off of the plugin by Clint Helfers, with permission.</span></div>
<div class="line"><span class="comment">// http://blindsignals.com/index.php/2009/07/jquery-delay/</span></div>
<div class="line">jQuery.fn.delay = <span class="keyword">function</span>( time, type ) {</div>
<div class="line">    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;</div>
<div class="line">    type = type || <span class="stringliteral">&quot;fx&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> this.queue( type, <span class="keyword">function</span>( next, hooks ) {</div>
<div class="line">        var timeout = setTimeout( next, time );</div>
<div class="line">        hooks.stop = <span class="keyword">function</span>() {</div>
<div class="line">            clearTimeout( timeout );</div>
<div class="line">        };</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>() {</div>
<div class="line">    var input = document.createElement( <span class="stringliteral">&quot;input&quot;</span> ),</div>
<div class="line">        select = document.createElement( <span class="stringliteral">&quot;select&quot;</span> ),</div>
<div class="line">        opt = select.appendChild( document.createElement( <span class="stringliteral">&quot;option&quot;</span> ) );</div>
<div class="line"></div>
<div class="line">    input.type = <span class="stringliteral">&quot;checkbox&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: iOS 5.1, Android 4.x, Android 2.3</span></div>
<div class="line">    <span class="comment">// Check the default checkbox/radio value (&quot;&quot; on old WebKit; &quot;on&quot; elsewhere)</span></div>
<div class="line">    support.checkOn = input.value !== <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Must access the parent to make an option select properly</span></div>
<div class="line">    <span class="comment">// Support: IE9, IE10</span></div>
<div class="line">    support.optSelected = opt.selected;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Make sure that the options inside disabled selects aren&#39;t marked as disabled</span></div>
<div class="line">    <span class="comment">// (WebKit marks them as disabled)</span></div>
<div class="line">    select.disabled = <span class="keyword">true</span>;</div>
<div class="line">    support.optDisabled = !opt.disabled;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if an input maintains its value after becoming a radio</span></div>
<div class="line">    <span class="comment">// Support: IE9, IE10</span></div>
<div class="line">    input = document.createElement( <span class="stringliteral">&quot;input&quot;</span> );</div>
<div class="line">    input.value = <span class="stringliteral">&quot;t&quot;</span>;</div>
<div class="line">    input.type = <span class="stringliteral">&quot;radio&quot;</span>;</div>
<div class="line">    support.radioValue = input.value === <span class="stringliteral">&quot;t&quot;</span>;</div>
<div class="line">})();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var nodeHook, boolHook,</div>
<div class="line">    attrHandle = jQuery.expr.attrHandle;</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    attr: <span class="keyword">function</span>( name, value ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, jQuery.attr, name, value, arguments.length &gt; 1 );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeAttr: <span class="keyword">function</span>( name ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            jQuery.removeAttr( <span class="keyword">this</span>, name );</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    attr: <span class="keyword">function</span>( elem, name, value ) {</div>
<div class="line">        var hooks, ret,</div>
<div class="line">            nType = elem.nodeType;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// don&#39;t get/set attributes on text, comment and attribute nodes</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !elem || nType === 3 || nType === 8 || nType === 2 ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Fallback to prop when attributes are not supported</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof elem.getAttribute === strundefined ) {</div>
<div class="line">            <span class="keywordflow">return</span> jQuery.prop( elem, name, value );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// All attributes are lowercase</span></div>
<div class="line">        <span class="comment">// Grab necessary hook if one is defined</span></div>
<div class="line">        <span class="keywordflow">if</span> ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {</div>
<div class="line">            name = name.toLowerCase();</div>
<div class="line">            hooks = jQuery.attrHooks[ name ] ||</div>
<div class="line">                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( value !== undefined ) {</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( value === null ) {</div>
<div class="line">                jQuery.removeAttr( elem, name );</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;set&quot;</span> in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {</div>
<div class="line">                <span class="keywordflow">return</span> ret;</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                elem.setAttribute( name, value + <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">                <span class="keywordflow">return</span> value;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;get&quot;</span> in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {</div>
<div class="line">            <span class="keywordflow">return</span> ret;</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            ret = jQuery.find.attr( elem, name );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Non-existent attributes return null, we normalize to undefined</span></div>
<div class="line">            <span class="keywordflow">return</span> ret == null ?</div>
<div class="line">                undefined :</div>
<div class="line">                ret;</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeAttr: <span class="keyword">function</span>( elem, value ) {</div>
<div class="line">        var name, propName,</div>
<div class="line">            i = 0,</div>
<div class="line">            attrNames = value &amp;&amp; value.match( rnotwhite );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( attrNames &amp;&amp; elem.nodeType === 1 ) {</div>
<div class="line">            <span class="keywordflow">while</span> ( (name = attrNames[i++]) ) {</div>
<div class="line">                propName = jQuery.propFix[ name ] || name;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Boolean attributes get special treatment (#10870)</span></div>
<div class="line">                <span class="keywordflow">if</span> ( jQuery.expr.match.bool.test( name ) ) {</div>
<div class="line">                    <span class="comment">// Set corresponding property to false</span></div>
<div class="line">                    elem[ propName ] = <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                elem.removeAttribute( name );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    attrHooks: {</div>
<div class="line">        type: {</div>
<div class="line">            set: <span class="keyword">function</span>( elem, value ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( !support.radioValue &amp;&amp; value === <span class="stringliteral">&quot;radio&quot;</span> &amp;&amp;</div>
<div class="line">                    jQuery.nodeName( elem, <span class="stringliteral">&quot;input&quot;</span> ) ) {</div>
<div class="line">                    <span class="comment">// Setting the type on a radio button after the value resets the value in IE6-9</span></div>
<div class="line">                    <span class="comment">// Reset value to default in case type is set after value during creation</span></div>
<div class="line">                    var val = elem.value;</div>
<div class="line">                    elem.setAttribute( <span class="stringliteral">&quot;type&quot;</span>, value );</div>
<div class="line">                    <span class="keywordflow">if</span> ( val ) {</div>
<div class="line">                        elem.value = val;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">return</span> value;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Hooks for boolean attributes</span></div>
<div class="line">boolHook = {</div>
<div class="line">    set: <span class="keyword">function</span>( elem, value, name ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( value === <span class="keyword">false</span> ) {</div>
<div class="line">            <span class="comment">// Remove boolean attributes when set to false</span></div>
<div class="line">            jQuery.removeAttr( elem, name );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            elem.setAttribute( name, name );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> name;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), <span class="keyword">function</span>( i, name ) {</div>
<div class="line">    var getter = attrHandle[ name ] || jQuery.find.attr;</div>
<div class="line"></div>
<div class="line">    attrHandle[ name ] = <span class="keyword">function</span>( elem, name, isXML ) {</div>
<div class="line">        var ret, handle;</div>
<div class="line">        <span class="keywordflow">if</span> ( !isXML ) {</div>
<div class="line">            <span class="comment">// Avoid an infinite loop by temporarily removing this function from the getter</span></div>
<div class="line">            handle = attrHandle[ name ];</div>
<div class="line">            attrHandle[ name ] = ret;</div>
<div class="line">            ret = getter( elem, name, isXML ) != null ?</div>
<div class="line">                name.toLowerCase() :</div>
<div class="line">                null;</div>
<div class="line">            attrHandle[ name ] = handle;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var rfocusable = /^(?:input|select|textarea|button)$/i;</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    prop: <span class="keyword">function</span>( name, value ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, jQuery.prop, name, value, arguments.length &gt; 1 );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeProp: <span class="keyword">function</span>( name ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>[ jQuery.propFix[ name ] || name ];</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    propFix: {</div>
<div class="line">        <span class="stringliteral">&quot;for&quot;</span>: <span class="stringliteral">&quot;htmlFor&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;class&quot;</span>: <span class="stringliteral">&quot;className&quot;</span></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    prop: <span class="keyword">function</span>( elem, name, value ) {</div>
<div class="line">        var ret, hooks, notxml,</div>
<div class="line">            nType = elem.nodeType;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// don&#39;t get/set properties on text, comment and attribute nodes</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !elem || nType === 3 || nType === 8 || nType === 2 ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( notxml ) {</div>
<div class="line">            <span class="comment">// Fix name and attach hooks</span></div>
<div class="line">            name = jQuery.propFix[ name ] || name;</div>
<div class="line">            hooks = jQuery.propHooks[ name ];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( value !== undefined ) {</div>
<div class="line">            <span class="keywordflow">return</span> hooks &amp;&amp; <span class="stringliteral">&quot;set&quot;</span> in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ?</div>
<div class="line">                ret :</div>
<div class="line">                ( elem[ name ] = value );</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> hooks &amp;&amp; <span class="stringliteral">&quot;get&quot;</span> in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ?</div>
<div class="line">                ret :</div>
<div class="line">                elem[ name ];</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    propHooks: {</div>
<div class="line">        tabIndex: {</div>
<div class="line">            <span class="keyword">get</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">                <span class="keywordflow">return</span> elem.hasAttribute( <span class="stringliteral">&quot;tabindex&quot;</span> ) || rfocusable.test( elem.nodeName ) || elem.href ?</div>
<div class="line">                    elem.tabIndex :</div>
<div class="line">                    -1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE9+</span></div>
<div class="line"><span class="comment">// Selectedness for an option in an optgroup can be inaccurate</span></div>
<div class="line"><span class="keywordflow">if</span> ( !support.optSelected ) {</div>
<div class="line">    jQuery.propHooks.selected = {</div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">            var parent = elem.parentNode;</div>
<div class="line">            <span class="keywordflow">if</span> ( parent &amp;&amp; parent.parentNode ) {</div>
<div class="line">                parent.parentNode.selectedIndex;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> null;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.each([</div>
<div class="line">    <span class="stringliteral">&quot;tabIndex&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;readOnly&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;maxLength&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;cellSpacing&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;cellPadding&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;rowSpan&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;colSpan&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;useMap&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;frameBorder&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;contentEditable&quot;</span></div>
<div class="line">], <span class="keyword">function</span>() {</div>
<div class="line">    jQuery.propFix[ this.toLowerCase() ] = <span class="keyword">this</span>;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var rclass = /[\t\r\n\f]/g;</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    addClass: <span class="keyword">function</span>( value ) {</div>
<div class="line">        var classes, elem, cur, clazz, j, finalValue,</div>
<div class="line">            proceed = typeof value === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; value,</div>
<div class="line">            i = 0,</div>
<div class="line">            len = this.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( value ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( j ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).addClass( value.call( <span class="keyword">this</span>, j, <span class="keyword">this</span>.className ) );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( proceed ) {</div>
<div class="line">            <span class="comment">// The disjunction here is for better compressibility (see removeClass)</span></div>
<div class="line">            classes = ( value || <span class="stringliteral">&quot;&quot;</span> ).match( rnotwhite ) || [];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">                elem = <span class="keyword">this</span>[ i ];</div>
<div class="line">                cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?</div>
<div class="line">                    ( <span class="stringliteral">&quot; &quot;</span> + elem.className + <span class="stringliteral">&quot; &quot;</span> ).replace( rclass, <span class="stringliteral">&quot; &quot;</span> ) :</div>
<div class="line">                    <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">                );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( cur ) {</div>
<div class="line">                    j = 0;</div>
<div class="line">                    <span class="keywordflow">while</span> ( (clazz = classes[j++]) ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( cur.indexOf( <span class="stringliteral">&quot; &quot;</span> + clazz + <span class="stringliteral">&quot; &quot;</span> ) &lt; 0 ) {</div>
<div class="line">                            cur += clazz + <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// only assign if different to avoid unneeded rendering.</span></div>
<div class="line">                    finalValue = jQuery.trim( cur );</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.className !== finalValue ) {</div>
<div class="line">                        elem.className = finalValue;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    removeClass: <span class="keyword">function</span>( value ) {</div>
<div class="line">        var classes, elem, cur, clazz, j, finalValue,</div>
<div class="line">            proceed = arguments.length === 0 || typeof value === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; value,</div>
<div class="line">            i = 0,</div>
<div class="line">            len = this.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( value ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( j ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).removeClass( value.call( <span class="keyword">this</span>, j, <span class="keyword">this</span>.className ) );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( proceed ) {</div>
<div class="line">            classes = ( value || <span class="stringliteral">&quot;&quot;</span> ).match( rnotwhite ) || [];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> ( ; i &lt; len; i++ ) {</div>
<div class="line">                elem = <span class="keyword">this</span>[ i ];</div>
<div class="line">                <span class="comment">// This expression is here for better compressibility (see addClass)</span></div>
<div class="line">                cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?</div>
<div class="line">                    ( <span class="stringliteral">&quot; &quot;</span> + elem.className + <span class="stringliteral">&quot; &quot;</span> ).replace( rclass, <span class="stringliteral">&quot; &quot;</span> ) :</div>
<div class="line">                    <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">                );</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( cur ) {</div>
<div class="line">                    j = 0;</div>
<div class="line">                    <span class="keywordflow">while</span> ( (clazz = classes[j++]) ) {</div>
<div class="line">                        <span class="comment">// Remove *all* instances</span></div>
<div class="line">                        <span class="keywordflow">while</span> ( cur.indexOf( <span class="stringliteral">&quot; &quot;</span> + clazz + <span class="stringliteral">&quot; &quot;</span> ) &gt;= 0 ) {</div>
<div class="line">                            cur = cur.replace( <span class="stringliteral">&quot; &quot;</span> + clazz + <span class="stringliteral">&quot; &quot;</span>, <span class="stringliteral">&quot; &quot;</span> );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// only assign if different to avoid unneeded rendering.</span></div>
<div class="line">                    finalValue = value ? jQuery.trim( cur ) : <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">if</span> ( elem.className !== finalValue ) {</div>
<div class="line">                        elem.className = finalValue;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    toggleClass: <span class="keyword">function</span>( value, stateVal ) {</div>
<div class="line">        var type = typeof value;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof stateVal === <span class="stringliteral">&quot;boolean&quot;</span> &amp;&amp; type === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            <span class="keywordflow">return</span> stateVal ? this.addClass( value ) : this.removeClass( value );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( value ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).toggleClass( value.call(<span class="keyword">this</span>, i, <span class="keyword">this</span>.className, stateVal), stateVal );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( type === <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">                <span class="comment">// toggle individual class names</span></div>
<div class="line">                var className,</div>
<div class="line">                    i = 0,</div>
<div class="line">                    <span class="keyword">self</span> = jQuery( <span class="keyword">this</span> ),</div>
<div class="line">                    classNames = value.match( rnotwhite ) || [];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">while</span> ( (className = classNames[ i++ ]) ) {</div>
<div class="line">                    <span class="comment">// check each className given, space separated list</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( <span class="keyword">self</span>.hasClass( className ) ) {</div>
<div class="line">                        <span class="keyword">self</span>.removeClass( className );</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        <span class="keyword">self</span>.addClass( className );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Toggle whole class name</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( type === strundefined || type === <span class="stringliteral">&quot;boolean&quot;</span> ) {</div>
<div class="line">                <span class="keywordflow">if</span> ( this.className ) {</div>
<div class="line">                    <span class="comment">// store className if set</span></div>
<div class="line">                    data_priv.set( <span class="keyword">this</span>, <span class="stringliteral">&quot;__className__&quot;</span>, this.className );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If the element has a class name or if we&#39;re passed &quot;false&quot;,</span></div>
<div class="line">                <span class="comment">// then remove the whole classname (if there was one, the above saved it).</span></div>
<div class="line">                <span class="comment">// Otherwise bring back whatever was previously saved (if anything),</span></div>
<div class="line">                <span class="comment">// falling back to the empty string if nothing was stored.</span></div>
<div class="line">                this.className = this.className || value === <span class="keyword">false</span> ? <span class="stringliteral">&quot;&quot;</span> : data_priv.get( <span class="keyword">this</span>, <span class="stringliteral">&quot;__className__&quot;</span> ) || <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    hasClass: <span class="keyword">function</span>( selector ) {</div>
<div class="line">        var className = <span class="stringliteral">&quot; &quot;</span> + selector + <span class="stringliteral">&quot; &quot;</span>,</div>
<div class="line">            i = 0,</div>
<div class="line">            l = this.length;</div>
<div class="line">        <span class="keywordflow">for</span> ( ; i &lt; l; i++ ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( <span class="keyword">this</span>[i].nodeType === 1 &amp;&amp; (<span class="stringliteral">&quot; &quot;</span> + <span class="keyword">this</span>[i].className + <span class="stringliteral">&quot; &quot;</span>).replace(rclass, <span class="stringliteral">&quot; &quot;</span>).indexOf( className ) &gt;= 0 ) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var rreturn = /\r/g;</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    val: <span class="keyword">function</span>( value ) {</div>
<div class="line">        var hooks, ret, isFunction,</div>
<div class="line">            elem = <span class="keyword">this</span>[0];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !arguments.length ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( elem ) {</div>
<div class="line">                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( hooks &amp;&amp; <span class="stringliteral">&quot;get&quot;</span> in hooks &amp;&amp; (ret = hooks.get( elem, <span class="stringliteral">&quot;value&quot;</span> )) !== undefined ) {</div>
<div class="line">                    <span class="keywordflow">return</span> ret;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ret = elem.value;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> typeof ret === <span class="stringliteral">&quot;string&quot;</span> ?</div>
<div class="line">                    <span class="comment">// handle most common string cases</span></div>
<div class="line">                    ret.replace(rreturn, <span class="stringliteral">&quot;&quot;</span>) :</div>
<div class="line">                    <span class="comment">// handle cases where value is null/undef or number</span></div>
<div class="line">                    ret == null ? <span class="stringliteral">&quot;&quot;</span> : ret;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        isFunction = jQuery.isFunction( value );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">            var val;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( this.nodeType !== 1 ) {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( isFunction ) {</div>
<div class="line">                val = value.call( <span class="keyword">this</span>, i, jQuery( <span class="keyword">this</span> ).val() );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                val = value;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Treat null/undefined as &quot;&quot;; convert numbers to string</span></div>
<div class="line">            <span class="keywordflow">if</span> ( val == null ) {</div>
<div class="line">                val = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( typeof val === <span class="stringliteral">&quot;number&quot;</span> ) {</div>
<div class="line">                val += <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( jQuery.isArray( val ) ) {</div>
<div class="line">                val = jQuery.map( val, <span class="keyword">function</span>( value ) {</div>
<div class="line">                    <span class="keywordflow">return</span> value == null ? <span class="stringliteral">&quot;&quot;</span> : value + <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If set returns undefined, fall back to normal setting</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !hooks || !(<span class="stringliteral">&quot;set&quot;</span> in hooks) || hooks.set( <span class="keyword">this</span>, val, <span class="stringliteral">&quot;value&quot;</span> ) === undefined ) {</div>
<div class="line">                this.value = val;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line">    valHooks: {</div>
<div class="line">        option: {</div>
<div class="line">            <span class="keyword">get</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">                var val = jQuery.find.attr( elem, <span class="stringliteral">&quot;value&quot;</span> );</div>
<div class="line">                <span class="keywordflow">return</span> val != null ?</div>
<div class="line">                    val :</div>
<div class="line">                    <span class="comment">// Support: IE10-11+</span></div>
<div class="line">                    <span class="comment">// option.text throws exceptions (#14686, #14858)</span></div>
<div class="line">                    jQuery.trim( jQuery.text( elem ) );</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        select: {</div>
<div class="line">            <span class="keyword">get</span>: <span class="keyword">function</span>( elem ) {</div>
<div class="line">                var value, option,</div>
<div class="line">                    options = elem.options,</div>
<div class="line">                    index = elem.selectedIndex,</div>
<div class="line">                    one = elem.type === <span class="stringliteral">&quot;select-one&quot;</span> || index &lt; 0,</div>
<div class="line">                    values = one ? null : [],</div>
<div class="line">                    max = one ? index + 1 : options.length,</div>
<div class="line">                    i = index &lt; 0 ?</div>
<div class="line">                        max :</div>
<div class="line">                        one ? index : 0;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Loop through all the selected options</span></div>
<div class="line">                <span class="keywordflow">for</span> ( ; i &lt; max; i++ ) {</div>
<div class="line">                    option = options[ i ];</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// IE6-9 doesn&#39;t update selected after form reset (#2551)</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( ( option.selected || i === index ) &amp;&amp;</div>
<div class="line">                            <span class="comment">// Don&#39;t return options that are disabled or in a disabled optgroup</span></div>
<div class="line">                            ( support.optDisabled ? !option.disabled : option.getAttribute( <span class="stringliteral">&quot;disabled&quot;</span> ) === null ) &amp;&amp;</div>
<div class="line">                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, <span class="stringliteral">&quot;optgroup&quot;</span> ) ) ) {</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Get the specific value for the option</span></div>
<div class="line">                        value = jQuery( option ).val();</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// We don&#39;t need an array for one selects</span></div>
<div class="line">                        <span class="keywordflow">if</span> ( one ) {</div>
<div class="line">                            <span class="keywordflow">return</span> value;</div>
<div class="line">                        }</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Multi-Selects return an array</span></div>
<div class="line">                        values.push( value );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> values;</div>
<div class="line">            },</div>
<div class="line"></div>
<div class="line">            set: <span class="keyword">function</span>( elem, value ) {</div>
<div class="line">                var optionSet, option,</div>
<div class="line">                    options = elem.options,</div>
<div class="line">                    values = jQuery.makeArray( value ),</div>
<div class="line">                    i = options.length;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">while</span> ( i-- ) {</div>
<div class="line">                    option = options[ i ];</div>
<div class="line">                    <span class="keywordflow">if</span> ( (option.selected = jQuery.inArray( option.value, values ) &gt;= 0) ) {</div>
<div class="line">                        optionSet = <span class="keyword">true</span>;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// force browsers to behave consistently when non-matching value is set</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !optionSet ) {</div>
<div class="line">                    elem.selectedIndex = -1;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> values;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Radios and checkboxes getter/setter</span></div>
<div class="line">jQuery.each([ <span class="stringliteral">&quot;radio&quot;</span>, <span class="stringliteral">&quot;checkbox&quot;</span> ], <span class="keyword">function</span>() {</div>
<div class="line">    jQuery.valHooks[ this ] = {</div>
<div class="line">        set: <span class="keyword">function</span>( elem, value ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.isArray( value ) ) {</div>
<div class="line">                <span class="keywordflow">return</span> ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">if</span> ( !support.checkOn ) {</div>
<div class="line">        jQuery.valHooks[ this ].get = <span class="keyword">function</span>( elem ) {</div>
<div class="line">            <span class="comment">// Support: Webkit</span></div>
<div class="line">            <span class="comment">// &quot;&quot; is returned instead of &quot;on&quot; if a value isn&#39;t specified</span></div>
<div class="line">            <span class="keywordflow">return</span> elem.getAttribute(<span class="stringliteral">&quot;value&quot;</span>) === null ? <span class="stringliteral">&quot;on&quot;</span> : elem.value;</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return jQuery for attributes-only inclusion</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.each( (<span class="stringliteral">&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot;</span> +</div>
<div class="line">    <span class="stringliteral">&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot;</span> +</div>
<div class="line">    <span class="stringliteral">&quot;change select submit keydown keypress keyup error contextmenu&quot;</span>).split(<span class="stringliteral">&quot; &quot;</span>), <span class="keyword">function</span>( i, name ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle event binding</span></div>
<div class="line">    jQuery.fn[ name ] = <span class="keyword">function</span>( data, fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> arguments.length &gt; 0 ?</div>
<div class="line">            this.on( name, null, data, fn ) :</div>
<div class="line">            this.trigger( name );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    hover: <span class="keyword">function</span>( fnOver, fnOut ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    bind: <span class="keyword">function</span>( types, data, fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.on( types, null, data, fn );</div>
<div class="line">    },</div>
<div class="line">    unbind: <span class="keyword">function</span>( types, fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.off( types, null, fn );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    delegate: <span class="keyword">function</span>( selector, types, data, fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.on( types, selector, data, fn );</div>
<div class="line">    },</div>
<div class="line">    undelegate: <span class="keyword">function</span>( selector, types, fn ) {</div>
<div class="line">        <span class="comment">// ( namespace ) or ( selector, types [, fn] )</span></div>
<div class="line">        <span class="keywordflow">return</span> arguments.length === 1 ? this.off( selector, <span class="stringliteral">&quot;**&quot;</span> ) : this.off( types, selector || <span class="stringliteral">&quot;**&quot;</span>, fn );</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var nonce = jQuery.now();</div>
<div class="line"></div>
<div class="line">var rquery = (/\?/);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: Android 2.3</span></div>
<div class="line"><span class="comment">// Workaround failure to string-cast null input</span></div>
<div class="line">jQuery.parseJSON = <span class="keyword">function</span>( data ) {</div>
<div class="line">    <span class="keywordflow">return</span> JSON.parse( data + <span class="stringliteral">&quot;&quot;</span> );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Cross-browser xml parsing</span></div>
<div class="line">jQuery.parseXML = <span class="keyword">function</span>( data ) {</div>
<div class="line">    var xml, tmp;</div>
<div class="line">    <span class="keywordflow">if</span> ( !data || typeof data !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">        <span class="keywordflow">return</span> null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support: IE9</span></div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        tmp = <span class="keyword">new</span> DOMParser();</div>
<div class="line">        xml = tmp.parseFromString( data, <span class="stringliteral">&quot;text/xml&quot;</span> );</div>
<div class="line">    } <span class="keywordflow">catch</span> ( e ) {</div>
<div class="line">        xml = undefined;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( !xml || xml.getElementsByTagName( <span class="stringliteral">&quot;parsererror&quot;</span> ).length ) {</div>
<div class="line">        jQuery.error( <span class="stringliteral">&quot;Invalid XML: &quot;</span> + data );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> xml;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    <span class="comment">// Document location</span></div>
<div class="line">    ajaxLocParts,</div>
<div class="line">    ajaxLocation,</div>
<div class="line"></div>
<div class="line">    rhash = /#.*$/,</div>
<div class="line">    rts = /([?&amp;])_=[^&amp;]*/,</div>
<div class="line">    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,</div>
<div class="line">    <span class="comment">// #7653, #8125, #8152: local protocol detection</span></div>
<div class="line">    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,</div>
<div class="line">    rnoContent = /^(?:GET|HEAD)$/,</div>
<div class="line">    rprotocol = /^\/\<span class="comment">//,</span></div>
<div class="line">    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Prefilters</span></div>
<div class="line"><span class="comment">     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)</span></div>
<div class="line"><span class="comment">     * 2) These are called:</span></div>
<div class="line"><span class="comment">     *    - BEFORE asking for a transport</span></div>
<div class="line"><span class="comment">     *    - AFTER param serialization (s.data is a string if s.processData is true)</span></div>
<div class="line"><span class="comment">     * 3) key is the dataType</span></div>
<div class="line"><span class="comment">     * 4) the catchall symbol &quot;*&quot; can be used</span></div>
<div class="line"><span class="comment">     * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    prefilters = {},</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Transports bindings</span></div>
<div class="line"><span class="comment">     * 1) key is the dataType</span></div>
<div class="line"><span class="comment">     * 2) the catchall symbol &quot;*&quot; can be used</span></div>
<div class="line"><span class="comment">     * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    transports = {},</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression</span></div>
<div class="line">    allTypes = <span class="stringliteral">&quot;*/&quot;</span>.concat(<span class="stringliteral">&quot;*&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// #8138, IE may throw an exception when accessing</span></div>
<div class="line"><span class="comment">// a field from window.location if document.domain has been set</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    ajaxLocation = location.href;</div>
<div class="line">} <span class="keywordflow">catch</span>( e ) {</div>
<div class="line">    <span class="comment">// Use the href attribute of an A element</span></div>
<div class="line">    <span class="comment">// since IE will modify it given document.location</span></div>
<div class="line">    ajaxLocation = document.createElement( <span class="stringliteral">&quot;a&quot;</span> );</div>
<div class="line">    ajaxLocation.href = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    ajaxLocation = ajaxLocation.href;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Segment location into parts</span></div>
<div class="line">ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport</span></div>
<div class="line"><span class="keyword">function</span> addToPrefiltersOrTransports( structure ) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// dataTypeExpression is optional and defaults to &quot;*&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>( dataTypeExpression, func ) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof dataTypeExpression !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            func = dataTypeExpression;</div>
<div class="line">            dataTypeExpression = <span class="stringliteral">&quot;*&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var dataType,</div>
<div class="line">            i = 0,</div>
<div class="line">            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( func ) ) {</div>
<div class="line">            <span class="comment">// For each dataType in the dataTypeExpression</span></div>
<div class="line">            <span class="keywordflow">while</span> ( (dataType = dataTypes[i++]) ) {</div>
<div class="line">                <span class="comment">// Prepend if requested</span></div>
<div class="line">                <span class="keywordflow">if</span> ( dataType[0] === <span class="stringliteral">&quot;+&quot;</span> ) {</div>
<div class="line">                    dataType = dataType.slice( 1 ) || <span class="stringliteral">&quot;*&quot;</span>;</div>
<div class="line">                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Otherwise append</span></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    (structure[ dataType ] = structure[ dataType ] || []).push( func );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Base inspection function for prefilters and transports</span></div>
<div class="line"><span class="keyword">function</span> inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {</div>
<div class="line"></div>
<div class="line">    var inspected = {},</div>
<div class="line">        seekingTransport = ( structure === transports );</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> inspect( dataType ) {</div>
<div class="line">        var selected;</div>
<div class="line">        inspected[ dataType ] = <span class="keyword">true</span>;</div>
<div class="line">        jQuery.each( structure[ dataType ] || [], <span class="keyword">function</span>( _, prefilterOrFactory ) {</div>
<div class="line">            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );</div>
<div class="line">            <span class="keywordflow">if</span> ( typeof dataTypeOrTransport === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {</div>
<div class="line">                options.dataTypes.unshift( dataTypeOrTransport );</div>
<div class="line">                inspect( dataTypeOrTransport );</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( seekingTransport ) {</div>
<div class="line">                <span class="keywordflow">return</span> !( selected = dataTypeOrTransport );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> selected;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> inspect( options.dataTypes[ 0 ] ) || !inspected[ <span class="stringliteral">&quot;*&quot;</span> ] &amp;&amp; inspect( <span class="stringliteral">&quot;*&quot;</span> );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// A special extend for ajax options</span></div>
<div class="line"><span class="comment">// that takes &quot;flat&quot; options (not to be deep extended)</span></div>
<div class="line"><span class="comment">// Fixes #9887</span></div>
<div class="line"><span class="keyword">function</span> ajaxExtend( target, src ) {</div>
<div class="line">    var key, deep,</div>
<div class="line">        flatOptions = jQuery.ajaxSettings.flatOptions || {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> ( key in src ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( src[ key ] !== undefined ) {</div>
<div class="line">            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> ( deep ) {</div>
<div class="line">        jQuery.extend( <span class="keyword">true</span>, target, deep );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> target;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Handles responses to an ajax request:</span></div>
<div class="line"><span class="comment"> * - finds the right dataType (mediates between content-type and expected dataType)</span></div>
<div class="line"><span class="comment"> * - returns the corresponding response</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">function</span> ajaxHandleResponses( s, jqXHR, responses ) {</div>
<div class="line"></div>
<div class="line">    var ct, type, finalDataType, firstDataType,</div>
<div class="line">        contents = s.contents,</div>
<div class="line">        dataTypes = s.dataTypes;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Remove auto dataType and get content-type in the process</span></div>
<div class="line">    <span class="keywordflow">while</span> ( dataTypes[ 0 ] === <span class="stringliteral">&quot;*&quot;</span> ) {</div>
<div class="line">        dataTypes.shift();</div>
<div class="line">        <span class="keywordflow">if</span> ( ct === undefined ) {</div>
<div class="line">            ct = s.mimeType || jqXHR.getResponseHeader(<span class="stringliteral">&quot;Content-Type&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if we&#39;re dealing with a known content-type</span></div>
<div class="line">    <span class="keywordflow">if</span> ( ct ) {</div>
<div class="line">        <span class="keywordflow">for</span> ( type in contents ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {</div>
<div class="line">                dataTypes.unshift( type );</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check to see if we have a response for the expected dataType</span></div>
<div class="line">    <span class="keywordflow">if</span> ( dataTypes[ 0 ] in responses ) {</div>
<div class="line">        finalDataType = dataTypes[ 0 ];</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Try convertible dataTypes</span></div>
<div class="line">        <span class="keywordflow">for</span> ( type in responses ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( !dataTypes[ 0 ] || s.converters[ type + <span class="stringliteral">&quot; &quot;</span> + dataTypes[0] ] ) {</div>
<div class="line">                finalDataType = type;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> ( !firstDataType ) {</div>
<div class="line">                firstDataType = type;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Or just use first one</span></div>
<div class="line">        finalDataType = finalDataType || firstDataType;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If we found a dataType</span></div>
<div class="line">    <span class="comment">// We add the dataType to the list if needed</span></div>
<div class="line">    <span class="comment">// and return the corresponding response</span></div>
<div class="line">    <span class="keywordflow">if</span> ( finalDataType ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( finalDataType !== dataTypes[ 0 ] ) {</div>
<div class="line">            dataTypes.unshift( finalDataType );</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> responses[ finalDataType ];</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Chain conversions given the request and the original response</span></div>
<div class="line"><span class="comment"> * Also sets the responseXXX fields on the jqXHR instance</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">function</span> ajaxConvert( s, response, jqXHR, isSuccess ) {</div>
<div class="line">    var conv2, current, conv, tmp, prev,</div>
<div class="line">        converters = {},</div>
<div class="line">        <span class="comment">// Work with a copy of dataTypes in case we need to modify it for conversion</span></div>
<div class="line">        dataTypes = s.dataTypes.slice();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create converters map with lowercased keys</span></div>
<div class="line">    <span class="keywordflow">if</span> ( dataTypes[ 1 ] ) {</div>
<div class="line">        <span class="keywordflow">for</span> ( conv in s.converters ) {</div>
<div class="line">            converters[ conv.toLowerCase() ] = s.converters[ conv ];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    current = dataTypes.shift();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert to each sequential dataType</span></div>
<div class="line">    <span class="keywordflow">while</span> ( current ) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( s.responseFields[ current ] ) {</div>
<div class="line">            jqXHR[ s.responseFields[ current ] ] = response;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Apply the dataFilter if provided</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {</div>
<div class="line">            response = s.dataFilter( response, s.dataType );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        prev = current;</div>
<div class="line">        current = dataTypes.shift();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( current ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// There&#39;s only work to do if current dataType is non-auto</span></div>
<div class="line">            <span class="keywordflow">if</span> ( current === <span class="stringliteral">&quot;*&quot;</span> ) {</div>
<div class="line"></div>
<div class="line">                current = prev;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Convert response if prev dataType is non-auto and differs from current</span></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( prev !== <span class="stringliteral">&quot;*&quot;</span> &amp;&amp; prev !== current ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Seek a direct converter</span></div>
<div class="line">                conv = converters[ prev + <span class="stringliteral">&quot; &quot;</span> + current ] || converters[ <span class="stringliteral">&quot;* &quot;</span> + current ];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If none found, seek a pair</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !conv ) {</div>
<div class="line">                    <span class="keywordflow">for</span> ( conv2 in converters ) {</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// If conv2 outputs current</span></div>
<div class="line">                        tmp = conv2.split( <span class="stringliteral">&quot; &quot;</span> );</div>
<div class="line">                        <span class="keywordflow">if</span> ( tmp[ 1 ] === current ) {</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// If prev can be converted to accepted input</span></div>
<div class="line">                            conv = converters[ prev + <span class="stringliteral">&quot; &quot;</span> + tmp[ 0 ] ] ||</div>
<div class="line">                                converters[ <span class="stringliteral">&quot;* &quot;</span> + tmp[ 0 ] ];</div>
<div class="line">                            <span class="keywordflow">if</span> ( conv ) {</div>
<div class="line">                                <span class="comment">// Condense equivalence converters</span></div>
<div class="line">                                <span class="keywordflow">if</span> ( conv === <span class="keyword">true</span> ) {</div>
<div class="line">                                    conv = converters[ conv2 ];</div>
<div class="line"></div>
<div class="line">                                <span class="comment">// Otherwise, insert the intermediate dataType</span></div>
<div class="line">                                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( converters[ conv2 ] !== <span class="keyword">true</span> ) {</div>
<div class="line">                                    current = tmp[ 0 ];</div>
<div class="line">                                    dataTypes.unshift( tmp[ 1 ] );</div>
<div class="line">                                }</div>
<div class="line">                                <span class="keywordflow">break</span>;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Apply converter (if not an equivalence)</span></div>
<div class="line">                <span class="keywordflow">if</span> ( conv !== <span class="keyword">true</span> ) {</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Unless errors are allowed to bubble, catch and return them</span></div>
<div class="line">                    <span class="keywordflow">if</span> ( conv &amp;&amp; s[ <span class="stringliteral">&quot;throws&quot;</span> ] ) {</div>
<div class="line">                        response = conv( response );</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        <span class="keywordflow">try</span> {</div>
<div class="line">                            response = conv( response );</div>
<div class="line">                        } <span class="keywordflow">catch</span> ( e ) {</div>
<div class="line">                            <span class="keywordflow">return</span> { state: <span class="stringliteral">&quot;parsererror&quot;</span>, error: conv ? e : <span class="stringliteral">&quot;No conversion from &quot;</span> + prev + <span class="stringliteral">&quot; to &quot;</span> + current };</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> { state: <span class="stringliteral">&quot;success&quot;</span>, data: response };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.extend({</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Counter for holding the number of active queries</span></div>
<div class="line">    active: 0,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Last-Modified header cache for next request</span></div>
<div class="line">    lastModified: {},</div>
<div class="line">    etag: {},</div>
<div class="line"></div>
<div class="line">    ajaxSettings: {</div>
<div class="line">        url: ajaxLocation,</div>
<div class="line">        type: <span class="stringliteral">&quot;GET&quot;</span>,</div>
<div class="line">        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),</div>
<div class="line">        global: <span class="keyword">true</span>,</div>
<div class="line">        processData: <span class="keyword">true</span>,</div>
<div class="line">        async: <span class="keyword">true</span>,</div>
<div class="line">        contentType: <span class="stringliteral">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">        timeout: 0,</span></div>
<div class="line"><span class="comment">        data: null,</span></div>
<div class="line"><span class="comment">        dataType: null,</span></div>
<div class="line"><span class="comment">        username: null,</span></div>
<div class="line"><span class="comment">        password: null,</span></div>
<div class="line"><span class="comment">        cache: null,</span></div>
<div class="line"><span class="comment">        throws: false,</span></div>
<div class="line"><span class="comment">        traditional: false,</span></div>
<div class="line"><span class="comment">        headers: {},</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line"></div>
<div class="line">        accepts: {</div>
<div class="line">            <span class="stringliteral">&quot;*&quot;</span>: allTypes,</div>
<div class="line">            text: <span class="stringliteral">&quot;text/plain&quot;</span>,</div>
<div class="line">            html: <span class="stringliteral">&quot;text/html&quot;</span>,</div>
<div class="line">            xml: <span class="stringliteral">&quot;application/xml, text/xml&quot;</span>,</div>
<div class="line">            json: <span class="stringliteral">&quot;application/json, text/javascript&quot;</span></div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        contents: {</div>
<div class="line">            xml: /xml/,</div>
<div class="line">            html: /html/,</div>
<div class="line">            json: /json/</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        responseFields: {</div>
<div class="line">            xml: <span class="stringliteral">&quot;responseXML&quot;</span>,</div>
<div class="line">            text: <span class="stringliteral">&quot;responseText&quot;</span>,</div>
<div class="line">            json: <span class="stringliteral">&quot;responseJSON&quot;</span></div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Data converters</span></div>
<div class="line">        <span class="comment">// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space</span></div>
<div class="line">        converters: {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Convert anything to text</span></div>
<div class="line">            <span class="stringliteral">&quot;* text&quot;</span>: String,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Text to html (true = no transformation)</span></div>
<div class="line">            <span class="stringliteral">&quot;text html&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Evaluate text as a json expression</span></div>
<div class="line">            <span class="stringliteral">&quot;text json&quot;</span>: jQuery.parseJSON,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Parse text as xml</span></div>
<div class="line">            <span class="stringliteral">&quot;text xml&quot;</span>: jQuery.parseXML</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="comment">// For options that shouldn&#39;t be deep extended:</span></div>
<div class="line">        <span class="comment">// you can add your own custom options here if</span></div>
<div class="line">        <span class="comment">// and when you create one that shouldn&#39;t be</span></div>
<div class="line">        <span class="comment">// deep extended (see ajaxExtend)</span></div>
<div class="line">        flatOptions: {</div>
<div class="line">            url: <span class="keyword">true</span>,</div>
<div class="line">            context: <span class="keyword">true</span></div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Creates a full fledged settings object into target</span></div>
<div class="line">    <span class="comment">// with both ajaxSettings and settings fields.</span></div>
<div class="line">    <span class="comment">// If target is omitted, writes into ajaxSettings.</span></div>
<div class="line">    ajaxSetup: <span class="keyword">function</span>( target, settings ) {</div>
<div class="line">        <span class="keywordflow">return</span> settings ?</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Building a settings object</span></div>
<div class="line">            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Extending ajaxSettings</span></div>
<div class="line">            ajaxExtend( jQuery.ajaxSettings, target );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),</div>
<div class="line">    ajaxTransport: addToPrefiltersOrTransports( transports ),</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Main method</span></div>
<div class="line">    ajax: <span class="keyword">function</span>( url, options ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If url is an object, simulate pre-1.5 signature</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof url === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">            options = url;</div>
<div class="line">            url = undefined;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Force options to be an object</span></div>
<div class="line">        options = options || {};</div>
<div class="line"></div>
<div class="line">        var transport,</div>
<div class="line">            <span class="comment">// URL without anti-cache param</span></div>
<div class="line">            cacheURL,</div>
<div class="line">            <span class="comment">// Response headers</span></div>
<div class="line">            responseHeadersString,</div>
<div class="line">            responseHeaders,</div>
<div class="line">            <span class="comment">// timeout handle</span></div>
<div class="line">            timeoutTimer,</div>
<div class="line">            <span class="comment">// Cross-domain detection vars</span></div>
<div class="line">            parts,</div>
<div class="line">            <span class="comment">// To know if global events are to be dispatched</span></div>
<div class="line">            fireGlobals,</div>
<div class="line">            <span class="comment">// Loop variable</span></div>
<div class="line">            i,</div>
<div class="line">            <span class="comment">// Create the final options object</span></div>
<div class="line">            s = jQuery.ajaxSetup( {}, options ),</div>
<div class="line">            <span class="comment">// Callbacks context</span></div>
<div class="line">            callbackContext = s.context || s,</div>
<div class="line">            <span class="comment">// Context for global events is callbackContext if it is a DOM node or jQuery collection</span></div>
<div class="line">            globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ?</div>
<div class="line">                jQuery( callbackContext ) :</div>
<div class="line">                jQuery.event,</div>
<div class="line">            <span class="comment">// Deferreds</span></div>
<div class="line">            deferred = jQuery.Deferred(),</div>
<div class="line">            completeDeferred = jQuery.Callbacks(<span class="stringliteral">&quot;once memory&quot;</span>),</div>
<div class="line">            <span class="comment">// Status-dependent callbacks</span></div>
<div class="line">            statusCode = s.statusCode || {},</div>
<div class="line">            <span class="comment">// Headers (they are sent all at once)</span></div>
<div class="line">            requestHeaders = {},</div>
<div class="line">            requestHeadersNames = {},</div>
<div class="line">            <span class="comment">// The jqXHR state</span></div>
<div class="line">            state = 0,</div>
<div class="line">            <span class="comment">// Default abort message</span></div>
<div class="line">            strAbort = <span class="stringliteral">&quot;canceled&quot;</span>,</div>
<div class="line">            <span class="comment">// Fake xhr</span></div>
<div class="line">            jqXHR = {</div>
<div class="line">                readyState: 0,</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Builds headers hashtable if needed</span></div>
<div class="line">                getResponseHeader: <span class="keyword">function</span>( key ) {</div>
<div class="line">                    var match;</div>
<div class="line">                    <span class="keywordflow">if</span> ( state === 2 ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( !responseHeaders ) {</div>
<div class="line">                            responseHeaders = {};</div>
<div class="line">                            <span class="keywordflow">while</span> ( (match = rheaders.exec( responseHeadersString )) ) {</div>
<div class="line">                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                        match = responseHeaders[ key.toLowerCase() ];</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">return</span> match == null ? null : match;</div>
<div class="line">                },</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Raw string</span></div>
<div class="line">                getAllResponseHeaders: <span class="keyword">function</span>() {</div>
<div class="line">                    <span class="keywordflow">return</span> state === 2 ? responseHeadersString : null;</div>
<div class="line">                },</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Caches the header</span></div>
<div class="line">                setRequestHeader: <span class="keyword">function</span>( name, value ) {</div>
<div class="line">                    var lname = name.toLowerCase();</div>
<div class="line">                    <span class="keywordflow">if</span> ( !state ) {</div>
<div class="line">                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;</div>
<div class="line">                        requestHeaders[ name ] = value;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                },</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Overrides response content-type header</span></div>
<div class="line">                overrideMimeType: <span class="keyword">function</span>( type ) {</div>
<div class="line">                    <span class="keywordflow">if</span> ( !state ) {</div>
<div class="line">                        s.mimeType = type;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                },</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Status-dependent callbacks</span></div>
<div class="line">                statusCode: <span class="keyword">function</span>( map ) {</div>
<div class="line">                    var code;</div>
<div class="line">                    <span class="keywordflow">if</span> ( map ) {</div>
<div class="line">                        <span class="keywordflow">if</span> ( state &lt; 2 ) {</div>
<div class="line">                            <span class="keywordflow">for</span> ( code in map ) {</div>
<div class="line">                                <span class="comment">// Lazy-add the new callback in a way that preserves old ones</span></div>
<div class="line">                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];</div>
<div class="line">                            }</div>
<div class="line">                        } <span class="keywordflow">else</span> {</div>
<div class="line">                            <span class="comment">// Execute the appropriate callbacks</span></div>
<div class="line">                            jqXHR.always( map[ jqXHR.status ] );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                },</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Cancel the request</span></div>
<div class="line">                abort: <span class="keyword">function</span>( statusText ) {</div>
<div class="line">                    var finalText = statusText || strAbort;</div>
<div class="line">                    <span class="keywordflow">if</span> ( transport ) {</div>
<div class="line">                        transport.abort( finalText );</div>
<div class="line">                    }</div>
<div class="line">                    done( 0, finalText );</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Attach deferreds</span></div>
<div class="line">        deferred.promise( jqXHR ).complete = completeDeferred.add;</div>
<div class="line">        jqXHR.success = jqXHR.done;</div>
<div class="line">        jqXHR.error = jqXHR.fail;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove hash character (#7531: and string promotion)</span></div>
<div class="line">        <span class="comment">// Add protocol if not provided (prefilters might expect it)</span></div>
<div class="line">        <span class="comment">// Handle falsy url in the settings object (#10093: consistency with old signature)</span></div>
<div class="line">        <span class="comment">// We also use the url parameter if available</span></div>
<div class="line">        s.url = ( ( url || s.url || ajaxLocation ) + <span class="stringliteral">&quot;&quot;</span> ).replace( rhash, <span class="stringliteral">&quot;&quot;</span> )</div>
<div class="line">            .replace( rprotocol, ajaxLocParts[ 1 ] + <span class="stringliteral">&quot;//&quot;</span> );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Alias method option to type as per ticket #12004</span></div>
<div class="line">        s.type = options.method || options.type || s.method || s.type;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Extract dataTypes list</span></div>
<div class="line">        s.dataTypes = jQuery.trim( s.dataType || <span class="stringliteral">&quot;*&quot;</span> ).toLowerCase().match( rnotwhite ) || [ <span class="stringliteral">&quot;&quot;</span> ];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// A cross-domain request is in order when we have a protocol:host:port mismatch</span></div>
<div class="line">        <span class="keywordflow">if</span> ( s.crossDomain == null ) {</div>
<div class="line">            parts = rurl.exec( s.url.toLowerCase() );</div>
<div class="line">            s.crossDomain = !!( parts &amp;&amp;</div>
<div class="line">                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||</div>
<div class="line">                    ( parts[ 3 ] || ( parts[ 1 ] === <span class="stringliteral">&quot;http:&quot;</span> ? <span class="stringliteral">&quot;80&quot;</span> : <span class="stringliteral">&quot;443&quot;</span> ) ) !==</div>
<div class="line">                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === <span class="stringliteral">&quot;http:&quot;</span> ? <span class="stringliteral">&quot;80&quot;</span> : <span class="stringliteral">&quot;443&quot;</span> ) ) )</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Convert data if not already a string</span></div>
<div class="line">        <span class="keywordflow">if</span> ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">            s.data = jQuery.param( s.data, s.traditional );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Apply prefilters</span></div>
<div class="line">        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If request was aborted inside a prefilter, stop there</span></div>
<div class="line">        <span class="keywordflow">if</span> ( state === 2 ) {</div>
<div class="line">            <span class="keywordflow">return</span> jqXHR;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We can fire global events as of now if asked to</span></div>
<div class="line">        fireGlobals = s.global;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Watch for a new set of requests</span></div>
<div class="line">        <span class="keywordflow">if</span> ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {</div>
<div class="line">            jQuery.event.trigger(<span class="stringliteral">&quot;ajaxStart&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Uppercase the type</span></div>
<div class="line">        s.type = s.type.toUpperCase();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Determine if request has content</span></div>
<div class="line">        s.hasContent = !rnoContent.test( s.type );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Save the URL in case we&#39;re toying with the If-Modified-Since</span></div>
<div class="line">        <span class="comment">// and/or If-None-Match header later on</span></div>
<div class="line">        cacheURL = s.url;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// More options handling for requests with no content</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !s.hasContent ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If data is available, append data to url</span></div>
<div class="line">            <span class="keywordflow">if</span> ( s.data ) {</div>
<div class="line">                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? <span class="stringliteral">&quot;&amp;&quot;</span> : <span class="stringliteral">&quot;?&quot;</span> ) + s.data );</div>
<div class="line">                <span class="comment">// #9682: remove data so that it&#39;s not used in an eventual retry</span></div>
<div class="line">                <span class="keyword">delete</span> s.data;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add anti-cache in url if needed</span></div>
<div class="line">            <span class="keywordflow">if</span> ( s.cache === <span class="keyword">false</span> ) {</div>
<div class="line">                s.url = rts.test( cacheURL ) ?</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// If there is already a &#39;_&#39; parameter, set its value</span></div>
<div class="line">                    cacheURL.replace( rts, <span class="stringliteral">&quot;$1_=&quot;</span> + nonce++ ) :</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Otherwise add one to the end</span></div>
<div class="line">                    cacheURL + ( rquery.test( cacheURL ) ? <span class="stringliteral">&quot;&amp;&quot;</span> : <span class="stringliteral">&quot;?&quot;</span> ) + <span class="stringliteral">&quot;_=&quot;</span> + nonce++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span></div>
<div class="line">        <span class="keywordflow">if</span> ( s.ifModified ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.lastModified[ cacheURL ] ) {</div>
<div class="line">                jqXHR.setRequestHeader( <span class="stringliteral">&quot;If-Modified-Since&quot;</span>, jQuery.lastModified[ cacheURL ] );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> ( jQuery.etag[ cacheURL ] ) {</div>
<div class="line">                jqXHR.setRequestHeader( <span class="stringliteral">&quot;If-None-Match&quot;</span>, jQuery.etag[ cacheURL ] );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the correct header, if data is being sent</span></div>
<div class="line">        <span class="keywordflow">if</span> ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== <span class="keyword">false</span> || options.contentType ) {</div>
<div class="line">            jqXHR.setRequestHeader( <span class="stringliteral">&quot;Content-Type&quot;</span>, s.contentType );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set the Accepts header for the server, depending on the dataType</span></div>
<div class="line">        jqXHR.setRequestHeader(</div>
<div class="line">            <span class="stringliteral">&quot;Accept&quot;</span>,</div>
<div class="line">            s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?</div>
<div class="line">                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== <span class="stringliteral">&quot;*&quot;</span> ? <span class="stringliteral">&quot;, &quot;</span> + allTypes + <span class="stringliteral">&quot;; q=0.01&quot;</span> : <span class="stringliteral">&quot;&quot;</span> ) :</div>
<div class="line">                s.accepts[ <span class="stringliteral">&quot;*&quot;</span> ]</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check for headers option</span></div>
<div class="line">        <span class="keywordflow">for</span> ( i in s.headers ) {</div>
<div class="line">            jqXHR.setRequestHeader( i, s.headers[ i ] );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allow custom headers/mimetypes and early abort</span></div>
<div class="line">        <span class="keywordflow">if</span> ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === <span class="keyword">false</span> || state === 2 ) ) {</div>
<div class="line">            <span class="comment">// Abort if not done already and return</span></div>
<div class="line">            <span class="keywordflow">return</span> jqXHR.abort();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// aborting is no longer a cancellation</span></div>
<div class="line">        strAbort = <span class="stringliteral">&quot;abort&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Install callbacks on deferreds</span></div>
<div class="line">        <span class="keywordflow">for</span> ( i in { success: 1, error: 1, complete: 1 } ) {</div>
<div class="line">            jqXHR[ i ]( s[ i ] );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get transport</span></div>
<div class="line">        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If no transport, we auto-abort</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !transport ) {</div>
<div class="line">            done( -1, <span class="stringliteral">&quot;No Transport&quot;</span> );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            jqXHR.readyState = 1;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Send global event</span></div>
<div class="line">            <span class="keywordflow">if</span> ( fireGlobals ) {</div>
<div class="line">                globalEventContext.trigger( <span class="stringliteral">&quot;ajaxSend&quot;</span>, [ jqXHR, s ] );</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// Timeout</span></div>
<div class="line">            <span class="keywordflow">if</span> ( s.async &amp;&amp; s.timeout &gt; 0 ) {</div>
<div class="line">                timeoutTimer = setTimeout(<span class="keyword">function</span>() {</div>
<div class="line">                    jqXHR.abort(<span class="stringliteral">&quot;timeout&quot;</span>);</div>
<div class="line">                }, s.timeout );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                state = 1;</div>
<div class="line">                transport.send( requestHeaders, done );</div>
<div class="line">            } <span class="keywordflow">catch</span> ( e ) {</div>
<div class="line">                <span class="comment">// Propagate exception as error if not done</span></div>
<div class="line">                <span class="keywordflow">if</span> ( state &lt; 2 ) {</div>
<div class="line">                    done( -1, e );</div>
<div class="line">                <span class="comment">// Simply rethrow otherwise</span></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keywordflow">throw</span> e;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Callback for when everything is done</span></div>
<div class="line">        <span class="keyword">function</span> done( status, nativeStatusText, responses, headers ) {</div>
<div class="line">            var isSuccess, success, error, response, modified,</div>
<div class="line">                statusText = nativeStatusText;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Called once</span></div>
<div class="line">            <span class="keywordflow">if</span> ( state === 2 ) {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// State is &quot;done&quot; now</span></div>
<div class="line">            state = 2;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Clear timeout if it exists</span></div>
<div class="line">            <span class="keywordflow">if</span> ( timeoutTimer ) {</div>
<div class="line">                clearTimeout( timeoutTimer );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Dereference transport for early garbage collection</span></div>
<div class="line">            <span class="comment">// (no matter how long the jqXHR object will be used)</span></div>
<div class="line">            transport = undefined;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Cache response headers</span></div>
<div class="line">            responseHeadersString = headers || <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set readyState</span></div>
<div class="line">            jqXHR.readyState = status &gt; 0 ? 4 : 0;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Determine if successful</span></div>
<div class="line">            isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get response data</span></div>
<div class="line">            <span class="keywordflow">if</span> ( responses ) {</div>
<div class="line">                response = ajaxHandleResponses( s, jqXHR, responses );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Convert no matter what (that way responseXXX fields are always set)</span></div>
<div class="line">            response = ajaxConvert( s, response, jqXHR, isSuccess );</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If successful, handle type chaining</span></div>
<div class="line">            <span class="keywordflow">if</span> ( isSuccess ) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span></div>
<div class="line">                <span class="keywordflow">if</span> ( s.ifModified ) {</div>
<div class="line">                    modified = jqXHR.getResponseHeader(<span class="stringliteral">&quot;Last-Modified&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">if</span> ( modified ) {</div>
<div class="line">                        jQuery.lastModified[ cacheURL ] = modified;</div>
<div class="line">                    }</div>
<div class="line">                    modified = jqXHR.getResponseHeader(<span class="stringliteral">&quot;etag&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">if</span> ( modified ) {</div>
<div class="line">                        jQuery.etag[ cacheURL ] = modified;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// if no content</span></div>
<div class="line">                <span class="keywordflow">if</span> ( status === 204 || s.type === <span class="stringliteral">&quot;HEAD&quot;</span> ) {</div>
<div class="line">                    statusText = <span class="stringliteral">&quot;nocontent&quot;</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// if not modified</span></div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( status === 304 ) {</div>
<div class="line">                    statusText = <span class="stringliteral">&quot;notmodified&quot;</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If we have data, let&#39;s convert it</span></div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    statusText = response.state;</div>
<div class="line">                    success = response.data;</div>
<div class="line">                    error = response.error;</div>
<div class="line">                    isSuccess = !error;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// We extract error from statusText</span></div>
<div class="line">                <span class="comment">// then normalize statusText and status for non-aborts</span></div>
<div class="line">                error = statusText;</div>
<div class="line">                <span class="keywordflow">if</span> ( status || !statusText ) {</div>
<div class="line">                    statusText = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">if</span> ( status &lt; 0 ) {</div>
<div class="line">                        status = 0;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set data for the fake xhr object</span></div>
<div class="line">            jqXHR.status = status;</div>
<div class="line">            jqXHR.statusText = ( nativeStatusText || statusText ) + <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Success/Error</span></div>
<div class="line">            <span class="keywordflow">if</span> ( isSuccess ) {</div>
<div class="line">                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Status-dependent callbacks</span></div>
<div class="line">            jqXHR.statusCode( statusCode );</div>
<div class="line">            statusCode = undefined;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( fireGlobals ) {</div>
<div class="line">                globalEventContext.trigger( isSuccess ? <span class="stringliteral">&quot;ajaxSuccess&quot;</span> : <span class="stringliteral">&quot;ajaxError&quot;</span>,</div>
<div class="line">                    [ jqXHR, s, isSuccess ? success : error ] );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Complete</span></div>
<div class="line">            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( fireGlobals ) {</div>
<div class="line">                globalEventContext.trigger( <span class="stringliteral">&quot;ajaxComplete&quot;</span>, [ jqXHR, s ] );</div>
<div class="line">                <span class="comment">// Handle the global AJAX counter</span></div>
<div class="line">                <span class="keywordflow">if</span> ( !( --jQuery.active ) ) {</div>
<div class="line">                    jQuery.event.trigger(<span class="stringliteral">&quot;ajaxStop&quot;</span>);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> jqXHR;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    getJSON: <span class="keyword">function</span>( url, data, callback ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.get( url, data, callback, <span class="stringliteral">&quot;json&quot;</span> );</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    getScript: <span class="keyword">function</span>( url, callback ) {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.get( url, undefined, callback, <span class="stringliteral">&quot;script&quot;</span> );</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">jQuery.each( [ <span class="stringliteral">&quot;get&quot;</span>, <span class="stringliteral">&quot;post&quot;</span> ], <span class="keyword">function</span>( i, method ) {</div>
<div class="line">    jQuery[ method ] = <span class="keyword">function</span>( url, data, callback, type ) {</div>
<div class="line">        <span class="comment">// shift arguments if data argument was omitted</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( data ) ) {</div>
<div class="line">            type = type || callback;</div>
<div class="line">            callback = data;</div>
<div class="line">            data = undefined;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> jQuery.ajax({</div>
<div class="line">            url: url,</div>
<div class="line">            type: method,</div>
<div class="line">            dataType: type,</div>
<div class="line">            data: data,</div>
<div class="line">            success: callback</div>
<div class="line">        });</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach a bunch of functions for handling common AJAX events</span></div>
<div class="line">jQuery.each( [ <span class="stringliteral">&quot;ajaxStart&quot;</span>, <span class="stringliteral">&quot;ajaxStop&quot;</span>, <span class="stringliteral">&quot;ajaxComplete&quot;</span>, <span class="stringliteral">&quot;ajaxError&quot;</span>, <span class="stringliteral">&quot;ajaxSuccess&quot;</span>, <span class="stringliteral">&quot;ajaxSend&quot;</span> ], <span class="keyword">function</span>( i, type ) {</div>
<div class="line">    jQuery.fn[ type ] = <span class="keyword">function</span>( fn ) {</div>
<div class="line">        <span class="keywordflow">return</span> this.on( type, fn );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery._evalUrl = <span class="keyword">function</span>( url ) {</div>
<div class="line">    <span class="keywordflow">return</span> jQuery.ajax({</div>
<div class="line">        url: url,</div>
<div class="line">        type: <span class="stringliteral">&quot;GET&quot;</span>,</div>
<div class="line">        dataType: <span class="stringliteral">&quot;script&quot;</span>,</div>
<div class="line">        async: <span class="keyword">false</span>,</div>
<div class="line">        global: <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;throws&quot;</span>: <span class="keyword">true</span></div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    wrapAll: <span class="keyword">function</span>( html ) {</div>
<div class="line">        var wrap;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( html ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).wrapAll( html.call(<span class="keyword">this</span>, i) );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( <span class="keyword">this</span>[ 0 ] ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The elements to wrap the target around</span></div>
<div class="line">            wrap = jQuery( html, <span class="keyword">this</span>[ 0 ].ownerDocument ).eq( 0 ).clone( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( <span class="keyword">this</span>[ 0 ].parentNode ) {</div>
<div class="line">                wrap.insertBefore( <span class="keyword">this</span>[ 0 ] );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            wrap.map(<span class="keyword">function</span>() {</div>
<div class="line">                var elem = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">while</span> ( elem.firstElementChild ) {</div>
<div class="line">                    elem = elem.firstElementChild;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> elem;</div>
<div class="line">            }).append( <span class="keyword">this</span> );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    wrapInner: <span class="keyword">function</span>( html ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( html ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).wrapInner( html.call(<span class="keyword">this</span>, i) );</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>() {</div>
<div class="line">            var <span class="keyword">self</span> = jQuery( <span class="keyword">this</span> ),</div>
<div class="line">                contents = <span class="keyword">self</span>.contents();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( contents.length ) {</div>
<div class="line">                contents.wrapAll( html );</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keyword">self</span>.append( html );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    wrap: <span class="keyword">function</span>( html ) {</div>
<div class="line">        var isFunction = jQuery.isFunction( html );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">            jQuery( <span class="keyword">this</span> ).wrapAll( isFunction ? html.call(<span class="keyword">this</span>, i) : html );</div>
<div class="line">        });</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    unwrap: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.parent().each(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( !jQuery.nodeName( <span class="keyword">this</span>, <span class="stringliteral">&quot;body&quot;</span> ) ) {</div>
<div class="line">                jQuery( <span class="keyword">this</span> ).replaceWith( this.childNodes );</div>
<div class="line">            }</div>
<div class="line">        }).end();</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.expr.filters.hidden = <span class="keyword">function</span>( elem ) {</div>
<div class="line">    <span class="comment">// Support: Opera &lt;= 12.12</span></div>
<div class="line">    <span class="comment">// Opera reports offsetWidths and offsetHeights less than zero on some elements</span></div>
<div class="line">    <span class="keywordflow">return</span> elem.offsetWidth &lt;= 0 &amp;&amp; elem.offsetHeight &lt;= 0;</div>
<div class="line">};</div>
<div class="line">jQuery.expr.filters.visible = <span class="keyword">function</span>( elem ) {</div>
<div class="line">    <span class="keywordflow">return</span> !jQuery.expr.filters.hidden( elem );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var r20 = /%20/g,</div>
<div class="line">    rbracket = /\[\]$/,</div>
<div class="line">    rCRLF = /\r?\n/g,</div>
<div class="line">    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,</div>
<div class="line">    rsubmittable = /^(?:input|select|textarea|keygen)/i;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> buildParams( prefix, obj, traditional, add ) {</div>
<div class="line">    var name;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.isArray( obj ) ) {</div>
<div class="line">        <span class="comment">// Serialize array item.</span></div>
<div class="line">        jQuery.each( obj, <span class="keyword">function</span>( i, v ) {</div>
<div class="line">            <span class="keywordflow">if</span> ( traditional || rbracket.test( prefix ) ) {</div>
<div class="line">                <span class="comment">// Treat each array item as a scalar.</span></div>
<div class="line">                add( prefix, v );</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Item is non-scalar (array or object), encode its numeric index.</span></div>
<div class="line">                buildParams( prefix + <span class="stringliteral">&quot;[&quot;</span> + ( typeof v === <span class="stringliteral">&quot;object&quot;</span> ? i : <span class="stringliteral">&quot;&quot;</span> ) + <span class="stringliteral">&quot;]&quot;</span>, v, traditional, add );</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !traditional &amp;&amp; jQuery.type( obj ) === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">        <span class="comment">// Serialize object item.</span></div>
<div class="line">        <span class="keywordflow">for</span> ( name in obj ) {</div>
<div class="line">            buildParams( prefix + <span class="stringliteral">&quot;[&quot;</span> + name + <span class="stringliteral">&quot;]&quot;</span>, obj[ name ], traditional, add );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Serialize scalar item.</span></div>
<div class="line">        add( prefix, obj );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Serialize an array of form elements or a set of</span></div>
<div class="line"><span class="comment">// key/values into a query string</span></div>
<div class="line">jQuery.param = <span class="keyword">function</span>( a, traditional ) {</div>
<div class="line">    var prefix,</div>
<div class="line">        s = [],</div>
<div class="line">        add = <span class="keyword">function</span>( key, value ) {</div>
<div class="line">            <span class="comment">// If value is a function, invoke it and return its value</span></div>
<div class="line">            value = jQuery.isFunction( value ) ? value() : ( value == null ? <span class="stringliteral">&quot;&quot;</span> : value );</div>
<div class="line">            s[ s.length ] = encodeURIComponent( key ) + <span class="stringliteral">&quot;=&quot;</span> + encodeURIComponent( value );</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set traditional to true for jQuery &lt;= 1.3.2 behavior.</span></div>
<div class="line">    <span class="keywordflow">if</span> ( traditional === undefined ) {</div>
<div class="line">        traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If an array was passed in, assume that it is an array of form elements.</span></div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {</div>
<div class="line">        <span class="comment">// Serialize the form elements</span></div>
<div class="line">        jQuery.each( a, <span class="keyword">function</span>() {</div>
<div class="line">            add( this.name, this.value );</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older</span></div>
<div class="line">        <span class="comment">// did it), otherwise encode params recursively.</span></div>
<div class="line">        <span class="keywordflow">for</span> ( prefix in a ) {</div>
<div class="line">            buildParams( prefix, a[ prefix ], traditional, add );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return the resulting serialization</span></div>
<div class="line">    <span class="keywordflow">return</span> s.join( <span class="stringliteral">&quot;&amp;&quot;</span> ).replace( r20, <span class="stringliteral">&quot;+&quot;</span> );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    serialize: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery.param( this.serializeArray() );</div>
<div class="line">    },</div>
<div class="line">    serializeArray: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.map(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="comment">// Can add propHook for &quot;elements&quot; to filter or add form elements</span></div>
<div class="line">            var elements = jQuery.prop( <span class="keyword">this</span>, <span class="stringliteral">&quot;elements&quot;</span> );</div>
<div class="line">            <span class="keywordflow">return</span> elements ? jQuery.makeArray( elements ) : <span class="keyword">this</span>;</div>
<div class="line">        })</div>
<div class="line">        .filter(<span class="keyword">function</span>() {</div>
<div class="line">            var type = this.type;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works</span></div>
<div class="line">            <span class="keywordflow">return</span> this.name &amp;&amp; !jQuery( <span class="keyword">this</span> ).is( <span class="stringliteral">&quot;:disabled&quot;</span> ) &amp;&amp;</div>
<div class="line">                rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;</div>
<div class="line">                ( this.checked || !rcheckableType.test( type ) );</div>
<div class="line">        })</div>
<div class="line">        .map(<span class="keyword">function</span>( i, elem ) {</div>
<div class="line">            var val = jQuery( <span class="keyword">this</span> ).val();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> val == null ?</div>
<div class="line">                null :</div>
<div class="line">                jQuery.isArray( val ) ?</div>
<div class="line">                    jQuery.map( val, <span class="keyword">function</span>( val ) {</div>
<div class="line">                        <span class="keywordflow">return</span> { name: elem.name, value: val.replace( rCRLF, <span class="stringliteral">&quot;\r\n&quot;</span> ) };</div>
<div class="line">                    }) :</div>
<div class="line">                    { name: elem.name, value: val.replace( rCRLF, <span class="stringliteral">&quot;\r\n&quot;</span> ) };</div>
<div class="line">        }).<span class="keyword">get</span>();</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.ajaxSettings.xhr = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> XMLHttpRequest();</div>
<div class="line">    } <span class="keywordflow">catch</span>( e ) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var xhrId = 0,</div>
<div class="line">    xhrCallbacks = {},</div>
<div class="line">    xhrSuccessStatus = {</div>
<div class="line">        <span class="comment">// file protocol always yields status code 0, assume 200</span></div>
<div class="line">        0: 200,</div>
<div class="line">        <span class="comment">// Support: IE9</span></div>
<div class="line">        <span class="comment">// #1450: sometimes IE returns 1223 when it should be 204</span></div>
<div class="line">        1223: 204</div>
<div class="line">    },</div>
<div class="line">    xhrSupported = jQuery.ajaxSettings.xhr();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Support: IE9</span></div>
<div class="line"><span class="comment">// Open requests must be manually aborted on unload (#5280)</span></div>
<div class="line"><span class="keywordflow">if</span> ( window.ActiveXObject ) {</div>
<div class="line">    jQuery( window ).on( <span class="stringliteral">&quot;unload&quot;</span>, <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">for</span> ( var key in xhrCallbacks ) {</div>
<div class="line">            xhrCallbacks[ key ]();</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">support.cors = !!xhrSupported &amp;&amp; ( <span class="stringliteral">&quot;withCredentials&quot;</span> in xhrSupported );</div>
<div class="line">support.ajax = xhrSupported = !!xhrSupported;</div>
<div class="line"></div>
<div class="line">jQuery.ajaxTransport(<span class="keyword">function</span>( options ) {</div>
<div class="line">    var callback;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cross domain only allowed if supported through XMLHttpRequest</span></div>
<div class="line">    <span class="keywordflow">if</span> ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {</div>
<div class="line">        return {</div>
<div class="line">            send: function( headers, complete ) {</div>
<div class="line">                var i,</div>
<div class="line">                    xhr = options.xhr(),</div>
<div class="line">                    id = ++xhrId;</div>
<div class="line"></div>
<div class="line">                xhr.open( options.type, options.url, options.async, options.username, options.password );</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Apply custom fields if provided</span></div>
<div class="line">                if ( options.xhrFields ) {</div>
<div class="line">                    for ( i in options.xhrFields ) {</div>
<div class="line">                        xhr[ i ] = options.xhrFields[ i ];</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Override mime type if needed</span></div>
<div class="line">                if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {</div>
<div class="line">                    xhr.overrideMimeType( options.mimeType );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// X-Requested-With header</span></div>
<div class="line">                <span class="comment">// For cross-domain requests, seeing as conditions for a preflight are</span></div>
<div class="line">                <span class="comment">// akin to a jigsaw puzzle, we simply never set it to be sure.</span></div>
<div class="line">                <span class="comment">// (it can always be set on a per-request basis or even using ajaxSetup)</span></div>
<div class="line">                <span class="comment">// For same-domain requests, won&#39;t change header if already provided.</span></div>
<div class="line">                if ( !options.crossDomain &amp;&amp; !headers[<span class="stringliteral">&quot;X-Requested-With&quot;</span>] ) {</div>
<div class="line">                    headers[<span class="stringliteral">&quot;X-Requested-With&quot;</span>] = <span class="stringliteral">&quot;XMLHttpRequest&quot;</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set headers</span></div>
<div class="line">                for ( i in headers ) {</div>
<div class="line">                    xhr.setRequestHeader( i, headers[ i ] );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Callback</span></div>
<div class="line">                callback = function( type ) {</div>
<div class="line">                    return function() {</div>
<div class="line">                        if ( callback ) {</div>
<div class="line">                            delete xhrCallbacks[ id ];</div>
<div class="line">                            callback = xhr.onload = xhr.onerror = null;</div>
<div class="line"></div>
<div class="line">                            if ( type === <span class="stringliteral">&quot;abort&quot;</span> ) {</div>
<div class="line">                                xhr.abort();</div>
<div class="line">                            } else if ( type === <span class="stringliteral">&quot;error&quot;</span> ) {</div>
<div class="line">                                complete(</div>
<div class="line">                                    <span class="comment">// file: protocol always yields status 0; see #8605, #14207</span></div>
<div class="line">                                    xhr.status,</div>
<div class="line">                                    xhr.statusText</div>
<div class="line">                                );</div>
<div class="line">                            } else {</div>
<div class="line">                                complete(</div>
<div class="line">                                    xhrSuccessStatus[ xhr.status ] || xhr.status,</div>
<div class="line">                                    xhr.statusText,</div>
<div class="line">                                    <span class="comment">// Support: IE9</span></div>
<div class="line">                                    <span class="comment">// Accessing binary-data responseText throws an exception</span></div>
<div class="line">                                    <span class="comment">// (#11426)</span></div>
<div class="line">                                    typeof xhr.responseText === <span class="stringliteral">&quot;string&quot;</span> ? {</div>
<div class="line">                                        text: xhr.responseText</div>
<div class="line">                                    } : undefined,</div>
<div class="line">                                    xhr.getAllResponseHeaders()</div>
<div class="line">                                );</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    };</div>
<div class="line">                };</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Listen to events</span></div>
<div class="line">                xhr.onload = callback();</div>
<div class="line">                xhr.onerror = callback(<span class="stringliteral">&quot;error&quot;</span>);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Create the abort callback</span></div>
<div class="line">                callback = xhrCallbacks[ id ] = callback(<span class="stringliteral">&quot;abort&quot;</span>);</div>
<div class="line"></div>
<div class="line">                try {</div>
<div class="line">                    <span class="comment">// Do send the request (this may raise an exception)</span></div>
<div class="line">                    xhr.send( options.hasContent &amp;&amp; options.data || null );</div>
<div class="line">                } catch ( e ) {</div>
<div class="line">                    <span class="comment">// #14683: Only rethrow if this hasn&#39;t been notified as an error yet</span></div>
<div class="line">                    if ( callback ) {</div>
<div class="line">                        throw e;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            },</div>
<div class="line"></div>
<div class="line">            abort: function() {</div>
<div class="line">                if ( callback ) {</div>
<div class="line">                    callback();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Install script dataType</span></div>
<div class="line">jQuery.ajaxSetup({</div>
<div class="line">    accepts: {</div>
<div class="line">        script: <span class="stringliteral">&quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;</span></div>
<div class="line">    },</div>
<div class="line">    contents: {</div>
<div class="line">        script: /(?:java|ecma)script/</div>
<div class="line">    },</div>
<div class="line">    converters: {</div>
<div class="line">        <span class="stringliteral">&quot;text script&quot;</span>: <span class="keyword">function</span>( text ) {</div>
<div class="line">            jQuery.globalEval( text );</div>
<div class="line">            <span class="keywordflow">return</span> text;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Handle cache&#39;s special case and crossDomain</span></div>
<div class="line">jQuery.ajaxPrefilter( <span class="stringliteral">&quot;script&quot;</span>, <span class="keyword">function</span>( s ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( s.cache === undefined ) {</div>
<div class="line">        s.cache = false;</div>
<div class="line">    }</div>
<div class="line">    if ( s.crossDomain ) {</div>
<div class="line">        s.type = <span class="stringliteral">&quot;GET&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Bind script tag hack transport</span></div>
<div class="line">jQuery.ajaxTransport( <span class="stringliteral">&quot;script&quot;</span>, <span class="keyword">function</span>( s ) {</div>
<div class="line">    <span class="comment">// This transport only deals with cross domain requests</span></div>
<div class="line">    <span class="keywordflow">if</span> ( s.crossDomain ) {</div>
<div class="line">        var script, callback;</div>
<div class="line">        return {</div>
<div class="line">            send: function( _, complete ) {</div>
<div class="line">                script = jQuery(<span class="stringliteral">&quot;&lt;script&gt;&quot;</span>).prop({</div>
<div class="line">                    async: true,</div>
<div class="line">                    charset: s.scriptCharset,</div>
<div class="line">                    src: s.url</div>
<div class="line">                }).on(</div>
<div class="line">                    <span class="stringliteral">&quot;load error&quot;</span>,</div>
<div class="line">                    callback = function( evt ) {</div>
<div class="line">                        script.remove();</div>
<div class="line">                        callback = null;</div>
<div class="line">                        if ( evt ) {</div>
<div class="line">                            complete( evt.type === <span class="stringliteral">&quot;error&quot;</span> ? 404 : 200, evt.type );</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                );</div>
<div class="line">                document.head.appendChild( script[ 0 ] );</div>
<div class="line">            },</div>
<div class="line">            abort: function() {</div>
<div class="line">                if ( callback ) {</div>
<div class="line">                    callback();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var oldCallbacks = [],</div>
<div class="line">    rjsonp = /(=)\?(?=&amp;|$)|\?\?/;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Default jsonp settings</span></div>
<div class="line">jQuery.ajaxSetup({</div>
<div class="line">    jsonp: <span class="stringliteral">&quot;callback&quot;</span>,</div>
<div class="line">    jsonpCallback: <span class="keyword">function</span>() {</div>
<div class="line">        var callback = oldCallbacks.pop() || ( jQuery.expando + <span class="stringliteral">&quot;_&quot;</span> + ( nonce++ ) );</div>
<div class="line">        <span class="keyword">this</span>[ callback ] = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">return</span> callback;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Detect, normalize options and install callbacks for jsonp requests</span></div>
<div class="line">jQuery.ajaxPrefilter( <span class="stringliteral">&quot;json jsonp&quot;</span>, <span class="keyword">function</span>( s, originalSettings, jqXHR ) {</div>
<div class="line"></div>
<div class="line">    var callbackName, overwritten, responseContainer,</div>
<div class="line">        jsonProp = s.jsonp !== <span class="keyword">false</span> &amp;&amp; ( rjsonp.test( s.url ) ?</div>
<div class="line">            <span class="stringliteral">&quot;url&quot;</span> :</div>
<div class="line">            typeof s.data === <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; !( s.contentType || <span class="stringliteral">&quot;&quot;</span> ).indexOf(<span class="stringliteral">&quot;application/x-www-form-urlencoded&quot;</span>) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; <span class="stringliteral">&quot;data&quot;</span></div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set</span></div>
<div class="line">    <span class="keywordflow">if</span> ( jsonProp || s.dataTypes[ 0 ] === <span class="stringliteral">&quot;jsonp&quot;</span> ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get callback name, remembering preexisting value associated with it</span></div>
<div class="line">        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?</div>
<div class="line">            s.jsonpCallback() :</div>
<div class="line">            s.jsonpCallback;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Insert callback into url or form data</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jsonProp ) {</div>
<div class="line">            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, <span class="stringliteral">&quot;$1&quot;</span> + callbackName );</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.jsonp !== <span class="keyword">false</span> ) {</div>
<div class="line">            s.url += ( rquery.test( s.url ) ? <span class="stringliteral">&quot;&amp;&quot;</span> : <span class="stringliteral">&quot;?&quot;</span> ) + s.jsonp + <span class="stringliteral">&quot;=&quot;</span> + callbackName;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Use data converter to retrieve json after script execution</span></div>
<div class="line">        s.converters[<span class="stringliteral">&quot;script json&quot;</span>] = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> ( !responseContainer ) {</div>
<div class="line">                jQuery.error( callbackName + <span class="stringliteral">&quot; was not called&quot;</span> );</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> responseContainer[ 0 ];</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// force json dataType</span></div>
<div class="line">        s.dataTypes[ 0 ] = <span class="stringliteral">&quot;json&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Install callback</span></div>
<div class="line">        overwritten = window[ callbackName ];</div>
<div class="line">        window[ callbackName ] = <span class="keyword">function</span>() {</div>
<div class="line">            responseContainer = arguments;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clean-up function (fires after converters)</span></div>
<div class="line">        jqXHR.always(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="comment">// Restore preexisting value</span></div>
<div class="line">            window[ callbackName ] = overwritten;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Save back as free</span></div>
<div class="line">            <span class="keywordflow">if</span> ( s[ callbackName ] ) {</div>
<div class="line">                <span class="comment">// make sure that re-using the options doesn&#39;t screw things around</span></div>
<div class="line">                s.jsonpCallback = originalSettings.jsonpCallback;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// save the callback name for future use</span></div>
<div class="line">                oldCallbacks.push( callbackName );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Call if it was a function and we have a response</span></div>
<div class="line">            <span class="keywordflow">if</span> ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {</div>
<div class="line">                overwritten( responseContainer[ 0 ] );</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            responseContainer = overwritten = undefined;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Delegate to script</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;script&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// data: string of html</span></div>
<div class="line"><span class="comment">// context (optional): If specified, the fragment will be created in this context, defaults to document</span></div>
<div class="line"><span class="comment">// keepScripts (optional): If true, will include scripts passed in the html string</span></div>
<div class="line">jQuery.parseHTML = <span class="keyword">function</span>( data, context, keepScripts ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( !data || typeof data !== <span class="stringliteral">&quot;string&quot;</span> ) {</div>
<div class="line">        <span class="keywordflow">return</span> null;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> ( typeof context === <span class="stringliteral">&quot;boolean&quot;</span> ) {</div>
<div class="line">        keepScripts = context;</div>
<div class="line">        context = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    context = context || document;</div>
<div class="line"></div>
<div class="line">    var parsed = rsingleTag.exec( data ),</div>
<div class="line">        scripts = !keepScripts &amp;&amp; [];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Single tag</span></div>
<div class="line">    <span class="keywordflow">if</span> ( parsed ) {</div>
<div class="line">        <span class="keywordflow">return</span> [ context.createElement( parsed[1] ) ];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    parsed = jQuery.buildFragment( [ data ], context, scripts );</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( scripts &amp;&amp; scripts.length ) {</div>
<div class="line">        jQuery( scripts ).remove();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> jQuery.merge( [], parsed.childNodes );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Keep a copy of the old load method</span></div>
<div class="line">var _load = jQuery.fn.load;</div>
<div class="line"></div>
<div class="line">jQuery.fn.load = <span class="keyword">function</span>( url, params, callback ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( typeof url !== <span class="stringliteral">&quot;string&quot;</span> &amp;&amp; _load ) {</div>
<div class="line">        <span class="keywordflow">return</span> _load.apply( <span class="keyword">this</span>, arguments );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var selector, type, response,</div>
<div class="line">        <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">        off = url.indexOf(<span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( off &gt;= 0 ) {</div>
<div class="line">        selector = jQuery.trim( url.slice( off ) );</div>
<div class="line">        url = url.slice( 0, off );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If it&#39;s a function</span></div>
<div class="line">    <span class="keywordflow">if</span> ( jQuery.isFunction( params ) ) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We assume that it&#39;s the callback</span></div>
<div class="line">        callback = params;</div>
<div class="line">        params = undefined;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Otherwise, build a param string</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( params &amp;&amp; typeof params === <span class="stringliteral">&quot;object&quot;</span> ) {</div>
<div class="line">        type = <span class="stringliteral">&quot;POST&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If we have elements to modify, make the request</span></div>
<div class="line">    <span class="keywordflow">if</span> ( <span class="keyword">self</span>.length &gt; 0 ) {</div>
<div class="line">        jQuery.ajax({</div>
<div class="line">            url: url,</div>
<div class="line"></div>
<div class="line">            <span class="comment">// if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used</span></div>
<div class="line">            type: type,</div>
<div class="line">            dataType: <span class="stringliteral">&quot;html&quot;</span>,</div>
<div class="line">            data: params</div>
<div class="line">        }).done(<span class="keyword">function</span>( responseText ) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Save response for use in complete callback</span></div>
<div class="line">            response = arguments;</div>
<div class="line"></div>
<div class="line">            <span class="keyword">self</span>.html( selector ?</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If a selector was specified, locate the right elements in a dummy div</span></div>
<div class="line">                <span class="comment">// Exclude scripts to avoid IE &#39;Permission Denied&#39; errors</span></div>
<div class="line">                jQuery(<span class="stringliteral">&quot;&lt;div&gt;&quot;</span>).append( jQuery.parseHTML( responseText ) ).find( selector ) :</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Otherwise use the full result</span></div>
<div class="line">                responseText );</div>
<div class="line"></div>
<div class="line">        }).complete( callback &amp;&amp; <span class="keyword">function</span>( jqXHR, status ) {</div>
<div class="line">            <span class="keyword">self</span>.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">jQuery.expr.filters.animated = <span class="keyword">function</span>( elem ) {</div>
<div class="line">    <span class="keywordflow">return</span> jQuery.grep(jQuery.timers, <span class="keyword">function</span>( fn ) {</div>
<div class="line">        return elem === fn.elem;</div>
<div class="line">    }).length;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var docElem = window.document.documentElement;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getWindow( elem ) {</div>
<div class="line">    <span class="keywordflow">return</span> jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">jQuery.offset = {</div>
<div class="line">    setOffset: <span class="keyword">function</span>( elem, options, i ) {</div>
<div class="line">        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,</div>
<div class="line">            position = jQuery.css( elem, <span class="stringliteral">&quot;position&quot;</span> ),</div>
<div class="line">            curElem = jQuery( elem ),</div>
<div class="line">            props = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set position first, in-case top/left are set even on static elem</span></div>
<div class="line">        <span class="keywordflow">if</span> ( position === <span class="stringliteral">&quot;static&quot;</span> ) {</div>
<div class="line">            elem.style.position = <span class="stringliteral">&quot;relative&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        curOffset = curElem.offset();</div>
<div class="line">        curCSSTop = jQuery.css( elem, <span class="stringliteral">&quot;top&quot;</span> );</div>
<div class="line">        curCSSLeft = jQuery.css( elem, <span class="stringliteral">&quot;left&quot;</span> );</div>
<div class="line">        calculatePosition = ( position === <span class="stringliteral">&quot;absolute&quot;</span> || position === <span class="stringliteral">&quot;fixed&quot;</span> ) &amp;&amp;</div>
<div class="line">            ( curCSSTop + curCSSLeft ).indexOf(<span class="stringliteral">&quot;auto&quot;</span>) &gt; -1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed</span></div>
<div class="line">        <span class="keywordflow">if</span> ( calculatePosition ) {</div>
<div class="line">            curPosition = curElem.position();</div>
<div class="line">            curTop = curPosition.top;</div>
<div class="line">            curLeft = curPosition.left;</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            curTop = parseFloat( curCSSTop ) || 0;</div>
<div class="line">            curLeft = parseFloat( curCSSLeft ) || 0;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.isFunction( options ) ) {</div>
<div class="line">            options = options.call( elem, i, curOffset );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( options.top != null ) {</div>
<div class="line">            props.top = ( options.top - curOffset.top ) + curTop;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ( options.left != null ) {</div>
<div class="line">            props.left = ( options.left - curOffset.left ) + curLeft;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( <span class="stringliteral">&quot;using&quot;</span> in options ) {</div>
<div class="line">            options.using.call( elem, props );</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            curElem.css( props );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fn.extend({</div>
<div class="line">    offset: <span class="keyword">function</span>( options ) {</div>
<div class="line">        <span class="keywordflow">if</span> ( arguments.length ) {</div>
<div class="line">            <span class="keywordflow">return</span> options === undefined ?</div>
<div class="line">                <span class="keyword">this</span> :</div>
<div class="line">                this.each(<span class="keyword">function</span>( i ) {</div>
<div class="line">                    jQuery.offset.setOffset( <span class="keyword">this</span>, options, i );</div>
<div class="line">                });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var docElem, win,</div>
<div class="line">            elem = <span class="keyword">this</span>[ 0 ],</div>
<div class="line">            box = { top: 0, left: 0 },</div>
<div class="line">            doc = elem &amp;&amp; elem.ownerDocument;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !doc ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        docElem = doc.documentElement;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure it&#39;s not a disconnected DOM node</span></div>
<div class="line">        <span class="keywordflow">if</span> ( !jQuery.contains( docElem, elem ) ) {</div>
<div class="line">            <span class="keywordflow">return</span> box;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we don&#39;t have gBCR, just use 0,0 rather than error</span></div>
<div class="line">        <span class="comment">// BlackBerry 5, iOS 3 (original iPhone)</span></div>
<div class="line">        <span class="keywordflow">if</span> ( typeof elem.getBoundingClientRect !== strundefined ) {</div>
<div class="line">            box = elem.getBoundingClientRect();</div>
<div class="line">        }</div>
<div class="line">        win = getWindow( doc );</div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            top: box.top + win.pageYOffset - docElem.clientTop,</div>
<div class="line">            left: box.left + win.pageXOffset - docElem.clientLeft</div>
<div class="line">        };</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    position: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> ( !<span class="keyword">this</span>[ 0 ] ) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var offsetParent, offset,</div>
<div class="line">            elem = <span class="keyword">this</span>[ 0 ],</div>
<div class="line">            parentOffset = { top: 0, left: 0 };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent</span></div>
<div class="line">        <span class="keywordflow">if</span> ( jQuery.css( elem, <span class="stringliteral">&quot;position&quot;</span> ) === <span class="stringliteral">&quot;fixed&quot;</span> ) {</div>
<div class="line">            <span class="comment">// We assume that getBoundingClientRect is available when computed position is fixed</span></div>
<div class="line">            offset = elem.getBoundingClientRect();</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Get *real* offsetParent</span></div>
<div class="line">            offsetParent = this.offsetParent();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get correct offsets</span></div>
<div class="line">            offset = this.offset();</div>
<div class="line">            <span class="keywordflow">if</span> ( !jQuery.nodeName( offsetParent[ 0 ], <span class="stringliteral">&quot;html&quot;</span> ) ) {</div>
<div class="line">                parentOffset = offsetParent.offset();</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add offsetParent borders</span></div>
<div class="line">            parentOffset.top += jQuery.css( offsetParent[ 0 ], <span class="stringliteral">&quot;borderTopWidth&quot;</span>, <span class="keyword">true</span> );</div>
<div class="line">            parentOffset.left += jQuery.css( offsetParent[ 0 ], <span class="stringliteral">&quot;borderLeftWidth&quot;</span>, <span class="keyword">true</span> );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Subtract parent offsets and element margins</span></div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            top: offset.top - parentOffset.top - jQuery.css( elem, <span class="stringliteral">&quot;marginTop&quot;</span>, <span class="keyword">true</span> ),</div>
<div class="line">            left: offset.left - parentOffset.left - jQuery.css( elem, <span class="stringliteral">&quot;marginLeft&quot;</span>, <span class="keyword">true</span> )</div>
<div class="line">        };</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    offsetParent: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> this.map(<span class="keyword">function</span>() {</div>
<div class="line">            var offsetParent = this.offsetParent || docElem;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">while</span> ( offsetParent &amp;&amp; ( !jQuery.nodeName( offsetParent, <span class="stringliteral">&quot;html&quot;</span> ) &amp;&amp; jQuery.css( offsetParent, <span class="stringliteral">&quot;position&quot;</span> ) === <span class="stringliteral">&quot;static&quot;</span> ) ) {</div>
<div class="line">                offsetParent = offsetParent.offsetParent;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> offsetParent || docElem;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create scrollLeft and scrollTop methods</span></div>
<div class="line">jQuery.each( { scrollLeft: <span class="stringliteral">&quot;pageXOffset&quot;</span>, scrollTop: <span class="stringliteral">&quot;pageYOffset&quot;</span> }, <span class="keyword">function</span>( method, prop ) {</div>
<div class="line">    var top = <span class="stringliteral">&quot;pageYOffset&quot;</span> === prop;</div>
<div class="line"></div>
<div class="line">    jQuery.fn[ method ] = <span class="keyword">function</span>( val ) {</div>
<div class="line">        <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( elem, method, val ) {</div>
<div class="line">            var win = getWindow( elem );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( val === undefined ) {</div>
<div class="line">                <span class="keywordflow">return</span> win ? win[ prop ] : elem[ method ];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ( win ) {</div>
<div class="line">                win.scrollTo(</div>
<div class="line">                    !top ? val : window.pageXOffset,</div>
<div class="line">                    top ? val : window.pageYOffset</div>
<div class="line">                );</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                elem[ method ] = val;</div>
<div class="line">            }</div>
<div class="line">        }, method, val, arguments.length, null );</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add the top/left cssHooks using jQuery.fn.position</span></div>
<div class="line"><span class="comment">// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084</span></div>
<div class="line"><span class="comment">// getComputedStyle returns percent when specified for top/left/bottom/right</span></div>
<div class="line"><span class="comment">// rather than make the css module depend on the offset module, we just check for it here</span></div>
<div class="line">jQuery.each( [ <span class="stringliteral">&quot;top&quot;</span>, <span class="stringliteral">&quot;left&quot;</span> ], <span class="keyword">function</span>( i, prop ) {</div>
<div class="line">    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,</div>
<div class="line">        <span class="keyword">function</span>( elem, computed ) {</div>
<div class="line">            if ( computed ) {</div>
<div class="line">                computed = curCSS( elem, prop );</div>
<div class="line">                <span class="comment">// if curCSS returns percentage, fallback to offset</span></div>
<div class="line">                return rnumnonpx.test( computed ) ?</div>
<div class="line">                    jQuery( elem ).position()[ prop ] + <span class="stringliteral">&quot;px&quot;</span> :</div>
<div class="line">                    computed;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods</span></div>
<div class="line">jQuery.each( { Height: <span class="stringliteral">&quot;height&quot;</span>, Width: <span class="stringliteral">&quot;width&quot;</span> }, <span class="keyword">function</span>( name, type ) {</div>
<div class="line">    jQuery.each( { padding: <span class="stringliteral">&quot;inner&quot;</span> + name, content: type, <span class="stringliteral">&quot;&quot;</span>: <span class="stringliteral">&quot;outer&quot;</span> + name }, <span class="keyword">function</span>( defaultExtra, funcName ) {</div>
<div class="line">        <span class="comment">// margin is only for outerHeight, outerWidth</span></div>
<div class="line">        jQuery.fn[ funcName ] = <span class="keyword">function</span>( margin, value ) {</div>
<div class="line">            var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== <span class="stringliteral">&quot;boolean&quot;</span> ),</div>
<div class="line">                extra = defaultExtra || ( margin === <span class="keyword">true</span> || value === <span class="keyword">true</span> ? <span class="stringliteral">&quot;margin&quot;</span> : <span class="stringliteral">&quot;border&quot;</span> );</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> access( <span class="keyword">this</span>, <span class="keyword">function</span>( elem, type, value ) {</div>
<div class="line">                var doc;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> ( jQuery.isWindow( elem ) ) {</div>
<div class="line">                    <span class="comment">// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there</span></div>
<div class="line">                    <span class="comment">// isn&#39;t a whole lot we can do. See pull request at this URL for discussion:</span></div>
<div class="line">                    <span class="comment">// https://github.com/jquery/jquery/pull/764</span></div>
<div class="line">                    <span class="keywordflow">return</span> elem.document.documentElement[ <span class="stringliteral">&quot;client&quot;</span> + name ];</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Get document width or height</span></div>
<div class="line">                <span class="keywordflow">if</span> ( elem.nodeType === 9 ) {</div>
<div class="line">                    doc = elem.documentElement;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],</span></div>
<div class="line">                    <span class="comment">// whichever is greatest</span></div>
<div class="line">                    <span class="keywordflow">return</span> Math.max(</div>
<div class="line">                        elem.body[ <span class="stringliteral">&quot;scroll&quot;</span> + name ], doc[ <span class="stringliteral">&quot;scroll&quot;</span> + name ],</div>
<div class="line">                        elem.body[ <span class="stringliteral">&quot;offset&quot;</span> + name ], doc[ <span class="stringliteral">&quot;offset&quot;</span> + name ],</div>
<div class="line">                        doc[ <span class="stringliteral">&quot;client&quot;</span> + name ]</div>
<div class="line">                    );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> value === undefined ?</div>
<div class="line">                    <span class="comment">// Get width or height on the element, requesting but not forcing parseFloat</span></div>
<div class="line">                    jQuery.css( elem, type, extra ) :</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Set width or height on the element</span></div>
<div class="line">                    jQuery.style( elem, type, value, extra );</div>
<div class="line">            }, type, chainable ? margin : undefined, chainable, null );</div>
<div class="line">        };</div>
<div class="line">    });</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The number of elements contained in the matched element set</span></div>
<div class="line">jQuery.fn.size = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.length;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">jQuery.fn.andSelf = jQuery.fn.addBack;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Register as a named AMD module, since jQuery can be concatenated with other</span></div>
<div class="line"><span class="comment">// files that may use define, but not via a proper concatenation script that</span></div>
<div class="line"><span class="comment">// understands anonymous AMD modules. A named AMD is safest and most robust</span></div>
<div class="line"><span class="comment">// way to register. Lowercase jquery is used because AMD module names are</span></div>
<div class="line"><span class="comment">// derived from file names, and jQuery is normally delivered in a lowercase</span></div>
<div class="line"><span class="comment">// file name. Do this after creating the global so that if an AMD module wants</span></div>
<div class="line"><span class="comment">// to call noConflict to hide this version of jQuery, it will work.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Note that for maximum portability, libraries that are not jQuery should</span></div>
<div class="line"><span class="comment">// declare themselves as anonymous modules, and avoid setting a global if an</span></div>
<div class="line"><span class="comment">// AMD loader is present. jQuery is a special case. For more information, see</span></div>
<div class="line"><span class="comment">// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ( typeof define === <span class="stringliteral">&quot;function&quot;</span> &amp;&amp; define.amd ) {</div>
<div class="line">    define( <span class="stringliteral">&quot;jquery&quot;</span>, [], <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> jQuery;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    <span class="comment">// Map over jQuery in case of overwrite</span></div>
<div class="line">    _jQuery = window.jQuery,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Map over the $ in case of overwrite</span></div>
<div class="line">    _$ = window.$;</div>
<div class="line"></div>
<div class="line">jQuery.noConflict = <span class="keyword">function</span>( deep ) {</div>
<div class="line">    <span class="keywordflow">if</span> ( window.$ === jQuery ) {</div>
<div class="line">        window.$ = _$;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( deep &amp;&amp; window.jQuery === jQuery ) {</div>
<div class="line">        window.jQuery = _jQuery;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> jQuery;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Expose jQuery and $ identifiers, even in</span></div>
<div class="line"><span class="comment">// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span></div>
<div class="line"><span class="comment">// and CommonJS for browser emulators (#13566)</span></div>
<div class="line"><span class="keywordflow">if</span> ( typeof noGlobal === strundefined ) {</div>
<div class="line">    window.jQuery = window.$ = jQuery;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">return</span> jQuery;</div>
<div class="line"></div>
<div class="line">}));</div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>(window, document){</div>
<div class="line">  var _jQuery = window.jQuery.noConflict(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> minErr(module, ErrorConstructor) {</div>
<div class="line">  ErrorConstructor = ErrorConstructor || Error;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    var SKIP_INDEXES = 2;</div>
<div class="line"></div>
<div class="line">    var templateArgs = arguments,</div>
<div class="line">      code = templateArgs[0],</div>
<div class="line">      message = <span class="charliteral">&#39;[&#39;</span> + (module ? module + <span class="charliteral">&#39;:&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + code + <span class="stringliteral">&#39;] &#39;</span>,</div>
<div class="line">      <span class="keyword">template</span> = templateArgs[1],</div>
<div class="line">      paramPrefix, i;</div>
<div class="line"></div>
<div class="line">    message += <span class="keyword">template</span>.replace(/\{\d+\}/g, <span class="keyword">function</span>(match) {</div>
<div class="line">      var index = +match.slice(1, -1),</div>
<div class="line">        shiftedIndex = index + SKIP_INDEXES;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (shiftedIndex &lt; templateArgs.length) {</div>
<div class="line">        <span class="keywordflow">return</span> toDebugString(templateArgs[shiftedIndex]);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> match;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    message += <span class="stringliteral">&#39;\nhttp://errors.angularjs.org/1.4.4/&#39;</span> +</div>
<div class="line">      (module ? module + <span class="charliteral">&#39;/&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + code;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = SKIP_INDEXES, paramPrefix = <span class="charliteral">&#39;?&#39;</span>; i &lt; templateArgs.length; i++, paramPrefix = <span class="charliteral">&#39;&amp;&#39;</span>) {</div>
<div class="line">      message += paramPrefix + <span class="charliteral">&#39;p&#39;</span> + (i - SKIP_INDEXES) + <span class="charliteral">&#39;=&#39;</span> +</div>
<div class="line">        encodeURIComponent(toDebugString(templateArgs[i]));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ErrorConstructor(message);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* We need to tell jshint what variables are being exported */</span></div>
<div class="line"><span class="comment">/* global angular: true,</span></div>
<div class="line"><span class="comment">  msie: true,</span></div>
<div class="line"><span class="comment">  jqLite: true,</span></div>
<div class="line"><span class="comment">  jQuery: true,</span></div>
<div class="line"><span class="comment">  slice: true,</span></div>
<div class="line"><span class="comment">  splice: true,</span></div>
<div class="line"><span class="comment">  push: true,</span></div>
<div class="line"><span class="comment">  toString: true,</span></div>
<div class="line"><span class="comment">  ngMinErr: true,</span></div>
<div class="line"><span class="comment">  angularModule: true,</span></div>
<div class="line"><span class="comment">  uid: true,</span></div>
<div class="line"><span class="comment">  REGEX_STRING_REGEXP: true,</span></div>
<div class="line"><span class="comment">  VALIDITY_STATE_PROPERTY: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  lowercase: true,</span></div>
<div class="line"><span class="comment">  uppercase: true,</span></div>
<div class="line"><span class="comment">  manualLowercase: true,</span></div>
<div class="line"><span class="comment">  manualUppercase: true,</span></div>
<div class="line"><span class="comment">  nodeName_: true,</span></div>
<div class="line"><span class="comment">  isArrayLike: true,</span></div>
<div class="line"><span class="comment">  forEach: true,</span></div>
<div class="line"><span class="comment">  forEachSorted: true,</span></div>
<div class="line"><span class="comment">  reverseParams: true,</span></div>
<div class="line"><span class="comment">  nextUid: true,</span></div>
<div class="line"><span class="comment">  setHashKey: true,</span></div>
<div class="line"><span class="comment">  extend: true,</span></div>
<div class="line"><span class="comment">  toInt: true,</span></div>
<div class="line"><span class="comment">  inherit: true,</span></div>
<div class="line"><span class="comment">  merge: true,</span></div>
<div class="line"><span class="comment">  noop: true,</span></div>
<div class="line"><span class="comment">  identity: true,</span></div>
<div class="line"><span class="comment">  valueFn: true,</span></div>
<div class="line"><span class="comment">  isUndefined: true,</span></div>
<div class="line"><span class="comment">  isDefined: true,</span></div>
<div class="line"><span class="comment">  isObject: true,</span></div>
<div class="line"><span class="comment">  isBlankObject: true,</span></div>
<div class="line"><span class="comment">  isString: true,</span></div>
<div class="line"><span class="comment">  isNumber: true,</span></div>
<div class="line"><span class="comment">  isDate: true,</span></div>
<div class="line"><span class="comment">  isArray: true,</span></div>
<div class="line"><span class="comment">  isFunction: true,</span></div>
<div class="line"><span class="comment">  isRegExp: true,</span></div>
<div class="line"><span class="comment">  isWindow: true,</span></div>
<div class="line"><span class="comment">  isScope: true,</span></div>
<div class="line"><span class="comment">  isFile: true,</span></div>
<div class="line"><span class="comment">  isFormData: true,</span></div>
<div class="line"><span class="comment">  isBlob: true,</span></div>
<div class="line"><span class="comment">  isBoolean: true,</span></div>
<div class="line"><span class="comment">  isPromiseLike: true,</span></div>
<div class="line"><span class="comment">  trim: true,</span></div>
<div class="line"><span class="comment">  escapeForRegexp: true,</span></div>
<div class="line"><span class="comment">  isElement: true,</span></div>
<div class="line"><span class="comment">  makeMap: true,</span></div>
<div class="line"><span class="comment">  includes: true,</span></div>
<div class="line"><span class="comment">  arrayRemove: true,</span></div>
<div class="line"><span class="comment">  copy: true,</span></div>
<div class="line"><span class="comment">  shallowCopy: true,</span></div>
<div class="line"><span class="comment">  equals: true,</span></div>
<div class="line"><span class="comment">  csp: true,</span></div>
<div class="line"><span class="comment">  jq: true,</span></div>
<div class="line"><span class="comment">  concat: true,</span></div>
<div class="line"><span class="comment">  sliceArgs: true,</span></div>
<div class="line"><span class="comment">  bind: true,</span></div>
<div class="line"><span class="comment">  toJsonReplacer: true,</span></div>
<div class="line"><span class="comment">  toJson: true,</span></div>
<div class="line"><span class="comment">  fromJson: true,</span></div>
<div class="line"><span class="comment">  convertTimezoneToLocal: true,</span></div>
<div class="line"><span class="comment">  timezoneToOffset: true,</span></div>
<div class="line"><span class="comment">  startingTag: true,</span></div>
<div class="line"><span class="comment">  tryDecodeURIComponent: true,</span></div>
<div class="line"><span class="comment">  parseKeyValue: true,</span></div>
<div class="line"><span class="comment">  toKeyValue: true,</span></div>
<div class="line"><span class="comment">  encodeUriSegment: true,</span></div>
<div class="line"><span class="comment">  encodeUriQuery: true,</span></div>
<div class="line"><span class="comment">  angularInit: true,</span></div>
<div class="line"><span class="comment">  bootstrap: true,</span></div>
<div class="line"><span class="comment">  getTestability: true,</span></div>
<div class="line"><span class="comment">  snake_case: true,</span></div>
<div class="line"><span class="comment">  bindJQuery: true,</span></div>
<div class="line"><span class="comment">  assertArg: true,</span></div>
<div class="line"><span class="comment">  assertArgFn: true,</span></div>
<div class="line"><span class="comment">  assertNotHasOwnProperty: true,</span></div>
<div class="line"><span class="comment">  getter: true,</span></div>
<div class="line"><span class="comment">  getBlockNodes: true,</span></div>
<div class="line"><span class="comment">  hasOwnProperty: true,</span></div>
<div class="line"><span class="comment">  createMap: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  NODE_TYPE_ELEMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_ATTRIBUTE: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_TEXT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_COMMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_DOCUMENT: true,</span></div>
<div class="line"><span class="comment">  NODE_TYPE_DOCUMENT_FRAGMENT: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The name of a form control&#39;s ValidityState property.</span></div>
<div class="line"><span class="comment">// This is used so that it&#39;s possible for internal tests to create mock ValidityStates.</span></div>
<div class="line">var VALIDITY_STATE_PROPERTY = <span class="stringliteral">&#39;validity&#39;</span>;</div>
<div class="line"></div>
<div class="line">var lowercase = <span class="keyword">function</span>(string) {<span class="keywordflow">return</span> isString(<span class="keywordtype">string</span>) ? <span class="keywordtype">string</span>.toLowerCase() : string;};</div>
<div class="line">var hasOwnProperty = Object.prototype.hasOwnProperty;</div>
<div class="line"></div>
<div class="line">var uppercase = <span class="keyword">function</span>(string) {<span class="keywordflow">return</span> isString(<span class="keywordtype">string</span>) ? <span class="keywordtype">string</span>.toUpperCase() : string;};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var manualLowercase = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="comment">/* jshint bitwise: false */</span></div>
<div class="line">  <span class="keywordflow">return</span> isString(s)</div>
<div class="line">      ? s.replace(/[A-Z]/g, <span class="keyword">function</span>(ch) {<span class="keywordflow">return</span> String.fromCharCode(ch.charCodeAt(0) | 32);})</div>
<div class="line">      : s;</div>
<div class="line">};</div>
<div class="line">var manualUppercase = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="comment">/* jshint bitwise: false */</span></div>
<div class="line">  <span class="keywordflow">return</span> isString(s)</div>
<div class="line">      ? s.replace(/[a-z]/g, <span class="keyword">function</span>(ch) {<span class="keywordflow">return</span> String.fromCharCode(ch.charCodeAt(0) &amp; ~32);})</div>
<div class="line">      : s;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// String#toLowerCase and String#toUpperCase don&#39;t produce correct results in browsers with Turkish</span></div>
<div class="line"><span class="comment">// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods</span></div>
<div class="line"><span class="comment">// with correct but slower alternatives.</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="charliteral">&#39;i&#39;</span> !== <span class="charliteral">&#39;I&#39;</span>.toLowerCase()) {</div>
<div class="line">  lowercase = manualLowercase;</div>
<div class="line">  uppercase = manualUppercase;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var</div>
<div class="line">    msie,             <span class="comment">// holds major version number for IE, or NaN if UA is not IE.</span></div>
<div class="line">    jqLite,           <span class="comment">// delay binding since jQuery could be loaded after us.</span></div>
<div class="line">    jQuery,           <span class="comment">// delay binding</span></div>
<div class="line">    slice             = [].slice,</div>
<div class="line">    splice            = [].splice,</div>
<div class="line">    push              = [].push,</div>
<div class="line">    toString          = Object.prototype.toString,</div>
<div class="line">    getPrototypeOf    = Object.getPrototypeOf,</div>
<div class="line">    ngMinErr          = minErr(<span class="stringliteral">&#39;ng&#39;</span>),</div>
<div class="line"></div>
<div class="line">    angular           = window.angular || (window.angular = {}),</div>
<div class="line">    angularModule,</div>
<div class="line">    uid               = 0;</div>
<div class="line"></div>
<div class="line">msie = document.documentMode;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isArrayLike(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj == null || isWindow(obj)) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Support: iOS 8.2 (not reproducible in simulator)</span></div>
<div class="line">  <span class="comment">// &quot;length&quot; in obj used to prevent JIT error (gh-11508)</span></div>
<div class="line">  var length = <span class="stringliteral">&quot;length&quot;</span> in Object(obj) &amp;&amp; obj.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (obj.nodeType === NODE_TYPE_ELEMENT &amp;&amp; length) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> isString(obj) || isArray(obj) || length === 0 ||</div>
<div class="line">         typeof length === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> forEach(obj, iterator, context) {</div>
<div class="line">  var key, length;</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (isFunction(obj)) {</div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="comment">// Need to check if hasOwnProperty exists,</span></div>
<div class="line">        <span class="comment">// as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function</span></div>
<div class="line">        <span class="keywordflow">if</span> (key != <span class="stringliteral">&#39;prototype&#39;</span> &amp;&amp; key != <span class="stringliteral">&#39;length&#39;</span> &amp;&amp; key != <span class="stringliteral">&#39;name&#39;</span> &amp;&amp; (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(obj) || isArrayLike(obj)) {</div>
<div class="line">      var isPrimitive = typeof obj !== <span class="stringliteral">&#39;object&#39;</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (key = 0, length = obj.length; key &lt; length; key++) {</div>
<div class="line">        <span class="keywordflow">if</span> (isPrimitive || key in obj) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj.forEach &amp;&amp; obj.forEach !== forEach) {</div>
<div class="line">        obj.forEach(iterator, context, obj);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isBlankObject(obj)) {</div>
<div class="line">      <span class="comment">// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        iterator.call(context, obj[key], key, obj);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj.hasOwnProperty === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      <span class="comment">// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="keywordflow">if</span> (obj.hasOwnProperty(key)) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Slow path for objects which do not have a method `hasOwnProperty`</span></div>
<div class="line">      <span class="keywordflow">for</span> (key in obj) {</div>
<div class="line">        <span class="keywordflow">if</span> (hasOwnProperty.call(obj, key)) {</div>
<div class="line">          iterator.call(context, obj[key], key, obj);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> forEachSorted(obj, iterator, context) {</div>
<div class="line">  var keys = Object.keys(obj).sort();</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; keys.length; i++) {</div>
<div class="line">    iterator.call(context, obj[keys[i]], keys[i]);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> keys;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> reverseParams(iteratorFn) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(value, key) { iteratorFn(key, value); };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nextUid() {</div>
<div class="line">  <span class="keywordflow">return</span> ++uid;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setHashKey(obj, h) {</div>
<div class="line">  <span class="keywordflow">if</span> (h) {</div>
<div class="line">    obj.$$hashKey = h;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keyword">delete</span> obj.$$hashKey;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> baseExtend(dst, objs, deep) {</div>
<div class="line">  var h = dst.$$hashKey;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0, ii = objs.length; i &lt; ii; ++i) {</div>
<div class="line">    var obj = objs[i];</div>
<div class="line">    <span class="keywordflow">if</span> (!isObject(obj) &amp;&amp; !isFunction(obj)) <span class="keywordflow">continue</span>;</div>
<div class="line">    var keys = Object.keys(obj);</div>
<div class="line">    <span class="keywordflow">for</span> (var j = 0, jj = keys.length; j &lt; jj; j++) {</div>
<div class="line">      var key = keys[j];</div>
<div class="line">      var src = obj[key];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (deep &amp;&amp; isObject(src)) {</div>
<div class="line">        <span class="keywordflow">if</span> (isDate(src)) {</div>
<div class="line">          dst[key] = <span class="keyword">new</span> Date(src.valueOf());</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(src)) {</div>
<div class="line">          dst[key] = <span class="keyword">new</span> RegExp(src);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};</div>
<div class="line">          baseExtend(dst[key], [src], <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        dst[key] = src;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  setHashKey(dst, h);</div>
<div class="line">  <span class="keywordflow">return</span> dst;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> extend(dst) {</div>
<div class="line">  <span class="keywordflow">return</span> baseExtend(dst, slice.call(arguments, 1), <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> merge(dst) {</div>
<div class="line">  <span class="keywordflow">return</span> baseExtend(dst, slice.call(arguments, 1), <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toInt(str) {</div>
<div class="line">  <span class="keywordflow">return</span> parseInt(str, 10);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> inherit(parent, extra) {</div>
<div class="line">  <span class="keywordflow">return</span> extend(Object.create(parent), extra);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> noop() {}</div>
<div class="line">noop.$inject = [];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> identity($) {<span class="keywordflow">return</span> $;}</div>
<div class="line">identity.$inject = [];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> valueFn(value) {<span class="keywordflow">return</span> <span class="keyword">function</span>() {<span class="keywordflow">return</span> value;};}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> hasCustomToString(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> isFunction(obj.toString) &amp;&amp; obj.toString !== Object.prototype.toString;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isUndefined(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;undefined&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isDefined(value) {<span class="keywordflow">return</span> typeof value !== <span class="stringliteral">&#39;undefined&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isObject(value) {</div>
<div class="line">  <span class="comment">// http://jsperf.com/isobject4</span></div>
<div class="line">  <span class="keywordflow">return</span> value !== null &amp;&amp; typeof value === <span class="stringliteral">&#39;object&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBlankObject(value) {</div>
<div class="line">  <span class="keywordflow">return</span> value !== null &amp;&amp; typeof value === <span class="stringliteral">&#39;object&#39;</span> &amp;&amp; !getPrototypeOf(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isString(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;string&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isNumber(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;number&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isDate(value) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(value) === <span class="stringliteral">&#39;[object Date]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var isArray = Array.isArray;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFunction(value) {<span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;function&#39;</span>;}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isRegExp(value) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(value) === <span class="stringliteral">&#39;[object RegExp]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isWindow(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; obj.window === obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isScope(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFile(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object File]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isFormData(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object FormData]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBlob(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> toString.call(obj) === <span class="stringliteral">&#39;[object Blob]&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isBoolean(value) {</div>
<div class="line">  <span class="keywordflow">return</span> typeof value === <span class="stringliteral">&#39;boolean&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isPromiseLike(obj) {</div>
<div class="line">  <span class="keywordflow">return</span> obj &amp;&amp; isFunction(obj.then);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;</div>
<div class="line"><span class="keyword">function</span> isTypedArray(value) {</div>
<div class="line">  <span class="keywordflow">return</span> TYPED_ARRAY_REGEXP.test(toString.call(value));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var trim = <span class="keyword">function</span>(value) {</div>
<div class="line">  <span class="keywordflow">return</span> isString(value) ? value.trim() : value;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copied from:</span></div>
<div class="line"><span class="comment">// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021</span></div>
<div class="line"><span class="comment">// Prereq: s is a string.</span></div>
<div class="line">var escapeForRegexp = <span class="keyword">function</span>(s) {</div>
<div class="line">  <span class="keywordflow">return</span> s.replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, <span class="stringliteral">&#39;\\$1&#39;</span>).</div>
<div class="line">           replace(/\x08/g, <span class="stringliteral">&#39;\\x08&#39;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isElement(node) {</div>
<div class="line">  <span class="keywordflow">return</span> !!(node &amp;&amp;</div>
<div class="line">    (node.nodeName  <span class="comment">// we are a direct element</span></div>
<div class="line">    || (node.prop &amp;&amp; node.attr &amp;&amp; node.find)));  <span class="comment">// we have an on and find method part of jQuery API</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> makeMap(str) {</div>
<div class="line">  var obj = {}, items = str.split(<span class="stringliteral">&quot;,&quot;</span>), i;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; items.length; i++) {</div>
<div class="line">    obj[items[i]] = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nodeName_(element) {</div>
<div class="line">  <span class="keywordflow">return</span> lowercase(element.nodeName || (element[0] &amp;&amp; element[0].nodeName));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> includes(array, obj) {</div>
<div class="line">  <span class="keywordflow">return</span> Array.prototype.indexOf.call(array, obj) != -1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> arrayRemove(array, value) {</div>
<div class="line">  var index = array.indexOf(value);</div>
<div class="line">  <span class="keywordflow">if</span> (index &gt;= 0) {</div>
<div class="line">    array.splice(index, 1);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> index;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> copy(source, destination, stackSource, stackDest) {</div>
<div class="line">  <span class="keywordflow">if</span> (isWindow(source) || isScope(source)) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpws&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! Making copies of Window or Scope instances is not supported.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (isTypedArray(destination)) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpta&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! TypedArray destination cannot be mutated.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!destination) {</div>
<div class="line">    destination = source;</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(source)) {</div>
<div class="line">      var index;</div>
<div class="line">      <span class="keywordflow">if</span> (stackSource &amp;&amp; (index = stackSource.indexOf(source)) !== -1) {</div>
<div class="line">        <span class="keywordflow">return</span> stackDest[index];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// TypedArray, Date and RegExp have specific copy functionality and must be</span></div>
<div class="line">      <span class="comment">// pushed onto the stack before returning.</span></div>
<div class="line">      <span class="comment">// Array and other objects create the base object and recurse to copy child</span></div>
<div class="line">      <span class="comment">// objects. The array/object will be pushed onto the stack when recursed.</span></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(source)) {</div>
<div class="line">        <span class="keywordflow">return</span> copy(source, [], stackSource, stackDest);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isTypedArray(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> source.constructor(source);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDate(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> Date(source.getTime());</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(source)) {</div>
<div class="line">        destination = <span class="keyword">new</span> RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);</div>
<div class="line">        destination.lastIndex = source.lastIndex;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var emptyObject = Object.create(getPrototypeOf(source));</div>
<div class="line">        <span class="keywordflow">return</span> copy(source, emptyObject, stackSource, stackDest);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (stackDest) {</div>
<div class="line">        stackSource.push(source);</div>
<div class="line">        stackDest.push(destination);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (source === destination) <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;cpi&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Can&#39;t copy! Source and destination are identical.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    stackSource = stackSource || [];</div>
<div class="line">    stackDest = stackDest || [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isObject(source)) {</div>
<div class="line">      stackSource.push(source);</div>
<div class="line">      stackDest.push(destination);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var result, key;</div>
<div class="line">    <span class="keywordflow">if</span> (isArray(source)) {</div>
<div class="line">      destination.length = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; source.length; i++) {</div>
<div class="line">        destination.push(copy(source[i], null, stackSource, stackDest));</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var h = destination.$$hashKey;</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(destination)) {</div>
<div class="line">        destination.length = 0;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        forEach(destination, <span class="keyword">function</span>(value, key) {</div>
<div class="line">          <span class="keyword">delete</span> destination[key];</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isBlankObject(source)) {</div>
<div class="line">        <span class="comment">// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (source &amp;&amp; typeof source.hasOwnProperty === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">        <span class="comment">// Slow path, which must rely on hasOwnProperty</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          <span class="keywordflow">if</span> (source.hasOwnProperty(key)) {</div>
<div class="line">            destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Slowest path --- hasOwnProperty can&#39;t be called as a method</span></div>
<div class="line">        <span class="keywordflow">for</span> (key in source) {</div>
<div class="line">          <span class="keywordflow">if</span> (hasOwnProperty.call(source, key)) {</div>
<div class="line">            destination[key] = copy(source[key], null, stackSource, stackDest);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      setHashKey(destination,h);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> destination;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> shallowCopy(src, dst) {</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(src)) {</div>
<div class="line">    dst = dst || [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = src.length; i &lt; ii; i++) {</div>
<div class="line">      dst[i] = src[i];</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(src)) {</div>
<div class="line">    dst = dst || {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var key in src) {</div>
<div class="line">      <span class="keywordflow">if</span> (!(key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> &amp;&amp; key.charAt(1) === <span class="charliteral">&#39;$&#39;</span>)) {</div>
<div class="line">        dst[key] = src[key];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> dst || src;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> equals(o1, o2) {</div>
<div class="line">  <span class="keywordflow">if</span> (o1 === o2) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (o1 === null || o2 === null) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (o1 !== o1 &amp;&amp; o2 !== o2) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// NaN === NaN</span></div>
<div class="line">  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;</div>
<div class="line">  <span class="keywordflow">if</span> (t1 == t2) {</div>
<div class="line">    <span class="keywordflow">if</span> (t1 == <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(o1)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!isArray(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> ((length = o1.length) == o2.length) {</div>
<div class="line">          <span class="keywordflow">for</span> (key = 0; key &lt; length; key++) {</div>
<div class="line">            <span class="keywordflow">if</span> (!equals(o1[key], o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDate(o1)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!isDate(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">return</span> equals(o1.getTime(), o2.getTime());</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(o1)) {</div>
<div class="line">        <span class="keywordflow">return</span> isRegExp(o2) ? o1.toString() == o2.toString() : <span class="keyword">false</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||</div>
<div class="line">          isArray(o2) || isDate(o2) || isRegExp(o2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        keySet = createMap();</div>
<div class="line">        <span class="keywordflow">for</span> (key in o1) {</div>
<div class="line">          <span class="keywordflow">if</span> (key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> || isFunction(o1[key])) <span class="keywordflow">continue</span>;</div>
<div class="line">          <span class="keywordflow">if</span> (!equals(o1[key], o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          keySet[key] = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (key in o2) {</div>
<div class="line">          <span class="keywordflow">if</span> (!(key in keySet) &amp;&amp;</div>
<div class="line">              key.charAt(0) !== <span class="charliteral">&#39;$&#39;</span> &amp;&amp;</div>
<div class="line">              o2[key] !== undefined &amp;&amp;</div>
<div class="line">              !isFunction(o2[key])) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var csp = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">if</span> (!isDefined(csp.rules)) {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    var ngCspElement = (document.querySelector(<span class="stringliteral">&#39;[ng-csp]&#39;</span>) ||</div>
<div class="line">                    document.querySelector(<span class="stringliteral">&#39;[data-ng-csp]&#39;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (ngCspElement) {</div>
<div class="line">      var ngCspAttribute = ngCspElement.getAttribute(<span class="stringliteral">&#39;ng-csp&#39;</span>) ||</div>
<div class="line">                    ngCspElement.getAttribute(<span class="stringliteral">&#39;data-ng-csp&#39;</span>);</div>
<div class="line">      csp.rules = {</div>
<div class="line">        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf(<span class="stringliteral">&#39;no-unsafe-eval&#39;</span>) !== -1),</div>
<div class="line">        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf(<span class="stringliteral">&#39;no-inline-style&#39;</span>) !== -1)</div>
<div class="line">      };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      csp.rules = {</div>
<div class="line">        noUnsafeEval: noUnsafeEval(),</div>
<div class="line">        noInlineStyle: <span class="keyword">false</span></div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> csp.rules;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> noUnsafeEval() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="comment">/* jshint -W031, -W054 */</span></div>
<div class="line">      <span class="keyword">new</span> Function(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      <span class="comment">/* jshint +W031, +W054 */</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var jq = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(jq.name_)) <span class="keywordflow">return</span> jq.name_;</div>
<div class="line">  var el;</div>
<div class="line">  var i, ii = ngAttrPrefixes.length, prefix, name;</div>
<div class="line">  for (i = 0; i &lt; ii; ++i) {</div>
<div class="line">    prefix = ngAttrPrefixes[i];</div>
<div class="line">    <span class="keywordflow">if</span> (el = document.querySelector(<span class="charliteral">&#39;[&#39;</span> + prefix.replace(<span class="charliteral">&#39;:&#39;</span>, <span class="stringliteral">&#39;\\:&#39;</span>) + <span class="stringliteral">&#39;jq]&#39;</span>)) {</div>
<div class="line">      name = el.getAttribute(prefix + <span class="stringliteral">&#39;jq&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> (jq.name_ = name);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> concat(array1, array2, index) {</div>
<div class="line">  <span class="keywordflow">return</span> array1.concat(slice.call(array2, index));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> sliceArgs(args, startIndex) {</div>
<div class="line">  <span class="keywordflow">return</span> slice.call(args, startIndex || 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint -W101 */</span></div>
<div class="line"><span class="comment">/* jshint +W101 */</span></div>
<div class="line"><span class="keyword">function</span> bind(<span class="keyword">self</span>, fn) {</div>
<div class="line">  var curryArgs = arguments.length &gt; 2 ? sliceArgs(arguments, 2) : [];</div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {</div>
<div class="line">    <span class="keywordflow">return</span> curryArgs.length</div>
<div class="line">      ? <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> arguments.length</div>
<div class="line">            ? fn.apply(<span class="keyword">self</span>, concat(curryArgs, arguments, 0))</div>
<div class="line">            : fn.apply(<span class="keyword">self</span>, curryArgs);</div>
<div class="line">        }</div>
<div class="line">      : <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> arguments.length</div>
<div class="line">            ? fn.apply(<span class="keyword">self</span>, arguments)</div>
<div class="line">            : fn.call(<span class="keyword">self</span>);</div>
<div class="line">        };</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// in IE, native methods are not functions so they cannot be bound (note: they don&#39;t need to be)</span></div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toJsonReplacer(key, value) {</div>
<div class="line">  var val = value;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (typeof key === <span class="stringliteral">&#39;string&#39;</span> &amp;&amp; key.charAt(0) === <span class="charliteral">&#39;$&#39;</span> &amp;&amp; key.charAt(1) === <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">    val = undefined;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isWindow(value)) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$WINDOW&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &amp;&amp;  document === value) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$DOCUMENT&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isScope(value)) {</div>
<div class="line">    val = <span class="stringliteral">&#39;$SCOPE&#39;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> val;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toJson(obj, pretty) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> undefined;</div>
<div class="line">  <span class="keywordflow">if</span> (!isNumber(pretty)) {</div>
<div class="line">    pretty = pretty ? 2 : null;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> JSON.stringify(obj, toJsonReplacer, pretty);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> fromJson(json) {</div>
<div class="line">  <span class="keywordflow">return</span> isString(json)</div>
<div class="line">      ? JSON.parse(json)</div>
<div class="line">      : json;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> timezoneToOffset(timezone, fallback) {</div>
<div class="line">  var requestedTimezoneOffset = Date.parse(<span class="stringliteral">&#39;Jan 01, 1970 00:00:00 &#39;</span> + timezone) / 60000;</div>
<div class="line">  <span class="keywordflow">return</span> isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> addDateMinutes(date, minutes) {</div>
<div class="line">  date = <span class="keyword">new</span> Date(date.getTime());</div>
<div class="line">  date.setMinutes(date.getMinutes() + minutes);</div>
<div class="line">  <span class="keywordflow">return</span> date;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> convertTimezoneToLocal(date, timezone, reverse) {</div>
<div class="line">  reverse = reverse ? -1 : 1;</div>
<div class="line">  var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());</div>
<div class="line">  <span class="keywordflow">return</span> addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> startingTag(element) {</div>
<div class="line">  element = jqLite(element).clone();</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// turns out IE does not let you set .html() on elements which</span></div>
<div class="line">    <span class="comment">// are not allowed to have children. So we just ignore it.</span></div>
<div class="line">    element.empty();</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {}</div>
<div class="line">  var elemHtml = jqLite(<span class="stringliteral">&#39;&lt;div&gt;&#39;</span>).append(element).html();</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">return</span> element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :</div>
<div class="line">        elemHtml.</div>
<div class="line">          match(/^(&lt;[^&gt;]+&gt;)/)[1].</div>
<div class="line">          replace(/^&lt;([\w\-]+)/, function(match, nodeName) { <span class="keywordflow">return</span> <span class="charliteral">&#39;&lt;&#39;</span> + lowercase(nodeName); });</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">    <span class="keywordflow">return</span> lowercase(elemHtml);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> tryDecodeURIComponent(value) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">return</span> decodeURIComponent(value);</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">    <span class="comment">// Ignore any invalid uri component</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> parseKeyValue(keyValue) {</div>
<div class="line">  var obj = {};</div>
<div class="line">  forEach((keyValue || <span class="stringliteral">&quot;&quot;</span>).split(<span class="charliteral">&#39;&amp;&#39;</span>), <span class="keyword">function</span>(keyValue) {</div>
<div class="line">    var splitPoint, key, val;</div>
<div class="line">    <span class="keywordflow">if</span> (keyValue) {</div>
<div class="line">      key = keyValue = keyValue.replace(/\+/g,<span class="stringliteral">&#39;%20&#39;</span>);</div>
<div class="line">      splitPoint = keyValue.indexOf(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (splitPoint !== -1) {</div>
<div class="line">        key = keyValue.substring(0, splitPoint);</div>
<div class="line">        val = keyValue.substring(splitPoint + 1);</div>
<div class="line">      }</div>
<div class="line">      key = tryDecodeURIComponent(key);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(key)) {</div>
<div class="line">        val = isDefined(val) ? tryDecodeURIComponent(val) : true;</div>
<div class="line">        <span class="keywordflow">if</span> (!hasOwnProperty.call(obj, key)) {</div>
<div class="line">          obj[key] = val;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(obj[key])) {</div>
<div class="line">          obj[key].push(val);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          obj[key] = [obj[key],val];</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toKeyValue(obj) {</div>
<div class="line">  var parts = [];</div>
<div class="line">  forEach(obj, <span class="keyword">function</span>(value, key) {</div>
<div class="line">    <span class="keywordflow">if</span> (isArray(value)) {</div>
<div class="line">      forEach(value, <span class="keyword">function</span>(arrayValue) {</div>
<div class="line">        parts.push(encodeUriQuery(key, <span class="keyword">true</span>) +</div>
<div class="line">                   (arrayValue === <span class="keyword">true</span> ? <span class="stringliteral">&#39;&#39;</span> : <span class="charliteral">&#39;=&#39;</span> + encodeUriQuery(arrayValue, <span class="keyword">true</span>)));</div>
<div class="line">      });</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">    parts.push(encodeUriQuery(key, <span class="keyword">true</span>) +</div>
<div class="line">               (value === <span class="keyword">true</span> ? <span class="stringliteral">&#39;&#39;</span> : <span class="charliteral">&#39;=&#39;</span> + encodeUriQuery(value, <span class="keyword">true</span>)));</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> parts.length ? parts.join(<span class="charliteral">&#39;&amp;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> encodeUriSegment(val) {</div>
<div class="line">  <span class="keywordflow">return</span> encodeUriQuery(val, <span class="keyword">true</span>).</div>
<div class="line">             replace(/%26/gi, <span class="charliteral">&#39;&amp;&#39;</span>).</div>
<div class="line">             replace(/%3D/gi, <span class="charliteral">&#39;=&#39;</span>).</div>
<div class="line">             replace(/%2B/gi, <span class="charliteral">&#39;+&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> encodeUriQuery(val, pctEncodeSpaces) {</div>
<div class="line">  <span class="keywordflow">return</span> encodeURIComponent(val).</div>
<div class="line">             replace(/%40/gi, <span class="charliteral">&#39;@&#39;</span>).</div>
<div class="line">             replace(/%3A/gi, <span class="charliteral">&#39;:&#39;</span>).</div>
<div class="line">             replace(/%24/g, <span class="charliteral">&#39;$&#39;</span>).</div>
<div class="line">             replace(/%2C/gi, <span class="charliteral">&#39;,&#39;</span>).</div>
<div class="line">             replace(/%3B/gi, <span class="charliteral">&#39;;&#39;</span>).</div>
<div class="line">             replace(/%20/g, (pctEncodeSpaces ? <span class="stringliteral">&#39;%20&#39;</span> : <span class="charliteral">&#39;+&#39;</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngAttrPrefixes = [<span class="stringliteral">&#39;ng-&#39;</span>, <span class="stringliteral">&#39;data-ng-&#39;</span>, <span class="stringliteral">&#39;ng:&#39;</span>, <span class="stringliteral">&#39;x-ng-&#39;</span>];</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getNgAttribute(element, ngAttr) {</div>
<div class="line">  var attr, i, ii = ngAttrPrefixes.length;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; ii; ++i) {</div>
<div class="line">    attr = ngAttrPrefixes[i] + ngAttr;</div>
<div class="line">    <span class="keywordflow">if</span> (isString(attr = element.getAttribute(attr))) {</div>
<div class="line">      <span class="keywordflow">return</span> attr;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> null;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> angularInit(element, bootstrap) {</div>
<div class="line">  var appElement,</div>
<div class="line">      module,</div>
<div class="line">      config = {};</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The element `element` has priority over any other element</span></div>
<div class="line">  forEach(ngAttrPrefixes, <span class="keyword">function</span>(prefix) {</div>
<div class="line">    var name = prefix + <span class="stringliteral">&#39;app&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name)) {</div>
<div class="line">      appElement = element;</div>
<div class="line">      module = element.getAttribute(name);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  forEach(ngAttrPrefixes, <span class="keyword">function</span>(prefix) {</div>
<div class="line">    var name = prefix + <span class="stringliteral">&#39;app&#39;</span>;</div>
<div class="line">    var candidate;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!appElement &amp;&amp; (candidate = element.querySelector(<span class="charliteral">&#39;[&#39;</span> + name.replace(<span class="charliteral">&#39;:&#39;</span>, <span class="stringliteral">&#39;\\:&#39;</span>) + <span class="charliteral">&#39;]&#39;</span>))) {</div>
<div class="line">      appElement = candidate;</div>
<div class="line">      module = candidate.getAttribute(name);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">if</span> (appElement) {</div>
<div class="line">    config.strictDi = getNgAttribute(appElement, <span class="stringliteral">&quot;strict-di&quot;</span>) !== null;</div>
<div class="line">    bootstrap(appElement, module ? [module] : [], config);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> bootstrap(element, modules, config) {</div>
<div class="line">  <span class="keywordflow">if</span> (!isObject(config)) config = {};</div>
<div class="line">  var defaultConfig = {</div>
<div class="line">    strictDi: <span class="keyword">false</span></div>
<div class="line">  };</div>
<div class="line">  config = extend(defaultConfig, config);</div>
<div class="line">  var doBootstrap = <span class="keyword">function</span>() {</div>
<div class="line">    element = jqLite(element);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (element.injector()) {</div>
<div class="line">      var tag = (element[0] === document) ? <span class="stringliteral">&#39;document&#39;</span> : startingTag(element);</div>
<div class="line">      <span class="comment">//Encode angle brackets to prevent input from being sanitized to empty string #8683</span></div>
<div class="line">      <span class="keywordflow">throw</span> ngMinErr(</div>
<div class="line">          <span class="stringliteral">&#39;btstrpd&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;App Already Bootstrapped with this Element &#39;{0}&#39;&quot;</span>,</div>
<div class="line">          tag.replace(/&lt;/,<span class="stringliteral">&#39;&amp;lt;&#39;</span>).replace(/&gt;/,<span class="stringliteral">&#39;&amp;gt;&#39;</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    modules = modules || [];</div>
<div class="line">    modules.unshift([<span class="stringliteral">&#39;$provide&#39;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">      $provide.value(<span class="stringliteral">&#39;$rootElement&#39;</span>, element);</div>
<div class="line">    }]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (config.debugInfoEnabled) {</div>
<div class="line">      <span class="comment">// Pushing so that this overrides `debugInfoEnabled` setting defined in user&#39;s `modules`.</span></div>
<div class="line">      modules.push([<span class="stringliteral">&#39;$compileProvider&#39;</span>, <span class="keyword">function</span>($compileProvider) {</div>
<div class="line">        $compileProvider.debugInfoEnabled(<span class="keyword">true</span>);</div>
<div class="line">      }]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    modules.unshift(<span class="stringliteral">&#39;ng&#39;</span>);</div>
<div class="line">    var injector = createInjector(modules, config.strictDi);</div>
<div class="line">    injector.invoke([<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$rootElement&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="stringliteral">&#39;$injector&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span> bootstrapApply(scope, element, compile, injector) {</div>
<div class="line">        scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">          element.data(<span class="stringliteral">&#39;$injector&#39;</span>, injector);</div>
<div class="line">          compile(element)(scope);</div>
<div class="line">        });</div>
<div class="line">      }]</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> injector;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;</div>
<div class="line">  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (window &amp;&amp; NG_ENABLE_DEBUG_INFO.test(window.name)) {</div>
<div class="line">    config.debugInfoEnabled = <span class="keyword">true</span>;</div>
<div class="line">    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {</div>
<div class="line">    <span class="keywordflow">return</span> doBootstrap();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  angular.resumeBootstrap = <span class="keyword">function</span>(extraModules) {</div>
<div class="line">    forEach(extraModules, <span class="keyword">function</span>(module) {</div>
<div class="line">      modules.push(module);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> doBootstrap();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(angular.resumeDeferredBootstrap)) {</div>
<div class="line">    angular.resumeDeferredBootstrap();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> reloadWithDebugInfo() {</div>
<div class="line">  window.name = <span class="stringliteral">&#39;NG_ENABLE_DEBUG_INFO!&#39;</span> + window.name;</div>
<div class="line">  window.location.reload();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getTestability(rootElement) {</div>
<div class="line">  var injector = angular.element(rootElement).injector();</div>
<div class="line">  <span class="keywordflow">if</span> (!injector) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;test&#39;</span>,</div>
<div class="line">      <span class="stringliteral">&#39;no injector found for element argument to getTestability&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> injector.get(<span class="stringliteral">&#39;$$testability&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var SNAKE_CASE_REGEXP = /[A-Z]/g;</div>
<div class="line"><span class="keyword">function</span> snake_case(name, separator) {</div>
<div class="line">  separator = separator || <span class="charliteral">&#39;_&#39;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> name.replace(SNAKE_CASE_REGEXP, <span class="keyword">function</span>(letter, pos) {</div>
<div class="line">    <span class="keywordflow">return</span> (pos ? separator : <span class="stringliteral">&#39;&#39;</span>) + letter.toLowerCase();</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var bindJQueryFired = <span class="keyword">false</span>;</div>
<div class="line">var skipDestroyOnNextJQueryCleanData;</div>
<div class="line"><span class="keyword">function</span> bindJQuery() {</div>
<div class="line">  var originalCleanData;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (bindJQueryFired) {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// bind to jQuery if present;</span></div>
<div class="line">  var jqName = jq();</div>
<div class="line">  jQuery = window.jQuery; <span class="comment">// use default jQuery.</span></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(jqName)) { <span class="comment">// `ngJq` present</span></div>
<div class="line">    jQuery = jqName === null ? undefined : window[jqName]; <span class="comment">// if empty; use jqLite. if not empty, use jQuery specified by `ngJq`.</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Use jQuery if it exists with proper functionality, otherwise default to us.</span></div>
<div class="line">  <span class="comment">// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.</span></div>
<div class="line">  <span class="comment">// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older</span></div>
<div class="line">  <span class="comment">// versions. It will not work for sure with jQuery &lt;1.7, though.</span></div>
<div class="line">  <span class="keywordflow">if</span> (jQuery &amp;&amp; jQuery.fn.on) {</div>
<div class="line">    jqLite = jQuery;</div>
<div class="line">    extend(jQuery.fn, {</div>
<div class="line">      scope: JQLitePrototype.scope,</div>
<div class="line">      isolateScope: JQLitePrototype.isolateScope,</div>
<div class="line">      controller: JQLitePrototype.controller,</div>
<div class="line">      injector: JQLitePrototype.injector,</div>
<div class="line">      inheritedData: JQLitePrototype.inheritedData</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// All nodes removed from the DOM via various jQuery APIs like .remove()</span></div>
<div class="line">    <span class="comment">// are passed through jQuery.cleanData. Monkey-patch this method to fire</span></div>
<div class="line">    <span class="comment">// the $destroy event on all removed nodes.</span></div>
<div class="line">    originalCleanData = jQuery.cleanData;</div>
<div class="line">    jQuery.cleanData = <span class="keyword">function</span>(elems) {</div>
<div class="line">      var events;</div>
<div class="line">      <span class="keywordflow">if</span> (!skipDestroyOnNextJQueryCleanData) {</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, elem; (elem = elems[i]) != null; i++) {</div>
<div class="line">          events = jQuery._data(elem, <span class="stringliteral">&quot;events&quot;</span>);</div>
<div class="line">          <span class="keywordflow">if</span> (events &amp;&amp; events.$destroy) {</div>
<div class="line">            jQuery(elem).triggerHandler(<span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        skipDestroyOnNextJQueryCleanData = <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      originalCleanData(elems);</div>
<div class="line">    };</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    jqLite = JQLite;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  angular.element = jqLite;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Prevent double-proxying.</span></div>
<div class="line">  bindJQueryFired = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertArg(arg, name, reason) {</div>
<div class="line">  <span class="keywordflow">if</span> (!arg) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;areq&#39;</span>, <span class="stringliteral">&quot;Argument &#39;{0}&#39; is {1}&quot;</span>, (name || <span class="charliteral">&#39;?&#39;</span>), (reason || <span class="stringliteral">&quot;required&quot;</span>));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> arg;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertArgFn(arg, name, acceptArrayAnnotation) {</div>
<div class="line">  <span class="keywordflow">if</span> (acceptArrayAnnotation &amp;&amp; isArray(arg)) {</div>
<div class="line">      arg = arg[arg.length - 1];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  assertArg(isFunction(arg), name, <span class="stringliteral">&#39;not a function, got &#39;</span> +</div>
<div class="line">      (arg &amp;&amp; typeof arg === <span class="stringliteral">&#39;object&#39;</span> ? arg.constructor.name || <span class="stringliteral">&#39;Object&#39;</span> : typeof arg));</div>
<div class="line">  <span class="keywordflow">return</span> arg;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assertNotHasOwnProperty(name, context) {</div>
<div class="line">  <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;hasOwnProperty&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;badname&#39;</span>, <span class="stringliteral">&quot;hasOwnProperty is not a valid {0} name&quot;</span>, context);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//TODO(misko): this function needs to be removed</span></div>
<div class="line"><span class="keyword">function</span> getter(obj, path, bindFnToScope) {</div>
<div class="line">  <span class="keywordflow">if</span> (!path) <span class="keywordflow">return</span> obj;</div>
<div class="line">  var keys = path.split(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">  var key;</div>
<div class="line">  var lastInstance = obj;</div>
<div class="line">  var len = keys.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; len; i++) {</div>
<div class="line">    key = keys[i];</div>
<div class="line">    <span class="keywordflow">if</span> (obj) {</div>
<div class="line">      obj = (lastInstance = obj)[key];</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!bindFnToScope &amp;&amp; isFunction(obj)) {</div>
<div class="line">    <span class="keywordflow">return</span> bind(lastInstance, obj);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getBlockNodes(nodes) {</div>
<div class="line">  <span class="comment">// TODO(perf): just check if all items in `nodes` are siblings and if they are return the original</span></div>
<div class="line">  <span class="comment">//             collection, otherwise update the original collection.</span></div>
<div class="line">  var node = nodes[0];</div>
<div class="line">  var endNode = nodes[nodes.length - 1];</div>
<div class="line">  var blockNodes = [node];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    node = node.nextSibling;</div>
<div class="line">    <span class="keywordflow">if</span> (!node) <span class="keywordflow">break</span>;</div>
<div class="line">    blockNodes.push(node);</div>
<div class="line">  } <span class="keywordflow">while</span> (node !== endNode);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> jqLite(blockNodes);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createMap() {</div>
<div class="line">  <span class="keywordflow">return</span> Object.create(null);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var NODE_TYPE_ELEMENT = 1;</div>
<div class="line">var NODE_TYPE_ATTRIBUTE = 2;</div>
<div class="line">var NODE_TYPE_TEXT = 3;</div>
<div class="line">var NODE_TYPE_COMMENT = 8;</div>
<div class="line">var NODE_TYPE_DOCUMENT = 9;</div>
<div class="line">var NODE_TYPE_DOCUMENT_FRAGMENT = 11;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> setupModuleLoader(window) {</div>
<div class="line"></div>
<div class="line">  var $injectorMinErr = minErr(<span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line">  var ngMinErr = minErr(<span class="stringliteral">&#39;ng&#39;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> ensure(obj, name, factory) {</div>
<div class="line">    <span class="keywordflow">return</span> obj[name] || (obj[name] = factory());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var angular = ensure(window, <span class="stringliteral">&#39;angular&#39;</span>, Object);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap</span></div>
<div class="line">  angular.$$minErr = angular.$$minErr || minErr;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> ensure(angular, <span class="stringliteral">&#39;module&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    var modules = {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> module(name, requires, configFn) {</div>
<div class="line">      var assertNotHasOwnProperty = <span class="keyword">function</span>(name, context) {</div>
<div class="line">        <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;hasOwnProperty&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">throw</span> ngMinErr(<span class="stringliteral">&#39;badname&#39;</span>, <span class="stringliteral">&#39;hasOwnProperty is not a valid {0} name&#39;</span>, context);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      assertNotHasOwnProperty(name, <span class="stringliteral">&#39;module&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (requires &amp;&amp; modules.hasOwnProperty(name)) {</div>
<div class="line">        modules[name] = null;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> ensure(modules, name, <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!requires) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;nomod&#39;</span>, <span class="stringliteral">&quot;Module &#39;{0}&#39; is not available! You either misspelled &quot;</span> +</div>
<div class="line">             <span class="stringliteral">&quot;the module name or forgot to load it. If registering a module ensure that you &quot;</span> +</div>
<div class="line">             <span class="stringliteral">&quot;specify the dependencies as the second argument.&quot;</span>, name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var invokeQueue = [];</div>
<div class="line"></div>
<div class="line">        var configBlocks = [];</div>
<div class="line"></div>
<div class="line">        var runBlocks = [];</div>
<div class="line"></div>
<div class="line">        var config = invokeLater(<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;invoke&#39;</span>, <span class="stringliteral">&#39;push&#39;</span>, configBlocks);</div>
<div class="line"></div>
<div class="line">        var moduleInstance = {</div>
<div class="line">          <span class="comment">// Private state</span></div>
<div class="line">          _invokeQueue: invokeQueue,</div>
<div class="line">          _configBlocks: configBlocks,</div>
<div class="line">          _runBlocks: runBlocks,</div>
<div class="line"></div>
<div class="line">          requires: requires,</div>
<div class="line"></div>
<div class="line">          name: name,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">          provider: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;provider&#39;</span>),</div>
<div class="line"></div>
<div class="line">          factory: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;factory&#39;</span>),</div>
<div class="line"></div>
<div class="line">          service: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;service&#39;</span>),</div>
<div class="line"></div>
<div class="line">          value: invokeLater(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;value&#39;</span>),</div>
<div class="line"></div>
<div class="line">          constant: invokeLater(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;constant&#39;</span>, <span class="stringliteral">&#39;unshift&#39;</span>),</div>
<div class="line"></div>
<div class="line">          decorator: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;decorator&#39;</span>),</div>
<div class="line"></div>
<div class="line">          animation: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$animateProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          filter: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$filterProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          controller: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$controllerProvider&#39;</span>, <span class="stringliteral">&#39;register&#39;</span>),</div>
<div class="line"></div>
<div class="line">          directive: invokeLaterAndSetModuleName(<span class="stringliteral">&#39;$compileProvider&#39;</span>, <span class="stringliteral">&#39;directive&#39;</span>),</div>
<div class="line"></div>
<div class="line">          config: config,</div>
<div class="line"></div>
<div class="line">          run: <span class="keyword">function</span>(block) {</div>
<div class="line">            runBlocks.push(block);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (configFn) {</div>
<div class="line">          config(configFn);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> invokeLater(provider, method, insertMethod, queue) {</div>
<div class="line">          <span class="keywordflow">if</span> (!queue) queue = invokeQueue;</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            queue[insertMethod || <span class="stringliteral">&#39;push&#39;</span>]([provider, method, arguments]);</div>
<div class="line">            <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> invokeLaterAndSetModuleName(provider, method) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>(recipeName, factoryFunction) {</div>
<div class="line">            <span class="keywordflow">if</span> (factoryFunction &amp;&amp; isFunction(factoryFunction)) factoryFunction.$$moduleName = name;</div>
<div class="line">            invokeQueue.push([provider, method, arguments]);</div>
<div class="line">            <span class="keywordflow">return</span> moduleInstance;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global: toDebugString: true */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> serializeObject(obj) {</div>
<div class="line">  var seen = [];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> JSON.stringify(obj, <span class="keyword">function</span>(key, val) {</div>
<div class="line">    val = toJsonReplacer(key, val);</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(val)) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (seen.indexOf(val) &gt;= 0) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&lt;&lt;already seen&gt;&gt;&#39;</span>;</div>
<div class="line"></div>
<div class="line">      seen.push(val);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> toDebugString(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> obj.toString().replace(/ \{[\s\S]*$/, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj === <span class="stringliteral">&#39;undefined&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;undefined&#39;</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof obj !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> serializeObject(obj);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global angularModule: true,</span></div>
<div class="line"><span class="comment">  version: true,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  $CompileProvider,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  htmlAnchorDirective,</span></div>
<div class="line"><span class="comment">  inputDirective,</span></div>
<div class="line"><span class="comment">  inputDirective,</span></div>
<div class="line"><span class="comment">  formDirective,</span></div>
<div class="line"><span class="comment">  scriptDirective,</span></div>
<div class="line"><span class="comment">  selectDirective,</span></div>
<div class="line"><span class="comment">  styleDirective,</span></div>
<div class="line"><span class="comment">  optionDirective,</span></div>
<div class="line"><span class="comment">  ngBindDirective,</span></div>
<div class="line"><span class="comment">  ngBindHtmlDirective,</span></div>
<div class="line"><span class="comment">  ngBindTemplateDirective,</span></div>
<div class="line"><span class="comment">  ngClassDirective,</span></div>
<div class="line"><span class="comment">  ngClassEvenDirective,</span></div>
<div class="line"><span class="comment">  ngClassOddDirective,</span></div>
<div class="line"><span class="comment">  ngCloakDirective,</span></div>
<div class="line"><span class="comment">  ngControllerDirective,</span></div>
<div class="line"><span class="comment">  ngFormDirective,</span></div>
<div class="line"><span class="comment">  ngHideDirective,</span></div>
<div class="line"><span class="comment">  ngIfDirective,</span></div>
<div class="line"><span class="comment">  ngIncludeDirective,</span></div>
<div class="line"><span class="comment">  ngIncludeFillContentDirective,</span></div>
<div class="line"><span class="comment">  ngInitDirective,</span></div>
<div class="line"><span class="comment">  ngNonBindableDirective,</span></div>
<div class="line"><span class="comment">  ngPluralizeDirective,</span></div>
<div class="line"><span class="comment">  ngRepeatDirective,</span></div>
<div class="line"><span class="comment">  ngShowDirective,</span></div>
<div class="line"><span class="comment">  ngStyleDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchWhenDirective,</span></div>
<div class="line"><span class="comment">  ngSwitchDefaultDirective,</span></div>
<div class="line"><span class="comment">  ngOptionsDirective,</span></div>
<div class="line"><span class="comment">  ngTranscludeDirective,</span></div>
<div class="line"><span class="comment">  ngModelDirective,</span></div>
<div class="line"><span class="comment">  ngListDirective,</span></div>
<div class="line"><span class="comment">  ngChangeDirective,</span></div>
<div class="line"><span class="comment">  patternDirective,</span></div>
<div class="line"><span class="comment">  patternDirective,</span></div>
<div class="line"><span class="comment">  requiredDirective,</span></div>
<div class="line"><span class="comment">  requiredDirective,</span></div>
<div class="line"><span class="comment">  minlengthDirective,</span></div>
<div class="line"><span class="comment">  minlengthDirective,</span></div>
<div class="line"><span class="comment">  maxlengthDirective,</span></div>
<div class="line"><span class="comment">  maxlengthDirective,</span></div>
<div class="line"><span class="comment">  ngValueDirective,</span></div>
<div class="line"><span class="comment">  ngModelOptionsDirective,</span></div>
<div class="line"><span class="comment">  ngAttributeAliasDirectives,</span></div>
<div class="line"><span class="comment">  ngEventDirectives,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  $AnchorScrollProvider,</span></div>
<div class="line"><span class="comment">  $AnimateProvider,</span></div>
<div class="line"><span class="comment">  $CoreAnimateCssProvider,</span></div>
<div class="line"><span class="comment">  $$CoreAnimateQueueProvider,</span></div>
<div class="line"><span class="comment">  $$CoreAnimateRunnerProvider,</span></div>
<div class="line"><span class="comment">  $BrowserProvider,</span></div>
<div class="line"><span class="comment">  $CacheFactoryProvider,</span></div>
<div class="line"><span class="comment">  $ControllerProvider,</span></div>
<div class="line"><span class="comment">  $DocumentProvider,</span></div>
<div class="line"><span class="comment">  $ExceptionHandlerProvider,</span></div>
<div class="line"><span class="comment">  $FilterProvider,</span></div>
<div class="line"><span class="comment">  $$ForceReflowProvider,</span></div>
<div class="line"><span class="comment">  $InterpolateProvider,</span></div>
<div class="line"><span class="comment">  $IntervalProvider,</span></div>
<div class="line"><span class="comment">  $$HashMapProvider,</span></div>
<div class="line"><span class="comment">  $HttpProvider,</span></div>
<div class="line"><span class="comment">  $HttpParamSerializerProvider,</span></div>
<div class="line"><span class="comment">  $HttpParamSerializerJQLikeProvider,</span></div>
<div class="line"><span class="comment">  $HttpBackendProvider,</span></div>
<div class="line"><span class="comment">  $LocationProvider,</span></div>
<div class="line"><span class="comment">  $LogProvider,</span></div>
<div class="line"><span class="comment">  $ParseProvider,</span></div>
<div class="line"><span class="comment">  $RootScopeProvider,</span></div>
<div class="line"><span class="comment">  $QProvider,</span></div>
<div class="line"><span class="comment">  $$QProvider,</span></div>
<div class="line"><span class="comment">  $$SanitizeUriProvider,</span></div>
<div class="line"><span class="comment">  $SceProvider,</span></div>
<div class="line"><span class="comment">  $SceDelegateProvider,</span></div>
<div class="line"><span class="comment">  $SnifferProvider,</span></div>
<div class="line"><span class="comment">  $TemplateCacheProvider,</span></div>
<div class="line"><span class="comment">  $TemplateRequestProvider,</span></div>
<div class="line"><span class="comment">  $$TestabilityProvider,</span></div>
<div class="line"><span class="comment">  $TimeoutProvider,</span></div>
<div class="line"><span class="comment">  $$RAFProvider,</span></div>
<div class="line"><span class="comment">  $WindowProvider,</span></div>
<div class="line"><span class="comment">  $$jqLiteProvider,</span></div>
<div class="line"><span class="comment">  $$CookieReaderProvider</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var version = {</div>
<div class="line">  full: <span class="stringliteral">&#39;1.4.4&#39;</span>,    <span class="comment">// all of these placeholder strings will be replaced by grunt&#39;s</span></div>
<div class="line">  major: 1,    <span class="comment">// package task</span></div>
<div class="line">  minor: 4,</div>
<div class="line">  dot: 4,</div>
<div class="line">  codeName: <span class="stringliteral">&#39;pylon-requirement&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> publishExternalAPI(angular) {</div>
<div class="line">  extend(angular, {</div>
<div class="line">    <span class="stringliteral">&#39;bootstrap&#39;</span>: bootstrap,</div>
<div class="line">    <span class="stringliteral">&#39;copy&#39;</span>: copy,</div>
<div class="line">    <span class="stringliteral">&#39;extend&#39;</span>: extend,</div>
<div class="line">    <span class="stringliteral">&#39;merge&#39;</span>: merge,</div>
<div class="line">    <span class="stringliteral">&#39;equals&#39;</span>: equals,</div>
<div class="line">    <span class="stringliteral">&#39;element&#39;</span>: jqLite,</div>
<div class="line">    <span class="stringliteral">&#39;forEach&#39;</span>: forEach,</div>
<div class="line">    <span class="stringliteral">&#39;injector&#39;</span>: createInjector,</div>
<div class="line">    <span class="stringliteral">&#39;noop&#39;</span>: noop,</div>
<div class="line">    <span class="stringliteral">&#39;bind&#39;</span>: bind,</div>
<div class="line">    <span class="stringliteral">&#39;toJson&#39;</span>: toJson,</div>
<div class="line">    <span class="stringliteral">&#39;fromJson&#39;</span>: fromJson,</div>
<div class="line">    <span class="stringliteral">&#39;identity&#39;</span>: identity,</div>
<div class="line">    <span class="stringliteral">&#39;isUndefined&#39;</span>: isUndefined,</div>
<div class="line">    <span class="stringliteral">&#39;isDefined&#39;</span>: isDefined,</div>
<div class="line">    <span class="stringliteral">&#39;isString&#39;</span>: isString,</div>
<div class="line">    <span class="stringliteral">&#39;isFunction&#39;</span>: isFunction,</div>
<div class="line">    <span class="stringliteral">&#39;isObject&#39;</span>: isObject,</div>
<div class="line">    <span class="stringliteral">&#39;isNumber&#39;</span>: isNumber,</div>
<div class="line">    <span class="stringliteral">&#39;isElement&#39;</span>: isElement,</div>
<div class="line">    <span class="stringliteral">&#39;isArray&#39;</span>: isArray,</div>
<div class="line">    <span class="stringliteral">&#39;version&#39;</span>: version,</div>
<div class="line">    <span class="stringliteral">&#39;isDate&#39;</span>: isDate,</div>
<div class="line">    <span class="stringliteral">&#39;lowercase&#39;</span>: lowercase,</div>
<div class="line">    <span class="stringliteral">&#39;uppercase&#39;</span>: uppercase,</div>
<div class="line">    <span class="stringliteral">&#39;callbacks&#39;</span>: {counter: 0},</div>
<div class="line">    <span class="stringliteral">&#39;getTestability&#39;</span>: getTestability,</div>
<div class="line">    <span class="stringliteral">&#39;$$minErr&#39;</span>: minErr,</div>
<div class="line">    <span class="stringliteral">&#39;$$csp&#39;</span>: csp,</div>
<div class="line">    <span class="stringliteral">&#39;reloadWithDebugInfo&#39;</span>: reloadWithDebugInfo</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  angularModule = setupModuleLoader(window);</div>
<div class="line"></div>
<div class="line">  angularModule(<span class="stringliteral">&#39;ng&#39;</span>, [<span class="stringliteral">&#39;ngLocale&#39;</span>], [<span class="stringliteral">&#39;$provide&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span> ngModule($provide) {</div>
<div class="line">      <span class="comment">// $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.</span></div>
<div class="line">      $provide.provider({</div>
<div class="line">        $$sanitizeUri: $$SanitizeUriProvider</div>
<div class="line">      });</div>
<div class="line">      $provide.provider(<span class="stringliteral">&#39;$compile&#39;</span>, $CompileProvider).</div>
<div class="line">        directive({</div>
<div class="line">            a: htmlAnchorDirective,</div>
<div class="line">            input: inputDirective,</div>
<div class="line">            textarea: inputDirective,</div>
<div class="line">            form: formDirective,</div>
<div class="line">            script: scriptDirective,</div>
<div class="line">            select: selectDirective,</div>
<div class="line">            style: styleDirective,</div>
<div class="line">            option: optionDirective,</div>
<div class="line">            ngBind: ngBindDirective,</div>
<div class="line">            ngBindHtml: ngBindHtmlDirective,</div>
<div class="line">            ngBindTemplate: ngBindTemplateDirective,</div>
<div class="line">            ngClass: ngClassDirective,</div>
<div class="line">            ngClassEven: ngClassEvenDirective,</div>
<div class="line">            ngClassOdd: ngClassOddDirective,</div>
<div class="line">            ngCloak: ngCloakDirective,</div>
<div class="line">            ngController: ngControllerDirective,</div>
<div class="line">            ngForm: ngFormDirective,</div>
<div class="line">            ngHide: ngHideDirective,</div>
<div class="line">            ngIf: ngIfDirective,</div>
<div class="line">            ngInclude: ngIncludeDirective,</div>
<div class="line">            ngInit: ngInitDirective,</div>
<div class="line">            ngNonBindable: ngNonBindableDirective,</div>
<div class="line">            ngPluralize: ngPluralizeDirective,</div>
<div class="line">            ngRepeat: ngRepeatDirective,</div>
<div class="line">            ngShow: ngShowDirective,</div>
<div class="line">            ngStyle: ngStyleDirective,</div>
<div class="line">            ngSwitch: ngSwitchDirective,</div>
<div class="line">            ngSwitchWhen: ngSwitchWhenDirective,</div>
<div class="line">            ngSwitchDefault: ngSwitchDefaultDirective,</div>
<div class="line">            ngOptions: ngOptionsDirective,</div>
<div class="line">            ngTransclude: ngTranscludeDirective,</div>
<div class="line">            ngModel: ngModelDirective,</div>
<div class="line">            ngList: ngListDirective,</div>
<div class="line">            ngChange: ngChangeDirective,</div>
<div class="line">            pattern: patternDirective,</div>
<div class="line">            ngPattern: patternDirective,</div>
<div class="line">            required: requiredDirective,</div>
<div class="line">            ngRequired: requiredDirective,</div>
<div class="line">            minlength: minlengthDirective,</div>
<div class="line">            ngMinlength: minlengthDirective,</div>
<div class="line">            maxlength: maxlengthDirective,</div>
<div class="line">            ngMaxlength: maxlengthDirective,</div>
<div class="line">            ngValue: ngValueDirective,</div>
<div class="line">            ngModelOptions: ngModelOptionsDirective</div>
<div class="line">        }).</div>
<div class="line">        directive({</div>
<div class="line">          ngInclude: ngIncludeFillContentDirective</div>
<div class="line">        }).</div>
<div class="line">        directive(ngAttributeAliasDirectives).</div>
<div class="line">        directive(ngEventDirectives);</div>
<div class="line">      $provide.provider({</div>
<div class="line">        $anchorScroll: $AnchorScrollProvider,</div>
<div class="line">        $animate: $AnimateProvider,</div>
<div class="line">        $animateCss: $CoreAnimateCssProvider,</div>
<div class="line">        $$animateQueue: $$CoreAnimateQueueProvider,</div>
<div class="line">        $$AnimateRunner: $$CoreAnimateRunnerProvider,</div>
<div class="line">        $browser: $BrowserProvider,</div>
<div class="line">        $cacheFactory: $CacheFactoryProvider,</div>
<div class="line">        $controller: $ControllerProvider,</div>
<div class="line">        $document: $DocumentProvider,</div>
<div class="line">        $exceptionHandler: $ExceptionHandlerProvider,</div>
<div class="line">        $filter: $FilterProvider,</div>
<div class="line">        $$forceReflow: $$ForceReflowProvider,</div>
<div class="line">        $interpolate: $InterpolateProvider,</div>
<div class="line">        $interval: $IntervalProvider,</div>
<div class="line">        $http: $HttpProvider,</div>
<div class="line">        $httpParamSerializer: $HttpParamSerializerProvider,</div>
<div class="line">        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,</div>
<div class="line">        $httpBackend: $HttpBackendProvider,</div>
<div class="line">        $location: $LocationProvider,</div>
<div class="line">        $log: $LogProvider,</div>
<div class="line">        $parse: $ParseProvider,</div>
<div class="line">        $rootScope: $RootScopeProvider,</div>
<div class="line">        $q: $QProvider,</div>
<div class="line">        $$q: $$QProvider,</div>
<div class="line">        $sce: $SceProvider,</div>
<div class="line">        $sceDelegate: $SceDelegateProvider,</div>
<div class="line">        $sniffer: $SnifferProvider,</div>
<div class="line">        $templateCache: $TemplateCacheProvider,</div>
<div class="line">        $templateRequest: $TemplateRequestProvider,</div>
<div class="line">        $$testability: $$TestabilityProvider,</div>
<div class="line">        $timeout: $TimeoutProvider,</div>
<div class="line">        $window: $WindowProvider,</div>
<div class="line">        $$rAF: $$RAFProvider,</div>
<div class="line">        $$jqLite: $$jqLiteProvider,</div>
<div class="line">        $$HashMap: $$HashMapProvider,</div>
<div class="line">        $$cookieReader: $$CookieReaderProvider</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  ]);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* global JQLitePrototype: true,</span></div>
<div class="line"><span class="comment">  addEventListenerFn: true,</span></div>
<div class="line"><span class="comment">  removeEventListenerFn: true,</span></div>
<div class="line"><span class="comment">  BOOLEAN_ATTR: true,</span></div>
<div class="line"><span class="comment">  ALIASED_ATTR: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//JQLite</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">JQLite.expando = <span class="stringliteral">&#39;ng339&#39;</span>;</div>
<div class="line"></div>
<div class="line">var jqCache = JQLite.cache = {},</div>
<div class="line">    jqId = 1,</div>
<div class="line">    addEventListenerFn = <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">      element.addEventListener(type, fn, <span class="keyword">false</span>);</div>
<div class="line">    },</div>
<div class="line">    removeEventListenerFn = <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">      element.removeEventListener(type, fn, <span class="keyword">false</span>);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * !!! This is an undocumented &quot;private&quot; function !!!</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">JQLite._data = <span class="keyword">function</span>(node) {</div>
<div class="line">  <span class="comment">//jQuery always returns an object on cache miss</span></div>
<div class="line">  <span class="keywordflow">return</span> this.cache[node[this.expando]] || {};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqNextId() { <span class="keywordflow">return</span> ++jqId; }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;</div>
<div class="line">var MOZ_HACK_REGEXP = /^moz([A-Z])/;</div>
<div class="line">var MOUSE_EVENT_MAP= { mouseleave: <span class="stringliteral">&quot;mouseout&quot;</span>, mouseenter: <span class="stringliteral">&quot;mouseover&quot;</span>};</div>
<div class="line">var jqLiteMinErr = minErr(<span class="stringliteral">&#39;jqLite&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> camelCase(name) {</div>
<div class="line">  <span class="keywordflow">return</span> name.</div>
<div class="line">    replace(SPECIAL_CHARS_REGEXP, <span class="keyword">function</span>(_, separator, letter, offset) {</div>
<div class="line">      <span class="keywordflow">return</span> offset ? letter.toUpperCase() : letter;</div>
<div class="line">    }).</div>
<div class="line">    replace(MOZ_HACK_REGEXP, <span class="stringliteral">&#39;Moz$1&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var SINGLE_TAG_REGEXP = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/;</div>
<div class="line">var HTML_REGEXP = /&lt;|&amp;#?\w+;/;</div>
<div class="line">var TAG_NAME_REGEXP = /&lt;([\w:]+)/;</div>
<div class="line">var XHTML_TAG_REGEXP = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi;</div>
<div class="line"></div>
<div class="line">var wrapMap = {</div>
<div class="line">  <span class="stringliteral">&#39;option&#39;</span>: [1, <span class="stringliteral">&#39;&lt;select multiple=&quot;multiple&quot;&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/select&gt;&#39;</span>],</div>
<div class="line"></div>
<div class="line">  <span class="stringliteral">&#39;thead&#39;</span>: [1, <span class="stringliteral">&#39;&lt;table&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;col&#39;</span>: [2, <span class="stringliteral">&#39;&lt;table&gt;&lt;colgroup&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/colgroup&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;tr&#39;</span>: [2, <span class="stringliteral">&#39;&lt;table&gt;&lt;tbody&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/tbody&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;td&#39;</span>: [3, <span class="stringliteral">&#39;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;</span>],</div>
<div class="line">  <span class="stringliteral">&#39;_default&#39;</span>: [0, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>]</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">wrapMap.optgroup = wrapMap.option;</div>
<div class="line">wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;</div>
<div class="line">wrapMap.th = wrapMap.td;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteIsTextNode(html) {</div>
<div class="line">  <span class="keywordflow">return</span> !HTML_REGEXP.test(html);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAcceptsData(node) {</div>
<div class="line">  <span class="comment">// The window object can accept data but has no nodeType</span></div>
<div class="line">  <span class="comment">// Otherwise we are only interested in elements (1) and documents (9)</span></div>
<div class="line">  var nodeType = node.nodeType;</div>
<div class="line">  <span class="keywordflow">return</span> nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteHasData(node) {</div>
<div class="line">  <span class="keywordflow">for</span> (var key in jqCache[node.ng339]) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteBuildFragment(html, context) {</div>
<div class="line">  var tmp, tag, wrap,</div>
<div class="line">      fragment = context.createDocumentFragment(),</div>
<div class="line">      nodes = [], i;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (jqLiteIsTextNode(html)) {</div>
<div class="line">    <span class="comment">// Convert non-html into a text node</span></div>
<div class="line">    nodes.push(context.createTextNode(html));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Convert html into DOM nodes</span></div>
<div class="line">    tmp = tmp || fragment.appendChild(context.createElement(<span class="stringliteral">&quot;div&quot;</span>));</div>
<div class="line">    tag = (TAG_NAME_REGEXP.exec(html) || [<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>])[1].toLowerCase();</div>
<div class="line">    wrap = wrapMap[tag] || wrapMap._default;</div>
<div class="line">    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, <span class="stringliteral">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span>) + wrap[2];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Descend through wrappers to the right content</span></div>
<div class="line">    i = wrap[0];</div>
<div class="line">    <span class="keywordflow">while</span> (i--) {</div>
<div class="line">      tmp = tmp.lastChild;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    nodes = concat(nodes, tmp.childNodes);</div>
<div class="line"></div>
<div class="line">    tmp = fragment.firstChild;</div>
<div class="line">    tmp.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Remove wrapper from fragment</span></div>
<div class="line">  fragment.textContent = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">  fragment.innerHTML = <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// Clear inner HTML</span></div>
<div class="line">  forEach(nodes, <span class="keyword">function</span>(node) {</div>
<div class="line">    fragment.appendChild(node);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> fragment;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteParseHTML(html, context) {</div>
<div class="line">  context = context || document;</div>
<div class="line">  var parsed;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((parsed = SINGLE_TAG_REGEXP.exec(html))) {</div>
<div class="line">    <span class="keywordflow">return</span> [context.createElement(parsed[1])];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((parsed = jqLiteBuildFragment(html, context))) {</div>
<div class="line">    <span class="keywordflow">return</span> parsed.childNodes;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> [];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> JQLite(element) {</div>
<div class="line">  <span class="keywordflow">if</span> (element instanceof JQLite) {</div>
<div class="line">    <span class="keywordflow">return</span> element;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var argIsString;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isString(element)) {</div>
<div class="line">    element = trim(element);</div>
<div class="line">    argIsString = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!(<span class="keyword">this</span> instanceof JQLite)) {</div>
<div class="line">    <span class="keywordflow">if</span> (argIsString &amp;&amp; element.charAt(0) != <span class="charliteral">&#39;&lt;&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;nosel&#39;</span>, <span class="stringliteral">&#39;Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> JQLite(element);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (argIsString) {</div>
<div class="line">    jqLiteAddNodes(<span class="keyword">this</span>, jqLiteParseHTML(element));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    jqLiteAddNodes(<span class="keyword">this</span>, element);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteClone(element) {</div>
<div class="line">  <span class="keywordflow">return</span> element.cloneNode(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteDealoc(element, onlyDescendants) {</div>
<div class="line">  <span class="keywordflow">if</span> (!onlyDescendants) jqLiteRemoveData(element);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (element.querySelectorAll) {</div>
<div class="line">    var descendants = element.querySelectorAll(<span class="charliteral">&#39;*&#39;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, l = descendants.length; i &lt; l; i++) {</div>
<div class="line">      jqLiteRemoveData(descendants[i]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteOff(element, type, fn, unsupported) {</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(unsupported)) <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;offargs&#39;</span>, <span class="stringliteral">&#39;jqLite#off() does not support the `selector` argument&#39;</span>);</div>
<div class="line"></div>
<div class="line">  var expandoStore = jqLiteExpandoStore(element);</div>
<div class="line">  var events = expandoStore &amp;&amp; expandoStore.events;</div>
<div class="line">  var handle = expandoStore &amp;&amp; expandoStore.handle;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!handle) <span class="keywordflow">return</span>; <span class="comment">//no listeners registered</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!type) {</div>
<div class="line">    <span class="keywordflow">for</span> (type in events) {</div>
<div class="line">      <span class="keywordflow">if</span> (type !== <span class="stringliteral">&#39;$destroy&#39;</span>) {</div>
<div class="line">        removeEventListenerFn(element, type, handle);</div>
<div class="line">      }</div>
<div class="line">      <span class="keyword">delete</span> events[type];</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    forEach(type.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(type) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(fn)) {</div>
<div class="line">        var listenerFns = events[type];</div>
<div class="line">        arrayRemove(listenerFns || [], fn);</div>
<div class="line">        <span class="keywordflow">if</span> (listenerFns &amp;&amp; listenerFns.length &gt; 0) {</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      removeEventListenerFn(element, type, handle);</div>
<div class="line">      <span class="keyword">delete</span> events[type];</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemoveData(element, name) {</div>
<div class="line">  var expandoId = element.ng339;</div>
<div class="line">  var expandoStore = expandoId &amp;&amp; jqCache[expandoId];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (expandoStore) {</div>
<div class="line">    <span class="keywordflow">if</span> (name) {</div>
<div class="line">      <span class="keyword">delete</span> expandoStore.data[name];</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (expandoStore.handle) {</div>
<div class="line">      <span class="keywordflow">if</span> (expandoStore.events.$destroy) {</div>
<div class="line">        expandoStore.handle({}, <span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">      jqLiteOff(element);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span> jqCache[expandoId];</div>
<div class="line">    element.ng339 = undefined; <span class="comment">// don&#39;t delete DOM expandos. IE and Chrome don&#39;t like it</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteExpandoStore(element, createIfNecessary) {</div>
<div class="line">  var expandoId = element.ng339,</div>
<div class="line">      expandoStore = expandoId &amp;&amp; jqCache[expandoId];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (createIfNecessary &amp;&amp; !expandoStore) {</div>
<div class="line">    element.ng339 = expandoId = jqNextId();</div>
<div class="line">    expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined};</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> expandoStore;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteData(element, key, value) {</div>
<div class="line">  <span class="keywordflow">if</span> (jqLiteAcceptsData(element)) {</div>
<div class="line"></div>
<div class="line">    var isSimpleSetter = isDefined(value);</div>
<div class="line">    var isSimpleGetter = !isSimpleSetter &amp;&amp; key &amp;&amp; !isObject(key);</div>
<div class="line">    var massGetter = !key;</div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);</div>
<div class="line">    var data = expandoStore &amp;&amp; expandoStore.data;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isSimpleSetter) { <span class="comment">// data(&#39;key&#39;, value)</span></div>
<div class="line">      data[key] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (massGetter) {  <span class="comment">// data()</span></div>
<div class="line">        <span class="keywordflow">return</span> data;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isSimpleGetter) { <span class="comment">// data(&#39;key&#39;)</span></div>
<div class="line">          <span class="comment">// don&#39;t force creation of expandoStore if it doesn&#39;t exist yet</span></div>
<div class="line">          <span class="keywordflow">return</span> data &amp;&amp; data[key];</div>
<div class="line">        } <span class="keywordflow">else</span> { <span class="comment">// mass-setter: data({key1: val1, key2: val2})</span></div>
<div class="line">          extend(data, key);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteHasClass(element, selector) {</div>
<div class="line">  <span class="keywordflow">if</span> (!element.getAttribute) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> ((<span class="stringliteral">&quot; &quot;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="stringliteral">&quot; &quot;</span>).replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>).</div>
<div class="line">      indexOf(<span class="stringliteral">&quot; &quot;</span> + selector + <span class="stringliteral">&quot; &quot;</span>) &gt; -1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemoveClass(element, cssClasses) {</div>
<div class="line">  <span class="keywordflow">if</span> (cssClasses &amp;&amp; element.setAttribute) {</div>
<div class="line">    forEach(cssClasses.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(cssClass) {</div>
<div class="line">      element.setAttribute(<span class="stringliteral">&#39;class&#39;</span>, trim(</div>
<div class="line">          (<span class="stringliteral">&quot; &quot;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">          .replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>)</div>
<div class="line">          .replace(<span class="stringliteral">&quot; &quot;</span> + trim(cssClass) + <span class="stringliteral">&quot; &quot;</span>, <span class="stringliteral">&quot; &quot;</span>))</div>
<div class="line">      );</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAddClass(element, cssClasses) {</div>
<div class="line">  <span class="keywordflow">if</span> (cssClasses &amp;&amp; element.setAttribute) {</div>
<div class="line">    var existingClasses = (<span class="charliteral">&#39; &#39;</span> + (element.getAttribute(<span class="stringliteral">&#39;class&#39;</span>) || <span class="stringliteral">&#39;&#39;</span>) + <span class="charliteral">&#39; &#39;</span>)</div>
<div class="line">                            .replace(/[\n\t]/g, <span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line"></div>
<div class="line">    forEach(cssClasses.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(cssClass) {</div>
<div class="line">      cssClass = trim(cssClass);</div>
<div class="line">      <span class="keywordflow">if</span> (existingClasses.indexOf(<span class="charliteral">&#39; &#39;</span> + cssClass + <span class="charliteral">&#39; &#39;</span>) === -1) {</div>
<div class="line">        existingClasses += cssClass + <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    element.setAttribute(<span class="stringliteral">&#39;class&#39;</span>, trim(existingClasses));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteAddNodes(root, elements) {</div>
<div class="line">  <span class="comment">// THIS CODE IS VERY HOT. Don&#39;t make changes without benchmarking.</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (elements) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if a Node (the most common case)</span></div>
<div class="line">    <span class="keywordflow">if</span> (elements.nodeType) {</div>
<div class="line">      root[root.length++] = elements;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var length = elements.length;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if an Array or NodeList and not a Window</span></div>
<div class="line">      <span class="keywordflow">if</span> (typeof length === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; elements.window !== elements) {</div>
<div class="line">        <span class="keywordflow">if</span> (length) {</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; length; i++) {</div>
<div class="line">            root[root.length++] = elements[i];</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        root[root.length++] = elements;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteController(element, name) {</div>
<div class="line">  <span class="keywordflow">return</span> jqLiteInheritedData(element, <span class="charliteral">&#39;$&#39;</span> + (name || <span class="stringliteral">&#39;ngController&#39;</span>) + <span class="stringliteral">&#39;Controller&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteInheritedData(element, name, value) {</div>
<div class="line">  <span class="comment">// if element is the document object work with the html element instead</span></div>
<div class="line">  <span class="comment">// this makes $(document).scope() possible</span></div>
<div class="line">  <span class="keywordflow">if</span> (element.nodeType == NODE_TYPE_DOCUMENT) {</div>
<div class="line">    element = element.documentElement;</div>
<div class="line">  }</div>
<div class="line">  var names = isArray(name) ? name : [name];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span> (element) {</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = names.length; i &lt; ii; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((value = jqLite.data(element, names[i])) !== undefined) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If dealing with a document fragment node with a host element, and no parent, use the host</span></div>
<div class="line">    <span class="comment">// element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM</span></div>
<div class="line">    <span class="comment">// to lookup parent controllers.</span></div>
<div class="line">    element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT &amp;&amp; element.host);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteEmpty(element) {</div>
<div class="line">  jqLiteDealoc(element, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">while</span> (element.firstChild) {</div>
<div class="line">    element.removeChild(element.firstChild);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteRemove(element, keepData) {</div>
<div class="line">  <span class="keywordflow">if</span> (!keepData) jqLiteDealoc(element);</div>
<div class="line">  var parent = element.parentNode;</div>
<div class="line">  <span class="keywordflow">if</span> (parent) parent.removeChild(element);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jqLiteDocumentLoaded(action, win) {</div>
<div class="line">  win = win || window;</div>
<div class="line">  <span class="keywordflow">if</span> (win.document.readyState === <span class="stringliteral">&#39;complete&#39;</span>) {</div>
<div class="line">    <span class="comment">// Force the action to be run async for consistent behaviour</span></div>
<div class="line">    <span class="comment">// from the action&#39;s point of view</span></div>
<div class="line">    <span class="comment">// i.e. it will definitely not be in a $apply</span></div>
<div class="line">    win.setTimeout(action);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// No need to unbind this handler as load is only ever called once</span></div>
<div class="line">    jqLite(win).on(<span class="stringliteral">&#39;load&#39;</span>, action);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions which are declared directly.</span></div>
<div class="line"><span class="comment"></span>var JQLitePrototype = JQLite.prototype = {</div>
<div class="line">  ready: <span class="keyword">function</span>(fn) {</div>
<div class="line">    var fired = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> trigger() {</div>
<div class="line">      <span class="keywordflow">if</span> (fired) <span class="keywordflow">return</span>;</div>
<div class="line">      fired = <span class="keyword">true</span>;</div>
<div class="line">      fn();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check if document is already loaded</span></div>
<div class="line">    <span class="keywordflow">if</span> (document.readyState === <span class="stringliteral">&#39;complete&#39;</span>) {</div>
<div class="line">      setTimeout(trigger);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      this.on(<span class="stringliteral">&#39;DOMContentLoaded&#39;</span>, trigger); <span class="comment">// works for modern browsers and IE9</span></div>
<div class="line">      <span class="comment">// we can not use jqLite since we are not done loading and jQuery could be loaded later.</span></div>
<div class="line">      <span class="comment">// jshint -W064</span></div>
<div class="line">      JQLite(window).on(<span class="stringliteral">&#39;load&#39;</span>, trigger); <span class="comment">// fallback to window.onload for others</span></div>
<div class="line">      <span class="comment">// jshint +W064</span></div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  toString: <span class="keyword">function</span>() {</div>
<div class="line">    var value = [];</div>
<div class="line">    forEach(<span class="keyword">this</span>, <span class="keyword">function</span>(e) { value.push(<span class="stringliteral">&#39;&#39;</span> + e);});</div>
<div class="line">    <span class="keywordflow">return</span> <span class="charliteral">&#39;[&#39;</span> + value.join(<span class="stringliteral">&#39;, &#39;</span>) + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  eq: <span class="keyword">function</span>(index) {</div>
<div class="line">      <span class="keywordflow">return</span> (index &gt;= 0) ? jqLite(<span class="keyword">this</span>[index]) : jqLite(this[this.length + index]);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  length: 0,</div>
<div class="line">  push: push,</div>
<div class="line">  sort: [].sort,</div>
<div class="line">  splice: [].splice</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions iterating getter/setters.</span></div>
<div class="line"><span class="comment">// these functions return self on setter and</span></div>
<div class="line"><span class="comment">// value on get.</span></div>
<div class="line"><span class="comment"></span>var BOOLEAN_ATTR = {};</div>
<div class="line">forEach(<span class="stringliteral">&#39;multiple,selected,checked,disabled,readOnly,required,open&#39;</span>.split(<span class="charliteral">&#39;,&#39;</span>), <span class="keyword">function</span>(value) {</div>
<div class="line">  BOOLEAN_ATTR[lowercase(value)] = value;</div>
<div class="line">});</div>
<div class="line">var BOOLEAN_ELEMENTS = {};</div>
<div class="line">forEach(<span class="stringliteral">&#39;input,select,option,textarea,button,form,details&#39;</span>.split(<span class="charliteral">&#39;,&#39;</span>), <span class="keyword">function</span>(value) {</div>
<div class="line">  BOOLEAN_ELEMENTS[value] = <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line">var ALIASED_ATTR = {</div>
<div class="line">  <span class="stringliteral">&#39;ngMinlength&#39;</span>: <span class="stringliteral">&#39;minlength&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMaxlength&#39;</span>: <span class="stringliteral">&#39;maxlength&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMin&#39;</span>: <span class="stringliteral">&#39;min&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngMax&#39;</span>: <span class="stringliteral">&#39;max&#39;</span>,</div>
<div class="line">  <span class="stringliteral">&#39;ngPattern&#39;</span>: <span class="stringliteral">&#39;pattern&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getBooleanAttrName(element, name) {</div>
<div class="line">  <span class="comment">// check dom last since we will most likely fail on name</span></div>
<div class="line">  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// booleanAttr is here twice to minimize DOM access</span></div>
<div class="line">  <span class="keywordflow">return</span> booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[nodeName_(element)] &amp;&amp; booleanAttr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getAliasedAttrName(element, name) {</div>
<div class="line">  var nodeName = element.nodeName;</div>
<div class="line">  <span class="keywordflow">return</span> (nodeName === <span class="stringliteral">&#39;INPUT&#39;</span> || nodeName === <span class="stringliteral">&#39;TEXTAREA&#39;</span>) &amp;&amp; ALIASED_ATTR[name];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">forEach({</div>
<div class="line">  data: jqLiteData,</div>
<div class="line">  removeData: jqLiteRemoveData,</div>
<div class="line">  hasData: jqLiteHasData</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite[name] = fn;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">forEach({</div>
<div class="line">  data: jqLiteData,</div>
<div class="line">  inheritedData: jqLiteInheritedData,</div>
<div class="line"></div>
<div class="line">  scope: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="comment">// Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!</span></div>
<div class="line">    <span class="keywordflow">return</span> jqLite.data(element, <span class="stringliteral">&#39;$scope&#39;</span>) || jqLiteInheritedData(element.parentNode || element, [<span class="stringliteral">&#39;$isolateScope&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>]);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isolateScope: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="comment">// Can&#39;t use jqLiteData here directly so we stay compatible with jQuery!</span></div>
<div class="line">    <span class="keywordflow">return</span> jqLite.data(element, <span class="stringliteral">&#39;$isolateScope&#39;</span>) || jqLite.data(element, <span class="stringliteral">&#39;$isolateScopeNoTemplate&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  controller: jqLiteController,</div>
<div class="line"></div>
<div class="line">  injector: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> jqLiteInheritedData(element, <span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  removeAttr: <span class="keyword">function</span>(element, name) {</div>
<div class="line">    element.removeAttribute(name);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  hasClass: jqLiteHasClass,</div>
<div class="line"></div>
<div class="line">  css: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    name = camelCase(name);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element.style[name] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> element.style[name];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  attr: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    var nodeType = element.nodeType;</div>
<div class="line">    <span class="keywordflow">if</span> (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    var lowercasedName = lowercase(name);</div>
<div class="line">    <span class="keywordflow">if</span> (BOOLEAN_ATTR[lowercasedName]) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">        <span class="keywordflow">if</span> (!!value) {</div>
<div class="line">          element[name] = <span class="keyword">true</span>;</div>
<div class="line">          element.setAttribute(name, lowercasedName);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          element[name] = <span class="keyword">false</span>;</div>
<div class="line">          element.removeAttribute(lowercasedName);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> (element[name] ||</div>
<div class="line">                 (element.attributes.getNamedItem(name) || noop).specified)</div>
<div class="line">               ? lowercasedName</div>
<div class="line">               : undefined;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element.setAttribute(name, value);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (element.getAttribute) {</div>
<div class="line">      <span class="comment">// the extra argument &quot;2&quot; is to get the right thing for a.href in IE, see jQuery code</span></div>
<div class="line">      <span class="comment">// some elements (e.g. Document) don&#39;t have get attribute, so return undefined</span></div>
<div class="line">      var ret = element.getAttribute(name, 2);</div>
<div class="line">      <span class="comment">// normalize non-existing attributes to undefined (as jQuery)</span></div>
<div class="line">      <span class="keywordflow">return</span> ret === null ? undefined : ret;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  prop: <span class="keyword">function</span>(element, name, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">      element[name] = value;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> element[name];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  text: (<span class="keyword">function</span>() {</div>
<div class="line">    getText.$dv = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> getText;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getText(element, value) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">        var nodeType = element.nodeType;</div>
<div class="line">        <span class="keywordflow">return</span> (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">      element.textContent = value;</div>
<div class="line">    }</div>
<div class="line">  })(),</div>
<div class="line"></div>
<div class="line">  val: <span class="keyword">function</span>(element, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">if</span> (element.multiple &amp;&amp; nodeName_(element) === <span class="stringliteral">&#39;select&#39;</span>) {</div>
<div class="line">        var result = [];</div>
<div class="line">        forEach(element.options, <span class="keyword">function</span>(option) {</div>
<div class="line">          if (option.selected) {</div>
<div class="line">            result.push(option.value || option.text);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> result.length === 0 ? null : result;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> element.value;</div>
<div class="line">    }</div>
<div class="line">    element.value = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  html: <span class="keyword">function</span>(element, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">return</span> element.innerHTML;</div>
<div class="line">    }</div>
<div class="line">    jqLiteDealoc(element, <span class="keyword">true</span>);</div>
<div class="line">    element.innerHTML = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  empty: jqLiteEmpty</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite.prototype[name] = <span class="keyword">function</span>(arg1, arg2) {</div>
<div class="line">    var i, key;</div>
<div class="line">    var nodeCount = this.length;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it</span></div>
<div class="line">    <span class="comment">// in a way that survives minification.</span></div>
<div class="line">    <span class="comment">// jqLiteEmpty takes no arguments but is a setter.</span></div>
<div class="line">    <span class="keywordflow">if</span> (fn !== jqLiteEmpty &amp;&amp;</div>
<div class="line">        (((fn.length == 2 &amp;&amp; (fn !== jqLiteHasClass &amp;&amp; fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(arg1)) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we are a write, but the object properties are the key/values</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; nodeCount; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> (fn === jqLiteData) {</div>
<div class="line">            <span class="comment">// data() takes the whole object in jQuery</span></div>
<div class="line">            fn(<span class="keyword">this</span>[i], arg1);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">for</span> (key in arg1) {</div>
<div class="line">              fn(<span class="keyword">this</span>[i], key, arg1[key]);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// return self for chaining</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// we are a read, so read the first child.</span></div>
<div class="line">        <span class="comment">// TODO: do we still need this?</span></div>
<div class="line">        var value = fn.$dv;</div>
<div class="line">        <span class="comment">// Only if we have $dv do we iterate over all, otherwise it is just the first element.</span></div>
<div class="line">        var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;</div>
<div class="line">        <span class="keywordflow">for</span> (var j = 0; j &lt; jj; j++) {</div>
<div class="line">          var nodeValue = fn(<span class="keyword">this</span>[j], arg1, arg2);</div>
<div class="line">          value = value ? value + nodeValue : nodeValue;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// we are a write, so apply to all children</span></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; nodeCount; i++) {</div>
<div class="line">        fn(<span class="keyword">this</span>[i], arg1, arg2);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// return self for chaining</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createEventHandler(element, events) {</div>
<div class="line">  var eventHandler = <span class="keyword">function</span>(event, type) {</div>
<div class="line">    <span class="comment">// jQuery specific api</span></div>
<div class="line">    <span class="keyword">event</span>.isDefaultPrevented = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">event</span>.defaultPrevented;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var eventFns = events[type || <span class="keyword">event</span>.type];</div>
<div class="line">    var eventFnsLength = eventFns ? eventFns.length : 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!eventFnsLength) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(event.immediatePropagationStopped)) {</div>
<div class="line">      var originalStopImmediatePropagation = <span class="keyword">event</span>.stopImmediatePropagation;</div>
<div class="line">      <span class="keyword">event</span>.stopImmediatePropagation = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keyword">event</span>.immediatePropagationStopped = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (event.stopPropagation) {</div>
<div class="line">          <span class="keyword">event</span>.stopPropagation();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (originalStopImmediatePropagation) {</div>
<div class="line">          originalStopImmediatePropagation.call(event);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">event</span>.isImmediatePropagationStopped = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">event</span>.immediatePropagationStopped === <span class="keyword">true</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy event handlers in case event handlers array is modified during execution.</span></div>
<div class="line">    <span class="keywordflow">if</span> ((eventFnsLength &gt; 1)) {</div>
<div class="line">      eventFns = shallowCopy(eventFns);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0; i &lt; eventFnsLength; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> (!event.isImmediatePropagationStopped()) {</div>
<div class="line">        eventFns[i].call(element, event);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all</span></div>
<div class="line">  <span class="comment">//       events on `element`</span></div>
<div class="line">  eventHandler.elem = element;</div>
<div class="line">  <span class="keywordflow">return</span> eventHandler;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Functions iterating traversal.</span></div>
<div class="line"><span class="comment">// These functions chain results into a single</span></div>
<div class="line"><span class="comment">// selector.</span></div>
<div class="line"><span class="comment"></span>forEach({</div>
<div class="line">  removeData: jqLiteRemoveData,</div>
<div class="line"></div>
<div class="line">  on: <span class="keyword">function</span> jqLiteOn(element, type, fn, unsupported) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(unsupported)) <span class="keywordflow">throw</span> jqLiteMinErr(<span class="stringliteral">&#39;onargs&#39;</span>, <span class="stringliteral">&#39;jqLite#on() does not support the `selector` or `eventData` parameters&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do not add event handlers to non-elements because they will not be cleaned up.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!jqLiteAcceptsData(element)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element, <span class="keyword">true</span>);</div>
<div class="line">    var events = expandoStore.events;</div>
<div class="line">    var handle = expandoStore.handle;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!handle) {</div>
<div class="line">      handle = expandoStore.handle = createEventHandler(element, events);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// http://jsperf.com/string-indexof-vs-split</span></div>
<div class="line">    var types = type.indexOf(<span class="charliteral">&#39; &#39;</span>) &gt;= 0 ? type.split(<span class="charliteral">&#39; &#39;</span>) : [type];</div>
<div class="line">    var i = types.length;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (i--) {</div>
<div class="line">      type = types[i];</div>
<div class="line">      var eventFns = events[type];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!eventFns) {</div>
<div class="line">        events[type] = [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;mouseenter&#39;</span> || type === <span class="stringliteral">&#39;mouseleave&#39;</span>) {</div>
<div class="line">          <span class="comment">// Refer to jQuery&#39;s implementation of mouseenter &amp; mouseleave</span></div>
<div class="line">          <span class="comment">// Read about mouseenter and mouseleave:</span></div>
<div class="line">          <span class="comment">// http://www.quirksmode.org/js/events_mouse.html#link8</span></div>
<div class="line"></div>
<div class="line">          jqLiteOn(element, MOUSE_EVENT_MAP[type], <span class="keyword">function</span>(event) {</div>
<div class="line">            var target = <span class="keyword">this</span>, related = <span class="keyword">event</span>.relatedTarget;</div>
<div class="line">            <span class="comment">// For mousenter/leave call the handler if related is outside the target.</span></div>
<div class="line">            <span class="comment">// NB: No relatedTarget if the mouse left/entered the browser window</span></div>
<div class="line">            <span class="keywordflow">if</span> (!related || (related !== target &amp;&amp; !target.contains(related))) {</div>
<div class="line">              handle(event, type);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (type !== <span class="stringliteral">&#39;$destroy&#39;</span>) {</div>
<div class="line">            addEventListenerFn(element, type, handle);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        eventFns = events[type];</div>
<div class="line">      }</div>
<div class="line">      eventFns.push(fn);</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  off: jqLiteOff,</div>
<div class="line"></div>
<div class="line">  one: <span class="keyword">function</span>(element, type, fn) {</div>
<div class="line">    element = jqLite(element);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//add the listener twice so that when it is called</span></div>
<div class="line">    <span class="comment">//you can remove the original function and still be</span></div>
<div class="line">    <span class="comment">//able to call element.off(ev, fn) normally</span></div>
<div class="line">    element.on(type, <span class="keyword">function</span> onFn() {</div>
<div class="line">      element.off(type, fn);</div>
<div class="line">      element.off(type, onFn);</div>
<div class="line">    });</div>
<div class="line">    element.on(type, fn);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  replaceWith: <span class="keyword">function</span>(element, replaceNode) {</div>
<div class="line">    var index, parent = element.parentNode;</div>
<div class="line">    jqLiteDealoc(element);</div>
<div class="line">    forEach(<span class="keyword">new</span> JQLite(replaceNode), <span class="keyword">function</span>(node) {</div>
<div class="line">      <span class="keywordflow">if</span> (index) {</div>
<div class="line">        parent.insertBefore(node, index.nextSibling);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        parent.replaceChild(node, element);</div>
<div class="line">      }</div>
<div class="line">      index = node;</div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  children: <span class="keyword">function</span>(element) {</div>
<div class="line">    var children = [];</div>
<div class="line">    forEach(element.childNodes, <span class="keyword">function</span>(element) {</div>
<div class="line">      if (element.nodeType === NODE_TYPE_ELEMENT) {</div>
<div class="line">        children.push(element);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> children;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  contents: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> element.contentDocument || element.childNodes || [];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  append: <span class="keyword">function</span>(element, node) {</div>
<div class="line">    var nodeType = element.nodeType;</div>
<div class="line">    <span class="keywordflow">if</span> (nodeType !== NODE_TYPE_ELEMENT &amp;&amp; nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    node = <span class="keyword">new</span> JQLite(node);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = node.length; i &lt; ii; i++) {</div>
<div class="line">      var child = node[i];</div>
<div class="line">      element.appendChild(child);</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  prepend: <span class="keyword">function</span>(element, node) {</div>
<div class="line">    <span class="keywordflow">if</span> (element.nodeType === NODE_TYPE_ELEMENT) {</div>
<div class="line">      var index = element.firstChild;</div>
<div class="line">      forEach(<span class="keyword">new</span> JQLite(node), <span class="keyword">function</span>(child) {</div>
<div class="line">        element.insertBefore(child, index);</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  wrap: <span class="keyword">function</span>(element, wrapNode) {</div>
<div class="line">    wrapNode = jqLite(wrapNode).eq(0).clone()[0];</div>
<div class="line">    var parent = element.parentNode;</div>
<div class="line">    <span class="keywordflow">if</span> (parent) {</div>
<div class="line">      parent.replaceChild(wrapNode, element);</div>
<div class="line">    }</div>
<div class="line">    wrapNode.appendChild(element);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">remove</span>: jqLiteRemove,</div>
<div class="line"></div>
<div class="line">  detach: <span class="keyword">function</span>(element) {</div>
<div class="line">    jqLiteRemove(element, <span class="keyword">true</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  after: <span class="keyword">function</span>(element, newElement) {</div>
<div class="line">    var index = element, parent = element.parentNode;</div>
<div class="line">    newElement = <span class="keyword">new</span> JQLite(newElement);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = newElement.length; i &lt; ii; i++) {</div>
<div class="line">      var node = newElement[i];</div>
<div class="line">      parent.insertBefore(node, index.nextSibling);</div>
<div class="line">      index = node;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addClass: jqLiteAddClass,</div>
<div class="line">  removeClass: jqLiteRemoveClass,</div>
<div class="line"></div>
<div class="line">  toggleClass: <span class="keyword">function</span>(element, selector, condition) {</div>
<div class="line">    <span class="keywordflow">if</span> (selector) {</div>
<div class="line">      forEach(selector.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(className) {</div>
<div class="line">        var classCondition = condition;</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(classCondition)) {</div>
<div class="line">          classCondition = !jqLiteHasClass(element, className);</div>
<div class="line">        }</div>
<div class="line">        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  parent: <span class="keyword">function</span>(element) {</div>
<div class="line">    var parent = element.parentNode;</div>
<div class="line">    <span class="keywordflow">return</span> parent &amp;&amp; parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  next: <span class="keyword">function</span>(element) {</div>
<div class="line">    <span class="keywordflow">return</span> element.nextElementSibling;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  find: <span class="keyword">function</span>(element, selector) {</div>
<div class="line">    <span class="keywordflow">if</span> (element.getElementsByTagName) {</div>
<div class="line">      <span class="keywordflow">return</span> element.getElementsByTagName(selector);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> [];</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  clone: jqLiteClone,</div>
<div class="line"></div>
<div class="line">  triggerHandler: <span class="keyword">function</span>(element, event, extraParameters) {</div>
<div class="line"></div>
<div class="line">    var dummyEvent, eventFnsCopy, handlerArgs;</div>
<div class="line">    var eventName = <span class="keyword">event</span>.type || event;</div>
<div class="line">    var expandoStore = jqLiteExpandoStore(element);</div>
<div class="line">    var events = expandoStore &amp;&amp; expandoStore.events;</div>
<div class="line">    var eventFns = events &amp;&amp; events[eventName];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (eventFns) {</div>
<div class="line">      <span class="comment">// Create a dummy event to pass to the handlers</span></div>
<div class="line">      dummyEvent = {</div>
<div class="line">        preventDefault: <span class="keyword">function</span>() { this.defaultPrevented = <span class="keyword">true</span>; },</div>
<div class="line">        isDefaultPrevented: <span class="keyword">function</span>() { <span class="keywordflow">return</span> this.defaultPrevented === <span class="keyword">true</span>; },</div>
<div class="line">        stopImmediatePropagation: <span class="keyword">function</span>() { this.immediatePropagationStopped = <span class="keyword">true</span>; },</div>
<div class="line">        isImmediatePropagationStopped: <span class="keyword">function</span>() { <span class="keywordflow">return</span> this.immediatePropagationStopped === <span class="keyword">true</span>; },</div>
<div class="line">        stopPropagation: noop,</div>
<div class="line">        type: eventName,</div>
<div class="line">        target: element</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If a custom event was provided then extend our dummy event with it</span></div>
<div class="line">      <span class="keywordflow">if</span> (event.type) {</div>
<div class="line">        dummyEvent = extend(dummyEvent, event);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Copy event handlers in case event handlers array is modified during execution.</span></div>
<div class="line">      eventFnsCopy = shallowCopy(eventFns);</div>
<div class="line">      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];</div>
<div class="line"></div>
<div class="line">      forEach(eventFnsCopy, <span class="keyword">function</span>(fn) {</div>
<div class="line">        <span class="keywordflow">if</span> (!dummyEvent.isImmediatePropagationStopped()) {</div>
<div class="line">          fn.apply(element, handlerArgs);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">  JQLite.prototype[name] = <span class="keyword">function</span>(arg1, arg2, arg3) {</div>
<div class="line">    var value;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = this.length; i &lt; ii; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">        value = fn(<span class="keyword">this</span>[i], arg1, arg2, arg3);</div>
<div class="line">        <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">          <span class="comment">// any function which returns a value needs to be wrapped</span></div>
<div class="line">          value = jqLite(value);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        jqLiteAddNodes(value, fn(<span class="keyword">this</span>[i], arg1, arg2, arg3));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> isDefined(value) ? value : <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// bind legacy bind/unbind to on/off</span></div>
<div class="line">  JQLite.prototype.bind = JQLite.prototype.on;</div>
<div class="line">  JQLite.prototype.unbind = JQLite.prototype.off;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Provider for private $$jqLite service</span></div>
<div class="line"><span class="keyword">function</span> $$jqLiteProvider() {</div>
<div class="line">  this.$get = <span class="keyword">function</span> $$jqLite() {</div>
<div class="line">    <span class="keywordflow">return</span> extend(JQLite, {</div>
<div class="line">      hasClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteHasClass(node, classes);</div>
<div class="line">      },</div>
<div class="line">      addClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteAddClass(node, classes);</div>
<div class="line">      },</div>
<div class="line">      removeClass: <span class="keyword">function</span>(node, classes) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.attr) node = node[0];</div>
<div class="line">        <span class="keywordflow">return</span> jqLiteRemoveClass(node, classes);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> hashKey(obj, nextUidFn) {</div>
<div class="line">  var key = obj &amp;&amp; obj.$$hashKey;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (key) {</div>
<div class="line">    <span class="keywordflow">if</span> (typeof key === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      key = obj.$$hashKey();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> key;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var objType = typeof obj;</div>
<div class="line">  <span class="keywordflow">if</span> (objType == <span class="stringliteral">&#39;function&#39;</span> || (objType == <span class="stringliteral">&#39;object&#39;</span> &amp;&amp; obj !== null)) {</div>
<div class="line">    key = obj.$$hashKey = objType + <span class="charliteral">&#39;:&#39;</span> + (nextUidFn || nextUid)();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    key = objType + <span class="charliteral">&#39;:&#39;</span> + obj;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> key;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> HashMap(array, isolatedUid) {</div>
<div class="line">  <span class="keywordflow">if</span> (isolatedUid) {</div>
<div class="line">    var uid = 0;</div>
<div class="line">    this.nextUid = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> ++uid;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">  forEach(array, this.put, <span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line">HashMap.prototype = {</div>
<div class="line">  put: <span class="keyword">function</span>(key, value) {</div>
<div class="line">    <span class="keyword">this</span>[hashKey(key, this.nextUid)] = value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">get</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>[hashKey(key, this.nextUid)];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keyword">remove</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">    var value = <span class="keyword">this</span>[key = hashKey(key, this.nextUid)];</div>
<div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>[key];</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var $$HashMapProvider = [<span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> HashMap;</div>
<div class="line">  }];</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;</div>
<div class="line">var FN_ARG_SPLIT = /,/;</div>
<div class="line">var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;</div>
<div class="line">var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;</div>
<div class="line">var $injectorMinErr = minErr(<span class="stringliteral">&#39;$injector&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> anonFn(fn) {</div>
<div class="line">  <span class="comment">// For anonymous functions, showing at the very least the function signature can help in</span></div>
<div class="line">  <span class="comment">// debugging.</span></div>
<div class="line">  var fnText = fn.toString().replace(STRIP_COMMENTS, <span class="stringliteral">&#39;&#39;</span>),</div>
<div class="line">      args = fnText.match(FN_ARGS);</div>
<div class="line">  <span class="keywordflow">if</span> (args) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;function(&#39;</span> + (args[1] || <span class="stringliteral">&#39;&#39;</span>).replace(/[\s\r\n]+/, <span class="charliteral">&#39; &#39;</span>) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&#39;fn&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> annotate(fn, strictDi, name) {</div>
<div class="line">  var $inject,</div>
<div class="line">      fnText,</div>
<div class="line">      argDecl,</div>
<div class="line">      last;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (typeof fn === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (!($inject = fn.$inject)) {</div>
<div class="line">      $inject = [];</div>
<div class="line">      <span class="keywordflow">if</span> (fn.length) {</div>
<div class="line">        <span class="keywordflow">if</span> (strictDi) {</div>
<div class="line">          <span class="keywordflow">if</span> (!isString(name) || !name) {</div>
<div class="line">            name = fn.name || anonFn(fn);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;strictdi&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;{0} is not using explicit annotation and cannot be invoked in strict mode&#39;</span>, name);</div>
<div class="line">        }</div>
<div class="line">        fnText = fn.toString().replace(STRIP_COMMENTS, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        argDecl = fnText.match(FN_ARGS);</div>
<div class="line">        forEach(argDecl[1].split(FN_ARG_SPLIT), <span class="keyword">function</span>(arg) {</div>
<div class="line">          arg.replace(FN_ARG, <span class="keyword">function</span>(all, underscore, name) {</div>
<div class="line">            $inject.push(name);</div>
<div class="line">          });</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      fn.$inject = $inject;</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(fn)) {</div>
<div class="line">    last = fn.length - 1;</div>
<div class="line">    assertArgFn(fn[last], <span class="stringliteral">&#39;fn&#39;</span>);</div>
<div class="line">    $inject = fn.slice(0, last);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    assertArgFn(fn, <span class="stringliteral">&#39;fn&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> $inject;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createInjector(modulesToLoad, strictDi) {</div>
<div class="line">  strictDi = (strictDi === <span class="keyword">true</span>);</div>
<div class="line">  var INSTANTIATING = {},</div>
<div class="line">      providerSuffix = <span class="stringliteral">&#39;Provider&#39;</span>,</div>
<div class="line">      path = [],</div>
<div class="line">      loadedModules = <span class="keyword">new</span> HashMap([], <span class="keyword">true</span>),</div>
<div class="line">      providerCache = {</div>
<div class="line">        $provide: {</div>
<div class="line">            provider: supportObject(provider),</div>
<div class="line">            factory: supportObject(factory),</div>
<div class="line">            service: supportObject(service),</div>
<div class="line">            value: supportObject(value),</div>
<div class="line">            constant: supportObject(constant),</div>
<div class="line">            decorator: decorator</div>
<div class="line">          }</div>
<div class="line">      },</div>
<div class="line">      providerInjector = (providerCache.$injector =</div>
<div class="line">          createInternalInjector(providerCache, <span class="keyword">function</span>(serviceName, caller) {</div>
<div class="line">            <span class="keywordflow">if</span> (angular.isString(caller)) {</div>
<div class="line">              path.push(caller);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;unpr&#39;</span>, <span class="stringliteral">&quot;Unknown provider: {0}&quot;</span>, path.join(<span class="stringliteral">&#39; &lt;- &#39;</span>));</div>
<div class="line">          })),</div>
<div class="line">      instanceCache = {},</div>
<div class="line">      instanceInjector = (instanceCache.$injector =</div>
<div class="line">          createInternalInjector(instanceCache, <span class="keyword">function</span>(serviceName, caller) {</div>
<div class="line">            var provider = providerInjector.get(serviceName + providerSuffix, caller);</div>
<div class="line">            <span class="keywordflow">return</span> instanceInjector.invoke(provider.$get, provider, undefined, serviceName);</div>
<div class="line">          }));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  forEach(loadModules(modulesToLoad), <span class="keyword">function</span>(fn) { <span class="keywordflow">if</span> (fn) instanceInjector.invoke(fn); });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> instanceInjector;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// $provider</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">function</span> supportObject(delegate) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(key, value) {</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(key)) {</div>
<div class="line">        forEach(key, reverseParams(delegate));</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> delegate(key, value);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> provider(name, provider_) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;service&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isFunction(provider_) || isArray(provider_)) {</div>
<div class="line">      provider_ = providerInjector.instantiate(provider_);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!provider_.$get) {</div>
<div class="line">      <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;pget&#39;</span>, <span class="stringliteral">&quot;Provider &#39;{0}&#39; must define $get factory method.&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> providerCache[name + providerSuffix] = provider_;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> enforceReturnValue(name, factory) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> enforcedReturnValue() {</div>
<div class="line">      var result = instanceInjector.invoke(factory, <span class="keyword">this</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(result)) {</div>
<div class="line">        <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;undef&#39;</span>, <span class="stringliteral">&quot;Provider &#39;{0}&#39; must return a value from $get factory method.&quot;</span>, name);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> factory(name, factoryFn, enforce) {</div>
<div class="line">    <span class="keywordflow">return</span> provider(name, {</div>
<div class="line">      $get: enforce !== <span class="keyword">false</span> ? enforceReturnValue(name, factoryFn) : factoryFn</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> service(name, constructor) {</div>
<div class="line">    <span class="keywordflow">return</span> factory(name, [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line">      <span class="keywordflow">return</span> $injector.instantiate(constructor);</div>
<div class="line">    }]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> value(name, val) { <span class="keywordflow">return</span> factory(name, valueFn(val), <span class="keyword">false</span>); }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> constant(name, value) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;constant&#39;</span>);</div>
<div class="line">    providerCache[name] = value;</div>
<div class="line">    instanceCache[name] = value;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> decorator(serviceName, decorFn) {</div>
<div class="line">    var origProvider = providerInjector.get(serviceName + providerSuffix),</div>
<div class="line">        orig$get = origProvider.$get;</div>
<div class="line"></div>
<div class="line">    origProvider.$get = <span class="keyword">function</span>() {</div>
<div class="line">      var origInstance = instanceInjector.invoke(orig$get, origProvider);</div>
<div class="line">      <span class="keywordflow">return</span> instanceInjector.invoke(decorFn, null, {$delegate: origInstance});</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Module Loading</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">function</span> loadModules(modulesToLoad) {</div>
<div class="line">    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), <span class="stringliteral">&#39;modulesToLoad&#39;</span>, <span class="stringliteral">&#39;not an array&#39;</span>);</div>
<div class="line">    var runBlocks = [], moduleFn;</div>
<div class="line">    forEach(modulesToLoad, <span class="keyword">function</span>(module) {</div>
<div class="line">      <span class="keywordflow">if</span> (loadedModules.get(module)) <span class="keywordflow">return</span>;</div>
<div class="line">      loadedModules.put(module, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> runInvokeQueue(queue) {</div>
<div class="line">        var i, ii;</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = queue.length; i &lt; ii; i++) {</div>
<div class="line">          var invokeArgs = queue[i],</div>
<div class="line">              provider = providerInjector.get(invokeArgs[0]);</div>
<div class="line"></div>
<div class="line">          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isString(module)) {</div>
<div class="line">          moduleFn = angularModule(module);</div>
<div class="line">          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);</div>
<div class="line">          runInvokeQueue(moduleFn._invokeQueue);</div>
<div class="line">          runInvokeQueue(moduleFn._configBlocks);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isFunction(module)) {</div>
<div class="line">            runBlocks.push(providerInjector.invoke(module));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(module)) {</div>
<div class="line">            runBlocks.push(providerInjector.invoke(module));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          assertArgFn(module, <span class="stringliteral">&#39;module&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="keywordflow">if</span> (isArray(module)) {</div>
<div class="line">          module = module[module.length - 1];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (e.message &amp;&amp; e.stack &amp;&amp; e.stack.indexOf(e.message) == -1) {</div>
<div class="line">          <span class="comment">// Safari &amp; FF&#39;s stack traces don&#39;t contain error.message content</span></div>
<div class="line">          <span class="comment">// unlike those of Chrome and IE</span></div>
<div class="line">          <span class="comment">// So if stack doesn&#39;t contain message, we create a new string that contains both.</span></div>
<div class="line">          <span class="comment">// Since error.stack is read-only in Safari, I&#39;m overriding e and not e.stack here.</span></div>
<div class="line">          <span class="comment">/* jshint -W022 */</span></div>
<div class="line">          e = e.message + <span class="charliteral">&#39;\n&#39;</span> + e.stack;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;modulerr&#39;</span>, <span class="stringliteral">&quot;Failed to instantiate module {0} due to:\n{1}&quot;</span>,</div>
<div class="line">                  module, e.stack || e.message || e);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> runBlocks;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// internal Injector</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">function</span> createInternalInjector(cache, factory) {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getService(serviceName, caller) {</div>
<div class="line">      <span class="keywordflow">if</span> (cache.hasOwnProperty(serviceName)) {</div>
<div class="line">        <span class="keywordflow">if</span> (cache[serviceName] === INSTANTIATING) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;cdep&#39;</span>, <span class="stringliteral">&#39;Circular dependency found: {0}&#39;</span>,</div>
<div class="line">                    serviceName + <span class="stringliteral">&#39; &lt;- &#39;</span> + path.join(<span class="stringliteral">&#39; &lt;- &#39;</span>));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> cache[serviceName];</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          path.unshift(serviceName);</div>
<div class="line">          cache[serviceName] = INSTANTIATING;</div>
<div class="line">          <span class="keywordflow">return</span> cache[serviceName] = factory(serviceName, caller);</div>
<div class="line">        } <span class="keywordflow">catch</span> (err) {</div>
<div class="line">          <span class="keywordflow">if</span> (cache[serviceName] === INSTANTIATING) {</div>
<div class="line">            <span class="keyword">delete</span> cache[serviceName];</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">throw</span> err;</div>
<div class="line">        } <span class="keywordflow">finally</span> {</div>
<div class="line">          path.shift();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> invoke(fn, <span class="keyword">self</span>, locals, serviceName) {</div>
<div class="line">      <span class="keywordflow">if</span> (typeof locals === <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">        serviceName = locals;</div>
<div class="line">        locals = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var args = [],</div>
<div class="line">          $inject = createInjector.$$annotate(fn, strictDi, serviceName),</div>
<div class="line">          length, i,</div>
<div class="line">          key;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0, length = $inject.length; i &lt; length; i++) {</div>
<div class="line">        key = $inject[i];</div>
<div class="line">        <span class="keywordflow">if</span> (typeof key !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">throw</span> $injectorMinErr(<span class="stringliteral">&#39;itkn&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&#39;Incorrect injection token! Expected service name as string, got {0}&#39;</span>, key);</div>
<div class="line">        }</div>
<div class="line">        args.push(</div>
<div class="line">          locals &amp;&amp; locals.hasOwnProperty(key)</div>
<div class="line">          ? locals[key]</div>
<div class="line">          : getService(key, serviceName)</div>
<div class="line">        );</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(fn)) {</div>
<div class="line">        fn = fn[length];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// http://jsperf.com/angularjs-invoke-apply-vs-switch</span></div>
<div class="line">      <span class="comment">// #5388</span></div>
<div class="line">      <span class="keywordflow">return</span> fn.apply(<span class="keyword">self</span>, args);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> instantiate(Type, locals, serviceName) {</div>
<div class="line">      <span class="comment">// Check if Type is annotated and use just the given function at n-1 as parameter</span></div>
<div class="line">      <span class="comment">// e.g. someModule.factory(&#39;greeter&#39;, [&#39;$window&#39;, function(renamed$window) {}]);</span></div>
<div class="line">      <span class="comment">// Object creation: http://jsperf.com/create-constructor/2</span></div>
<div class="line">      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);</div>
<div class="line">      var returnedValue = invoke(Type, instance, locals, serviceName);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      invoke: invoke,</div>
<div class="line">      instantiate: instantiate,</div>
<div class="line">      <span class="keyword">get</span>: getService,</div>
<div class="line">      annotate: createInjector.$$annotate,</div>
<div class="line">      has: <span class="keyword">function</span>(name) {</div>
<div class="line">        <span class="keywordflow">return</span> providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">createInjector.$$annotate = annotate;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $AnchorScrollProvider() {</div>
<div class="line"></div>
<div class="line">  var autoScrollingEnabled = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">  this.disableAutoScrolling = <span class="keyword">function</span>() {</div>
<div class="line">    autoScrollingEnabled = <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$location&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($window, $location, $rootScope) {</div>
<div class="line">    var document = $window.document;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Helper function to get first anchor from a NodeList</span></div>
<div class="line">    <span class="comment">// (using `Array#some()` instead of `angular#forEach()` since it&#39;s more performant</span></div>
<div class="line">    <span class="comment">//  and working in all supported browsers.)</span></div>
<div class="line">    <span class="keyword">function</span> getFirstAnchor(list) {</div>
<div class="line">      var result = null;</div>
<div class="line">      Array.prototype.some.call(list, <span class="keyword">function</span>(element) {</div>
<div class="line">        <span class="keywordflow">if</span> (nodeName_(element) === <span class="charliteral">&#39;a&#39;</span>) {</div>
<div class="line">          result = element;</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getYOffset() {</div>
<div class="line"></div>
<div class="line">      var offset = scroll.yOffset;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(offset)) {</div>
<div class="line">        offset = offset();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isElement(offset)) {</div>
<div class="line">        var elem = offset[0];</div>
<div class="line">        var style = $window.getComputedStyle(elem);</div>
<div class="line">        <span class="keywordflow">if</span> (style.position !== <span class="stringliteral">&#39;fixed&#39;</span>) {</div>
<div class="line">          offset = 0;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          offset = elem.getBoundingClientRect().bottom;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isNumber(offset)) {</div>
<div class="line">        offset = 0;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> offset;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scrollTo(elem) {</div>
<div class="line">      <span class="keywordflow">if</span> (elem) {</div>
<div class="line">        elem.scrollIntoView();</div>
<div class="line"></div>
<div class="line">        var offset = getYOffset();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (offset) {</div>
<div class="line">          <span class="comment">// `offset` is the number of pixels we should scroll UP in order to align `elem` properly.</span></div>
<div class="line">          <span class="comment">// This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the</span></div>
<div class="line">          <span class="comment">// top of the viewport.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// IF the number of pixels from the top of `elem` to the end of the page&#39;s content is less</span></div>
<div class="line">          <span class="comment">// than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some</span></div>
<div class="line">          <span class="comment">// way down the page.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// This is often the case for elements near the bottom of the page.</span></div>
<div class="line">          <span class="comment">//</span></div>
<div class="line">          <span class="comment">// In such cases we do not need to scroll the whole `offset` up, just the difference between</span></div>
<div class="line">          <span class="comment">// the top of the element and the offset, which is enough to align the top of `elem` at the</span></div>
<div class="line">          <span class="comment">// desired position.</span></div>
<div class="line">          var elemTop = elem.getBoundingClientRect().top;</div>
<div class="line">          $window.scrollBy(0, elemTop - offset);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        $window.scrollTo(0, 0);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scroll(hash) {</div>
<div class="line">      hash = isString(hash) ? hash : $location.hash();</div>
<div class="line">      var elm;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// empty hash, scroll to the top of the page</span></div>
<div class="line">      <span class="keywordflow">if</span> (!hash) scrollTo(null);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// element with given id</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((elm = document.getElementById(hash))) scrollTo(elm);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// first anchor with given name :-D</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// no element and hash == &#39;top&#39;, scroll to the top of the page</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hash === <span class="stringliteral">&#39;top&#39;</span>) scrollTo(null);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// does not scroll when user clicks on anchor link that is currently on</span></div>
<div class="line">    <span class="comment">// (no url change, no $location.hash() change), browser native does scroll</span></div>
<div class="line">    <span class="keywordflow">if</span> (autoScrollingEnabled) {</div>
<div class="line">      $rootScope.$watch(<span class="keyword">function</span> autoScrollWatch() {<span class="keywordflow">return</span> $location.hash();},</div>
<div class="line">        <span class="keyword">function</span> autoScrollWatchAction(newVal, oldVal) {</div>
<div class="line">          <span class="comment">// skip the initial scroll if $location.hash is empty</span></div>
<div class="line">          <span class="keywordflow">if</span> (newVal === oldVal &amp;&amp; newVal === <span class="stringliteral">&#39;&#39;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          jqLiteDocumentLoaded(<span class="keyword">function</span>() {</div>
<div class="line">            $rootScope.$evalAsync(scroll);</div>
<div class="line">          });</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> scroll;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $animateMinErr = minErr(<span class="stringliteral">&#39;$animate&#39;</span>);</div>
<div class="line">var ELEMENT_NODE = 1;</div>
<div class="line">var NG_ANIMATE_CLASSNAME = <span class="stringliteral">&#39;ng-animate&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> mergeClasses(a,b) {</div>
<div class="line">  <span class="keywordflow">if</span> (!a &amp;&amp; !b) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> b;</div>
<div class="line">  <span class="keywordflow">if</span> (!b) <span class="keywordflow">return</span> a;</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(a)) a = a.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (isArray(b)) b = b.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> a + <span class="charliteral">&#39; &#39;</span> + b;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> extractElementNode(element) {</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; element.length; i++) {</div>
<div class="line">    var elm = element[i];</div>
<div class="line">    <span class="keywordflow">if</span> (elm.nodeType === ELEMENT_NODE) {</div>
<div class="line">      <span class="keywordflow">return</span> elm;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> splitClasses(classes) {</div>
<div class="line">  <span class="keywordflow">if</span> (isString(classes)) {</div>
<div class="line">    classes = classes.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Use createMap() to prevent class assumptions involving property names in</span></div>
<div class="line">  <span class="comment">// Object.prototype</span></div>
<div class="line">  var obj = createMap();</div>
<div class="line">  forEach(classes, <span class="keyword">function</span>(klass) {</div>
<div class="line">    <span class="comment">// sometimes the split leaves empty string values</span></div>
<div class="line">    <span class="comment">// incase extra spaces were applied to the options</span></div>
<div class="line">    <span class="keywordflow">if</span> (klass.length) {</div>
<div class="line">      obj[klass] = true;</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// if any other type of options value besides an Object value is</span></div>
<div class="line"><span class="comment">// passed into the $animate.method() animation then this helper code</span></div>
<div class="line"><span class="comment">// will be run which will ignore it. While this patch is not the</span></div>
<div class="line"><span class="comment">// greatest solution to this, a lot of existing plugins depend on</span></div>
<div class="line"><span class="comment">// $animate to either call the callback (&lt; 1.2) or return a promise</span></div>
<div class="line"><span class="comment">// that can be changed. This helper function ensures that the options</span></div>
<div class="line"><span class="comment">// are wiped clean incase a callback function is provided.</span></div>
<div class="line"><span class="keyword">function</span> prepareAnimateOptions(options) {</div>
<div class="line">  <span class="keywordflow">return</span> isObject(options)</div>
<div class="line">      ? options</div>
<div class="line">      : {};</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $$CoreAnimateRunnerProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$$rAF&#39;</span>, <span class="keyword">function</span>($q, $$rAF) {</div>
<div class="line">    <span class="keyword">function</span> AnimateRunner() {}</div>
<div class="line">    AnimateRunner.all = noop;</div>
<div class="line">    AnimateRunner.chain = noop;</div>
<div class="line">    AnimateRunner.prototype = {</div>
<div class="line">      end: noop,</div>
<div class="line">      cancel: noop,</div>
<div class="line">      resume: noop,</div>
<div class="line">      pause: noop,</div>
<div class="line">      complete: noop,</div>
<div class="line">      then: <span class="keyword">function</span>(pass, fail) {</div>
<div class="line">        <span class="keywordflow">return</span> $q(<span class="keyword">function</span>(resolve) {</div>
<div class="line">          $$rAF(<span class="keyword">function</span>() {</div>
<div class="line">            resolve();</div>
<div class="line">          });</div>
<div class="line">        }).then(pass, fail);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">return</span> AnimateRunner;</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// this is prefixed with Core since it conflicts with</span></div>
<div class="line"><span class="comment">// the animateQueueProvider defined in ngAnimate/animateQueue.js</span></div>
<div class="line">var $$CoreAnimateQueueProvider = <span class="keyword">function</span>() {</div>
<div class="line">  var postDigestQueue = <span class="keyword">new</span> HashMap();</div>
<div class="line">  var postDigestElements = [];</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$AnimateRunner&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($$AnimateRunner,   $rootScope) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      enabled: noop,</div>
<div class="line">      on: noop,</div>
<div class="line">      off: noop,</div>
<div class="line">      pin: noop,</div>
<div class="line"></div>
<div class="line">      push: <span class="keyword">function</span>(element, event, options, domOperation) {</div>
<div class="line">        domOperation        &amp;&amp; domOperation();</div>
<div class="line"></div>
<div class="line">        options = options || {};</div>
<div class="line">        options.from        &amp;&amp; element.css(options.from);</div>
<div class="line">        options.to          &amp;&amp; element.css(options.to);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (options.addClass || options.removeClass) {</div>
<div class="line">          addRemoveClassesPostDigest(element, options.addClass, options.removeClass);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> $$AnimateRunner(); <span class="comment">// jshint ignore:line</span></div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addRemoveClassesPostDigest(element, add, <span class="keyword">remove</span>) {</div>
<div class="line">      var classVal, data = postDigestQueue.get(element);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!data) {</div>
<div class="line">        postDigestQueue.put(element, data = {});</div>
<div class="line">        postDigestElements.push(element);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var updateData = <span class="keyword">function</span>(classes, value) {</div>
<div class="line">        var changed = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (classes) {</div>
<div class="line">          classes = isString(classes) ? classes.split(<span class="charliteral">&#39; &#39;</span>) :</div>
<div class="line">                    isArray(classes) ? classes : [];</div>
<div class="line">          forEach(classes, <span class="keyword">function</span>(className) {</div>
<div class="line">            <span class="keywordflow">if</span> (className) {</div>
<div class="line">              changed = <span class="keyword">true</span>;</div>
<div class="line">              data[className] = value;</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> changed;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var classesAdded = updateData(add, <span class="keyword">true</span>);</div>
<div class="line">      var classesRemoved = updateData(<span class="keyword">remove</span>, <span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">if</span> ((!classesAdded &amp;&amp; !classesRemoved) || postDigestElements.length &gt; 1) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      $rootScope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">        forEach(postDigestElements, <span class="keyword">function</span>(element) {</div>
<div class="line">          var data = postDigestQueue.get(element);</div>
<div class="line">          <span class="keywordflow">if</span> (data) {</div>
<div class="line">            var existing = splitClasses(element.attr(<span class="stringliteral">&#39;class&#39;</span>));</div>
<div class="line">            var toAdd = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">            var toRemove = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">            forEach(data, <span class="keyword">function</span>(status, className) {</div>
<div class="line">              var hasClass = !!existing[className];</div>
<div class="line">              <span class="keywordflow">if</span> (status !== hasClass) {</div>
<div class="line">                <span class="keywordflow">if</span> (status) {</div>
<div class="line">                  toAdd += (toAdd.length ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + className;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  toRemove += (toRemove.length ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + className;</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line"></div>
<div class="line">            forEach(element, <span class="keyword">function</span>(elm) {</div>
<div class="line">              toAdd    &amp;&amp; jqLiteAddClass(elm, toAdd);</div>
<div class="line">              toRemove &amp;&amp; jqLiteRemoveClass(elm, toRemove);</div>
<div class="line">            });</div>
<div class="line">            postDigestQueue.remove(element);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        postDigestElements.length = 0;</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var $AnimateProvider = [<span class="stringliteral">&#39;$provide&#39;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">  var provider = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.$$registeredAnimations = Object.create(null);</div>
<div class="line"></div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">function</span>(name, factory) {</div>
<div class="line">    <span class="keywordflow">if</span> (name &amp;&amp; name.charAt(0) !== <span class="charliteral">&#39;.&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">throw</span> $animateMinErr(<span class="stringliteral">&#39;notcsel&#39;</span>, <span class="stringliteral">&quot;Expecting class selector starting with &#39;.&#39; got &#39;{0}&#39;.&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var key = name + <span class="stringliteral">&#39;-animation&#39;</span>;</div>
<div class="line">    provider.$$registeredAnimations[name.substr(1)] = key;</div>
<div class="line">    $provide.factory(key, factory);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.classNameFilter = <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length === 1) {</div>
<div class="line">      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;</div>
<div class="line">      <span class="keywordflow">if</span> (this.$$classNameFilter) {</div>
<div class="line">        var reservedRegex = <span class="keyword">new</span> RegExp(<span class="stringliteral">&quot;(\\s+|\\/)&quot;</span> + NG_ANIMATE_CLASSNAME + <span class="stringliteral">&quot;(\\s+|\\/)&quot;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (reservedRegex.test(<span class="keyword">this</span>.$$classNameFilter.toString())) {</div>
<div class="line">          <span class="keywordflow">throw</span> $animateMinErr(<span class="stringliteral">&#39;nongcls&#39;</span>,<span class="stringliteral">&#39;$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the &quot;{0}&quot; CSS class.&#39;</span>, NG_ANIMATE_CLASSNAME);</div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.$$classNameFilter;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$animateQueue&#39;</span>, <span class="keyword">function</span>($$animateQueue) {</div>
<div class="line">    <span class="keyword">function</span> domInsert(element, parentElement, afterElement) {</div>
<div class="line">      <span class="comment">// if for some reason the previous element was removed</span></div>
<div class="line">      <span class="comment">// from the dom sometime before this code runs then let&#39;s</span></div>
<div class="line">      <span class="comment">// just stick to using the parent element as the anchor</span></div>
<div class="line">      <span class="keywordflow">if</span> (afterElement) {</div>
<div class="line">        var afterNode = extractElementNode(afterElement);</div>
<div class="line">        <span class="keywordflow">if</span> (afterNode &amp;&amp; !afterNode.parentNode &amp;&amp; !afterNode.previousElementSibling) {</div>
<div class="line">          afterElement = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      afterElement ? afterElement.after(element) : parentElement.prepend(element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      <span class="comment">// we don&#39;t call it directly since non-existant arguments may</span></div>
<div class="line">      <span class="comment">// be interpreted as null within the sub enabled function</span></div>
<div class="line"></div>
<div class="line">      on: $$animateQueue.on,</div>
<div class="line"></div>
<div class="line">      off: $$animateQueue.off,</div>
<div class="line"></div>
<div class="line">      pin: $$animateQueue.pin,</div>
<div class="line"></div>
<div class="line">      enabled: $$animateQueue.enabled,</div>
<div class="line"></div>
<div class="line">      cancel: <span class="keyword">function</span>(runner) {</div>
<div class="line">        runner.end &amp;&amp; runner.end();</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      enter: <span class="keyword">function</span>(element, parent, after, options) {</div>
<div class="line">        parent = parent &amp;&amp; jqLite(parent);</div>
<div class="line">        after = after &amp;&amp; jqLite(after);</div>
<div class="line">        parent = parent || after.parent();</div>
<div class="line">        domInsert(element, parent, after);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;enter&#39;</span>, prepareAnimateOptions(options));</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      move: <span class="keyword">function</span>(element, parent, after, options) {</div>
<div class="line">        parent = parent &amp;&amp; jqLite(parent);</div>
<div class="line">        after = after &amp;&amp; jqLite(after);</div>
<div class="line">        parent = parent || after.parent();</div>
<div class="line">        domInsert(element, parent, after);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;move&#39;</span>, prepareAnimateOptions(options));</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      leave: <span class="keyword">function</span>(element, options) {</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;leave&#39;</span>, prepareAnimateOptions(options), <span class="keyword">function</span>() {</div>
<div class="line">          element.remove();</div>
<div class="line">        });</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      addClass: <span class="keyword">function</span>(element, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.addClass = mergeClasses(options.addclass, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;addClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      removeClass: <span class="keyword">function</span>(element, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.removeClass = mergeClasses(options.removeClass, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;removeClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      setClass: <span class="keyword">function</span>(element, add, <span class="keyword">remove</span>, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.addClass = mergeClasses(options.addClass, add);</div>
<div class="line">        options.removeClass = mergeClasses(options.removeClass, <span class="keyword">remove</span>);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;setClass&#39;</span>, options);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      animate: <span class="keyword">function</span>(element, from, to, className, options) {</div>
<div class="line">        options = prepareAnimateOptions(options);</div>
<div class="line">        options.from = options.from ? extend(options.from, from) : from;</div>
<div class="line">        options.to   = options.to   ? extend(options.to, to)     : to;</div>
<div class="line"></div>
<div class="line">        className = className || <span class="stringliteral">&#39;ng-inline-animate&#39;</span>;</div>
<div class="line">        options.tempClasses = mergeClasses(options.tempClasses, className);</div>
<div class="line">        <span class="keywordflow">return</span> $$animateQueue.push(element, <span class="stringliteral">&#39;animate&#39;</span>, options);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var $CoreAnimateCssProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$$rAF&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="keyword">function</span>($$rAF, $q) {</div>
<div class="line"></div>
<div class="line">    var RAFPromise = <span class="keyword">function</span>() {};</div>
<div class="line">    RAFPromise.prototype = {</div>
<div class="line">      done: <span class="keyword">function</span>(cancel) {</div>
<div class="line">        this.defer &amp;&amp; this.defer[cancel === <span class="keyword">true</span> ? <span class="stringliteral">&#39;reject&#39;</span> : <span class="stringliteral">&#39;resolve&#39;</span>]();</div>
<div class="line">      },</div>
<div class="line">      end: <span class="keyword">function</span>() {</div>
<div class="line">        this.done();</div>
<div class="line">      },</div>
<div class="line">      cancel: <span class="keyword">function</span>() {</div>
<div class="line">        this.done(<span class="keyword">true</span>);</div>
<div class="line">      },</div>
<div class="line">      getPromise: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!this.defer) {</div>
<div class="line">          this.defer = $q.defer();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> this.defer.promise;</div>
<div class="line">      },</div>
<div class="line">      then: <span class="keyword">function</span>(f1,f2) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().then(f1,f2);</div>
<div class="line">      },</div>
<div class="line">      <span class="stringliteral">&#39;catch&#39;</span>: <span class="keyword">function</span>(f1) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().catch(f1);</div>
<div class="line">      },</div>
<div class="line">      <span class="stringliteral">&#39;finally&#39;</span>: <span class="keyword">function</span>(f1) {</div>
<div class="line">        <span class="keywordflow">return</span> this.getPromise().finally(f1);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(element, options) {</div>
<div class="line">      <span class="keywordflow">if</span> (options.from) {</div>
<div class="line">        element.css(options.from);</div>
<div class="line">        options.from = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var closed, runner = <span class="keyword">new</span> RAFPromise();</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        start: run,</div>
<div class="line">        end: run</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> run() {</div>
<div class="line">        $$rAF(<span class="keyword">function</span>() {</div>
<div class="line">          close();</div>
<div class="line">          <span class="keywordflow">if</span> (!closed) {</div>
<div class="line">            runner.done();</div>
<div class="line">          }</div>
<div class="line">          closed = <span class="keyword">true</span>;</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> runner;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> close() {</div>
<div class="line">        <span class="keywordflow">if</span> (options.addClass) {</div>
<div class="line">          element.addClass(options.addClass);</div>
<div class="line">          options.addClass = null;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (options.removeClass) {</div>
<div class="line">          element.removeClass(options.removeClass);</div>
<div class="line">          options.removeClass = null;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (options.to) {</div>
<div class="line">          element.css(options.to);</div>
<div class="line">          options.to = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global stripHash: true */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> Browser(window, document, $log, $sniffer) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">      rawDocument = document[0],</div>
<div class="line">      location = window.location,</div>
<div class="line">      history = window.history,</div>
<div class="line">      setTimeout = window.setTimeout,</div>
<div class="line">      clearTimeout = window.clearTimeout,</div>
<div class="line">      pendingDeferIds = {};</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.isMock = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  var outstandingRequestCount = 0;</div>
<div class="line">  var outstandingRequestCallbacks = [];</div>
<div class="line"></div>
<div class="line">  <span class="comment">// TODO(vojta): remove this temporary api</span></div>
<div class="line">  <span class="keyword">self</span>.$$completeOutstandingRequest = completeOutstandingRequest;</div>
<div class="line">  <span class="keyword">self</span>.$$incOutstandingRequestCount = <span class="keyword">function</span>() { outstandingRequestCount++; };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> completeOutstandingRequest(fn) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      fn.apply(null, sliceArgs(arguments, 1));</div>
<div class="line">    } <span class="keywordflow">finally</span> {</div>
<div class="line">      outstandingRequestCount--;</div>
<div class="line">      <span class="keywordflow">if</span> (outstandingRequestCount === 0) {</div>
<div class="line">        <span class="keywordflow">while</span> (outstandingRequestCallbacks.length) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            outstandingRequestCallbacks.pop()();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $log.error(e);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getHash(url) {</div>
<div class="line">    var index = url.indexOf(<span class="charliteral">&#39;#&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> index === -1 ? <span class="stringliteral">&#39;&#39;</span> : url.substr(index);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.notifyWhenNoOutstandingRequests = <span class="keyword">function</span>(callback) {</div>
<div class="line">    <span class="keywordflow">if</span> (outstandingRequestCount === 0) {</div>
<div class="line">      callback();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      outstandingRequestCallbacks.push(callback);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// URL API</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  var cachedState, lastHistoryState,</div>
<div class="line">      lastBrowserUrl = location.href,</div>
<div class="line">      baseElement = document.find(<span class="stringliteral">&#39;base&#39;</span>),</div>
<div class="line">      reloadLocation = null;</div>
<div class="line"></div>
<div class="line">  cacheState();</div>
<div class="line">  lastHistoryState = cachedState;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.url = <span class="keyword">function</span>(url, replace, state) {</div>
<div class="line">    <span class="comment">// In modern browsers `history.state` is `null` by default; treating it separately</span></div>
<div class="line">    <span class="comment">// from `undefined` would cause `$browser.url(&#39;/foo&#39;)` to change `history.state`</span></div>
<div class="line">    <span class="comment">// to undefined via `pushState`. Instead, let&#39;s change `undefined` to `null` here.</span></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(state)) {</div>
<div class="line">      state = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Android Browser BFCache causes location, history reference to become stale.</span></div>
<div class="line">    <span class="keywordflow">if</span> (location !== window.location) location = window.location;</div>
<div class="line">    <span class="keywordflow">if</span> (history !== window.history) history = window.history;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// setter</span></div>
<div class="line">    <span class="keywordflow">if</span> (url) {</div>
<div class="line">      var sameState = lastHistoryState === state;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Don&#39;t change anything if previous and current URLs and states match. This also prevents</span></div>
<div class="line">      <span class="comment">// IE&lt;10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.</span></div>
<div class="line">      <span class="comment">// See https://github.com/angular/angular.js/commit/ffb2701</span></div>
<div class="line">      <span class="keywordflow">if</span> (lastBrowserUrl === url &amp;&amp; (!$sniffer.history || sameState)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">self</span>;</div>
<div class="line">      }</div>
<div class="line">      var sameBase = lastBrowserUrl &amp;&amp; stripHash(lastBrowserUrl) === stripHash(url);</div>
<div class="line">      lastBrowserUrl = url;</div>
<div class="line">      lastHistoryState = state;</div>
<div class="line">      <span class="comment">// Don&#39;t use history API if only the hash changed</span></div>
<div class="line">      <span class="comment">// due to a bug in IE10/IE11 which leads</span></div>
<div class="line">      <span class="comment">// to not firing a `hashchange` nor `popstate` event</span></div>
<div class="line">      <span class="comment">// in some cases (see #9143).</span></div>
<div class="line">      <span class="keywordflow">if</span> ($sniffer.history &amp;&amp; (!sameBase || !sameState)) {</div>
<div class="line">        history[replace ? <span class="stringliteral">&#39;replaceState&#39;</span> : <span class="stringliteral">&#39;pushState&#39;</span>](state, <span class="stringliteral">&#39;&#39;</span>, url);</div>
<div class="line">        cacheState();</div>
<div class="line">        <span class="comment">// Do the assignment again so that those two variables are referentially identical.</span></div>
<div class="line">        lastHistoryState = cachedState;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (!sameBase || reloadLocation) {</div>
<div class="line">          reloadLocation = url;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (replace) {</div>
<div class="line">          location.replace(url);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sameBase) {</div>
<div class="line">          location.href = url;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          location.hash = getHash(url);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">self</span>;</div>
<div class="line">    <span class="comment">// getter</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// - reloadLocation is needed as browsers don&#39;t allow to read out</span></div>
<div class="line">      <span class="comment">//   the new location.href if a reload happened.</span></div>
<div class="line">      <span class="comment">// - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172</span></div>
<div class="line">      <span class="keywordflow">return</span> reloadLocation || location.href.replace(/%27/g,<span class="stringliteral">&quot;&#39;&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.state = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> cachedState;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var urlChangeListeners = [],</div>
<div class="line">      urlChangeInit = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> cacheStateAndFireUrlChange() {</div>
<div class="line">    cacheState();</div>
<div class="line">    fireUrlChange();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getCurrentState() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">return</span> history.state;</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="comment">// MSIE can reportedly throw when there is no state (UNCONFIRMED).</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// This variable should be used *only* inside the cacheState function.</span></div>
<div class="line">  var lastCachedState = null;</div>
<div class="line">  <span class="keyword">function</span> cacheState() {</div>
<div class="line">    <span class="comment">// This should be the only place in $browser where `history.state` is read.</span></div>
<div class="line">    cachedState = getCurrentState();</div>
<div class="line">    cachedState = isUndefined(cachedState) ? null : cachedState;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prevent callbacks fo fire twice if both hashchange &amp; popstate were fired.</span></div>
<div class="line">    <span class="keywordflow">if</span> (equals(cachedState, lastCachedState)) {</div>
<div class="line">      cachedState = lastCachedState;</div>
<div class="line">    }</div>
<div class="line">    lastCachedState = cachedState;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> fireUrlChange() {</div>
<div class="line">    <span class="keywordflow">if</span> (lastBrowserUrl === <span class="keyword">self</span>.url() &amp;&amp; lastHistoryState === cachedState) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    lastBrowserUrl = <span class="keyword">self</span>.url();</div>
<div class="line">    lastHistoryState = cachedState;</div>
<div class="line">    forEach(urlChangeListeners, <span class="keyword">function</span>(listener) {</div>
<div class="line">      listener(<span class="keyword">self</span>.url(), cachedState);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.onUrlChange = <span class="keyword">function</span>(callback) {</div>
<div class="line">    <span class="comment">// TODO(vojta): refactor to use node&#39;s syntax for events</span></div>
<div class="line">    <span class="keywordflow">if</span> (!urlChangeInit) {</div>
<div class="line">      <span class="comment">// We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)</span></div>
<div class="line">      <span class="comment">// don&#39;t fire popstate when user change the address bar and don&#39;t fire hashchange when url</span></div>
<div class="line">      <span class="comment">// changed by push/replaceState</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// html5 history api - popstate event</span></div>
<div class="line">      <span class="keywordflow">if</span> ($sniffer.history) jqLite(window).on(<span class="stringliteral">&#39;popstate&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line">      <span class="comment">// hashchange event</span></div>
<div class="line">      jqLite(window).on(<span class="stringliteral">&#39;hashchange&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line"></div>
<div class="line">      urlChangeInit = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    urlChangeListeners.push(callback);</div>
<div class="line">    <span class="keywordflow">return</span> callback;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.$$applicationDestroyed = <span class="keyword">function</span>() {</div>
<div class="line">    jqLite(window).off(<span class="stringliteral">&#39;hashchange popstate&#39;</span>, cacheStateAndFireUrlChange);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.$$checkUrlChange = fireUrlChange;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Misc API</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="keyword">self</span>.baseHref = <span class="keyword">function</span>() {</div>
<div class="line">    var href = baseElement.attr(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> href ? href.replace(/^(https?\:)?\/\/[^\/]*/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.defer = <span class="keyword">function</span>(fn, delay) {</div>
<div class="line">    var timeoutId;</div>
<div class="line">    outstandingRequestCount++;</div>
<div class="line">    timeoutId = setTimeout(<span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">delete</span> pendingDeferIds[timeoutId];</div>
<div class="line">      completeOutstandingRequest(fn);</div>
<div class="line">    }, delay || 0);</div>
<div class="line">    pendingDeferIds[timeoutId] = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> timeoutId;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.defer.cancel = <span class="keyword">function</span>(deferId) {</div>
<div class="line">    <span class="keywordflow">if</span> (pendingDeferIds[deferId]) {</div>
<div class="line">      <span class="keyword">delete</span> pendingDeferIds[deferId];</div>
<div class="line">      clearTimeout(deferId);</div>
<div class="line">      completeOutstandingRequest(noop);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $BrowserProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$log&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $log, $sniffer, $document) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Browser($window, $document, $log, $sniffer);</div>
<div class="line">      }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $CacheFactoryProvider() {</div>
<div class="line"></div>
<div class="line">  this.$get = <span class="keyword">function</span>() {</div>
<div class="line">    var caches = {};</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> cacheFactory(cacheId, options) {</div>
<div class="line">      <span class="keywordflow">if</span> (cacheId in caches) {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;$cacheFactory&#39;</span>)(<span class="stringliteral">&#39;iid&#39;</span>, <span class="stringliteral">&quot;CacheId &#39;{0}&#39; is already taken!&quot;</span>, cacheId);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var size = 0,</div>
<div class="line">          stats = extend({}, options, {<span class="keywordtype">id</span>: cacheId}),</div>
<div class="line">          data = {},</div>
<div class="line">          capacity = (options &amp;&amp; options.capacity) || Number.MAX_VALUE,</div>
<div class="line">          lruHash = {},</div>
<div class="line">          freshEnd = null,</div>
<div class="line">          staleEnd = null;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> caches[cacheId] = {</div>
<div class="line"></div>
<div class="line">        put: <span class="keyword">function</span>(key, value) {</div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(value)) <span class="keywordflow">return</span>;</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key] || (lruHash[key] = {key: key});</div>
<div class="line"></div>
<div class="line">            refresh(lruEntry);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!(key in data)) size++;</div>
<div class="line">          data[key] = value;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (size &gt; capacity) {</div>
<div class="line">            this.<span class="keyword">remove</span>(staleEnd.key);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> value;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line">        <span class="keyword">get</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!lruEntry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            refresh(lruEntry);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> data[key];</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keyword">remove</span>: <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">if</span> (capacity &lt; Number.MAX_VALUE) {</div>
<div class="line">            var lruEntry = lruHash[key];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!lruEntry) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (lruEntry == freshEnd) freshEnd = lruEntry.p;</div>
<div class="line">            <span class="keywordflow">if</span> (lruEntry == staleEnd) staleEnd = lruEntry.n;</div>
<div class="line">            link(lruEntry.n,lruEntry.p);</div>
<div class="line"></div>
<div class="line">            <span class="keyword">delete</span> lruHash[key];</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keyword">delete</span> data[key];</div>
<div class="line">          size--;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        removeAll: <span class="keyword">function</span>() {</div>
<div class="line">          data = {};</div>
<div class="line">          size = 0;</div>
<div class="line">          lruHash = {};</div>
<div class="line">          freshEnd = staleEnd = null;</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        destroy: <span class="keyword">function</span>() {</div>
<div class="line">          data = null;</div>
<div class="line">          stats = null;</div>
<div class="line">          lruHash = null;</div>
<div class="line">          <span class="keyword">delete</span> caches[cacheId];</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        info: <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> extend({}, stats, {size: size});</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> refresh(entry) {</div>
<div class="line">        <span class="keywordflow">if</span> (entry != freshEnd) {</div>
<div class="line">          <span class="keywordflow">if</span> (!staleEnd) {</div>
<div class="line">            staleEnd = entry;</div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (staleEnd == entry) {</div>
<div class="line">            staleEnd = entry.n;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          link(entry.n, entry.p);</div>
<div class="line">          link(entry, freshEnd);</div>
<div class="line">          freshEnd = entry;</div>
<div class="line">          freshEnd.n = null;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> link(nextEntry, prevEntry) {</div>
<div class="line">        <span class="keywordflow">if</span> (nextEntry != prevEntry) {</div>
<div class="line">          <span class="keywordflow">if</span> (nextEntry) nextEntry.p = prevEntry; <span class="comment">//p stands for previous, &#39;prev&#39; didn&#39;t minify</span></div>
<div class="line">          <span class="keywordflow">if</span> (prevEntry) prevEntry.n = nextEntry; <span class="comment">//n stands for next, &#39;next&#39; didn&#39;t minify</span></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    cacheFactory.info = <span class="keyword">function</span>() {</div>
<div class="line">      var info = {};</div>
<div class="line">      forEach(caches, <span class="keyword">function</span>(cache, cacheId) {</div>
<div class="line">        info[cacheId] = cache.info();</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> info;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    cacheFactory.get = <span class="keyword">function</span>(cacheId) {</div>
<div class="line">      <span class="keywordflow">return</span> caches[cacheId];</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cacheFactory;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TemplateCacheProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$cacheFactory&#39;</span>, <span class="keyword">function</span>($cacheFactory) {</div>
<div class="line">    <span class="keywordflow">return</span> $cacheFactory(<span class="stringliteral">&#39;templates&#39;</span>);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * DOM-related variables:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * - &quot;node&quot; - DOM Node</span></div>
<div class="line"><span class="comment"> * - &quot;element&quot; - DOM Element or Node</span></div>
<div class="line"><span class="comment"> * - &quot;$node&quot; or &quot;$element&quot; - jqLite-wrapped node or element</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Compiler related stuff:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * - &quot;linkFn&quot; - linking fn of a single directive</span></div>
<div class="line"><span class="comment"> * - &quot;nodeLinkFn&quot; - function that aggregates all linking fns for a particular node</span></div>
<div class="line"><span class="comment"> * - &quot;childLinkFn&quot; -  function that aggregates all linking fns for child nodes of a particular node</span></div>
<div class="line"><span class="comment"> * - &quot;compositeLinkFn&quot; - function that aggregates all linking fns for a compilation root (nodeList)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var $compileMinErr = minErr(<span class="stringliteral">&#39;$compile&#39;</span>);</div>
<div class="line"></div>
<div class="line">$CompileProvider.$inject = [<span class="stringliteral">&#39;$provide&#39;</span>, <span class="stringliteral">&#39;$$sanitizeUriProvider&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> $CompileProvider($provide, $$sanitizeUriProvider) {</div>
<div class="line">  var hasDirectives = {},</div>
<div class="line">      Suffix = <span class="stringliteral">&#39;Directive&#39;</span>,</div>
<div class="line">      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,</div>
<div class="line">      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,</div>
<div class="line">      ALL_OR_NOTHING_ATTRS = makeMap(<span class="stringliteral">&#39;ngSrc,ngSrcset,src,srcset&#39;</span>),</div>
<div class="line">      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes</span></div>
<div class="line">  <span class="comment">// The assumption is that future DOM event attribute names will begin with</span></div>
<div class="line">  <span class="comment">// &#39;on&#39; and be composed of only English letters.</span></div>
<div class="line">  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseIsolateBindings(scope, directiveName, isController) {</div>
<div class="line">    var LOCAL_REGEXP = /^\s*([@&amp;]|=(\*?))(\??)\s*(\w*)\s*$/;</div>
<div class="line"></div>
<div class="line">    var bindings = {};</div>
<div class="line"></div>
<div class="line">    forEach(scope, <span class="keyword">function</span>(definition, scopeName) {</div>
<div class="line">      var match = definition.match(LOCAL_REGEXP);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;iscp&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Invalid {3} for directive &#39;{0}&#39;.&quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot; Definition: {... {1}: &#39;{2}&#39; ...}&quot;</span>,</div>
<div class="line">            directiveName, scopeName, definition,</div>
<div class="line">            (isController ? <span class="stringliteral">&quot;controller bindings definition&quot;</span> :</div>
<div class="line">            <span class="stringliteral">&quot;isolate scope definition&quot;</span>));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      bindings[scopeName] = {</div>
<div class="line">        mode: match[1][0],</div>
<div class="line">        collection: match[2] === <span class="charliteral">&#39;*&#39;</span>,</div>
<div class="line">        optional: match[3] === <span class="charliteral">&#39;?&#39;</span>,</div>
<div class="line">        attrName: match[4] || scopeName</div>
<div class="line">      };</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bindings;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseDirectiveBindings(directive, directiveName) {</div>
<div class="line">    var bindings = {</div>
<div class="line">      isolateScope: null,</div>
<div class="line">      bindToController: null</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(directive.scope)) {</div>
<div class="line">      <span class="keywordflow">if</span> (directive.bindToController === <span class="keyword">true</span>) {</div>
<div class="line">        bindings.bindToController = parseIsolateBindings(directive.scope,</div>
<div class="line">                                                         directiveName, <span class="keyword">true</span>);</div>
<div class="line">        bindings.isolateScope = {};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        bindings.isolateScope = parseIsolateBindings(directive.scope,</div>
<div class="line">                                                     directiveName, <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(directive.bindToController)) {</div>
<div class="line">      bindings.bindToController =</div>
<div class="line">          parseIsolateBindings(directive.bindToController, directiveName, <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(bindings.bindToController)) {</div>
<div class="line">      var controller = directive.controller;</div>
<div class="line">      var controllerAs = directive.controllerAs;</div>
<div class="line">      <span class="keywordflow">if</span> (!controller) {</div>
<div class="line">        <span class="comment">// There is no controller, there may or may not be a controllerAs property</span></div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;noctrl&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&quot;Cannot bind to controller without directive &#39;{0}&#39;s controller.&quot;</span>,</div>
<div class="line">              directiveName);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!identifierForController(controller, controllerAs)) {</div>
<div class="line">        <span class="comment">// There is a controller, but no identifier or controllerAs property</span></div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;noident&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&quot;Cannot bind to controller without identifier for directive &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">              directiveName);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> bindings;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> assertValidDirectiveName(name) {</div>
<div class="line">    var letter = name.charAt(0);</div>
<div class="line">    <span class="keywordflow">if</span> (!letter || letter !== lowercase(letter)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;baddir&#39;</span>, <span class="stringliteral">&quot;Directive name &#39;{0}&#39; is invalid. The first character must be a lowercase letter&quot;</span>, name);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (name !== name.trim()) {</div>
<div class="line">      <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;baddir&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Directive name &#39;{0}&#39; is invalid. The name should not contain leading or trailing whitespaces&quot;</span>,</div>
<div class="line">            name);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">   this.directive = <span class="keyword">function</span> registerDirective(name, directiveFactory) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;directive&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isString(name)) {</div>
<div class="line">      assertValidDirectiveName(name);</div>
<div class="line">      assertArg(directiveFactory, <span class="stringliteral">&#39;directiveFactory&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (!hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        hasDirectives[name] = [];</div>
<div class="line">        $provide.factory(name + Suffix, [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>,</div>
<div class="line">          <span class="keyword">function</span>($injector, $exceptionHandler) {</div>
<div class="line">            var directives = [];</div>
<div class="line">            forEach(hasDirectives[name], <span class="keyword">function</span>(directiveFactory, index) {</div>
<div class="line">              <span class="keywordflow">try</span> {</div>
<div class="line">                var directive = $injector.invoke(directiveFactory);</div>
<div class="line">                <span class="keywordflow">if</span> (isFunction(directive)) {</div>
<div class="line">                  directive = { compile: valueFn(directive) };</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!directive.compile &amp;&amp; directive.link) {</div>
<div class="line">                  directive.compile = valueFn(directive.link);</div>
<div class="line">                }</div>
<div class="line">                directive.priority = directive.priority || 0;</div>
<div class="line">                directive.index = index;</div>
<div class="line">                directive.name = directive.name || name;</div>
<div class="line">                directive.require = directive.require || (directive.controller &amp;&amp; directive.name);</div>
<div class="line">                directive.restrict = directive.restrict || <span class="stringliteral">&#39;EA&#39;</span>;</div>
<div class="line">                var bindings = directive.$$bindings =</div>
<div class="line">                    parseDirectiveBindings(directive, directive.name);</div>
<div class="line">                <span class="keywordflow">if</span> (isObject(bindings.isolateScope)) {</div>
<div class="line">                  directive.$$isolateBindings = bindings.isolateScope;</div>
<div class="line">                }</div>
<div class="line">                directive.$$moduleName = directiveFactory.$$moduleName;</div>
<div class="line">                directives.push(directive);</div>
<div class="line">              } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">                $exceptionHandler(e);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            <span class="keywordflow">return</span> directives;</div>
<div class="line">          }]);</div>
<div class="line">      }</div>
<div class="line">      hasDirectives[name].push(directiveFactory);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      forEach(name, reverseParams(registerDirective));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.aHrefSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $$sanitizeUriProvider.aHrefSanitizationWhitelist();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.imgSrcSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $$sanitizeUriProvider.imgSrcSanitizationWhitelist();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var debugInfoEnabled = <span class="keyword">true</span>;</div>
<div class="line">  this.debugInfoEnabled = <span class="keyword">function</span>(enabled) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(enabled)) {</div>
<div class="line">      debugInfoEnabled = enabled;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> debugInfoEnabled;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [</div>
<div class="line">            <span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$templateRequest&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;$controller&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>, <span class="stringliteral">&#39;$sce&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$$sanitizeUri&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,</div>
<div class="line">             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {</div>
<div class="line"></div>
<div class="line">    var Attributes = <span class="keyword">function</span>(element, attributesToCopy) {</div>
<div class="line">      <span class="keywordflow">if</span> (attributesToCopy) {</div>
<div class="line">        var keys = Object.keys(attributesToCopy);</div>
<div class="line">        var i, l, key;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, l = keys.length; i &lt; l; i++) {</div>
<div class="line">          key = keys[i];</div>
<div class="line">          <span class="keyword">this</span>[key] = attributesToCopy[key];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.$attr = {};</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      this.$$element = element;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    Attributes.prototype = {</div>
<div class="line">      $normalize: directiveNormalize,</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $addClass: <span class="keyword">function</span>(classVal) {</div>
<div class="line">        <span class="keywordflow">if</span> (classVal &amp;&amp; classVal.length &gt; 0) {</div>
<div class="line">          $animate.addClass(this.$$element, classVal);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $removeClass: <span class="keyword">function</span>(classVal) {</div>
<div class="line">        <span class="keywordflow">if</span> (classVal &amp;&amp; classVal.length &gt; 0) {</div>
<div class="line">          $animate.removeClass(this.$$element, classVal);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $updateClass: <span class="keyword">function</span>(newClasses, oldClasses) {</div>
<div class="line">        var toAdd = tokenDifference(newClasses, oldClasses);</div>
<div class="line">        <span class="keywordflow">if</span> (toAdd &amp;&amp; toAdd.length) {</div>
<div class="line">          $animate.addClass(this.$$element, toAdd);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var toRemove = tokenDifference(oldClasses, newClasses);</div>
<div class="line">        <span class="keywordflow">if</span> (toRemove &amp;&amp; toRemove.length) {</div>
<div class="line">          $animate.removeClass(this.$$element, toRemove);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $set: <span class="keyword">function</span>(key, value, writeAttr, attrName) {</div>
<div class="line">        <span class="comment">// TODO: decide whether or not to throw an error if &quot;class&quot;</span></div>
<div class="line">        <span class="comment">//is set through this function since it may cause $updateClass to</span></div>
<div class="line">        <span class="comment">//become unstable.</span></div>
<div class="line"></div>
<div class="line">        var node = this.$$element[0],</div>
<div class="line">            booleanKey = getBooleanAttrName(node, key),</div>
<div class="line">            aliasedKey = getAliasedAttrName(node, key),</div>
<div class="line">            observer = key,</div>
<div class="line">            nodeName;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (booleanKey) {</div>
<div class="line">          this.$$element.prop(key, value);</div>
<div class="line">          attrName = booleanKey;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aliasedKey) {</div>
<div class="line">          <span class="keyword">this</span>[aliasedKey] = value;</div>
<div class="line">          observer = aliasedKey;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">this</span>[key] = value;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// translate normalized key to actual key</span></div>
<div class="line">        <span class="keywordflow">if</span> (attrName) {</div>
<div class="line">          this.$attr[key] = attrName;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          attrName = this.$attr[key];</div>
<div class="line">          <span class="keywordflow">if</span> (!attrName) {</div>
<div class="line">            this.$attr[key] = attrName = snake_case(key, <span class="charliteral">&#39;-&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        nodeName = nodeName_(this.$$element);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ((nodeName === <span class="charliteral">&#39;a&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;href&#39;</span>) ||</div>
<div class="line">            (nodeName === <span class="stringliteral">&#39;img&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;src&#39;</span>)) {</div>
<div class="line">          <span class="comment">// sanitize a[href] and img[src] values</span></div>
<div class="line">          <span class="keyword">this</span>[key] = value = $$sanitizeUri(value, key === <span class="stringliteral">&#39;src&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nodeName === <span class="stringliteral">&#39;img&#39;</span> &amp;&amp; key === <span class="stringliteral">&#39;srcset&#39;</span>) {</div>
<div class="line">          <span class="comment">// sanitize img[srcset] values</span></div>
<div class="line">          var result = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// first check if there are spaces because it&#39;s not the same pattern</span></div>
<div class="line">          var trimmedSrcset = trim(value);</div>
<div class="line">          <span class="comment">//                (   999x   ,|   999w   ,|   ,|,   )</span></div>
<div class="line">          var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;</div>
<div class="line">          var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// split srcset into tuple of uri and descriptor except for the last item</span></div>
<div class="line">          var rawUris = trimmedSrcset.split(pattern);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// for each tuples</span></div>
<div class="line">          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; nbrUrisWith2parts; i++) {</div>
<div class="line">            var innerIdx = i * 2;</div>
<div class="line">            <span class="comment">// sanitize the uri</span></div>
<div class="line">            result += $$sanitizeUri(trim(rawUris[innerIdx]), <span class="keyword">true</span>);</div>
<div class="line">            <span class="comment">// add the descriptor</span></div>
<div class="line">            result += (<span class="stringliteral">&quot; &quot;</span> + trim(rawUris[innerIdx + 1]));</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// split the last item into uri and descriptor</span></div>
<div class="line">          var lastTuple = trim(rawUris[i * 2]).split(/\s/);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// sanitize the last uri</span></div>
<div class="line">          result += $$sanitizeUri(trim(lastTuple[0]), <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// and add the last descriptor if any</span></div>
<div class="line">          <span class="keywordflow">if</span> (lastTuple.length === 2) {</div>
<div class="line">            result += (<span class="stringliteral">&quot; &quot;</span> + trim(lastTuple[1]));</div>
<div class="line">          }</div>
<div class="line">          <span class="keyword">this</span>[key] = value = result;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (writeAttr !== <span class="keyword">false</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (value === null || value === undefined) {</div>
<div class="line">            this.$$element.removeAttr(attrName);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            this.$$element.attr(attrName, value);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fire observers</span></div>
<div class="line">        var $$observers = this.$$observers;</div>
<div class="line">        $$observers &amp;&amp; forEach($$observers[observer], <span class="keyword">function</span>(fn) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            fn(value);</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $observe: <span class="keyword">function</span>(key, fn) {</div>
<div class="line">        var attrs = <span class="keyword">this</span>,</div>
<div class="line">            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),</div>
<div class="line">            listeners = ($$observers[key] || ($$observers[key] = []));</div>
<div class="line"></div>
<div class="line">        listeners.push(fn);</div>
<div class="line">        $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (!listeners.$$inter &amp;&amp; attrs.hasOwnProperty(key) &amp;&amp; !isUndefined(attrs[key])) {</div>
<div class="line">            <span class="comment">// no one registered attribute interpolation function, so lets call it manually</span></div>
<div class="line">            fn(attrs[key]);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          arrayRemove(listeners, fn);</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> safeAddClass($element, className) {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        $element.addClass(className);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="comment">// ignore, since it means that we are trying to set class on</span></div>
<div class="line">        <span class="comment">// SVG element, where class name is read-only.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    var startSymbol = $interpolate.startSymbol(),</div>
<div class="line">        endSymbol = $interpolate.endSymbol(),</div>
<div class="line">        denormalizeTemplate = (startSymbol == <span class="stringliteral">&#39;{{&#39;</span> || endSymbol  == <span class="stringliteral">&#39;}}&#39;</span>)</div>
<div class="line">            ? identity</div>
<div class="line">            : <span class="keyword">function</span> denormalizeTemplate(<span class="keyword">template</span>) {</div>
<div class="line">              <span class="keywordflow">return</span> <span class="keyword">template</span>.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);</div>
<div class="line">        },</div>
<div class="line">        NG_ATTR_BINDING = /^ngAttr[A-Z]/;</div>
<div class="line"></div>
<div class="line">    compile.$$addBindingInfo = debugInfoEnabled ? <span class="keyword">function</span> $$addBindingInfo($element, binding) {</div>
<div class="line">      var bindings = $element.data(<span class="stringliteral">&#39;$binding&#39;</span>) || [];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(binding)) {</div>
<div class="line">        bindings = bindings.concat(binding);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        bindings.push(binding);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $element.data(<span class="stringliteral">&#39;$binding&#39;</span>, bindings);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addBindingClass = debugInfoEnabled ? <span class="keyword">function</span> $$addBindingClass($element) {</div>
<div class="line">      safeAddClass($element, <span class="stringliteral">&#39;ng-binding&#39;</span>);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addScopeInfo = debugInfoEnabled ? <span class="keyword">function</span> $$addScopeInfo($element, scope, isolated, noTemplate) {</div>
<div class="line">      var dataName = isolated ? (noTemplate ? <span class="stringliteral">&#39;$isolateScopeNoTemplate&#39;</span> : <span class="stringliteral">&#39;$isolateScope&#39;</span>) : <span class="stringliteral">&#39;$scope&#39;</span>;</div>
<div class="line">      $element.data(dataName, scope);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    compile.$$addScopeClass = debugInfoEnabled ? <span class="keyword">function</span> $$addScopeClass($element, isolated) {</div>
<div class="line">      safeAddClass($element, isolated ? <span class="stringliteral">&#39;ng-isolate-scope&#39;</span> : <span class="stringliteral">&#39;ng-scope&#39;</span>);</div>
<div class="line">    } : noop;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> compile;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//================================</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,</div>
<div class="line">                        previousCompileContext) {</div>
<div class="line">      <span class="keywordflow">if</span> (!($compileNodes instanceof jqLite)) {</div>
<div class="line">        <span class="comment">// jquery always rewraps, whereas we need to preserve the original selector so that we can</span></div>
<div class="line">        <span class="comment">// modify it.</span></div>
<div class="line">        $compileNodes = jqLite($compileNodes);</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// We can not compile top level text elements since text nodes can be merged and we will</span></div>
<div class="line">      <span class="comment">// not be able to attach scope data to them, so we will wrap them in &lt;span&gt;</span></div>
<div class="line">      forEach($compileNodes, <span class="keyword">function</span>(node, index) {</div>
<div class="line">        <span class="keywordflow">if</span> (node.nodeType == NODE_TYPE_TEXT &amp;&amp; node.nodeValue.match(/\S+/) <span class="comment">/* non-empty */</span> ) {</div>
<div class="line">          $compileNodes[index] = jqLite(node).wrap(<span class="stringliteral">&#39;&lt;span&gt;&lt;/span&gt;&#39;</span>).parent()[0];</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      var compositeLinkFn =</div>
<div class="line">              compileNodes($compileNodes, transcludeFn, $compileNodes,</div>
<div class="line">                           maxPriority, ignoreDirective, previousCompileContext);</div>
<div class="line">      compile.$$addScopeClass($compileNodes);</div>
<div class="line">      var <span class="keyword">namespace </span>= null;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> publicLinkFn(scope, cloneConnectFn, options) {</div>
<div class="line">        assertArg(scope, <span class="stringliteral">&#39;scope&#39;</span>);</div>
<div class="line"></div>
<div class="line">        options = options || {};</div>
<div class="line">        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,</div>
<div class="line">          transcludeControllers = options.transcludeControllers,</div>
<div class="line">          futureParentElement = options.futureParentElement;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// When `parentBoundTranscludeFn` is passed, it is a</span></div>
<div class="line">        <span class="comment">// `controllersBoundTransclude` function (it was previously passed</span></div>
<div class="line">        <span class="comment">// as `transclude` to directive.link) so we must unwrap it to get</span></div>
<div class="line">        <span class="comment">// its `boundTranscludeFn`</span></div>
<div class="line">        <span class="keywordflow">if</span> (parentBoundTranscludeFn &amp;&amp; parentBoundTranscludeFn.$$boundTransclude) {</div>
<div class="line">          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!<span class="keyword">namespace</span>) {</div>
<div class="line">          <span class="keyword">namespace </span>= detectNamespaceForChildElements(futureParentElement);</div>
<div class="line">        }</div>
<div class="line">        var $linkNode;</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">namespace</span> !== <span class="stringliteral">&#39;html&#39;</span>) {</div>
<div class="line">          <span class="comment">// When using a directive with replace:true and templateUrl the $compileNodes</span></div>
<div class="line">          <span class="comment">// (or a child element inside of them)</span></div>
<div class="line">          <span class="comment">// might change, so we need to recreate the namespace adapted compileNodes</span></div>
<div class="line">          <span class="comment">// for call to the link function.</span></div>
<div class="line">          <span class="comment">// Note: This will already clone the nodes...</span></div>
<div class="line">          $linkNode = jqLite(</div>
<div class="line">            wrapTemplate(<span class="keyword">namespace</span>, jqLite(<span class="stringliteral">&#39;&lt;div&gt;&#39;</span>).append($compileNodes).html())</div>
<div class="line">          );</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cloneConnectFn) {</div>
<div class="line">          <span class="comment">// important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart</span></div>
<div class="line">          <span class="comment">// and sometimes changes the structure of the DOM.</span></div>
<div class="line">          $linkNode = JQLitePrototype.clone.call($compileNodes);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          $linkNode = $compileNodes;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (transcludeControllers) {</div>
<div class="line">          <span class="keywordflow">for</span> (var controllerName in transcludeControllers) {</div>
<div class="line">            $linkNode.data(<span class="charliteral">&#39;$&#39;</span> + controllerName + <span class="stringliteral">&#39;Controller&#39;</span>, transcludeControllers[controllerName].instance);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        compile.$$addScopeInfo($linkNode, scope);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (cloneConnectFn) cloneConnectFn($linkNode, scope);</div>
<div class="line">        <span class="keywordflow">if</span> (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);</div>
<div class="line">        <span class="keywordflow">return</span> $linkNode;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> detectNamespaceForChildElements(parentElement) {</div>
<div class="line">      <span class="comment">// TODO: Make this detect MathML as well...</span></div>
<div class="line">      var node = parentElement &amp;&amp; parentElement[0];</div>
<div class="line">      <span class="keywordflow">if</span> (!node) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;html&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> nodeName_(node) !== <span class="stringliteral">&#39;foreignobject&#39;</span> &amp;&amp; node.toString().match(/SVG/) ? <span class="stringliteral">&#39;svg&#39;</span> : <span class="stringliteral">&#39;html&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,</div>
<div class="line">                            previousCompileContext) {</div>
<div class="line">      var linkFns = [],</div>
<div class="line">          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; nodeList.length; i++) {</div>
<div class="line">        attrs = <span class="keyword">new</span> Attributes();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we must always refer to nodeList[i] since the nodes can be replaced underneath us.</span></div>
<div class="line">        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,</div>
<div class="line">                                        ignoreDirective);</div>
<div class="line"></div>
<div class="line">        nodeLinkFn = (directives.length)</div>
<div class="line">            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,</div>
<div class="line">                                      null, [], [], previousCompileContext)</div>
<div class="line">            : null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFn &amp;&amp; nodeLinkFn.scope) {</div>
<div class="line">          compile.$$addScopeClass(attrs.$$element);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        childLinkFn = (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||</div>
<div class="line">                      !(childNodes = nodeList[i].childNodes) ||</div>
<div class="line">                      !childNodes.length)</div>
<div class="line">            ? null</div>
<div class="line">            : compileNodes(childNodes,</div>
<div class="line">                 nodeLinkFn ? (</div>
<div class="line">                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)</div>
<div class="line">                     &amp;&amp; nodeLinkFn.transclude) : transcludeFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFn || childLinkFn) {</div>
<div class="line">          linkFns.push(i, nodeLinkFn, childLinkFn);</div>
<div class="line">          linkFnFound = <span class="keyword">true</span>;</div>
<div class="line">          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//use the previous context only for the first element in the virtual group</span></div>
<div class="line">        previousCompileContext = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// return a linking function if we have found anything, null otherwise</span></div>
<div class="line">      <span class="keywordflow">return</span> linkFnFound ? compositeLinkFn : null;</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {</div>
<div class="line">        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;</div>
<div class="line">        var stableNodeList;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nodeLinkFnFound) {</div>
<div class="line">          <span class="comment">// copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our</span></div>
<div class="line">          <span class="comment">// offsets don&#39;t get screwed up</span></div>
<div class="line">          var nodeListLength = nodeList.length;</div>
<div class="line">          stableNodeList = <span class="keyword">new</span> Array(nodeListLength);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// create a sparse array by only copying the elements which have a linkFn</span></div>
<div class="line">          <span class="keywordflow">for</span> (i = 0; i &lt; linkFns.length; i+=3) {</div>
<div class="line">            idx = linkFns[i];</div>
<div class="line">            stableNodeList[idx] = nodeList[idx];</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          stableNodeList = nodeList;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = linkFns.length; i &lt; ii;) {</div>
<div class="line">          node = stableNodeList[linkFns[i++]];</div>
<div class="line">          nodeLinkFn = linkFns[i++];</div>
<div class="line">          childLinkFn = linkFns[i++];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (nodeLinkFn) {</div>
<div class="line">            <span class="keywordflow">if</span> (nodeLinkFn.scope) {</div>
<div class="line">              childScope = scope.$new();</div>
<div class="line">              compile.$$addScopeInfo(jqLite(node), childScope);</div>
<div class="line">              var destroyBindings = nodeLinkFn.$$destroyBindings;</div>
<div class="line">              <span class="keywordflow">if</span> (destroyBindings) {</div>
<div class="line">                nodeLinkFn.$$destroyBindings = null;</div>
<div class="line">                childScope.$on(<span class="stringliteral">&#39;$destroyed&#39;</span>, destroyBindings);</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childScope = scope;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (nodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(</div>
<div class="line">                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!nodeLinkFn.templateOnThisElement &amp;&amp; parentBoundTranscludeFn) {</div>
<div class="line">              childBoundTranscludeFn = parentBoundTranscludeFn;</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!parentBoundTranscludeFn &amp;&amp; transcludeFn) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);</div>
<div class="line"></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childBoundTranscludeFn = null;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn,</div>
<div class="line">                       nodeLinkFn);</div>
<div class="line"></div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (childLinkFn) {</div>
<div class="line">            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {</div>
<div class="line"></div>
<div class="line">      var boundTranscludeFn = <span class="keyword">function</span>(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!transcludedScope) {</div>
<div class="line">          transcludedScope = scope.$new(<span class="keyword">false</span>, containingScope);</div>
<div class="line">          transcludedScope.$$transcluded = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> transcludeFn(transcludedScope, cloneFn, {</div>
<div class="line">          parentBoundTranscludeFn: previousBoundTranscludeFn,</div>
<div class="line">          transcludeControllers: controllers,</div>
<div class="line">          futureParentElement: futureParentElement</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> boundTranscludeFn;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {</div>
<div class="line">      var nodeType = node.nodeType,</div>
<div class="line">          attrsMap = attrs.$attr,</div>
<div class="line">          match,</div>
<div class="line">          className;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">switch</span> (nodeType) {</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_ELEMENT: <span class="comment">/* Element */</span></div>
<div class="line">          <span class="comment">// use the node name: &lt;directive&gt;</span></div>
<div class="line">          addDirective(directives,</div>
<div class="line">              directiveNormalize(nodeName_(node)), <span class="charliteral">&#39;E&#39;</span>, maxPriority, ignoreDirective);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// iterate over the attributes</span></div>
<div class="line">          <span class="keywordflow">for</span> (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,</div>
<div class="line">                   j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {</div>
<div class="line">            var attrStartName = <span class="keyword">false</span>;</div>
<div class="line">            var attrEndName = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            attr = nAttrs[j];</div>
<div class="line">            name = attr.name;</div>
<div class="line">            value = trim(attr.value);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// support ngAttr attribute binding</span></div>
<div class="line">            ngAttrName = directiveNormalize(name);</div>
<div class="line">            <span class="keywordflow">if</span> (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {</div>
<div class="line">              name = name.replace(PREFIX_REGEXP, <span class="stringliteral">&#39;&#39;</span>)</div>
<div class="line">                .substr(8).replace(/_(.)/g, <span class="keyword">function</span>(match, letter) {</div>
<div class="line">                  <span class="keywordflow">return</span> letter.toUpperCase();</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            var directiveNName = ngAttrName.replace(/(Start|End)$/, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (directiveIsMultiElement(directiveNName)) {</div>
<div class="line">              <span class="keywordflow">if</span> (ngAttrName === directiveNName + <span class="stringliteral">&#39;Start&#39;</span>) {</div>
<div class="line">                attrStartName = name;</div>
<div class="line">                attrEndName = name.substr(0, name.length - 5) + <span class="stringliteral">&#39;end&#39;</span>;</div>
<div class="line">                name = name.substr(0, name.length - 6);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            nName = directiveNormalize(name.toLowerCase());</div>
<div class="line">            attrsMap[nName] = name;</div>
<div class="line">            <span class="keywordflow">if</span> (isNgAttr || !attrs.hasOwnProperty(nName)) {</div>
<div class="line">                attrs[nName] = value;</div>
<div class="line">                <span class="keywordflow">if</span> (getBooleanAttrName(node, nName)) {</div>
<div class="line">                  attrs[nName] = <span class="keyword">true</span>; <span class="comment">// presence means true</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);</div>
<div class="line">            addDirective(directives, nName, <span class="charliteral">&#39;A&#39;</span>, maxPriority, ignoreDirective, attrStartName,</div>
<div class="line">                          attrEndName);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// use class as directive</span></div>
<div class="line">          className = node.className;</div>
<div class="line">          <span class="keywordflow">if</span> (isObject(className)) {</div>
<div class="line">              <span class="comment">// Maybe SVGAnimatedString</span></div>
<div class="line">              className = className.animVal;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (isString(className) &amp;&amp; className !== <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">            <span class="keywordflow">while</span> (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {</div>
<div class="line">              nName = directiveNormalize(match[2]);</div>
<div class="line">              <span class="keywordflow">if</span> (addDirective(directives, nName, <span class="charliteral">&#39;C&#39;</span>, maxPriority, ignoreDirective)) {</div>
<div class="line">                attrs[nName] = trim(match[3]);</div>
<div class="line">              }</div>
<div class="line">              className = className.substr(match.index + match[0].length);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_TEXT: <span class="comment">/* Text Node */</span></div>
<div class="line">          <span class="keywordflow">if</span> (msie === 11) {</div>
<div class="line">            <span class="comment">// Workaround for #11781</span></div>
<div class="line">            <span class="keywordflow">while</span> (node.parentNode &amp;&amp; node.nextSibling &amp;&amp; node.nextSibling.nodeType === NODE_TYPE_TEXT) {</div>
<div class="line">              node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;</div>
<div class="line">              node.parentNode.removeChild(node.nextSibling);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          addTextInterpolateDirective(directives, node.nodeValue);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> NODE_TYPE_COMMENT: <span class="comment">/* Comment */</span></div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);</div>
<div class="line">            <span class="keywordflow">if</span> (match) {</div>
<div class="line">              nName = directiveNormalize(match[1]);</div>
<div class="line">              <span class="keywordflow">if</span> (addDirective(directives, nName, <span class="charliteral">&#39;M&#39;</span>, maxPriority, ignoreDirective)) {</div>
<div class="line">                attrs[nName] = trim(match[2]);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            <span class="comment">// turns out that under some circumstances IE9 throws errors when one attempts to read</span></div>
<div class="line">            <span class="comment">// comment&#39;s node value.</span></div>
<div class="line">            <span class="comment">// Just ignore it and continue. (Can&#39;t seem to reproduce in test case.)</span></div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      directives.sort(byPriority);</div>
<div class="line">      <span class="keywordflow">return</span> directives;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> groupScan(node, attrStart, attrEnd) {</div>
<div class="line">      var nodes = [];</div>
<div class="line">      var depth = 0;</div>
<div class="line">      <span class="keywordflow">if</span> (attrStart &amp;&amp; node.hasAttribute &amp;&amp; node.hasAttribute(attrStart)) {</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!node) {</div>
<div class="line">            <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;uterdir&#39;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Unterminated attribute, found &#39;{0}&#39; but no matching &#39;{1}&#39; found.&quot;</span>,</div>
<div class="line">                      attrStart, attrEnd);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (node.nodeType == NODE_TYPE_ELEMENT) {</div>
<div class="line">            <span class="keywordflow">if</span> (node.hasAttribute(attrStart)) depth++;</div>
<div class="line">            <span class="keywordflow">if</span> (node.hasAttribute(attrEnd)) depth--;</div>
<div class="line">          }</div>
<div class="line">          nodes.push(node);</div>
<div class="line">          node = node.nextSibling;</div>
<div class="line">        } <span class="keywordflow">while</span> (depth &gt; 0);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        nodes.push(node);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> jqLite(nodes);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element, attrs, controllers, transcludeFn) {</div>
<div class="line">        element = groupScan(element[0], attrStart, attrEnd);</div>
<div class="line">        <span class="keywordflow">return</span> linkFn(scope, element, attrs, controllers, transcludeFn);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,</div>
<div class="line">                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,</div>
<div class="line">                                   previousCompileContext) {</div>
<div class="line">      previousCompileContext = previousCompileContext || {};</div>
<div class="line"></div>
<div class="line">      var terminalPriority = -Number.MAX_VALUE,</div>
<div class="line">          newScopeDirective = previousCompileContext.newScopeDirective,</div>
<div class="line">          controllerDirectives = previousCompileContext.controllerDirectives,</div>
<div class="line">          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,</div>
<div class="line">          templateDirective = previousCompileContext.templateDirective,</div>
<div class="line">          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,</div>
<div class="line">          hasTranscludeDirective = <span class="keyword">false</span>,</div>
<div class="line">          hasTemplate = <span class="keyword">false</span>,</div>
<div class="line">          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,</div>
<div class="line">          $compileNode = templateAttrs.$$element = jqLite(compileNode),</div>
<div class="line">          directive,</div>
<div class="line">          directiveName,</div>
<div class="line">          $template,</div>
<div class="line">          replaceDirective = originalReplaceDirective,</div>
<div class="line">          childTranscludeFn = transcludeFn,</div>
<div class="line">          linkFn,</div>
<div class="line">          directiveValue;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// executes all directives on the current element</span></div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">        directive = directives[i];</div>
<div class="line">        var attrStart = directive.$$start;</div>
<div class="line">        var attrEnd = directive.$$end;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// collect multiblock sections</span></div>
<div class="line">        <span class="keywordflow">if</span> (attrStart) {</div>
<div class="line">          $compileNode = groupScan(compileNode, attrStart, attrEnd);</div>
<div class="line">        }</div>
<div class="line">        $template = undefined;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (terminalPriority &gt; directive.priority) {</div>
<div class="line">          <span class="keywordflow">break</span>; <span class="comment">// prevent further processing of directives</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directiveValue = directive.scope) {</div>
<div class="line"></div>
<div class="line">          <span class="comment">// skip the check for directives with async templates, we&#39;ll check the derived sync</span></div>
<div class="line">          <span class="comment">// directive when the template arrives</span></div>
<div class="line">          <span class="keywordflow">if</span> (!directive.templateUrl) {</div>
<div class="line">            <span class="keywordflow">if</span> (isObject(directiveValue)) {</div>
<div class="line">              <span class="comment">// This directive is trying to add an isolated scope.</span></div>
<div class="line">              <span class="comment">// Check that there is no scope of any kind already</span></div>
<div class="line">              assertNoDuplicate(<span class="stringliteral">&#39;new/isolated scope&#39;</span>, newIsolateScopeDirective || newScopeDirective,</div>
<div class="line">                                directive, $compileNode);</div>
<div class="line">              newIsolateScopeDirective = directive;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// This directive is trying to add a child scope.</span></div>
<div class="line">              <span class="comment">// Check that there is no isolated scope already</span></div>
<div class="line">              assertNoDuplicate(<span class="stringliteral">&#39;new/isolated scope&#39;</span>, newIsolateScopeDirective, directive,</div>
<div class="line">                                $compileNode);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          newScopeDirective = newScopeDirective || directive;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        directiveName = directive.name;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!directive.templateUrl &amp;&amp; directive.controller) {</div>
<div class="line">          directiveValue = directive.controller;</div>
<div class="line">          controllerDirectives = controllerDirectives || createMap();</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&quot;&#39;&quot;</span> + directiveName + <span class="stringliteral">&quot;&#39; controller&quot;</span>,</div>
<div class="line">              controllerDirectives[directiveName], directive, $compileNode);</div>
<div class="line">          controllerDirectives[directiveName] = directive;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directiveValue = directive.transclude) {</div>
<div class="line">          hasTranscludeDirective = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Special case ngIf and ngRepeat so that we don&#39;t complain about duplicate transclusion.</span></div>
<div class="line">          <span class="comment">// This option should only be used by directives that know how to safely handle element transclusion,</span></div>
<div class="line">          <span class="comment">// where the transcluded nodes are added or replaced after linking.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!directive.$$tlb) {</div>
<div class="line">            assertNoDuplicate(<span class="stringliteral">&#39;transclusion&#39;</span>, nonTlbTranscludeDirective, directive, $compileNode);</div>
<div class="line">            nonTlbTranscludeDirective = directive;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directiveValue == <span class="stringliteral">&#39;element&#39;</span>) {</div>
<div class="line">            hasElementTranscludeDirective = <span class="keyword">true</span>;</div>
<div class="line">            terminalPriority = directive.priority;</div>
<div class="line">            $template = $compileNode;</div>
<div class="line">            $compileNode = templateAttrs.$$element =</div>
<div class="line">                jqLite(document.createComment(<span class="charliteral">&#39; &#39;</span> + directiveName + <span class="stringliteral">&#39;: &#39;</span> +</div>
<div class="line">                                              templateAttrs[directiveName] + <span class="charliteral">&#39; &#39;</span>));</div>
<div class="line">            compileNode = $compileNode[0];</div>
<div class="line">            replaceWith(jqCollection, sliceArgs($template), compileNode);</div>
<div class="line"></div>
<div class="line">            childTranscludeFn = compile($template, transcludeFn, terminalPriority,</div>
<div class="line">                                        replaceDirective &amp;&amp; replaceDirective.name, {</div>
<div class="line">                                          <span class="comment">// Don&#39;t pass in:</span></div>
<div class="line">                                          <span class="comment">// - controllerDirectives - otherwise we&#39;ll create duplicates controllers</span></div>
<div class="line">                                          <span class="comment">// - newIsolateScopeDirective or templateDirective - combining templates with</span></div>
<div class="line">                                          <span class="comment">//   element transclusion doesn&#39;t make sense.</span></div>
<div class="line">                                          <span class="comment">//</span></div>
<div class="line">                                          <span class="comment">// We need only nonTlbTranscludeDirective so that we prevent putting transclusion</span></div>
<div class="line">                                          <span class="comment">// on the same element more than once.</span></div>
<div class="line">                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective</div>
<div class="line">                                        });</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            $template = jqLite(jqLiteClone(compileNode)).contents();</div>
<div class="line">            $compileNode.empty(); <span class="comment">// clear contents</span></div>
<div class="line">            childTranscludeFn = compile($template, transcludeFn);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.template) {</div>
<div class="line">          hasTemplate = <span class="keyword">true</span>;</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&#39;template&#39;</span>, templateDirective, directive, $compileNode);</div>
<div class="line">          templateDirective = directive;</div>
<div class="line"></div>
<div class="line">          directiveValue = (isFunction(directive.template))</div>
<div class="line">              ? directive.template($compileNode, templateAttrs)</div>
<div class="line">              : directive.template;</div>
<div class="line"></div>
<div class="line">          directiveValue = denormalizeTemplate(directiveValue);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directive.replace) {</div>
<div class="line">            replaceDirective = directive;</div>
<div class="line">            <span class="keywordflow">if</span> (jqLiteIsTextNode(directiveValue)) {</div>
<div class="line">              $template = [];</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));</div>
<div class="line">            }</div>
<div class="line">            compileNode = $template[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tplrt&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Template for directive &#39;{0}&#39; must have exactly one root element. {1}&quot;</span>,</div>
<div class="line">                  directiveName, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            replaceWith(jqCollection, $compileNode, compileNode);</div>
<div class="line"></div>
<div class="line">            var newTemplateAttrs = {$attr: {}};</div>
<div class="line"></div>
<div class="line">            <span class="comment">// combine directives from the original node and from the template:</span></div>
<div class="line">            <span class="comment">// - take the array of directives for this element</span></div>
<div class="line">            <span class="comment">// - split it into two parts, those that already applied (processed) and those that weren&#39;t (unprocessed)</span></div>
<div class="line">            <span class="comment">// - collect directives from the template and sort them by priority</span></div>
<div class="line">            <span class="comment">// - combine directives as: processed + template + unprocessed</span></div>
<div class="line">            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);</div>
<div class="line">            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">              markDirectivesAsIsolate(templateDirectives);</div>
<div class="line">            }</div>
<div class="line">            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);</div>
<div class="line">            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);</div>
<div class="line"></div>
<div class="line">            ii = directives.length;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            $compileNode.html(directiveValue);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.templateUrl) {</div>
<div class="line">          hasTemplate = <span class="keyword">true</span>;</div>
<div class="line">          assertNoDuplicate(<span class="stringliteral">&#39;template&#39;</span>, templateDirective, directive, $compileNode);</div>
<div class="line">          templateDirective = directive;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (directive.replace) {</div>
<div class="line">            replaceDirective = directive;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,</div>
<div class="line">              templateAttrs, jqCollection, hasTranscludeDirective &amp;&amp; childTranscludeFn, preLinkFns, postLinkFns, {</div>
<div class="line">                controllerDirectives: controllerDirectives,</div>
<div class="line">                newScopeDirective: (newScopeDirective !== directive) &amp;&amp; newScopeDirective,</div>
<div class="line">                newIsolateScopeDirective: newIsolateScopeDirective,</div>
<div class="line">                templateDirective: templateDirective,</div>
<div class="line">                nonTlbTranscludeDirective: nonTlbTranscludeDirective</div>
<div class="line">              });</div>
<div class="line">          ii = directives.length;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (directive.compile) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);</div>
<div class="line">            <span class="keywordflow">if</span> (isFunction(linkFn)) {</div>
<div class="line">              addLinkFns(null, linkFn, attrStart, attrEnd);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (linkFn) {</div>
<div class="line">              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e, startingTag($compileNode));</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (directive.terminal) {</div>
<div class="line">          nodeLinkFn.terminal = <span class="keyword">true</span>;</div>
<div class="line">          terminalPriority = Math.max(terminalPriority, directive.priority);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      nodeLinkFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope === <span class="keyword">true</span>;</div>
<div class="line">      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;</div>
<div class="line">      nodeLinkFn.templateOnThisElement = hasTemplate;</div>
<div class="line">      nodeLinkFn.transclude = childTranscludeFn;</div>
<div class="line"></div>
<div class="line">      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// might be normal or delayed nodeLinkFn depending on if templateUrl is present</span></div>
<div class="line">      <span class="keywordflow">return</span> nodeLinkFn;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> addLinkFns(pre, post, attrStart, attrEnd) {</div>
<div class="line">        <span class="keywordflow">if</span> (pre) {</div>
<div class="line">          <span class="keywordflow">if</span> (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);</div>
<div class="line">          pre.require = directive.require;</div>
<div class="line">          pre.directiveName = directiveName;</div>
<div class="line">          <span class="keywordflow">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) {</div>
<div class="line">            pre = cloneAndAnnotateFn(pre, {isolateScope: <span class="keyword">true</span>});</div>
<div class="line">          }</div>
<div class="line">          preLinkFns.push(pre);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (post) {</div>
<div class="line">          <span class="keywordflow">if</span> (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);</div>
<div class="line">          post.require = directive.require;</div>
<div class="line">          post.directiveName = directiveName;</div>
<div class="line">          <span class="keywordflow">if</span> (newIsolateScopeDirective === directive || directive.$$isolateScope) {</div>
<div class="line">            post = cloneAndAnnotateFn(post, {isolateScope: <span class="keyword">true</span>});</div>
<div class="line">          }</div>
<div class="line">          postLinkFns.push(post);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> getControllers(directiveName, require, $element, elementControllers) {</div>
<div class="line">        var value;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isString(require)) {</div>
<div class="line">          var match = require.match(REQUIRE_PREFIX_REGEXP);</div>
<div class="line">          var name = require.substring(match[0].length);</div>
<div class="line">          var inheritType = match[1] || match[3];</div>
<div class="line">          var optional = match[2] === <span class="charliteral">&#39;?&#39;</span>;</div>
<div class="line"></div>
<div class="line">          <span class="comment">//If only parents then start at the parent element</span></div>
<div class="line">          <span class="keywordflow">if</span> (inheritType === <span class="stringliteral">&#39;^^&#39;</span>) {</div>
<div class="line">            $element = $element.parent();</div>
<div class="line">          <span class="comment">//Otherwise attempt getting the controller from elementControllers in case</span></div>
<div class="line">          <span class="comment">//the element is transcluded (and has no data) and to avoid .data if possible</span></div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            value = elementControllers &amp;&amp; elementControllers[name];</div>
<div class="line">            value = value &amp;&amp; value.instance;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!value) {</div>
<div class="line">            var dataName = <span class="charliteral">&#39;$&#39;</span> + name + <span class="stringliteral">&#39;Controller&#39;</span>;</div>
<div class="line">            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!value &amp;&amp; !optional) {</div>
<div class="line">            <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;ctreq&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;Controller &#39;{0}&#39;, required by directive &#39;{1}&#39;, can&#39;t be found!&quot;</span>,</div>
<div class="line">                name, directiveName);</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(require)) {</div>
<div class="line">          value = [];</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0, ii = require.length; i &lt; ii; i++) {</div>
<div class="line">            value[i] = getControllers(directiveName, require[i], $element, elementControllers);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> value || null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {</div>
<div class="line">        var elementControllers = createMap();</div>
<div class="line">        <span class="keywordflow">for</span> (var controllerKey in controllerDirectives) {</div>
<div class="line">          var directive = controllerDirectives[controllerKey];</div>
<div class="line">          var locals = {</div>
<div class="line">            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,</div>
<div class="line">            $element: $element,</div>
<div class="line">            $attrs: attrs,</div>
<div class="line">            $transclude: transcludeFn</div>
<div class="line">          };</div>
<div class="line"></div>
<div class="line">          var controller = directive.controller;</div>
<div class="line">          <span class="keywordflow">if</span> (controller == <span class="charliteral">&#39;@&#39;</span>) {</div>
<div class="line">            controller = attrs[directive.name];</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          var controllerInstance = $controller(controller, locals, <span class="keyword">true</span>, directive.controllerAs);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// For directives with element transclusion the element is a comment,</span></div>
<div class="line">          <span class="comment">// but jQuery .data doesn&#39;t support attaching data to comment nodes as it&#39;s hard to</span></div>
<div class="line">          <span class="comment">// clean up (http://bugs.jquery.com/ticket/8335).</span></div>
<div class="line">          <span class="comment">// Instead, we save the controllers for the element in a local hash and attach to .data</span></div>
<div class="line">          <span class="comment">// later, once we have the actual element.</span></div>
<div class="line">          elementControllers[directive.name] = controllerInstance;</div>
<div class="line">          <span class="keywordflow">if</span> (!hasElementTranscludeDirective) {</div>
<div class="line">            $element.data(<span class="charliteral">&#39;$&#39;</span> + directive.name + <span class="stringliteral">&#39;Controller&#39;</span>, controllerInstance.instance);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> elementControllers;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn,</div>
<div class="line">                          thisLinkFn) {</div>
<div class="line">        var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element,</div>
<div class="line">            attrs;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (compileNode === linkNode) {</div>
<div class="line">          attrs = templateAttrs;</div>
<div class="line">          $element = templateAttrs.$$element;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          $element = jqLite(linkNode);</div>
<div class="line">          attrs = <span class="keyword">new</span> Attributes($element, templateAttrs);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">          isolateScope = scope.$new(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (boundTranscludeFn) {</div>
<div class="line">          <span class="comment">// track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`</span></div>
<div class="line">          <span class="comment">// is later passed as `parentBoundTranscludeFn` to `publicLinkFn`</span></div>
<div class="line">          transcludeFn = controllersBoundTransclude;</div>
<div class="line">          transcludeFn.$$boundTransclude = boundTranscludeFn;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (controllerDirectives) {</div>
<div class="line">          elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective) {</div>
<div class="line">          <span class="comment">// Initialize isolate scope bindings for new isolate scope directive.</span></div>
<div class="line">          compile.$$addScopeInfo($element, isolateScope, <span class="keyword">true</span>, !(templateDirective &amp;&amp; (templateDirective === newIsolateScopeDirective ||</div>
<div class="line">              templateDirective === newIsolateScopeDirective.$$originalDirective)));</div>
<div class="line">          compile.$$addScopeClass($element, <span class="keyword">true</span>);</div>
<div class="line">          isolateScope.$$isolateBindings =</div>
<div class="line">              newIsolateScopeDirective.$$isolateBindings;</div>
<div class="line">          initializeDirectiveBindings(scope, attrs, isolateScope,</div>
<div class="line">                                      isolateScope.$$isolateBindings,</div>
<div class="line">                                      newIsolateScopeDirective, isolateScope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (elementControllers) {</div>
<div class="line">          <span class="comment">// Initialize bindToController bindings for new/isolate scopes</span></div>
<div class="line">          var scopeDirective = newIsolateScopeDirective || newScopeDirective;</div>
<div class="line">          var bindings;</div>
<div class="line">          var controllerForBindings;</div>
<div class="line">          <span class="keywordflow">if</span> (scopeDirective &amp;&amp; elementControllers[scopeDirective.name]) {</div>
<div class="line">            bindings = scopeDirective.$$bindings.bindToController;</div>
<div class="line">            controller = elementControllers[scopeDirective.name];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (controller &amp;&amp; controller.identifier &amp;&amp; bindings) {</div>
<div class="line">              controllerForBindings = controller;</div>
<div class="line">              thisLinkFn.$$destroyBindings =</div>
<div class="line">                  initializeDirectiveBindings(scope, attrs, controller.instance,</div>
<div class="line">                                              bindings, scopeDirective);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">for</span> (i in elementControllers) {</div>
<div class="line">            controller = elementControllers[i];</div>
<div class="line">            var controllerResult = controller();</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (controllerResult !== controller.instance) {</div>
<div class="line">              <span class="comment">// If the controller constructor has a return value, overwrite the instance</span></div>
<div class="line">              <span class="comment">// from setupControllers and update the element data</span></div>
<div class="line">              controller.instance = controllerResult;</div>
<div class="line">              $element.data(<span class="charliteral">&#39;$&#39;</span> + i + <span class="stringliteral">&#39;Controller&#39;</span>, controllerResult);</div>
<div class="line">              <span class="keywordflow">if</span> (controller === controllerForBindings) {</div>
<div class="line">                <span class="comment">// Remove and re-install bindToController bindings</span></div>
<div class="line">                thisLinkFn.$$destroyBindings();</div>
<div class="line">                thisLinkFn.$$destroyBindings =</div>
<div class="line">                  initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// PRELINKING</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = preLinkFns.length; i &lt; ii; i++) {</div>
<div class="line">          linkFn = preLinkFns[i];</div>
<div class="line">          invokeLinkFn(linkFn,</div>
<div class="line">              linkFn.isolateScope ? isolateScope : scope,</div>
<div class="line">              $element,</div>
<div class="line">              attrs,</div>
<div class="line">              linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),</div>
<div class="line">              transcludeFn</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// RECURSION</span></div>
<div class="line">        <span class="comment">// We only pass the isolate scope, if the isolate directive has a template,</span></div>
<div class="line">        <span class="comment">// otherwise the child elements do not belong to the isolate directive.</span></div>
<div class="line">        var scopeToChild = scope;</div>
<div class="line">        <span class="keywordflow">if</span> (newIsolateScopeDirective &amp;&amp; (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {</div>
<div class="line">          scopeToChild = isolateScope;</div>
<div class="line">        }</div>
<div class="line">        childLinkFn &amp;&amp; childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// POSTLINKING</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = postLinkFns.length - 1; i &gt;= 0; i--) {</div>
<div class="line">          linkFn = postLinkFns[i];</div>
<div class="line">          invokeLinkFn(linkFn,</div>
<div class="line">              linkFn.isolateScope ? isolateScope : scope,</div>
<div class="line">              $element,</div>
<div class="line">              attrs,</div>
<div class="line">              linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),</div>
<div class="line">              transcludeFn</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This is the function that is injected as `$transclude`.</span></div>
<div class="line">        <span class="comment">// Note: all arguments are optional!</span></div>
<div class="line">        <span class="keyword">function</span> controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {</div>
<div class="line">          var transcludeControllers;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// No scope passed in:</span></div>
<div class="line">          <span class="keywordflow">if</span> (!isScope(scope)) {</div>
<div class="line">            futureParentElement = cloneAttachFn;</div>
<div class="line">            cloneAttachFn = scope;</div>
<div class="line">            scope = undefined;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (hasElementTranscludeDirective) {</div>
<div class="line">            transcludeControllers = elementControllers;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (!futureParentElement) {</div>
<div class="line">            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> markDirectivesAsIsolate(directives) {</div>
<div class="line">      <span class="comment">// mark all directives as needing isolate scope.</span></div>
<div class="line">      <span class="keywordflow">for</span> (var j = 0, jj = directives.length; j &lt; jj; j++) {</div>
<div class="line">        directives[j] = inherit(directives[j], {$$isolateScope: <span class="keyword">true</span>});</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,</div>
<div class="line">                          endAttrName) {</div>
<div class="line">      <span class="keywordflow">if</span> (name === ignoreDirective) <span class="keywordflow">return</span> null;</div>
<div class="line">      var match = null;</div>
<div class="line">      <span class="keywordflow">if</span> (hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        <span class="keywordflow">for</span> (var directive, directives = $injector.get(name + Suffix),</div>
<div class="line">            i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            directive = directives[i];</div>
<div class="line">            <span class="keywordflow">if</span> ((maxPriority === undefined || maxPriority &gt; directive.priority) &amp;&amp;</div>
<div class="line">                 directive.restrict.indexOf(location) != -1) {</div>
<div class="line">              <span class="keywordflow">if</span> (startAttrName) {</div>
<div class="line">                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});</div>
<div class="line">              }</div>
<div class="line">              tDirectives.push(directive);</div>
<div class="line">              match = directive;</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) { $exceptionHandler(e); }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> match;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> directiveIsMultiElement(name) {</div>
<div class="line">      <span class="keywordflow">if</span> (hasDirectives.hasOwnProperty(name)) {</div>
<div class="line">        <span class="keywordflow">for</span> (var directive, directives = $injector.get(name + Suffix),</div>
<div class="line">            i = 0, ii = directives.length; i &lt; ii; i++) {</div>
<div class="line">          directive = directives[i];</div>
<div class="line">          <span class="keywordflow">if</span> (directive.multiElement) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> mergeTemplateAttributes(dst, src) {</div>
<div class="line">      var srcAttr = src.$attr,</div>
<div class="line">          dstAttr = dst.$attr,</div>
<div class="line">          $element = dst.$$element;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// reapply the old attributes to the new element</span></div>
<div class="line">      forEach(dst, <span class="keyword">function</span>(value, key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key.charAt(0) != <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">          <span class="keywordflow">if</span> (src[key] &amp;&amp; src[key] !== value) {</div>
<div class="line">            value += (key === <span class="stringliteral">&#39;style&#39;</span> ? <span class="charliteral">&#39;;&#39;</span> : <span class="charliteral">&#39; &#39;</span>) + src[key];</div>
<div class="line">          }</div>
<div class="line">          dst.$set(key, value, <span class="keyword">true</span>, srcAttr[key]);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// copy the new attributes on the old attrs object</span></div>
<div class="line">      forEach(src, <span class="keyword">function</span>(value, key) {</div>
<div class="line">        <span class="keywordflow">if</span> (key == <span class="stringliteral">&#39;class&#39;</span>) {</div>
<div class="line">          safeAddClass($element, value);</div>
<div class="line">          dst[<span class="stringliteral">&#39;class&#39;</span>] = (dst[<span class="stringliteral">&#39;class&#39;</span>] ? dst[<span class="stringliteral">&#39;class&#39;</span>] + <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + value;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key == <span class="stringliteral">&#39;style&#39;</span>) {</div>
<div class="line">          $element.attr(<span class="stringliteral">&#39;style&#39;</span>, $element.attr(<span class="stringliteral">&#39;style&#39;</span>) + <span class="charliteral">&#39;;&#39;</span> + value);</div>
<div class="line">          dst[<span class="stringliteral">&#39;style&#39;</span>] = (dst[<span class="stringliteral">&#39;style&#39;</span>] ? dst[<span class="stringliteral">&#39;style&#39;</span>] + <span class="charliteral">&#39;;&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + value;</div>
<div class="line">          <span class="comment">// `dst` will never contain hasOwnProperty as DOM parser won&#39;t let it.</span></div>
<div class="line">          <span class="comment">// You will get an &quot;InvalidCharacterError: DOM Exception 5&quot; error if you</span></div>
<div class="line">          <span class="comment">// have an attribute like &quot;has-own-property&quot; or &quot;data-has-own-property&quot;, etc.</span></div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (key.charAt(0) != <span class="charliteral">&#39;$&#39;</span> &amp;&amp; !dst.hasOwnProperty(key)) {</div>
<div class="line">          dst[key] = value;</div>
<div class="line">          dstAttr[key] = srcAttr[key];</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> compileTemplateUrl(directives, $compileNode, tAttrs,</div>
<div class="line">        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {</div>
<div class="line">      var linkQueue = [],</div>
<div class="line">          afterTemplateNodeLinkFn,</div>
<div class="line">          afterTemplateChildLinkFn,</div>
<div class="line">          beforeTemplateCompileNode = $compileNode[0],</div>
<div class="line">          origAsyncDirective = directives.shift(),</div>
<div class="line">          derivedSyncDirective = inherit(origAsyncDirective, {</div>
<div class="line">            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective</div>
<div class="line">          }),</div>
<div class="line">          templateUrl = (isFunction(origAsyncDirective.templateUrl))</div>
<div class="line">              ? origAsyncDirective.templateUrl($compileNode, tAttrs)</div>
<div class="line">              : origAsyncDirective.templateUrl,</div>
<div class="line">          templateNamespace = origAsyncDirective.templateNamespace;</div>
<div class="line"></div>
<div class="line">      $compileNode.empty();</div>
<div class="line"></div>
<div class="line">      $templateRequest(templateUrl)</div>
<div class="line">        .then(<span class="keyword">function</span>(content) {</div>
<div class="line">          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;</div>
<div class="line"></div>
<div class="line">          content = denormalizeTemplate(content);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (origAsyncDirective.replace) {</div>
<div class="line">            <span class="keywordflow">if</span> (jqLiteIsTextNode(content)) {</div>
<div class="line">              $template = [];</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));</div>
<div class="line">            }</div>
<div class="line">            compileNode = $template[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tplrt&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Template for directive &#39;{0}&#39; must have exactly one root element. {1}&quot;</span>,</div>
<div class="line">                  origAsyncDirective.name, templateUrl);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            tempTemplateAttrs = {$attr: {}};</div>
<div class="line">            replaceWith($rootElement, $compileNode, compileNode);</div>
<div class="line">            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (isObject(origAsyncDirective.scope)) {</div>
<div class="line">              markDirectivesAsIsolate(templateDirectives);</div>
<div class="line">            }</div>
<div class="line">            directives = templateDirectives.concat(directives);</div>
<div class="line">            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            compileNode = beforeTemplateCompileNode;</div>
<div class="line">            $compileNode.html(content);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          directives.unshift(derivedSyncDirective);</div>
<div class="line"></div>
<div class="line">          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,</div>
<div class="line">              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,</div>
<div class="line">              previousCompileContext);</div>
<div class="line">          forEach($rootElement, <span class="keyword">function</span>(node, i) {</div>
<div class="line">            <span class="keywordflow">if</span> (node == compileNode) {</div>
<div class="line">              $rootElement[i] = $compileNode[0];</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">while</span> (linkQueue.length) {</div>
<div class="line">            var scope = linkQueue.shift(),</div>
<div class="line">                beforeTemplateLinkNode = linkQueue.shift(),</div>
<div class="line">                linkRootElement = linkQueue.shift(),</div>
<div class="line">                boundTranscludeFn = linkQueue.shift(),</div>
<div class="line">                linkNode = $compileNode[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (scope.$$destroyed) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (beforeTemplateLinkNode !== beforeTemplateCompileNode) {</div>
<div class="line">              var oldClasses = beforeTemplateLinkNode.className;</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">if</span> (!(previousCompileContext.hasElementTranscludeDirective &amp;&amp;</div>
<div class="line">                  origAsyncDirective.replace)) {</div>
<div class="line">                <span class="comment">// it was cloned therefore we have to clone as well.</span></div>
<div class="line">                linkNode = jqLiteClone(compileNode);</div>
<div class="line">              }</div>
<div class="line">              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Copy in CSS classes from original node</span></div>
<div class="line">              safeAddClass(jqLite(linkNode), oldClasses);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (afterTemplateNodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              childBoundTranscludeFn = boundTranscludeFn;</div>
<div class="line">            }</div>
<div class="line">            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,</div>
<div class="line">              childBoundTranscludeFn, afterTemplateNodeLinkFn);</div>
<div class="line">          }</div>
<div class="line">          linkQueue = null;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {</div>
<div class="line">        var childBoundTranscludeFn = boundTranscludeFn;</div>
<div class="line">        <span class="keywordflow">if</span> (scope.$$destroyed) <span class="keywordflow">return</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (linkQueue) {</div>
<div class="line">          linkQueue.push(scope,</div>
<div class="line">                         node,</div>
<div class="line">                         rootElement,</div>
<div class="line">                         childBoundTranscludeFn);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (afterTemplateNodeLinkFn.transcludeOnThisElement) {</div>
<div class="line">            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);</div>
<div class="line">          }</div>
<div class="line">          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn,</div>
<div class="line">                                  afterTemplateNodeLinkFn);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> byPriority(a, b) {</div>
<div class="line">      var diff = b.priority - a.priority;</div>
<div class="line">      <span class="keywordflow">if</span> (diff !== 0) <span class="keywordflow">return</span> diff;</div>
<div class="line">      <span class="keywordflow">if</span> (a.name !== b.name) <span class="keywordflow">return</span> (a.name &lt; b.name) ? -1 : 1;</div>
<div class="line">      <span class="keywordflow">return</span> a.index - b.index;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> assertNoDuplicate(what, previousDirective, directive, element) {</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> wrapModuleNameIfDefined(moduleName) {</div>
<div class="line">        <span class="keywordflow">return</span> moduleName ?</div>
<div class="line">          (<span class="stringliteral">&#39; (module: &#39;</span> + moduleName + <span class="charliteral">&#39;)&#39;</span>) :</div>
<div class="line">          <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (previousDirective) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;multidir&#39;</span>, <span class="stringliteral">&#39;Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}&#39;</span>,</div>
<div class="line">            previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),</div>
<div class="line">            directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addTextInterpolateDirective(directives, text) {</div>
<div class="line">      var interpolateFn = $interpolate(text, <span class="keyword">true</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (interpolateFn) {</div>
<div class="line">        directives.push({</div>
<div class="line">          priority: 0,</div>
<div class="line">          compile: <span class="keyword">function</span> textInterpolateCompileFn(templateNode) {</div>
<div class="line">            var templateNodeParent = templateNode.parent(),</div>
<div class="line">                hasCompileParent = !!templateNodeParent.length;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// When transcluding a template that has bindings in the root</span></div>
<div class="line">            <span class="comment">// we don&#39;t have a parent and thus need to add the class during linking fn.</span></div>
<div class="line">            <span class="keywordflow">if</span> (hasCompileParent) compile.$$addBindingClass(templateNodeParent);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">function</span> textInterpolateLinkFn(scope, node) {</div>
<div class="line">              var parent = node.parent();</div>
<div class="line">              <span class="keywordflow">if</span> (!hasCompileParent) compile.$$addBindingClass(parent);</div>
<div class="line">              compile.$$addBindingInfo(parent, interpolateFn.expressions);</div>
<div class="line">              scope.$watch(interpolateFn, <span class="keyword">function</span> interpolateFnWatchAction(value) {</div>
<div class="line">                node[0].nodeValue = value;</div>
<div class="line">              });</div>
<div class="line">            };</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> wrapTemplate(type, <span class="keyword">template</span>) {</div>
<div class="line">      type = lowercase(type || <span class="stringliteral">&#39;html&#39;</span>);</div>
<div class="line">      <span class="keywordflow">switch</span> (type) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;svg&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;math&#39;</span>:</div>
<div class="line">        var wrapper = document.createElement(<span class="stringliteral">&#39;div&#39;</span>);</div>
<div class="line">        wrapper.innerHTML = <span class="charliteral">&#39;&lt;&#39;</span> + type + <span class="charliteral">&#39;&gt;&#39;</span> + <span class="keyword">template</span> + <span class="stringliteral">&#39;&lt;/&#39;</span> + type + <span class="charliteral">&#39;&gt;&#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> wrapper.childNodes[0].childNodes;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">template</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getTrustedContext(node, attrNormalizedName) {</div>
<div class="line">      <span class="keywordflow">if</span> (attrNormalizedName == <span class="stringliteral">&quot;srcdoc&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> $sce.HTML;</div>
<div class="line">      }</div>
<div class="line">      var tag = nodeName_(node);</div>
<div class="line">      <span class="comment">// maction[xlink:href] can source SVG.  It&#39;s not limited to &lt;maction&gt;.</span></div>
<div class="line">      <span class="keywordflow">if</span> (attrNormalizedName == <span class="stringliteral">&quot;xlinkHref&quot;</span> ||</div>
<div class="line">          (tag == <span class="stringliteral">&quot;form&quot;</span> &amp;&amp; attrNormalizedName == <span class="stringliteral">&quot;action&quot;</span>) ||</div>
<div class="line">          (tag != <span class="stringliteral">&quot;img&quot;</span> &amp;&amp; (attrNormalizedName == <span class="stringliteral">&quot;src&quot;</span> ||</div>
<div class="line">                            attrNormalizedName == <span class="stringliteral">&quot;ngSrc&quot;</span>))) {</div>
<div class="line">        <span class="keywordflow">return</span> $sce.RESOURCE_URL;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {</div>
<div class="line">      var trustedContext = getTrustedContext(node, name);</div>
<div class="line">      allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;</div>
<div class="line"></div>
<div class="line">      var interpolateFn = $interpolate(value, <span class="keyword">true</span>, trustedContext, allOrNothing);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// no interpolation found -&gt; ignore</span></div>
<div class="line">      <span class="keywordflow">if</span> (!interpolateFn) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (name === <span class="stringliteral">&quot;multiple&quot;</span> &amp;&amp; nodeName_(node) === <span class="stringliteral">&quot;select&quot;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&quot;selmulti&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Binding to the &#39;multiple&#39; attribute is not supported. Element: {0}&quot;</span>,</div>
<div class="line">            startingTag(node));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      directives.push({</div>
<div class="line">        priority: 100,</div>
<div class="line">        compile: <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> {</div>
<div class="line">              pre: <span class="keyword">function</span> attrInterpolatePreLinkFn(scope, element, attr) {</div>
<div class="line">                var $$observers = (attr.$$observers || (attr.$$observers = {}));</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (EVENT_HANDLER_ATTR_REGEXP.test(name)) {</div>
<div class="line">                  <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;nodomevents&#39;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Interpolations for HTML DOM event attributes are disallowed.  Please use the &quot;</span> +</div>
<div class="line">                          <span class="stringliteral">&quot;ng- versions (such as ng-click instead of onclick) instead.&quot;</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If the attribute has changed since last $interpolate()ed</span></div>
<div class="line">                var newValue = attr[name];</div>
<div class="line">                <span class="keywordflow">if</span> (newValue !== value) {</div>
<div class="line">                  <span class="comment">// we need to interpolate again since the attribute value has been updated</span></div>
<div class="line">                  <span class="comment">// (e.g. by another directive&#39;s compile function)</span></div>
<div class="line">                  <span class="comment">// ensure unset/empty values make interpolateFn falsy</span></div>
<div class="line">                  interpolateFn = newValue &amp;&amp; $interpolate(newValue, <span class="keyword">true</span>, trustedContext, allOrNothing);</div>
<div class="line">                  value = newValue;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// if attribute was updated so that there is no interpolation going on we don&#39;t want to</span></div>
<div class="line">                <span class="comment">// register any observers</span></div>
<div class="line">                <span class="keywordflow">if</span> (!interpolateFn) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// initialize attr object so that it&#39;s ready in case we need the value for isolate</span></div>
<div class="line">                <span class="comment">// scope initialization, otherwise the value would not be available from isolate</span></div>
<div class="line">                <span class="comment">// directive&#39;s linking fn during linking phase</span></div>
<div class="line">                attr[name] = interpolateFn(scope);</div>
<div class="line"></div>
<div class="line">                ($$observers[name] || ($$observers[name] = [])).$$inter = <span class="keyword">true</span>;</div>
<div class="line">                (attr.$$observers &amp;&amp; attr.$$observers[name].$$scope || scope).</div>
<div class="line">                  $watch(interpolateFn, <span class="keyword">function</span> interpolateFnWatchAction(newValue, oldValue) {</div>
<div class="line">                    <span class="comment">//special case for class attribute addition + removal</span></div>
<div class="line">                    <span class="comment">//so that class changes can tap into the animation</span></div>
<div class="line">                    <span class="comment">//hooks provided by the $animate service. Be sure to</span></div>
<div class="line">                    <span class="comment">//skip animations when the first digest occurs (when</span></div>
<div class="line">                    <span class="comment">//both the new and the old values are the same) since</span></div>
<div class="line">                    <span class="comment">//the CSS classes are the non-interpolated values</span></div>
<div class="line">                    <span class="keywordflow">if</span> (name === <span class="stringliteral">&#39;class&#39;</span> &amp;&amp; newValue != oldValue) {</div>
<div class="line">                      attr.$updateClass(newValue, oldValue);</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                      attr.$set(name, newValue);</div>
<div class="line">                    }</div>
<div class="line">                  });</div>
<div class="line">              }</div>
<div class="line">            };</div>
<div class="line">          }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> replaceWith($rootElement, elementsToRemove, newNode) {</div>
<div class="line">      var firstElementToRemove = elementsToRemove[0],</div>
<div class="line">          removeCount = elementsToRemove.length,</div>
<div class="line">          parent = firstElementToRemove.parentNode,</div>
<div class="line">          i, ii;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> ($rootElement) {</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = $rootElement.length; i &lt; ii; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> ($rootElement[i] == firstElementToRemove) {</div>
<div class="line">            $rootElement[i++] = newNode;</div>
<div class="line">            <span class="keywordflow">for</span> (var j = i, j2 = j + removeCount - 1,</div>
<div class="line">                     jj = $rootElement.length;</div>
<div class="line">                 j &lt; jj; j++, j2++) {</div>
<div class="line">              <span class="keywordflow">if</span> (j2 &lt; jj) {</div>
<div class="line">                $rootElement[j] = $rootElement[j2];</div>
<div class="line">              } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keyword">delete</span> $rootElement[j];</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            $rootElement.length -= removeCount - 1;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// If the replaced element is also the jQuery .context then replace it</span></div>
<div class="line">            <span class="comment">// .context is a deprecated jQuery api, so we should set it only when jQuery set it</span></div>
<div class="line">            <span class="comment">// http://api.jquery.com/context/</span></div>
<div class="line">            <span class="keywordflow">if</span> ($rootElement.context === firstElementToRemove) {</div>
<div class="line">              $rootElement.context = newNode;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (parent) {</div>
<div class="line">        parent.replaceChild(newNode, firstElementToRemove);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// TODO(perf): what&#39;s this document fragment for? is it needed? can we at least reuse it?</span></div>
<div class="line">      var fragment = document.createDocumentFragment();</div>
<div class="line">      fragment.appendChild(firstElementToRemove);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (jqLite.hasData(firstElementToRemove)) {</div>
<div class="line">        <span class="comment">// Copy over user data (that includes Angular&#39;s $scope etc.). Don&#39;t copy private</span></div>
<div class="line">        <span class="comment">// data here because there&#39;s no public interface in jQuery to do that and copying over</span></div>
<div class="line">        <span class="comment">// event listeners (which is the main use of private data) wouldn&#39;t work anyway.</span></div>
<div class="line">        jqLite(newNode).data(jqLite(firstElementToRemove).data());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Remove data of the replaced element. We cannot just call .remove()</span></div>
<div class="line">        <span class="comment">// on the element it since that would deallocate scope that is needed</span></div>
<div class="line">        <span class="comment">// for the new node. Instead, remove the data &quot;manually&quot;.</span></div>
<div class="line">        <span class="keywordflow">if</span> (!jQuery) {</div>
<div class="line">          <span class="keyword">delete</span> jqLite.cache[firstElementToRemove[jqLite.expando]];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// jQuery 2.x doesn&#39;t expose the data storage. Use jQuery.cleanData to clean up after</span></div>
<div class="line">          <span class="comment">// the replaced element. The cleanData version monkey-patched by Angular would cause</span></div>
<div class="line">          <span class="comment">// the scope to be trashed and we do need the very same scope to work with the new</span></div>
<div class="line">          <span class="comment">// element. However, we cannot just cache the non-patched version and use it here as</span></div>
<div class="line">          <span class="comment">// that would break if another library patches the method after Angular does (one</span></div>
<div class="line">          <span class="comment">// example is jQuery UI). Instead, set a flag indicating scope destroying should be</span></div>
<div class="line">          <span class="comment">// skipped this one time.</span></div>
<div class="line">          skipDestroyOnNextJQueryCleanData = <span class="keyword">true</span>;</div>
<div class="line">          jQuery.cleanData([firstElementToRemove]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (var k = 1, kk = elementsToRemove.length; k &lt; kk; k++) {</div>
<div class="line">        var element = elementsToRemove[k];</div>
<div class="line">        jqLite(element).remove(); <span class="comment">// must do this way to clean up expando</span></div>
<div class="line">        fragment.appendChild(element);</div>
<div class="line">        <span class="keyword">delete</span> elementsToRemove[k];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      elementsToRemove[0] = newNode;</div>
<div class="line">      elementsToRemove.length = 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> cloneAndAnnotateFn(fn, annotation) {</div>
<div class="line">      <span class="keywordflow">return</span> extend(<span class="keyword">function</span>() { <span class="keywordflow">return</span> fn.apply(null, arguments); }, fn, annotation);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        linkFn(scope, $element, attrs, controllers, transcludeFn);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        $exceptionHandler(e, startingTag($element));</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set up $watches for isolate scope and controller bindings. This process</span></div>
<div class="line">    <span class="comment">// only occurs for isolate scopes and new scopes with controllerAs.</span></div>
<div class="line">    <span class="keyword">function</span> initializeDirectiveBindings(scope, attrs, destination, bindings,</div>
<div class="line">                                         directive, newScope) {</div>
<div class="line">      var onNewScopeDestroyed;</div>
<div class="line">      forEach(bindings, <span class="keyword">function</span>(definition, scopeName) {</div>
<div class="line">        var attrName = definition.attrName,</div>
<div class="line">        optional = definition.optional,</div>
<div class="line">        mode = definition.mode, <span class="comment">// @, =, or &amp;</span></div>
<div class="line">        lastValue,</div>
<div class="line">        parentGet, parentSet, compare;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">switch</span> (mode) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;@&#39;</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!optional &amp;&amp; !hasOwnProperty.call(attrs, attrName)) {</div>
<div class="line">              destination[scopeName] = attrs[attrName] = <span class="keywordtype">void</span> 0;</div>
<div class="line">            }</div>
<div class="line">            attrs.$observe(attrName, <span class="keyword">function</span>(value) {</div>
<div class="line">              <span class="keywordflow">if</span> (isString(value)) {</div>
<div class="line">                destination[scopeName] = value;</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            attrs.$$observers[attrName].$$scope = scope;</div>
<div class="line">            <span class="keywordflow">if</span> (isString(attrs[attrName])) {</div>
<div class="line">              <span class="comment">// If the attribute has been provided then we trigger an interpolation to ensure</span></div>
<div class="line">              <span class="comment">// the value is there for use in the link fn</span></div>
<div class="line">              destination[scopeName] = $interpolate(attrs[attrName])(scope);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;=&#39;</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!hasOwnProperty.call(attrs, attrName)) {</div>
<div class="line">              <span class="keywordflow">if</span> (optional) <span class="keywordflow">break</span>;</div>
<div class="line">              attrs[attrName] = <span class="keywordtype">void</span> 0;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (optional &amp;&amp; !attrs[attrName]) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            parentGet = $parse(attrs[attrName]);</div>
<div class="line">            <span class="keywordflow">if</span> (parentGet.literal) {</div>
<div class="line">              compare = equals;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              compare = <span class="keyword">function</span>(a, b) { <span class="keywordflow">return</span> a === b || (a !== a &amp;&amp; b !== b); };</div>
<div class="line">            }</div>
<div class="line">            parentSet = parentGet.assign || <span class="keyword">function</span>() {</div>
<div class="line">              <span class="comment">// reset the change, or we will throw this exception on every $digest</span></div>
<div class="line">              lastValue = destination[scopeName] = parentGet(scope);</div>
<div class="line">              <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;nonassign&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Expression &#39;{0}&#39; used with directive &#39;{1}&#39; is non-assignable!&quot;</span>,</div>
<div class="line">                  attrs[attrName], directive.name);</div>
<div class="line">            };</div>
<div class="line">            lastValue = destination[scopeName] = parentGet(scope);</div>
<div class="line">            var parentValueWatch = <span class="keyword">function</span> parentValueWatch(parentValue) {</div>
<div class="line">              <span class="keywordflow">if</span> (!compare(parentValue, destination[scopeName])) {</div>
<div class="line">                <span class="comment">// we are out of sync and need to copy</span></div>
<div class="line">                <span class="keywordflow">if</span> (!compare(parentValue, lastValue)) {</div>
<div class="line">                  <span class="comment">// parent changed and it has precedence</span></div>
<div class="line">                  destination[scopeName] = parentValue;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  <span class="comment">// if the parent can be assigned then do so</span></div>
<div class="line">                  parentSet(scope, parentValue = destination[scopeName]);</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">              <span class="keywordflow">return</span> lastValue = parentValue;</div>
<div class="line">            };</div>
<div class="line">            parentValueWatch.$stateful = <span class="keyword">true</span>;</div>
<div class="line">            var unwatch;</div>
<div class="line">            <span class="keywordflow">if</span> (definition.collection) {</div>
<div class="line">              unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);</div>
<div class="line">            }</div>
<div class="line">            onNewScopeDestroyed = (onNewScopeDestroyed || []);</div>
<div class="line">            onNewScopeDestroyed.push(unwatch);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>:</div>
<div class="line">            <span class="comment">// Don&#39;t assign Object.prototype method to scope</span></div>
<div class="line">            parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Don&#39;t assign noop to destination if expression is not valid</span></div>
<div class="line">            <span class="keywordflow">if</span> (parentGet === noop &amp;&amp; optional) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            destination[scopeName] = <span class="keyword">function</span>(locals) {</div>
<div class="line">              <span class="keywordflow">return</span> parentGet(scope, locals);</div>
<div class="line">            };</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      var destroyBindings = onNewScopeDestroyed ? <span class="keyword">function</span> destroyBindings() {</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, ii = onNewScopeDestroyed.length; i &lt; ii; ++i) {</div>
<div class="line">          onNewScopeDestroyed[i]();</div>
<div class="line">        }</div>
<div class="line">      } : noop;</div>
<div class="line">      <span class="keywordflow">if</span> (newScope &amp;&amp; destroyBindings !== noop) {</div>
<div class="line">        newScope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, destroyBindings);</div>
<div class="line">        <span class="keywordflow">return</span> noop;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> destroyBindings;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;</div>
<div class="line"><span class="keyword">function</span> directiveNormalize(name) {</div>
<div class="line">  <span class="keywordflow">return</span> camelCase(name.replace(PREFIX_REGEXP, <span class="stringliteral">&#39;&#39;</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nodesetLinkingFn(</div>
<div class="line">  <span class="comment">/* angular.Scope */</span> scope,</div>
<div class="line">  <span class="comment">/* NodeList */</span> nodeList,</div>
<div class="line">  <span class="comment">/* Element */</span> rootElement,</div>
<div class="line">  <span class="comment">/* function(Function) */</span> boundTranscludeFn</div>
<div class="line">) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> directiveLinkingFn(</div>
<div class="line">  <span class="comment">/* nodesetLinkingFn */</span> nodesetLinkingFn,</div>
<div class="line">  <span class="comment">/* angular.Scope */</span> scope,</div>
<div class="line">  <span class="comment">/* Node */</span> node,</div>
<div class="line">  <span class="comment">/* Element */</span> rootElement,</div>
<div class="line">  <span class="comment">/* function(Function) */</span> boundTranscludeFn</div>
<div class="line">) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> tokenDifference(str1, str2) {</div>
<div class="line">  var values = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      tokens1 = str1.split(/\s+/),</div>
<div class="line">      tokens2 = str2.split(/\s+/);</div>
<div class="line"></div>
<div class="line">  outer:</div>
<div class="line">  <span class="keywordflow">for</span> (var i = 0; i &lt; tokens1.length; i++) {</div>
<div class="line">    var token = tokens1[i];</div>
<div class="line">    <span class="keywordflow">for</span> (var j = 0; j &lt; tokens2.length; j++) {</div>
<div class="line">      <span class="keywordflow">if</span> (token == tokens2[j]) <span class="keywordflow">continue</span> outer;</div>
<div class="line">    }</div>
<div class="line">    values += (values.length &gt; 0 ? <span class="charliteral">&#39; &#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + token;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> values;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> removeComments(jqNodes) {</div>
<div class="line">  jqNodes = jqLite(jqNodes);</div>
<div class="line">  var i = jqNodes.length;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (i &lt;= 1) {</div>
<div class="line">    <span class="keywordflow">return</span> jqNodes;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span> (i--) {</div>
<div class="line">    var node = jqNodes[i];</div>
<div class="line">    <span class="keywordflow">if</span> (node.nodeType === NODE_TYPE_COMMENT) {</div>
<div class="line">      splice.call(jqNodes, i, 1);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> jqNodes;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $controllerMinErr = minErr(<span class="stringliteral">&#39;$controller&#39;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;</div>
<div class="line"><span class="keyword">function</span> identifierForController(controller, ident) {</div>
<div class="line">  <span class="keywordflow">if</span> (ident &amp;&amp; isString(ident)) <span class="keywordflow">return</span> ident;</div>
<div class="line">  <span class="keywordflow">if</span> (isString(controller)) {</div>
<div class="line">    var match = CNTRL_REG.exec(controller);</div>
<div class="line">    <span class="keywordflow">if</span> (match) <span class="keywordflow">return</span> match[3];</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ControllerProvider() {</div>
<div class="line">  var controllers = {},</div>
<div class="line">      globals = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">function</span>(name, constructor) {</div>
<div class="line">    assertNotHasOwnProperty(name, <span class="stringliteral">&#39;controller&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(name)) {</div>
<div class="line">      extend(controllers, name);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      controllers[name] = constructor;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.allowGlobals = <span class="keyword">function</span>() {</div>
<div class="line">    globals = <span class="keyword">true</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>($injector, $window) {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(expression, locals, later, ident) {</div>
<div class="line">      <span class="comment">// PRIVATE API:</span></div>
<div class="line">      <span class="comment">//   param `later` --- indicates that the controller&#39;s constructor is invoked at a later time.</span></div>
<div class="line">      <span class="comment">//                     If true, $controller will allocate the object with the correct</span></div>
<div class="line">      <span class="comment">//                     prototype chain, but will not invoke the controller until a returned</span></div>
<div class="line">      <span class="comment">//                     callback is invoked.</span></div>
<div class="line">      <span class="comment">//   param `ident` --- An optional label which overrides the label parsed from the controller</span></div>
<div class="line">      <span class="comment">//                     expression, if any.</span></div>
<div class="line">      var instance, match, constructor, identifier;</div>
<div class="line">      later = later === <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (ident &amp;&amp; isString(ident)) {</div>
<div class="line">        identifier = ident;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isString(expression)) {</div>
<div class="line">        match = expression.match(CNTRL_REG);</div>
<div class="line">        <span class="keywordflow">if</span> (!match) {</div>
<div class="line">          <span class="keywordflow">throw</span> $controllerMinErr(<span class="stringliteral">&#39;ctrlfmt&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Badly formed controller string &#39;{0}&#39;. &quot;</span> +</div>
<div class="line">            <span class="stringliteral">&quot;Must match `__name__ as __id__` or `__name__`.&quot;</span>, expression);</div>
<div class="line">        }</div>
<div class="line">        constructor = match[1],</div>
<div class="line">        identifier = identifier || match[3];</div>
<div class="line">        expression = controllers.hasOwnProperty(constructor)</div>
<div class="line">            ? controllers[constructor]</div>
<div class="line">            : getter(locals.$scope, constructor, <span class="keyword">true</span>) ||</div>
<div class="line">                (globals ? getter($window, constructor, <span class="keyword">true</span>) : undefined);</div>
<div class="line"></div>
<div class="line">        assertArgFn(expression, constructor, <span class="keyword">true</span>);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (later) {</div>
<div class="line">        <span class="comment">// Instantiate controller later:</span></div>
<div class="line">        <span class="comment">// This machinery is used to create an instance of the object before calling the</span></div>
<div class="line">        <span class="comment">// controller&#39;s constructor itself.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This allows properties to be added to the controller before the constructor is</span></div>
<div class="line">        <span class="comment">// invoked. Primarily, this is used for isolate scope bindings in $compile.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This feature is not intended for use by applications, and is thus not documented</span></div>
<div class="line">        <span class="comment">// publicly.</span></div>
<div class="line">        <span class="comment">// Object creation: http://jsperf.com/create-constructor/2</span></div>
<div class="line">        var controllerPrototype = (isArray(expression) ?</div>
<div class="line">          expression[expression.length - 1] : expression).prototype;</div>
<div class="line">        instance = Object.create(controllerPrototype || null);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">          addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        var instantiate;</div>
<div class="line">        <span class="keywordflow">return</span> instantiate = extend(<span class="keyword">function</span>() {</div>
<div class="line">          var result = $injector.invoke(expression, instance, locals, constructor);</div>
<div class="line">          <span class="keywordflow">if</span> (result !== instance &amp;&amp; (isObject(result) || isFunction(result))) {</div>
<div class="line">            instance = result;</div>
<div class="line">            <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">              <span class="comment">// If result changed, re-assign controllerAs value to scope.</span></div>
<div class="line">              addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> instance;</div>
<div class="line">        }, {</div>
<div class="line">          instance: instance,</div>
<div class="line">          identifier: identifier</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      instance = $injector.instantiate(expression, locals, constructor);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (identifier) {</div>
<div class="line">        addIdentifier(locals, identifier, instance, constructor || expression.name);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> instance;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addIdentifier(locals, identifier, instance, name) {</div>
<div class="line">      <span class="keywordflow">if</span> (!(locals &amp;&amp; isObject(locals.$scope))) {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;$controller&#39;</span>)(<span class="stringliteral">&#39;noscp&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;Cannot export controller &#39;{0}&#39; as &#39;{1}&#39;! No $scope object provided via `locals`.&quot;</span>,</div>
<div class="line">          name, identifier);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      locals.$scope[identifier] = instance;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $DocumentProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>(window) {</div>
<div class="line">    <span class="keywordflow">return</span> jqLite(window.document);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ExceptionHandlerProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$log&#39;</span>, <span class="keyword">function</span>($log) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(exception, cause) {</div>
<div class="line">      $log.error.apply($log, arguments);</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $$ForceReflowProvider = <span class="keyword">function</span>() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$document&#39;</span>, <span class="keyword">function</span>($document) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(domNode) {</div>
<div class="line">      <span class="comment">//the line below will force the browser to perform a repaint so</span></div>
<div class="line">      <span class="comment">//that all the animated elements within the animation frame will</span></div>
<div class="line">      <span class="comment">//be properly updated and drawn on screen. This is required to</span></div>
<div class="line">      <span class="comment">//ensure that the preparation animation is properly flushed so that</span></div>
<div class="line">      <span class="comment">//the active state picks up from there. DO NOT REMOVE THIS LINE.</span></div>
<div class="line">      <span class="comment">//DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH</span></div>
<div class="line">      <span class="comment">//WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND</span></div>
<div class="line">      <span class="comment">//WILL TAKE YEARS AWAY FROM YOUR LIFE.</span></div>
<div class="line">      <span class="keywordflow">if</span> (domNode) {</div>
<div class="line">        <span class="keywordflow">if</span> (!domNode.nodeType &amp;&amp; domNode instanceof jqLite) {</div>
<div class="line">          domNode = domNode[0];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        domNode = $document[0].body;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> domNode.offsetWidth + 1;</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var APPLICATION_JSON = <span class="stringliteral">&#39;application/json&#39;</span>;</div>
<div class="line">var CONTENT_TYPE_APPLICATION_JSON = {<span class="stringliteral">&#39;Content-Type&#39;</span>: APPLICATION_JSON + <span class="stringliteral">&#39;;charset=utf-8&#39;</span>};</div>
<div class="line">var JSON_START = /^\[|^\{(?!\{)/;</div>
<div class="line">var JSON_ENDS = {</div>
<div class="line">  <span class="charliteral">&#39;[&#39;</span>: /]$/,</div>
<div class="line">  <span class="charliteral">&#39;{&#39;</span>: /}$/</div>
<div class="line">};</div>
<div class="line">var JSON_PROTECTION_PREFIX = /^\)\]\}<span class="stringliteral">&#39;,?\n/;</span></div>
<div class="line"><span class="stringliteral">var $httpMinErr = minErr(&#39;</span>$http<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">var $httpMinErrLegacyFn = function(method) {</span></div>
<div class="line"><span class="stringliteral">  return function() {</span></div>
<div class="line"><span class="stringliteral">    throw $httpMinErr(&#39;</span>legacy<span class="stringliteral">&#39;, &#39;</span>The method `{0}` on the promise returned from `$http` has been disabled.<span class="stringliteral">&#39;, method);</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">};</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function serializeValue(v) {</span></div>
<div class="line"><span class="stringliteral">  if (isObject(v)) {</span></div>
<div class="line"><span class="stringliteral">    return isDate(v) ? v.toISOString() : toJson(v);</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral">  return v;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpParamSerializerProvider() {</span></div>
<div class="line"><span class="stringliteral">  this.$get = function() {</span></div>
<div class="line"><span class="stringliteral">    return function ngParamSerializer(params) {</span></div>
<div class="line"><span class="stringliteral">      if (!params) return &#39;</span><span class="stringliteral">&#39;;</span></div>
<div class="line"><span class="stringliteral">      var parts = [];</span></div>
<div class="line"><span class="stringliteral">      forEachSorted(params, function(value, key) {</span></div>
<div class="line"><span class="stringliteral">        if (value === null || isUndefined(value)) return;</span></div>
<div class="line"><span class="stringliteral">        if (isArray(value)) {</span></div>
<div class="line"><span class="stringliteral">          forEach(value, function(v, k) {</span></div>
<div class="line"><span class="stringliteral">            parts.push(encodeUriQuery(key)  + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(v)));</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else {</span></div>
<div class="line"><span class="stringliteral">          parts.push(encodeUriQuery(key) + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(value)));</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">      });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">      return parts.join(&#39;</span>&amp;<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">    };</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpParamSerializerJQLikeProvider() {</span></div>
<div class="line"><span class="stringliteral">  this.$get = function() {</span></div>
<div class="line"><span class="stringliteral">    return function jQueryLikeParamSerializer(params) {</span></div>
<div class="line"><span class="stringliteral">      if (!params) return &#39;</span><span class="stringliteral">&#39;;</span></div>
<div class="line"><span class="stringliteral">      var parts = [];</span></div>
<div class="line"><span class="stringliteral">      serialize(params, &#39;</span><span class="stringliteral">&#39;, true);</span></div>
<div class="line"><span class="stringliteral">      return parts.join(&#39;</span>&amp;<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">      function serialize(toSerialize, prefix, topLevel) {</span></div>
<div class="line"><span class="stringliteral">        if (toSerialize === null || isUndefined(toSerialize)) return;</span></div>
<div class="line"><span class="stringliteral">        if (isArray(toSerialize)) {</span></div>
<div class="line"><span class="stringliteral">          forEach(toSerialize, function(value, index) {</span></div>
<div class="line"><span class="stringliteral">            serialize(value, prefix + &#39;</span>[<span class="stringliteral">&#39; + (isObject(value) ? index : &#39;</span><span class="stringliteral">&#39;) + &#39;</span>]<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else if (isObject(toSerialize) &amp;&amp; !isDate(toSerialize)) {</span></div>
<div class="line"><span class="stringliteral">          forEachSorted(toSerialize, function(value, key) {</span></div>
<div class="line"><span class="stringliteral">            serialize(value, prefix +</span></div>
<div class="line"><span class="stringliteral">                (topLevel ? &#39;</span><span class="stringliteral">&#39; : &#39;</span>[<span class="stringliteral">&#39;) +</span></div>
<div class="line"><span class="stringliteral">                key +</span></div>
<div class="line"><span class="stringliteral">                (topLevel ? &#39;</span><span class="stringliteral">&#39; : &#39;</span>]<span class="stringliteral">&#39;));</span></div>
<div class="line"><span class="stringliteral">          });</span></div>
<div class="line"><span class="stringliteral">        } else {</span></div>
<div class="line"><span class="stringliteral">          parts.push(encodeUriQuery(prefix) + &#39;</span>=<span class="stringliteral">&#39; + encodeUriQuery(serializeValue(toSerialize)));</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">    };</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function defaultHttpResponseTransform(data, headers) {</span></div>
<div class="line"><span class="stringliteral">  if (isString(data)) {</span></div>
<div class="line"><span class="stringliteral">    // Strip json vulnerability protection prefix and trim whitespace</span></div>
<div class="line"><span class="stringliteral">    var tempData = data.replace(JSON_PROTECTION_PREFIX, &#39;</span><span class="stringliteral">&#39;).trim();</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    if (tempData) {</span></div>
<div class="line"><span class="stringliteral">      var contentType = headers(&#39;</span>Content-Type<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">      if ((contentType &amp;&amp; (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {</span></div>
<div class="line"><span class="stringliteral">        data = fromJson(tempData);</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return data;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function isJsonLike(str) {</span></div>
<div class="line"><span class="stringliteral">    var jsonStart = str.match(JSON_START);</span></div>
<div class="line"><span class="stringliteral">    return jsonStart &amp;&amp; JSON_ENDS[jsonStart[0]].test(str);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function parseHeaders(headers) {</span></div>
<div class="line"><span class="stringliteral">  var parsed = createMap(), i;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  function fillInParsed(key, val) {</span></div>
<div class="line"><span class="stringliteral">    if (key) {</span></div>
<div class="line"><span class="stringliteral">      parsed[key] = parsed[key] ? parsed[key] + &#39;</span>, <span class="stringliteral">&#39; + val : val;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  if (isString(headers)) {</span></div>
<div class="line"><span class="stringliteral">    forEach(headers.split(&#39;</span>\n<span class="stringliteral">&#39;), function(line) {</span></div>
<div class="line"><span class="stringliteral">      i = line.indexOf(&#39;</span>:<span class="stringliteral">&#39;);</span></div>
<div class="line"><span class="stringliteral">      fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  } else if (isObject(headers)) {</span></div>
<div class="line"><span class="stringliteral">    forEach(headers, function(headerVal, headerKey) {</span></div>
<div class="line"><span class="stringliteral">      fillInParsed(lowercase(headerKey), trim(headerVal));</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return parsed;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function headersGetter(headers) {</span></div>
<div class="line"><span class="stringliteral">  var headersObj;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return function(name) {</span></div>
<div class="line"><span class="stringliteral">    if (!headersObj) headersObj =  parseHeaders(headers);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    if (name) {</span></div>
<div class="line"><span class="stringliteral">      var value = headersObj[lowercase(name)];</span></div>
<div class="line"><span class="stringliteral">      if (value === void 0) {</span></div>
<div class="line"><span class="stringliteral">        value = null;</span></div>
<div class="line"><span class="stringliteral">      }</span></div>
<div class="line"><span class="stringliteral">      return value;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    return headersObj;</span></div>
<div class="line"><span class="stringliteral">  };</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function transformData(data, headers, status, fns) {</span></div>
<div class="line"><span class="stringliteral">  if (isFunction(fns)) {</span></div>
<div class="line"><span class="stringliteral">    return fns(data, headers, status);</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  forEach(fns, function(fn) {</span></div>
<div class="line"><span class="stringliteral">    data = fn(data, headers, status);</span></div>
<div class="line"><span class="stringliteral">  });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  return data;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function isSuccess(status) {</span></div>
<div class="line"><span class="stringliteral">  return 200 &lt;= status &amp;&amp; status &lt; 300;</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function $HttpProvider() {</span></div>
<div class="line"><span class="stringliteral">  var defaults = this.defaults = {</span></div>
<div class="line"><span class="stringliteral">    // transform incoming response data</span></div>
<div class="line"><span class="stringliteral">    transformResponse: [defaultHttpResponseTransform],</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // transform outgoing request data</span></div>
<div class="line"><span class="stringliteral">    transformRequest: [function(d) {</span></div>
<div class="line"><span class="stringliteral">      return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) &amp;&amp; !isFormData(d) ? toJson(d) : d;</span></div>
<div class="line"><span class="stringliteral">    }],</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // default headers</span></div>
<div class="line"><span class="stringliteral">    headers: {</span></div>
<div class="line"><span class="stringliteral">      common: {</span></div>
<div class="line"><span class="stringliteral">        &#39;</span>Accept<span class="stringliteral">&#39;: &#39;</span>application/json, text/plain, *<span class="comment">/*&#39;</span></div>
<div class="line"><span class="comment">      },</span></div>
<div class="line"><span class="comment">      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),</span></div>
<div class="line"><span class="comment">      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),</span></div>
<div class="line"><span class="comment">      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)</span></div>
<div class="line"><span class="comment">    },</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    xsrfCookieName: &#39;XSRF-TOKEN&#39;,</span></div>
<div class="line"><span class="comment">    xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;,</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    paramSerializer: &#39;$httpParamSerializer&#39;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var useApplyAsync = false;</span></div>
<div class="line"><span class="comment">  this.useApplyAsync = function(value) {</span></div>
<div class="line"><span class="comment">    if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">      useApplyAsync = !!value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    return useApplyAsync;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var useLegacyPromise = true;</span></div>
<div class="line"><span class="comment">  this.useLegacyPromiseExtensions = function(value) {</span></div>
<div class="line"><span class="comment">    if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">      useLegacyPromise = !!value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">    return useLegacyPromise;</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  var interceptorFactories = this.interceptors = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$httpBackend&#39;, &#39;$$cookieReader&#39;, &#39;$cacheFactory&#39;, &#39;$rootScope&#39;, &#39;$q&#39;, &#39;$injector&#39;,</span></div>
<div class="line"><span class="comment">      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    var defaultCache = $cacheFactory(&#39;$http&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    defaults.paramSerializer = isString(defaults.paramSerializer) ?</span></div>
<div class="line"><span class="comment">      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    var reversedInterceptors = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    forEach(interceptorFactories, function(interceptorFactory) {</span></div>
<div class="line"><span class="comment">      reversedInterceptors.unshift(isString(interceptorFactory)</span></div>
<div class="line"><span class="comment">          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));</span></div>
<div class="line"><span class="comment">    });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function $http(requestConfig) {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (!angular.isObject(requestConfig)) {</span></div>
<div class="line"><span class="comment">        throw minErr(&#39;$http&#39;)(&#39;badreq&#39;, &#39;Http request configuration must be an object.  Received: {0}&#39;, requestConfig);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var config = extend({</span></div>
<div class="line"><span class="comment">        method: &#39;get&#39;,</span></div>
<div class="line"><span class="comment">        transformRequest: defaults.transformRequest,</span></div>
<div class="line"><span class="comment">        transformResponse: defaults.transformResponse,</span></div>
<div class="line"><span class="comment">        paramSerializer: defaults.paramSerializer</span></div>
<div class="line"><span class="comment">      }, requestConfig);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      config.headers = mergeHeaders(requestConfig);</span></div>
<div class="line"><span class="comment">      config.method = uppercase(config.method);</span></div>
<div class="line"><span class="comment">      config.paramSerializer = isString(config.paramSerializer) ?</span></div>
<div class="line"><span class="comment">        $injector.get(config.paramSerializer) : config.paramSerializer;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var serverRequest = function(config) {</span></div>
<div class="line"><span class="comment">        var headers = config.headers;</span></div>
<div class="line"><span class="comment">        var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // strip content-type if data is undefined</span></div>
<div class="line"><span class="comment">        if (isUndefined(reqData)) {</span></div>
<div class="line"><span class="comment">          forEach(headers, function(value, header) {</span></div>
<div class="line"><span class="comment">            if (lowercase(header) === &#39;content-type&#39;) {</span></div>
<div class="line"><span class="comment">                delete headers[header];</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials)) {</span></div>
<div class="line"><span class="comment">          config.withCredentials = defaults.withCredentials;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // send request</span></div>
<div class="line"><span class="comment">        return sendReq(config, reqData).then(transformResponse, transformResponse);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var chain = [serverRequest, undefined];</span></div>
<div class="line"><span class="comment">      var promise = $q.when(config);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // apply interceptors</span></div>
<div class="line"><span class="comment">      forEach(reversedInterceptors, function(interceptor) {</span></div>
<div class="line"><span class="comment">        if (interceptor.request || interceptor.requestError) {</span></div>
<div class="line"><span class="comment">          chain.unshift(interceptor.request, interceptor.requestError);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        if (interceptor.response || interceptor.responseError) {</span></div>
<div class="line"><span class="comment">          chain.push(interceptor.response, interceptor.responseError);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      while (chain.length) {</span></div>
<div class="line"><span class="comment">        var thenFn = chain.shift();</span></div>
<div class="line"><span class="comment">        var rejectFn = chain.shift();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        promise = promise.then(thenFn, rejectFn);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (useLegacyPromise) {</span></div>
<div class="line"><span class="comment">        promise.success = function(fn) {</span></div>
<div class="line"><span class="comment">          assertArgFn(fn, &#39;fn&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          promise.then(function(response) {</span></div>
<div class="line"><span class="comment">            fn(response.data, response.status, response.headers, config);</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">          return promise;</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        promise.error = function(fn) {</span></div>
<div class="line"><span class="comment">          assertArgFn(fn, &#39;fn&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          promise.then(null, function(response) {</span></div>
<div class="line"><span class="comment">            fn(response.data, response.status, response.headers, config);</span></div>
<div class="line"><span class="comment">          });</span></div>
<div class="line"><span class="comment">          return promise;</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      } else {</span></div>
<div class="line"><span class="comment">        promise.success = $httpMinErrLegacyFn(&#39;success&#39;);</span></div>
<div class="line"><span class="comment">        promise.error = $httpMinErrLegacyFn(&#39;error&#39;);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function transformResponse(response) {</span></div>
<div class="line"><span class="comment">        // make a copy since the response must be cacheable</span></div>
<div class="line"><span class="comment">        var resp = extend({}, response);</span></div>
<div class="line"><span class="comment">        if (!response.data) {</span></div>
<div class="line"><span class="comment">          resp.data = response.data;</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        return (isSuccess(response.status))</span></div>
<div class="line"><span class="comment">          ? resp</span></div>
<div class="line"><span class="comment">          : $q.reject(resp);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function executeHeaderFns(headers, config) {</span></div>
<div class="line"><span class="comment">        var headerContent, processedHeaders = {};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        forEach(headers, function(headerFn, header) {</span></div>
<div class="line"><span class="comment">          if (isFunction(headerFn)) {</span></div>
<div class="line"><span class="comment">            headerContent = headerFn(config);</span></div>
<div class="line"><span class="comment">            if (headerContent != null) {</span></div>
<div class="line"><span class="comment">              processedHeaders[header] = headerContent;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            processedHeaders[header] = headerFn;</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        return processedHeaders;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function mergeHeaders(config) {</span></div>
<div class="line"><span class="comment">        var defHeaders = defaults.headers,</span></div>
<div class="line"><span class="comment">            reqHeaders = extend({}, config.headers),</span></div>
<div class="line"><span class="comment">            defHeaderName, lowercaseDefHeaderName, reqHeaderName;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // using for-in instead of forEach to avoid unecessary iteration after header has been found</span></div>
<div class="line"><span class="comment">        defaultHeadersIteration:</span></div>
<div class="line"><span class="comment">        for (defHeaderName in defHeaders) {</span></div>
<div class="line"><span class="comment">          lowercaseDefHeaderName = lowercase(defHeaderName);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          for (reqHeaderName in reqHeaders) {</span></div>
<div class="line"><span class="comment">            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {</span></div>
<div class="line"><span class="comment">              continue defaultHeadersIteration;</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          reqHeaders[defHeaderName] = defHeaders[defHeaderName];</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // execute if header value is a function for merged headers</span></div>
<div class="line"><span class="comment">        return executeHeaderFns(reqHeaders, shallowCopy(config));</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $http.pendingRequests = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    createShortMethods(&#39;get&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;jsonp&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    createShortMethodsWithData(&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $http.defaults = defaults;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return $http;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function createShortMethods(names) {</span></div>
<div class="line"><span class="comment">      forEach(arguments, function(name) {</span></div>
<div class="line"><span class="comment">        $http[name] = function(url, config) {</span></div>
<div class="line"><span class="comment">          return $http(extend({}, config || {}, {</span></div>
<div class="line"><span class="comment">            method: name,</span></div>
<div class="line"><span class="comment">            url: url</span></div>
<div class="line"><span class="comment">          }));</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function createShortMethodsWithData(name) {</span></div>
<div class="line"><span class="comment">      forEach(arguments, function(name) {</span></div>
<div class="line"><span class="comment">        $http[name] = function(url, data, config) {</span></div>
<div class="line"><span class="comment">          return $http(extend({}, config || {}, {</span></div>
<div class="line"><span class="comment">            method: name,</span></div>
<div class="line"><span class="comment">            url: url,</span></div>
<div class="line"><span class="comment">            data: data</span></div>
<div class="line"><span class="comment">          }));</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function sendReq(config, reqData) {</span></div>
<div class="line"><span class="comment">      var deferred = $q.defer(),</span></div>
<div class="line"><span class="comment">          promise = deferred.promise,</span></div>
<div class="line"><span class="comment">          cache,</span></div>
<div class="line"><span class="comment">          cachedResp,</span></div>
<div class="line"><span class="comment">          reqHeaders = config.headers,</span></div>
<div class="line"><span class="comment">          url = buildUrl(config.url, config.paramSerializer(config.params));</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      $http.pendingRequests.push(config);</span></div>
<div class="line"><span class="comment">      promise.then(removePendingReq, removePendingReq);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if ((config.cache || defaults.cache) &amp;&amp; config.cache !== false &amp;&amp;</span></div>
<div class="line"><span class="comment">          (config.method === &#39;GET&#39; || config.method === &#39;JSONP&#39;)) {</span></div>
<div class="line"><span class="comment">        cache = isObject(config.cache) ? config.cache</span></div>
<div class="line"><span class="comment">              : isObject(defaults.cache) ? defaults.cache</span></div>
<div class="line"><span class="comment">              : defaultCache;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (cache) {</span></div>
<div class="line"><span class="comment">        cachedResp = cache.get(url);</span></div>
<div class="line"><span class="comment">        if (isDefined(cachedResp)) {</span></div>
<div class="line"><span class="comment">          if (isPromiseLike(cachedResp)) {</span></div>
<div class="line"><span class="comment">            // cached request has already been sent, but there is no response yet</span></div>
<div class="line"><span class="comment">            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            // serving from cache</span></div>
<div class="line"><span class="comment">            if (isArray(cachedResp)) {</span></div>
<div class="line"><span class="comment">              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);</span></div>
<div class="line"><span class="comment">            } else {</span></div>
<div class="line"><span class="comment">              resolvePromise(cachedResp, 200, {}, &#39;OK&#39;);</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          // put the promise for the non-transformed response into cache as a placeholder</span></div>
<div class="line"><span class="comment">          cache.put(url, promise);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // if we won&#39;t have the response in cache, set the xsrf headers and</span></div>
<div class="line"><span class="comment">      // send the request to the backend</span></div>
<div class="line"><span class="comment">      if (isUndefined(cachedResp)) {</span></div>
<div class="line"><span class="comment">        var xsrfValue = urlIsSameOrigin(config.url)</span></div>
<div class="line"><span class="comment">            ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName]</span></div>
<div class="line"><span class="comment">            : undefined;</span></div>
<div class="line"><span class="comment">        if (xsrfValue) {</span></div>
<div class="line"><span class="comment">          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,</span></div>
<div class="line"><span class="comment">            config.withCredentials, config.responseType);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function done(status, response, headersString, statusText) {</span></div>
<div class="line"><span class="comment">        if (cache) {</span></div>
<div class="line"><span class="comment">          if (isSuccess(status)) {</span></div>
<div class="line"><span class="comment">            cache.put(url, [status, response, parseHeaders(headersString), statusText]);</span></div>
<div class="line"><span class="comment">          } else {</span></div>
<div class="line"><span class="comment">            // remove promise from the cache</span></div>
<div class="line"><span class="comment">            cache.remove(url);</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        function resolveHttpPromise() {</span></div>
<div class="line"><span class="comment">          resolvePromise(response, status, headersString, statusText);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (useApplyAsync) {</span></div>
<div class="line"><span class="comment">          $rootScope.$applyAsync(resolveHttpPromise);</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          resolveHttpPromise();</span></div>
<div class="line"><span class="comment">          if (!$rootScope.$$phase) $rootScope.$apply();</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function resolvePromise(response, status, headers, statusText) {</span></div>
<div class="line"><span class="comment">        // normalize internal statuses to 0</span></div>
<div class="line"><span class="comment">        status = Math.max(status, 0);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        (isSuccess(status) ? deferred.resolve : deferred.reject)({</span></div>
<div class="line"><span class="comment">          data: response,</span></div>
<div class="line"><span class="comment">          status: status,</span></div>
<div class="line"><span class="comment">          headers: headersGetter(headers),</span></div>
<div class="line"><span class="comment">          config: config,</span></div>
<div class="line"><span class="comment">          statusText: statusText</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function resolvePromiseWithResult(result) {</span></div>
<div class="line"><span class="comment">        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function removePendingReq() {</span></div>
<div class="line"><span class="comment">        var idx = $http.pendingRequests.indexOf(config);</span></div>
<div class="line"><span class="comment">        if (idx !== -1) $http.pendingRequests.splice(idx, 1);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function buildUrl(url, serializedParams) {</span></div>
<div class="line"><span class="comment">      if (serializedParams.length &gt; 0) {</span></div>
<div class="line"><span class="comment">        url += ((url.indexOf(&#39;?&#39;) == -1) ? &#39;?&#39; : &#39;&amp;&#39;) + serializedParams;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      return url;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function createXhr() {</span></div>
<div class="line"><span class="comment">    return new window.XMLHttpRequest();</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $HttpBackendProvider() {</span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$browser&#39;, &#39;$window&#39;, &#39;$document&#39;, function($browser, $window, $document) {</span></div>
<div class="line"><span class="comment">    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {</span></div>
<div class="line"><span class="comment">  // TODO(vojta): fix the signature</span></div>
<div class="line"><span class="comment">  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {</span></div>
<div class="line"><span class="comment">    $browser.$$incOutstandingRequestCount();</span></div>
<div class="line"><span class="comment">    url = url || $browser.url();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    if (lowercase(method) == &#39;jsonp&#39;) {</span></div>
<div class="line"><span class="comment">      var callbackId = &#39;_&#39; + (callbacks.counter++).toString(36);</span></div>
<div class="line"><span class="comment">      callbacks[callbackId] = function(data) {</span></div>
<div class="line"><span class="comment">        callbacks[callbackId].data = data;</span></div>
<div class="line"><span class="comment">        callbacks[callbackId].called = true;</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var jsonpDone = jsonpReq(url.replace(&#39;JSON_CALLBACK&#39;, &#39;angular.callbacks.&#39; + callbackId),</span></div>
<div class="line"><span class="comment">          callbackId, function(status, text) {</span></div>
<div class="line"><span class="comment">        completeRequest(callback, status, callbacks[callbackId].data, &quot;&quot;, text);</span></div>
<div class="line"><span class="comment">        callbacks[callbackId] = noop;</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var xhr = createXhr();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.open(method, url, true);</span></div>
<div class="line"><span class="comment">      forEach(headers, function(value, key) {</span></div>
<div class="line"><span class="comment">        if (isDefined(value)) {</span></div>
<div class="line"><span class="comment">            xhr.setRequestHeader(key, value);</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.onload = function requestLoaded() {</span></div>
<div class="line"><span class="comment">        var statusText = xhr.statusText || &#39;&#39;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // responseText is the old-school way of retrieving response (supported by IE9)</span></div>
<div class="line"><span class="comment">        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)</span></div>
<div class="line"><span class="comment">        var response = (&#39;response&#39; in xhr) ? xhr.response : xhr.responseText;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)</span></div>
<div class="line"><span class="comment">        var status = xhr.status === 1223 ? 204 : xhr.status;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        // fix status code when it is 0 (0 status is undocumented).</span></div>
<div class="line"><span class="comment">        // Occurs when accessing file resources or on Android 4.1 stock browser</span></div>
<div class="line"><span class="comment">        // while retrieving files from application cache.</span></div>
<div class="line"><span class="comment">        if (status === 0) {</span></div>
<div class="line"><span class="comment">          status = response ? 200 : urlResolve(url).protocol == &#39;file&#39; ? 404 : 0;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        completeRequest(callback,</span></div>
<div class="line"><span class="comment">            status,</span></div>
<div class="line"><span class="comment">            response,</span></div>
<div class="line"><span class="comment">            xhr.getAllResponseHeaders(),</span></div>
<div class="line"><span class="comment">            statusText);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      var requestError = function() {</span></div>
<div class="line"><span class="comment">        // The response is always empty</span></div>
<div class="line"><span class="comment">        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error</span></div>
<div class="line"><span class="comment">        completeRequest(callback, -1, null, null, &#39;&#39;);</span></div>
<div class="line"><span class="comment">      };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.onerror = requestError;</span></div>
<div class="line"><span class="comment">      xhr.onabort = requestError;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (withCredentials) {</span></div>
<div class="line"><span class="comment">        xhr.withCredentials = true;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (responseType) {</span></div>
<div class="line"><span class="comment">        try {</span></div>
<div class="line"><span class="comment">          xhr.responseType = responseType;</span></div>
<div class="line"><span class="comment">        } catch (e) {</span></div>
<div class="line"><span class="comment">          // WebKit added support for the json responseType value on 09/03/2013</span></div>
<div class="line"><span class="comment">          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are</span></div>
<div class="line"><span class="comment">          // known to throw when setting the value &quot;json&quot; as the response type. Other older</span></div>
<div class="line"><span class="comment">          // browsers implementing the responseType</span></div>
<div class="line"><span class="comment">          //</span></div>
<div class="line"><span class="comment">          // The json response type can be ignored if not supported, because JSON payloads are</span></div>
<div class="line"><span class="comment">          // parsed on the client-side regardless.</span></div>
<div class="line"><span class="comment">          if (responseType !== &#39;json&#39;) {</span></div>
<div class="line"><span class="comment">            throw e;</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      xhr.send(post);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    if (timeout &gt; 0) {</span></div>
<div class="line"><span class="comment">      var timeoutId = $browserDefer(timeoutRequest, timeout);</span></div>
<div class="line"><span class="comment">    } else if (isPromiseLike(timeout)) {</span></div>
<div class="line"><span class="comment">      timeout.then(timeoutRequest);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function timeoutRequest() {</span></div>
<div class="line"><span class="comment">      jsonpDone &amp;&amp; jsonpDone();</span></div>
<div class="line"><span class="comment">      xhr &amp;&amp; xhr.abort();</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function completeRequest(callback, status, response, headersString, statusText) {</span></div>
<div class="line"><span class="comment">      // cancel timeout and subsequent timeout promise resolution</span></div>
<div class="line"><span class="comment">      if (timeoutId !== undefined) {</span></div>
<div class="line"><span class="comment">        $browserDefer.cancel(timeoutId);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      jsonpDone = xhr = null;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      callback(status, response, headersString, statusText);</span></div>
<div class="line"><span class="comment">      $browser.$$completeOutstandingRequest(noop);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  function jsonpReq(url, callbackId, done) {</span></div>
<div class="line"><span class="comment">    // we can&#39;t use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:</span></div>
<div class="line"><span class="comment">    // - fetches local scripts via XHR and evals them</span></div>
<div class="line"><span class="comment">    // - adds and immediately removes script elements from the document</span></div>
<div class="line"><span class="comment">    var script = rawDocument.createElement(&#39;script&#39;), callback = null;</span></div>
<div class="line"><span class="comment">    script.type = &quot;text/javascript&quot;;</span></div>
<div class="line"><span class="comment">    script.src = url;</span></div>
<div class="line"><span class="comment">    script.async = true;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    callback = function(event) {</span></div>
<div class="line"><span class="comment">      removeEventListenerFn(script, &quot;load&quot;, callback);</span></div>
<div class="line"><span class="comment">      removeEventListenerFn(script, &quot;error&quot;, callback);</span></div>
<div class="line"><span class="comment">      rawDocument.body.removeChild(script);</span></div>
<div class="line"><span class="comment">      script = null;</span></div>
<div class="line"><span class="comment">      var status = -1;</span></div>
<div class="line"><span class="comment">      var text = &quot;unknown&quot;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (event) {</span></div>
<div class="line"><span class="comment">        if (event.type === &quot;load&quot; &amp;&amp; !callbacks[callbackId].called) {</span></div>
<div class="line"><span class="comment">          event = { type: &quot;error&quot; };</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">        text = event.type;</span></div>
<div class="line"><span class="comment">        status = event.type === &quot;error&quot; ? 404 : 200;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (done) {</span></div>
<div class="line"><span class="comment">        done(status, text);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    addEventListenerFn(script, &quot;load&quot;, callback);</span></div>
<div class="line"><span class="comment">    addEventListenerFn(script, &quot;error&quot;, callback);</span></div>
<div class="line"><span class="comment">    rawDocument.body.appendChild(script);</span></div>
<div class="line"><span class="comment">    return callback;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">var $interpolateMinErr = angular.$interpolateMinErr = minErr(&#39;$interpolate&#39;);</span></div>
<div class="line"><span class="comment">$interpolateMinErr.throwNoconcat = function(text) {</span></div>
<div class="line"><span class="comment">  throw $interpolateMinErr(&#39;noconcat&#39;,</span></div>
<div class="line"><span class="comment">      &quot;Error while interpolating: {0}\nStrict Contextual Escaping disallows &quot; +</span></div>
<div class="line"><span class="comment">      &quot;interpolations that concatenate multiple expressions when a trusted value is &quot; +</span></div>
<div class="line"><span class="comment">      &quot;required.  See http://docs.angularjs.org/api/ng.$sce&quot;, text);</span></div>
<div class="line"><span class="comment">};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">$interpolateMinErr.interr = function(text, err) {</span></div>
<div class="line"><span class="comment">  return $interpolateMinErr(&#39;interr&#39;, &quot;Can&#39;t interpolate: {0}\n{1}&quot;, text, err.toString());</span></div>
<div class="line"><span class="comment">};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $InterpolateProvider() {</span></div>
<div class="line"><span class="comment">  var startSymbol = &#39;{{&#39;;</span></div>
<div class="line"><span class="comment">  var endSymbol = &#39;}}&#39;;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.startSymbol = function(value) {</span></div>
<div class="line"><span class="comment">    if (value) {</span></div>
<div class="line"><span class="comment">      startSymbol = value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment">      return startSymbol;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.endSymbol = function(value) {</span></div>
<div class="line"><span class="comment">    if (value) {</span></div>
<div class="line"><span class="comment">      endSymbol = value;</span></div>
<div class="line"><span class="comment">      return this;</span></div>
<div class="line"><span class="comment">    } else {</span></div>
<div class="line"><span class="comment">      return endSymbol;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment">  };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$parse&#39;, &#39;$exceptionHandler&#39;, &#39;$sce&#39;, function($parse, $exceptionHandler, $sce) {</span></div>
<div class="line"><span class="comment">    var startSymbolLength = startSymbol.length,</span></div>
<div class="line"><span class="comment">        endSymbolLength = endSymbol.length,</span></div>
<div class="line"><span class="comment">        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), &#39;g&#39;),</span></div>
<div class="line"><span class="comment">        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), &#39;g&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function escape(ch) {</span></div>
<div class="line"><span class="comment">      return &#39;\\\\\\&#39; + ch;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function unescapeText(text) {</span></div>
<div class="line"><span class="comment">      return text.replace(escapedStartRegexp, startSymbol).</span></div>
<div class="line"><span class="comment">        replace(escapedEndRegexp, endSymbol);</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function stringify(value) {</span></div>
<div class="line"><span class="comment">      if (value == null) { // null || undefined</span></div>
<div class="line"><span class="comment">        return &#39;&#39;;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      switch (typeof value) {</span></div>
<div class="line"><span class="comment">        case &#39;string&#39;:</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        case &#39;number&#39;:</span></div>
<div class="line"><span class="comment">          value = &#39;&#39; + value;</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        default:</span></div>
<div class="line"><span class="comment">          value = toJson(value);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return value;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {</span></div>
<div class="line"><span class="comment">      allOrNothing = !!allOrNothing;</span></div>
<div class="line"><span class="comment">      var startIndex,</span></div>
<div class="line"><span class="comment">          endIndex,</span></div>
<div class="line"><span class="comment">          index = 0,</span></div>
<div class="line"><span class="comment">          expressions = [],</span></div>
<div class="line"><span class="comment">          parseFns = [],</span></div>
<div class="line"><span class="comment">          textLength = text.length,</span></div>
<div class="line"><span class="comment">          exp,</span></div>
<div class="line"><span class="comment">          concat = [],</span></div>
<div class="line"><span class="comment">          expressionPositions = [];</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      while (index &lt; textLength) {</span></div>
<div class="line"><span class="comment">        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;</span></div>
<div class="line"><span class="comment">             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {</span></div>
<div class="line"><span class="comment">          if (index !== startIndex) {</span></div>
<div class="line"><span class="comment">            concat.push(unescapeText(text.substring(index, startIndex)));</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          exp = text.substring(startIndex + startSymbolLength, endIndex);</span></div>
<div class="line"><span class="comment">          expressions.push(exp);</span></div>
<div class="line"><span class="comment">          parseFns.push($parse(exp, parseStringifyInterceptor));</span></div>
<div class="line"><span class="comment">          index = endIndex + endSymbolLength;</span></div>
<div class="line"><span class="comment">          expressionPositions.push(concat.length);</span></div>
<div class="line"><span class="comment">          concat.push(&#39;&#39;);</span></div>
<div class="line"><span class="comment">        } else {</span></div>
<div class="line"><span class="comment">          // we did not find an interpolation, so we have to add the remainder to the separators array</span></div>
<div class="line"><span class="comment">          if (index !== textLength) {</span></div>
<div class="line"><span class="comment">            concat.push(unescapeText(text.substring(index)));</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          break;</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      // Concatenating expressions makes it hard to reason about whether some combination of</span></div>
<div class="line"><span class="comment">      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a</span></div>
<div class="line"><span class="comment">      // single expression be used for iframe[src], object[src], etc., we ensure that the value</span></div>
<div class="line"><span class="comment">      // that&#39;s used is assigned or constructed by some JS code somewhere that is more testable or</span></div>
<div class="line"><span class="comment">      // make it obvious that you bound the value to some user controlled value.  This helps reduce</span></div>
<div class="line"><span class="comment">      // the load when auditing for XSS issues.</span></div>
<div class="line"><span class="comment">      if (trustedContext &amp;&amp; concat.length &gt; 1) {</span></div>
<div class="line"><span class="comment">          $interpolateMinErr.throwNoconcat(text);</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      if (!mustHaveExpression || expressions.length) {</span></div>
<div class="line"><span class="comment">        var compute = function(values) {</span></div>
<div class="line"><span class="comment">          for (var i = 0, ii = expressions.length; i &lt; ii; i++) {</span></div>
<div class="line"><span class="comment">            if (allOrNothing &amp;&amp; isUndefined(values[i])) return;</span></div>
<div class="line"><span class="comment">            concat[expressionPositions[i]] = values[i];</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">          return concat.join(&#39;&#39;);</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        var getValue = function(value) {</span></div>
<div class="line"><span class="comment">          return trustedContext ?</span></div>
<div class="line"><span class="comment">            $sce.getTrusted(trustedContext, value) :</span></div>
<div class="line"><span class="comment">            $sce.valueOf(value);</span></div>
<div class="line"><span class="comment">        };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        return extend(function interpolationFn(context) {</span></div>
<div class="line"><span class="comment">            var i = 0;</span></div>
<div class="line"><span class="comment">            var ii = expressions.length;</span></div>
<div class="line"><span class="comment">            var values = new Array(ii);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">            try {</span></div>
<div class="line"><span class="comment">              for (; i &lt; ii; i++) {</span></div>
<div class="line"><span class="comment">                values[i] = parseFns[i](context);</span></div>
<div class="line"><span class="comment">              }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">              return compute(values);</span></div>
<div class="line"><span class="comment">            } catch (err) {</span></div>
<div class="line"><span class="comment">              $exceptionHandler($interpolateMinErr.interr(text, err));</span></div>
<div class="line"><span class="comment">            }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">          }, {</span></div>
<div class="line"><span class="comment">          // all of these properties are undocumented for now</span></div>
<div class="line"><span class="comment">          exp: text, //just for compatibility with regular watchers created via $watch</span></div>
<div class="line"><span class="comment">          expressions: expressions,</span></div>
<div class="line"><span class="comment">          $$watchDelegate: function(scope, listener) {</span></div>
<div class="line"><span class="comment">            var lastValue;</span></div>
<div class="line"><span class="comment">            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {</span></div>
<div class="line"><span class="comment">              var currValue = compute(values);</span></div>
<div class="line"><span class="comment">              if (isFunction(listener)) {</span></div>
<div class="line"><span class="comment">                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);</span></div>
<div class="line"><span class="comment">              }</span></div>
<div class="line"><span class="comment">              lastValue = currValue;</span></div>
<div class="line"><span class="comment">            });</span></div>
<div class="line"><span class="comment">          }</span></div>
<div class="line"><span class="comment">        });</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      function parseStringifyInterceptor(value) {</span></div>
<div class="line"><span class="comment">        try {</span></div>
<div class="line"><span class="comment">          value = getValue(value);</span></div>
<div class="line"><span class="comment">          return allOrNothing &amp;&amp; !isDefined(value) ? value : stringify(value);</span></div>
<div class="line"><span class="comment">        } catch (err) {</span></div>
<div class="line"><span class="comment">          $exceptionHandler($interpolateMinErr.interr(text, err));</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $interpolate.startSymbol = function() {</span></div>
<div class="line"><span class="comment">      return startSymbol;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    $interpolate.endSymbol = function() {</span></div>
<div class="line"><span class="comment">      return endSymbol;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return $interpolate;</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function $IntervalProvider() {</span></div>
<div class="line"><span class="comment">  this.$get = [&#39;$rootScope&#39;, &#39;$window&#39;, &#39;$q&#39;, &#39;$$q&#39;,</span></div>
<div class="line"><span class="comment">       function($rootScope,   $window,   $q,   $$q) {</span></div>
<div class="line"><span class="comment">    var intervals = {};</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    function interval(fn, delay, count, invokeApply) {</span></div>
<div class="line"><span class="comment">      var hasParams = arguments.length &gt; 4,</span></div>
<div class="line"><span class="comment">          args = hasParams ? sliceArgs(arguments, 4) : [],</span></div>
<div class="line"><span class="comment">          setInterval = $window.setInterval,</span></div>
<div class="line"><span class="comment">          clearInterval = $window.clearInterval,</span></div>
<div class="line"><span class="comment">          iteration = 0,</span></div>
<div class="line"><span class="comment">          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),</span></div>
<div class="line"><span class="comment">          deferred = (skipApply ? $$q : $q).defer(),</span></div>
<div class="line"><span class="comment">          promise = deferred.promise;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      count = isDefined(count) ? count : 0;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      promise.then(null, null, (!hasParams) ? fn : function() {</span></div>
<div class="line"><span class="comment">        fn.apply(null, args);</span></div>
<div class="line"><span class="comment">      });</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      promise.$$intervalId = setInterval(function tick() {</span></div>
<div class="line"><span class="comment">        deferred.notify(iteration++);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (count &gt; 0 &amp;&amp; iteration &gt;= count) {</span></div>
<div class="line"><span class="comment">          deferred.resolve(iteration);</span></div>
<div class="line"><span class="comment">          clearInterval(promise.$$intervalId);</span></div>
<div class="line"><span class="comment">          delete intervals[promise.$$intervalId];</span></div>
<div class="line"><span class="comment">        }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">        if (!skipApply) $rootScope.$apply();</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      }, delay);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      intervals[promise.$$intervalId] = deferred;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      return promise;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    interval.cancel = function(promise) {</span></div>
<div class="line"><span class="comment">      if (promise &amp;&amp; promise.$$intervalId in intervals) {</span></div>
<div class="line"><span class="comment">        intervals[promise.$$intervalId].reject(&#39;canceled&#39;);</span></div>
<div class="line"><span class="comment">        $window.clearInterval(promise.$$intervalId);</span></div>
<div class="line"><span class="comment">        delete intervals[promise.$$intervalId];</span></div>
<div class="line"><span class="comment">        return true;</span></div>
<div class="line"><span class="comment">      }</span></div>
<div class="line"><span class="comment">      return false;</span></div>
<div class="line"><span class="comment">    };</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">    return interval;</span></div>
<div class="line"><span class="comment">  }];</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,</span></div>
<div class="line"><span class="comment">    DEFAULT_PORTS = {&#39;http&#39;: 80, &#39;https&#39;: 443, &#39;ftp&#39;: 21};</span></div>
<div class="line"><span class="comment">var $locationMinErr = minErr(&#39;$location&#39;);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function encodePath(path) {</span></div>
<div class="line"><span class="comment">  var segments = path.split(&#39;/&#39;),</span></div>
<div class="line"><span class="comment">      i = segments.length;</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  while (i--) {</span></div>
<div class="line"><span class="comment">    segments[i] = encodeUriSegment(segments[i]);</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  return segments.join(&#39;/&#39;);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function parseAbsoluteUrl(absoluteUrl, locationObj) {</span></div>
<div class="line"><span class="comment">  var parsedUrl = urlResolve(absoluteUrl);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  locationObj.$$protocol = parsedUrl.protocol;</span></div>
<div class="line"><span class="comment">  locationObj.$$host = parsedUrl.hostname;</span></div>
<div class="line"><span class="comment">  locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function parseAppUrl(relativeUrl, locationObj) {</span></div>
<div class="line"><span class="comment">  var prefixed = (relativeUrl.charAt(0) !== &#39;/&#39;);</span></div>
<div class="line"><span class="comment">  if (prefixed) {</span></div>
<div class="line"><span class="comment">    relativeUrl = &#39;/&#39; + relativeUrl;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">  var match = urlResolve(relativeUrl);</span></div>
<div class="line"><span class="comment">  locationObj.$$path = decodeURIComponent(prefixed &amp;&amp; match.pathname.charAt(0) === &#39;/&#39; ?</span></div>
<div class="line"><span class="comment">      match.pathname.substring(1) : match.pathname);</span></div>
<div class="line"><span class="comment">  locationObj.$$search = parseKeyValue(match.search);</span></div>
<div class="line"><span class="comment">  locationObj.$$hash = decodeURIComponent(match.hash);</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  // make sure path starts with &#39;/&#39;;</span></div>
<div class="line"><span class="comment">  if (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) != &#39;/&#39;) {</span></div>
<div class="line"><span class="comment">    locationObj.$$path = &#39;/&#39; + locationObj.$$path;</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function beginsWith(begin, whole) {</span></div>
<div class="line"><span class="comment">  if (whole.indexOf(begin) === 0) {</span></div>
<div class="line"><span class="comment">    return whole.substr(begin.length);</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function stripHash(url) {</span></div>
<div class="line"><span class="comment">  var index = url.indexOf(&#39;#&#39;);</span></div>
<div class="line"><span class="comment">  return index == -1 ? url : url.substr(0, index);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function trimEmptyHash(url) {</span></div>
<div class="line"><span class="comment">  return url.replace(/(#.+)|#$/, &#39;$1&#39;);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">function stripFile(url) {</span></div>
<div class="line"><span class="comment">  return url.substr(0, stripHash(url).lastIndexOf(&#39;/&#39;) + 1);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/* return the server only (scheme://host:port) */</span></div>
<div class="line"><span class="keyword">function</span> serverBase(url) {</div>
<div class="line">  <span class="keywordflow">return</span> url.substring(0, url.indexOf(<span class="charliteral">&#39;/&#39;</span>, url.indexOf(<span class="stringliteral">&#39;//&#39;</span>) + 2));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {</div>
<div class="line">  this.$$html5 = <span class="keyword">true</span>;</div>
<div class="line">  basePrefix = basePrefix || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  parseAbsoluteUrl(appBase, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$$parse = <span class="keyword">function</span>(url) {</div>
<div class="line">    var pathUrl = beginsWith(appBaseNoFile, url);</div>
<div class="line">    <span class="keywordflow">if</span> (!isString(pathUrl)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;ipthprfx&#39;</span>, <span class="stringliteral">&#39;Invalid url &quot;{0}&quot;, missing path prefix &quot;{1}&quot;.&#39;</span>, url,</div>
<div class="line">          appBaseNoFile);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    parseAppUrl(pathUrl, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!this.$$path) {</div>
<div class="line">      this.$$path = <span class="charliteral">&#39;/&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); <span class="comment">// first char is always &#39;/&#39;</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (relHref &amp;&amp; relHref[0] === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">      <span class="comment">// special case for links to hash fragments:</span></div>
<div class="line">      <span class="comment">// keep the old url and only replace the hash fragment</span></div>
<div class="line">      this.hash(relHref.slice(1));</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    var appUrl, prevAppUrl;</div>
<div class="line">    var rewrittenUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ((appUrl = beginsWith(appBase, url)) !== undefined) {</div>
<div class="line">      prevAppUrl = appUrl;</div>
<div class="line">      <span class="keywordflow">if</span> ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {</div>
<div class="line">        rewrittenUrl = appBaseNoFile + (beginsWith(<span class="charliteral">&#39;/&#39;</span>, appUrl) || appUrl);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        rewrittenUrl = appBase + prevAppUrl;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile + appUrl;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (appBaseNoFile == url + <span class="charliteral">&#39;/&#39;</span>) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rewrittenUrl) {</div>
<div class="line">      this.$$parse(rewrittenUrl);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> !!rewrittenUrl;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {</div>
<div class="line"></div>
<div class="line">  parseAbsoluteUrl(appBase, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.$$parse = <span class="keyword">function</span>(url) {</div>
<div class="line">    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);</div>
<div class="line">    var withoutHashUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isUndefined(withoutBaseUrl) &amp;&amp; withoutBaseUrl.charAt(0) === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The rest of the url starts with a hash so we have</span></div>
<div class="line">      <span class="comment">// got either a hashbang path or a plain hash fragment</span></div>
<div class="line">      withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(withoutHashUrl)) {</div>
<div class="line">        <span class="comment">// There was no hashbang prefix so we just have a hash fragment</span></div>
<div class="line">        withoutHashUrl = withoutBaseUrl;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// There was no hashbang path nor hash fragment:</span></div>
<div class="line">      <span class="comment">// If we are in HTML5 mode we use what is left as the path;</span></div>
<div class="line">      <span class="comment">// Otherwise we ignore what is left</span></div>
<div class="line">      <span class="keywordflow">if</span> (this.$$html5) {</div>
<div class="line">        withoutHashUrl = withoutBaseUrl;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        withoutHashUrl = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(withoutBaseUrl)) {</div>
<div class="line">          appBase = url;</div>
<div class="line">          this.replace();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    parseAppUrl(withoutHashUrl, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line"></div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * In Windows, on an anchor node on documents loaded from</span></div>
<div class="line"><span class="comment">     * the filesystem, the browser will return a pathname</span></div>
<div class="line"><span class="comment">     * prefixed with the drive name (&#39;/C:/path&#39;) when a</span></div>
<div class="line"><span class="comment">     * pathname without a drive is set:</span></div>
<div class="line"><span class="comment">     *  * a.setAttribute(&#39;href&#39;, &#39;/foo&#39;)</span></div>
<div class="line"><span class="comment">     *   * a.pathname === &#39;/C:/foo&#39; //true</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Inside of Angular, we&#39;re always using pathnames that</span></div>
<div class="line"><span class="comment">     * do not include drive names for routing.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">function</span> removeWindowsDriveName(path, url, base) {</div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">      Matches paths for file protocol on windows,</span></div>
<div class="line"><span class="comment">      such as /C:/foo/bar, and captures only /foo/bar.</span></div>
<div class="line"><span class="comment">      */</span></div>
<div class="line">      var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;</div>
<div class="line"></div>
<div class="line">      var firstPathSegmentMatch;</div>
<div class="line"></div>
<div class="line">      <span class="comment">//Get the relative path from the input URL.</span></div>
<div class="line">      <span class="keywordflow">if</span> (url.indexOf(base) === 0) {</div>
<div class="line">        url = url.replace(base, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The input URL intentionally contains a first path segment that ends with a colon.</span></div>
<div class="line">      <span class="keywordflow">if</span> (windowsFilePathExp.exec(url)) {</div>
<div class="line">        <span class="keywordflow">return</span> path;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      firstPathSegmentMatch = windowsFilePathExp.exec(path);</div>
<div class="line">      <span class="keywordflow">return</span> firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (stripHash(appBase) == stripHash(url)) {</div>
<div class="line">      this.$$parse(url);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {</div>
<div class="line">  this.$$html5 = <span class="keyword">true</span>;</div>
<div class="line">  LocationHashbangUrl.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line"></div>
<div class="line">  this.$$parseLinkUrl = <span class="keyword">function</span>(url, relHref) {</div>
<div class="line">    <span class="keywordflow">if</span> (relHref &amp;&amp; relHref[0] === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">      <span class="comment">// special case for links to hash fragments:</span></div>
<div class="line">      <span class="comment">// keep the old url and only replace the hash fragment</span></div>
<div class="line">      this.hash(relHref.slice(1));</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var rewrittenUrl;</div>
<div class="line">    var appUrl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (appBase == stripHash(url)) {</div>
<div class="line">      rewrittenUrl = url;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((appUrl = beginsWith(appBaseNoFile, url))) {</div>
<div class="line">      rewrittenUrl = appBase + hashPrefix + appUrl;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (appBaseNoFile === url + <span class="charliteral">&#39;/&#39;</span>) {</div>
<div class="line">      rewrittenUrl = appBaseNoFile;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (rewrittenUrl) {</div>
<div class="line">      this.$$parse(rewrittenUrl);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> !!rewrittenUrl;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$compose = <span class="keyword">function</span>() {</div>
<div class="line">    var search = toKeyValue(this.$$search),</div>
<div class="line">        hash = this.$$hash ? <span class="charliteral">&#39;#&#39;</span> + encodeUriSegment(this.$$hash) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    this.$$url = encodePath(this.$$path) + (search ? <span class="charliteral">&#39;?&#39;</span> + search : <span class="stringliteral">&#39;&#39;</span>) + hash;</div>
<div class="line">    <span class="comment">// include hashPrefix in $$absUrl when $$url is empty so IE9 does not reload page because of removal of &#39;#&#39;</span></div>
<div class="line">    this.$$absUrl = appBase + hashPrefix + this.$$url;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var locationPrototype = {</div>
<div class="line"></div>
<div class="line">  $$html5: <span class="keyword">false</span>,</div>
<div class="line"></div>
<div class="line">  $$replace: <span class="keyword">false</span>,</div>
<div class="line"></div>
<div class="line">  absUrl: locationGetter(<span class="stringliteral">&#39;$$absUrl&#39;</span>),</div>
<div class="line"></div>
<div class="line">  url: <span class="keyword">function</span>(url) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(url)) {</div>
<div class="line">      <span class="keywordflow">return</span> this.$$url;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var match = PATH_MATCH.exec(url);</div>
<div class="line">    <span class="keywordflow">if</span> (match[1] || url === <span class="stringliteral">&#39;&#39;</span>) this.path(decodeURIComponent(match[1]));</div>
<div class="line">    <span class="keywordflow">if</span> (match[2] || match[1] || url === <span class="stringliteral">&#39;&#39;</span>) this.search(match[3] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    this.hash(match[5] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  protocol: locationGetter(<span class="stringliteral">&#39;$$protocol&#39;</span>),</div>
<div class="line"></div>
<div class="line">  host: locationGetter(<span class="stringliteral">&#39;$$host&#39;</span>),</div>
<div class="line"></div>
<div class="line">  port: locationGetter(<span class="stringliteral">&#39;$$port&#39;</span>),</div>
<div class="line"></div>
<div class="line">  path: locationGetterSetter(<span class="stringliteral">&#39;$$path&#39;</span>, <span class="keyword">function</span>(path) {</div>
<div class="line">    path = path !== null ? path.toString() : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> path.charAt(0) == <span class="charliteral">&#39;/&#39;</span> ? path : <span class="charliteral">&#39;/&#39;</span> + path;</div>
<div class="line">  }),</div>
<div class="line"></div>
<div class="line">  search: <span class="keyword">function</span>(search, paramValue) {</div>
<div class="line">    <span class="keywordflow">switch</span> (arguments.length) {</div>
<div class="line">      <span class="keywordflow">case</span> 0:</div>
<div class="line">        <span class="keywordflow">return</span> this.$$search;</div>
<div class="line">      <span class="keywordflow">case</span> 1:</div>
<div class="line">        <span class="keywordflow">if</span> (isString(search) || isNumber(search)) {</div>
<div class="line">          search = search.toString();</div>
<div class="line">          this.$$search = parseKeyValue(search);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(search)) {</div>
<div class="line">          search = copy(search, {});</div>
<div class="line">          <span class="comment">// remove object undefined or null properties</span></div>
<div class="line">          forEach(search, <span class="keyword">function</span>(value, key) {</div>
<div class="line">            <span class="keywordflow">if</span> (value == null) <span class="keyword">delete</span> search[key];</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          this.$$search = search;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;isrcharg&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&#39;The first argument of the `$location#search()` call must be a string or an object.&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(paramValue) || paramValue === null) {</div>
<div class="line">          <span class="keyword">delete</span> this.$$search[search];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.$$search[search] = paramValue;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    this.$$compose();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  hash: locationGetterSetter(<span class="stringliteral">&#39;$$hash&#39;</span>, <span class="keyword">function</span>(hash) {</div>
<div class="line">    <span class="keywordflow">return</span> hash !== null ? hash.toString() : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  }),</div>
<div class="line"></div>
<div class="line">  replace: <span class="keyword">function</span>() {</div>
<div class="line">    this.$$replace = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], <span class="keyword">function</span>(Location) {</div>
<div class="line">  Location.prototype = Object.create(locationPrototype);</div>
<div class="line"></div>
<div class="line">  Location.prototype.state = <span class="keyword">function</span>(state) {</div>
<div class="line">    <span class="keywordflow">if</span> (!arguments.length) {</div>
<div class="line">      <span class="keywordflow">return</span> this.$$state;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (Location !== LocationHtml5Url || !this.$$html5) {</div>
<div class="line">      <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;nostate&#39;</span>, <span class="stringliteral">&#39;History API state support is available only &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;in HTML5 mode and only in browsers supporting HTML5 History API&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// The user might modify `stateObject` after invoking `$location.state(stateObject)`</span></div>
<div class="line">    <span class="comment">// but we&#39;re changing the $$state reference to $browser.state() during the $digest</span></div>
<div class="line">    <span class="comment">// so the modification window is narrow.</span></div>
<div class="line">    this.$$state = isUndefined(state) ? null : state;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> locationGetter(property) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>[property];</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> locationGetterSetter(property, preprocess) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(value)) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[property];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">this</span>[property] = preprocess(value);</div>
<div class="line">    this.$$compose();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $LocationProvider() {</div>
<div class="line">  var hashPrefix = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      html5Mode = {</div>
<div class="line">        enabled: <span class="keyword">false</span>,</div>
<div class="line">        requireBase: <span class="keyword">true</span>,</div>
<div class="line">        rewriteLinks: <span class="keyword">true</span></div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">  this.hashPrefix = <span class="keyword">function</span>(prefix) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(prefix)) {</div>
<div class="line">      hashPrefix = prefix;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> hashPrefix;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.html5Mode = <span class="keyword">function</span>(mode) {</div>
<div class="line">    <span class="keywordflow">if</span> (isBoolean(mode)) {</div>
<div class="line">      html5Mode.enabled = mode;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(mode)) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.enabled)) {</div>
<div class="line">        html5Mode.enabled = mode.enabled;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.requireBase)) {</div>
<div class="line">        html5Mode.requireBase = mode.requireBase;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isBoolean(mode.rewriteLinks)) {</div>
<div class="line">        html5Mode.rewriteLinks = mode.rewriteLinks;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> html5Mode;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$rootElement&#39;</span>, <span class="stringliteral">&#39;$window&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($rootScope, $browser, $sniffer, $rootElement, $window) {</div>
<div class="line">    var $location,</div>
<div class="line">        LocationMode,</div>
<div class="line">        baseHref = $browser.baseHref(), <span class="comment">// if base[href] is undefined, it defaults to &#39;&#39;</span></div>
<div class="line">        initialUrl = $browser.url(),</div>
<div class="line">        appBase;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (html5Mode.enabled) {</div>
<div class="line">      <span class="keywordflow">if</span> (!baseHref &amp;&amp; html5Mode.requireBase) {</div>
<div class="line">        <span class="keywordflow">throw</span> $locationMinErr(<span class="stringliteral">&#39;nobase&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;$location in HTML5 mode requires a &lt;base&gt; tag to be present!&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      appBase = serverBase(initialUrl) + (baseHref || <span class="charliteral">&#39;/&#39;</span>);</div>
<div class="line">      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      appBase = stripHash(initialUrl);</div>
<div class="line">      LocationMode = LocationHashbangUrl;</div>
<div class="line">    }</div>
<div class="line">    var appBaseNoFile = stripFile(appBase);</div>
<div class="line"></div>
<div class="line">    $location = <span class="keyword">new</span> LocationMode(appBase, appBaseNoFile, <span class="charliteral">&#39;#&#39;</span> + hashPrefix);</div>
<div class="line">    $location.$$parseLinkUrl(initialUrl, initialUrl);</div>
<div class="line"></div>
<div class="line">    $location.$$state = $browser.state();</div>
<div class="line"></div>
<div class="line">    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> setBrowserUrlWithFallback(url, replace, state) {</div>
<div class="line">      var oldUrl = $location.url();</div>
<div class="line">      var oldState = $location.$$state;</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        $browser.url(url, replace, state);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make sure $location.state() returns referentially identical (not just deeply equal)</span></div>
<div class="line">        <span class="comment">// state object; this makes possible quick checking if the state changed in the digest</span></div>
<div class="line">        <span class="comment">// loop. Checking deep equality would be too expensive.</span></div>
<div class="line">        $location.$$state = $browser.state();</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="comment">// Restore old values if pushState fails</span></div>
<div class="line">        $location.url(oldUrl);</div>
<div class="line">        $location.$$state = oldState;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">throw</span> e;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $rootElement.on(<span class="stringliteral">&#39;click&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">      <span class="comment">// TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)</span></div>
<div class="line">      <span class="comment">// currently we open nice url link and redirect then</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var elm = jqLite(event.target);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// traverse the DOM up to find first A tag</span></div>
<div class="line">      while (nodeName_(elm[0]) !== <span class="charliteral">&#39;a&#39;</span>) {</div>
<div class="line">        <span class="comment">// ignore rewriting if no A tag (reached root element, or no parent - removed from document)</span></div>
<div class="line">        <span class="keywordflow">if</span> (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var absHref = elm.prop(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">      <span class="comment">// get the actual href attribute - see</span></div>
<div class="line">      <span class="comment">// http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx</span></div>
<div class="line">      var relHref = elm.attr(<span class="stringliteral">&#39;href&#39;</span>) || elm.attr(<span class="stringliteral">&#39;xlink:href&#39;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isObject(absHref) &amp;&amp; absHref.toString() === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span>) {</div>
<div class="line">        <span class="comment">// SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during</span></div>
<div class="line">        <span class="comment">// an animation.</span></div>
<div class="line">        absHref = urlResolve(absHref.animVal).href;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Ignore when url is started with javascript: or mailto:</span></div>
<div class="line">      <span class="keywordflow">if</span> (IGNORE_URI_REGEXP.test(absHref)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (absHref &amp;&amp; !elm.attr(<span class="stringliteral">&#39;target&#39;</span>) &amp;&amp; !event.isDefaultPrevented()) {</div>
<div class="line">        <span class="keywordflow">if</span> ($location.$$parseLinkUrl(absHref, relHref)) {</div>
<div class="line">          <span class="comment">// We do a preventDefault for all urls that are part of the angular application,</span></div>
<div class="line">          <span class="comment">// in html5mode and also without, so that we are able to abort navigation without</span></div>
<div class="line">          <span class="comment">// getting double entries in the location history.</span></div>
<div class="line">          event.preventDefault();</div>
<div class="line">          <span class="comment">// update location manually</span></div>
<div class="line">          <span class="keywordflow">if</span> ($location.absUrl() != $browser.url()) {</div>
<div class="line">            $rootScope.$apply();</div>
<div class="line">            <span class="comment">// hack to work around FF6 bug 684208 when scenario runner clicks on links</span></div>
<div class="line">            $window.angular[<span class="stringliteral">&#39;ff-684208-preventDefault&#39;</span>] = <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// rewrite hashbang url &lt;&gt; html5 url</span></div>
<div class="line">    <span class="keywordflow">if</span> (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {</div>
<div class="line">      $browser.url($location.absUrl(), <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var initializing = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update $location when $browser url changes</span></div>
<div class="line">    $browser.onUrlChange(<span class="keyword">function</span>(newUrl, newState) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(beginsWith(appBaseNoFile, newUrl))) {</div>
<div class="line">        <span class="comment">// If we are navigating outside of the app then force a reload</span></div>
<div class="line">        $window.location.href = newUrl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">        var oldUrl = $location.absUrl();</div>
<div class="line">        var oldState = $location.$$state;</div>
<div class="line">        var defaultPrevented;</div>
<div class="line"></div>
<div class="line">        $location.$$parse(newUrl);</div>
<div class="line">        $location.$$state = newState;</div>
<div class="line"></div>
<div class="line">        defaultPrevented = $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeStart&#39;</span>, newUrl, oldUrl,</div>
<div class="line">            newState, oldState).defaultPrevented;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// if the location was changed by a `$locationChangeStart` handler then stop</span></div>
<div class="line">        <span class="comment">// processing this location change</span></div>
<div class="line">        <span class="keywordflow">if</span> ($location.absUrl() !== newUrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (defaultPrevented) {</div>
<div class="line">          $location.$$parse(oldUrl);</div>
<div class="line">          $location.$$state = oldState;</div>
<div class="line">          setBrowserUrlWithFallback(oldUrl, <span class="keyword">false</span>, oldState);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          initializing = <span class="keyword">false</span>;</div>
<div class="line">          afterLocationChange(oldUrl, oldState);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!$rootScope.$$phase) $rootScope.$digest();</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update browser</span></div>
<div class="line">    $rootScope.$watch(<span class="keyword">function</span> $locationWatch() {</div>
<div class="line">      var oldUrl = trimEmptyHash($browser.url());</div>
<div class="line">      var newUrl = trimEmptyHash($location.absUrl());</div>
<div class="line">      var oldState = $browser.state();</div>
<div class="line">      var currentReplace = $location.$$replace;</div>
<div class="line">      var urlOrStateChanged = oldUrl !== newUrl ||</div>
<div class="line">        ($location.$$html5 &amp;&amp; $sniffer.history &amp;&amp; oldState !== $location.$$state);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (initializing || urlOrStateChanged) {</div>
<div class="line">        initializing = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        $rootScope.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">          var newUrl = $location.absUrl();</div>
<div class="line">          var defaultPrevented = $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeStart&#39;</span>, newUrl, oldUrl,</div>
<div class="line">              $location.$$state, oldState).defaultPrevented;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// if the location was changed by a `$locationChangeStart` handler then stop</span></div>
<div class="line">          <span class="comment">// processing this location change</span></div>
<div class="line">          <span class="keywordflow">if</span> ($location.absUrl() !== newUrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (defaultPrevented) {</div>
<div class="line">            $location.$$parse(oldUrl);</div>
<div class="line">            $location.$$state = oldState;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (urlOrStateChanged) {</div>
<div class="line">              setBrowserUrlWithFallback(newUrl, currentReplace,</div>
<div class="line">                                        oldState === $location.$$state ? null : $location.$$state);</div>
<div class="line">            }</div>
<div class="line">            afterLocationChange(oldUrl, oldState);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $location.$$replace = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// we don&#39;t need to return anything because $evalAsync will make the digest loop dirty when</span></div>
<div class="line">      <span class="comment">// there is a change</span></div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> $location;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> afterLocationChange(oldUrl, oldState) {</div>
<div class="line">      $rootScope.$broadcast(<span class="stringliteral">&#39;$locationChangeSuccess&#39;</span>, $location.absUrl(), oldUrl,</div>
<div class="line">        $location.$$state, oldState);</div>
<div class="line">    }</div>
<div class="line">}];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $LogProvider() {</div>
<div class="line">  var debug = <span class="keyword">true</span>,</div>
<div class="line">      <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.debugEnabled = <span class="keyword">function</span>(flag) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(flag)) {</div>
<div class="line">      debug = flag;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> debug;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="keyword">function</span>($window) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      log: consoleLog(<span class="stringliteral">&#39;log&#39;</span>),</div>
<div class="line"></div>
<div class="line">      info: consoleLog(<span class="stringliteral">&#39;info&#39;</span>),</div>
<div class="line"></div>
<div class="line">      warn: consoleLog(<span class="stringliteral">&#39;warn&#39;</span>),</div>
<div class="line"></div>
<div class="line">      error: consoleLog(<span class="stringliteral">&#39;error&#39;</span>),</div>
<div class="line"></div>
<div class="line">      debug: (<span class="keyword">function</span>() {</div>
<div class="line">        var fn = consoleLog(<span class="stringliteral">&#39;debug&#39;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (debug) {</div>
<div class="line">            fn.apply(<span class="keyword">self</span>, arguments);</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }())</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> formatError(arg) {</div>
<div class="line">      <span class="keywordflow">if</span> (arg instanceof Error) {</div>
<div class="line">        <span class="keywordflow">if</span> (arg.stack) {</div>
<div class="line">          arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1)</div>
<div class="line">              ? <span class="stringliteral">&#39;Error: &#39;</span> + arg.message + <span class="charliteral">&#39;\n&#39;</span> + arg.stack</div>
<div class="line">              : arg.stack;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (arg.sourceURL) {</div>
<div class="line">          arg = arg.message + <span class="charliteral">&#39;\n&#39;</span> + arg.sourceURL + <span class="charliteral">&#39;:&#39;</span> + arg.line;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> arg;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> consoleLog(type) {</div>
<div class="line">      var console = $window.console || {},</div>
<div class="line">          logFn = console[type] || console.log || noop,</div>
<div class="line">          hasApply = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Note: reading logFn.apply throws an error in IE11 in IE8 document mode.</span></div>
<div class="line">      <span class="comment">// The reason behind this is that console.log has type &quot;object&quot; in IE8...</span></div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        hasApply = !!logFn.apply;</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {}</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (hasApply) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          var args = [];</div>
<div class="line">          forEach(arguments, <span class="keyword">function</span>(arg) {</div>
<div class="line">            args.push(formatError(arg));</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> logFn.apply(console, args);</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// we are IE which either doesn&#39;t have window.console =&gt; this is noop and we do nothing,</span></div>
<div class="line">      <span class="comment">// or we are IE where console.log doesn&#39;t have apply so we log at least first 2 args</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(arg1, arg2) {</div>
<div class="line">        logFn(arg1, arg2 == null ? <span class="stringliteral">&#39;&#39;</span> : arg2);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line">var $parseMinErr = minErr(<span class="stringliteral">&#39;$parse&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sandboxing Angular Expressions</span></div>
<div class="line"><span class="comment">// ------------------------------</span></div>
<div class="line"><span class="comment">// Angular expressions are generally considered safe because these expressions only have direct</span></div>
<div class="line"><span class="comment">// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by</span></div>
<div class="line"><span class="comment">// obtaining a reference to native JS functions such as the Function constructor.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// As an example, consider the following Angular expression:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//   {}.toString.constructor(&#39;alert(&quot;evil JS code&quot;)&#39;)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This sandboxing technique is not perfect and doesn&#39;t aim to be. The goal is to prevent exploits</span></div>
<div class="line"><span class="comment">// against the expression language, but not to prevent exploits that were enabled by exposing</span></div>
<div class="line"><span class="comment">// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good</span></div>
<div class="line"><span class="comment">// practice and therefore we are not even trying to protect against interaction with an object</span></div>
<div class="line"><span class="comment">// explicitly exposed in this way.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// In general, it is not possible to access a Window object from an angular expression unless a</span></div>
<div class="line"><span class="comment">// window or some DOM object that has a reference to window is published onto a Scope.</span></div>
<div class="line"><span class="comment">// Similarly we prevent invocations of function known to be dangerous, as well as assignments to</span></div>
<div class="line"><span class="comment">// native objects.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// See https://docs.angularjs.org/guide/security</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeMemberName(name, fullExpression) {</div>
<div class="line">  <span class="keywordflow">if</span> (name === <span class="stringliteral">&quot;__defineGetter__&quot;</span> || name === <span class="stringliteral">&quot;__defineSetter__&quot;</span></div>
<div class="line">      || name === <span class="stringliteral">&quot;__lookupGetter__&quot;</span> || name === <span class="stringliteral">&quot;__lookupSetter__&quot;</span></div>
<div class="line">      || name === <span class="stringliteral">&quot;__proto__&quot;</span>) {</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfld&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Attempting to access a disallowed field in Angular expressions! &#39;</span></div>
<div class="line">        + <span class="stringliteral">&#39;Expression: {0}&#39;</span>, fullExpression);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> name;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeObject(obj, fullExpression) {</div>
<div class="line">  <span class="comment">// nifty check if obj is Function that is fast and works across iframes and other contexts</span></div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (obj.constructor === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfn&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing Function in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// isWindow(obj)</span></div>
<div class="line">        obj.window === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecwindow&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing the Window in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// isElement(obj)</span></div>
<div class="line">        obj.children &amp;&amp; (obj.nodeName || (obj.prop &amp;&amp; obj.attr &amp;&amp; obj.find))) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecdom&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">// block Object so that we can&#39;t get hold of dangerous Object.* methods</span></div>
<div class="line">        obj === Object) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecobj&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Referencing Object in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">          fullExpression);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var CALL = Function.prototype.call;</div>
<div class="line">var APPLY = Function.prototype.apply;</div>
<div class="line">var BIND = Function.prototype.bind;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ensureSafeFunction(obj, fullExpression) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">if</span> (obj.constructor === obj) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecfn&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Referencing Function in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">        fullExpression);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (obj === CALL || obj === APPLY || obj === BIND) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;isecff&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}&#39;</span>,</div>
<div class="line">        fullExpression);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var OPERATORS = createMap();</div>
<div class="line">forEach(<span class="stringliteral">&#39;+ - * / % === !== == != &lt; &gt; &lt;= &gt;= &amp;&amp; || ! = |&#39;</span>.split(<span class="charliteral">&#39; &#39;</span>), <span class="keyword">function</span>(<span class="keyword">operator</span>) { OPERATORS[<span class="keyword">operator</span>] = <span class="keyword">true</span>; });</div>
<div class="line">var ESCAPE = {<span class="stringliteral">&quot;n&quot;</span>:<span class="stringliteral">&quot;\n&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>:<span class="stringliteral">&quot;\f&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>:<span class="stringliteral">&quot;\r&quot;</span>, <span class="stringliteral">&quot;t&quot;</span>:<span class="stringliteral">&quot;\t&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>:<span class="stringliteral">&quot;\v&quot;</span>, <span class="stringliteral">&quot;&#39;&quot;</span>:<span class="stringliteral">&quot;&#39;&quot;</span>, <span class="charliteral">&#39;&quot;&#39;</span>:<span class="charliteral">&#39;&quot;&#39;</span>};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var Lexer = <span class="keyword">function</span>(options) {</div>
<div class="line">  this.options = options;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Lexer.prototype = {</div>
<div class="line">  constructor: Lexer,</div>
<div class="line"></div>
<div class="line">  lex: <span class="keyword">function</span>(text) {</div>
<div class="line">    this.text = text;</div>
<div class="line">    this.index = 0;</div>
<div class="line">    this.tokens = [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;&quot;&#39;</span> || ch === <span class="stringliteral">&quot;&#39;&quot;</span>) {</div>
<div class="line">        this.readString(ch);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isNumber(ch) || ch === <span class="charliteral">&#39;.&#39;</span> &amp;&amp; this.isNumber(this.peek())) {</div>
<div class="line">        this.readNumber();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isIdent(ch)) {</div>
<div class="line">        this.readIdent();</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.is(ch, <span class="stringliteral">&#39;(){}[].,;:?&#39;</span>)) {</div>
<div class="line">        this.tokens.push({index: this.index, text: ch});</div>
<div class="line">        this.index++;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isWhitespace(ch)) {</div>
<div class="line">        this.index++;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var ch2 = ch + this.peek();</div>
<div class="line">        var ch3 = ch2 + this.peek(2);</div>
<div class="line">        var op1 = OPERATORS[ch];</div>
<div class="line">        var op2 = OPERATORS[ch2];</div>
<div class="line">        var op3 = OPERATORS[ch3];</div>
<div class="line">        <span class="keywordflow">if</span> (op1 || op2 || op3) {</div>
<div class="line">          var token = op3 ? ch3 : (op2 ? ch2 : ch);</div>
<div class="line">          this.tokens.push({index: this.index, text: token, <span class="keyword">operator</span>: <span class="keyword">true</span>});</div>
<div class="line">          this.index += token.length;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.throwError(<span class="stringliteral">&#39;Unexpected next character &#39;</span>, this.index, this.index + 1);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.tokens;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  is: <span class="keyword">function</span>(ch, chars) {</div>
<div class="line">    <span class="keywordflow">return</span> chars.indexOf(ch) !== -1;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peek: <span class="keyword">function</span>(i) {</div>
<div class="line">    var num = i || 1;</div>
<div class="line">    <span class="keywordflow">return</span> (this.index + num &lt; this.text.length) ? this.text.charAt(this.index + num) : <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isNumber: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="charliteral">&#39;0&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;9&#39;</span>) &amp;&amp; typeof ch === <span class="stringliteral">&quot;string&quot;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isWhitespace: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="comment">// IE treats non-breaking space as \u00A0</span></div>
<div class="line">    <span class="keywordflow">return</span> (ch === <span class="charliteral">&#39; &#39;</span> || ch === <span class="charliteral">&#39;\r&#39;</span> || ch === <span class="charliteral">&#39;\t&#39;</span> ||</div>
<div class="line">            ch === <span class="charliteral">&#39;\n&#39;</span> || ch === <span class="charliteral">&#39;\v&#39;</span> || ch === <span class="stringliteral">&#39;\u00A0&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isIdent: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="charliteral">&#39;a&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;z&#39;</span> ||</div>
<div class="line">            <span class="charliteral">&#39;A&#39;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">&#39;Z&#39;</span> ||</div>
<div class="line">            <span class="charliteral">&#39;_&#39;</span> === ch || ch === <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  isExpOperator: <span class="keyword">function</span>(ch) {</div>
<div class="line">    <span class="keywordflow">return</span> (ch === <span class="charliteral">&#39;-&#39;</span> || ch === <span class="charliteral">&#39;+&#39;</span> || this.isNumber(ch));</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  throwError: <span class="keyword">function</span>(error, start, end) {</div>
<div class="line">    end = end || this.index;</div>
<div class="line">    var colStr = (isDefined(start)</div>
<div class="line">            ? <span class="stringliteral">&#39;s &#39;</span> + start +  <span class="charliteral">&#39;-&#39;</span> + this.index + <span class="stringliteral">&#39; [&#39;</span> + this.text.substring(start, end) + <span class="charliteral">&#39;]&#39;</span></div>
<div class="line">            : <span class="charliteral">&#39; &#39;</span> + end);</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;lexerr&#39;</span>, <span class="stringliteral">&#39;Lexer Error: {0} at column{1} in expression [{2}].&#39;</span>,</div>
<div class="line">        error, colStr, this.text);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readNumber: <span class="keyword">function</span>() {</div>
<div class="line">    var number = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var start = this.index;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = lowercase(this.text.charAt(<span class="keyword">this</span>.index));</div>
<div class="line">      <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;.&#39;</span> || this.isNumber(ch)) {</div>
<div class="line">        number += ch;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var peekCh = this.peek();</div>
<div class="line">        <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;e&#39;</span> &amp;&amp; this.isExpOperator(peekCh)) {</div>
<div class="line">          number += ch;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isExpOperator(ch) &amp;&amp;</div>
<div class="line">            peekCh &amp;&amp; this.isNumber(peekCh) &amp;&amp;</div>
<div class="line">            number.charAt(number.length - 1) == <span class="charliteral">&#39;e&#39;</span>) {</div>
<div class="line">          number += ch;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.isExpOperator(ch) &amp;&amp;</div>
<div class="line">            (!peekCh || !this.isNumber(peekCh)) &amp;&amp;</div>
<div class="line">            number.charAt(number.length - 1) == <span class="charliteral">&#39;e&#39;</span>) {</div>
<div class="line">          this.throwError(<span class="stringliteral">&#39;Invalid exponent&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.tokens.push({</div>
<div class="line">      index: start,</div>
<div class="line">      text: number,</div>
<div class="line">      constant: <span class="keyword">true</span>,</div>
<div class="line">      value: Number(number)</div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readIdent: <span class="keyword">function</span>() {</div>
<div class="line">    var start = this.index;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      <span class="keywordflow">if</span> (!(this.isIdent(ch) || this.isNumber(ch))) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.tokens.push({</div>
<div class="line">      index: start,</div>
<div class="line">      text: this.text.slice(start, this.index),</div>
<div class="line">      identifier: <span class="keyword">true</span></div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  readString: <span class="keyword">function</span>(quote) {</div>
<div class="line">    var start = this.index;</div>
<div class="line">    this.index++;</div>
<div class="line">    var <span class="keywordtype">string</span> = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var rawString = quote;</div>
<div class="line">    var escape = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (this.index &lt; this.text.length) {</div>
<div class="line">      var ch = this.text.charAt(this.index);</div>
<div class="line">      rawString += ch;</div>
<div class="line">      <span class="keywordflow">if</span> (escape) {</div>
<div class="line">        <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;u&#39;</span>) {</div>
<div class="line">          var hex = this.text.substring(this.index + 1, this.index + 5);</div>
<div class="line">          <span class="keywordflow">if</span> (!hex.match(/[\da-f]{4}/i)) {</div>
<div class="line">            this.throwError(<span class="stringliteral">&#39;Invalid unicode escape [\\u&#39;</span> + hex + <span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">          this.index += 4;</div>
<div class="line">          <span class="keywordtype">string</span> += String.fromCharCode(parseInt(hex, 16));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          var rep = ESCAPE[ch];</div>
<div class="line">          <span class="keywordtype">string</span> = <span class="keywordtype">string</span> + (rep || ch);</div>
<div class="line">        }</div>
<div class="line">        escape = <span class="keyword">false</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch === <span class="charliteral">&#39;\\&#39;</span>) {</div>
<div class="line">        escape = <span class="keyword">true</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch === quote) {</div>
<div class="line">        this.index++;</div>
<div class="line">        this.tokens.push({</div>
<div class="line">          index: start,</div>
<div class="line">          text: rawString,</div>
<div class="line">          constant: <span class="keyword">true</span>,</div>
<div class="line">          value: <span class="keywordtype">string</span></div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordtype">string</span> += ch;</div>
<div class="line">      }</div>
<div class="line">      this.index++;</div>
<div class="line">    }</div>
<div class="line">    this.throwError(<span class="stringliteral">&#39;Unterminated quote&#39;</span>, start);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var AST = <span class="keyword">function</span>(lexer, options) {</div>
<div class="line">  this.lexer = lexer;</div>
<div class="line">  this.options = options;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">AST.Program = <span class="stringliteral">&#39;Program&#39;</span>;</div>
<div class="line">AST.ExpressionStatement = <span class="stringliteral">&#39;ExpressionStatement&#39;</span>;</div>
<div class="line">AST.AssignmentExpression = <span class="stringliteral">&#39;AssignmentExpression&#39;</span>;</div>
<div class="line">AST.ConditionalExpression = <span class="stringliteral">&#39;ConditionalExpression&#39;</span>;</div>
<div class="line">AST.LogicalExpression = <span class="stringliteral">&#39;LogicalExpression&#39;</span>;</div>
<div class="line">AST.BinaryExpression = <span class="stringliteral">&#39;BinaryExpression&#39;</span>;</div>
<div class="line">AST.UnaryExpression = <span class="stringliteral">&#39;UnaryExpression&#39;</span>;</div>
<div class="line">AST.CallExpression = <span class="stringliteral">&#39;CallExpression&#39;</span>;</div>
<div class="line">AST.MemberExpression = <span class="stringliteral">&#39;MemberExpression&#39;</span>;</div>
<div class="line">AST.Identifier = <span class="stringliteral">&#39;Identifier&#39;</span>;</div>
<div class="line">AST.Literal = <span class="stringliteral">&#39;Literal&#39;</span>;</div>
<div class="line">AST.ArrayExpression = <span class="stringliteral">&#39;ArrayExpression&#39;</span>;</div>
<div class="line">AST.Property = <span class="stringliteral">&#39;Property&#39;</span>;</div>
<div class="line">AST.ObjectExpression = <span class="stringliteral">&#39;ObjectExpression&#39;</span>;</div>
<div class="line">AST.ThisExpression = <span class="stringliteral">&#39;ThisExpression&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Internal use only</span></div>
<div class="line">AST.NGValueParameter = <span class="stringliteral">&#39;NGValueParameter&#39;</span>;</div>
<div class="line"></div>
<div class="line">AST.prototype = {</div>
<div class="line">  ast: <span class="keyword">function</span>(text) {</div>
<div class="line">    this.text = text;</div>
<div class="line">    this.tokens = this.lexer.lex(text);</div>
<div class="line"></div>
<div class="line">    var value = this.program();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length !== 0) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is an unexpected token&#39;</span>, this.tokens[0]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  program: <span class="keyword">function</span>() {</div>
<div class="line">    var body = [];</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">      <span class="keywordflow">if</span> (this.tokens.length &gt; 0 &amp;&amp; !<span class="keyword">this</span>.peek(<span class="charliteral">&#39;}&#39;</span>, <span class="charliteral">&#39;)&#39;</span>, <span class="charliteral">&#39;;&#39;</span>, <span class="charliteral">&#39;]&#39;</span>))</div>
<div class="line">        body.push(<span class="keyword">this</span>.expressionStatement());</div>
<div class="line">      <span class="keywordflow">if</span> (!this.expect(<span class="charliteral">&#39;;&#39;</span>)) {</div>
<div class="line">        <span class="keywordflow">return</span> { type: AST.Program, body: body};</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expressionStatement: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.ExpressionStatement, expression: this.filterChain() };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filterChain: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.expression();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;|&#39;</span>))) {</div>
<div class="line">      left = this.filter(left);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expression: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.assignment();</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  assignment: <span class="keyword">function</span>() {</div>
<div class="line">    var result = this.ternary();</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;=&#39;</span>)) {</div>
<div class="line">      result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), <span class="keyword">operator</span>: <span class="charliteral">&#39;=&#39;</span>};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ternary: <span class="keyword">function</span>() {</div>
<div class="line">    var test = this.logicalOR();</div>
<div class="line">    var alternate;</div>
<div class="line">    var consequent;</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;?&#39;</span>)) {</div>
<div class="line">      alternate = this.expression();</div>
<div class="line">      <span class="keywordflow">if</span> (this.consume(<span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line">        consequent = this.expression();</div>
<div class="line">        <span class="keywordflow">return</span> { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent};</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> test;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  logicalOR: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.logicalAND();</div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="stringliteral">&#39;||&#39;</span>)) {</div>
<div class="line">      left = { type: AST.LogicalExpression, <span class="keyword">operator</span>: <span class="stringliteral">&#39;||&#39;</span>, left: left, right: this.logicalAND() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  logicalAND: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.equality();</div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="stringliteral">&#39;&amp;&amp;&#39;</span>)) {</div>
<div class="line">      left = { type: AST.LogicalExpression, <span class="keyword">operator</span>: <span class="stringliteral">&#39;&amp;&amp;&#39;</span>, left: left, right: this.equality()};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  equality: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.relational();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="stringliteral">&#39;==&#39;</span>,<span class="stringliteral">&#39;!=&#39;</span>,<span class="stringliteral">&#39;===&#39;</span>,<span class="stringliteral">&#39;!==&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.relational() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  relational: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.additive();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>, <span class="stringliteral">&#39;&lt;=&#39;</span>, <span class="stringliteral">&#39;&gt;=&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.additive() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  additive: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.multiplicative();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;+&#39;</span>,<span class="charliteral">&#39;-&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.multiplicative() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  multiplicative: <span class="keyword">function</span>() {</div>
<div class="line">    var left = this.unary();</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">while</span> ((token = this.expect(<span class="charliteral">&#39;*&#39;</span>,<span class="charliteral">&#39;/&#39;</span>,<span class="charliteral">&#39;%&#39;</span>))) {</div>
<div class="line">      left = { type: AST.BinaryExpression, <span class="keyword">operator</span>: token.text, left: left, right: this.unary() };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> left;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  unary: <span class="keyword">function</span>() {</div>
<div class="line">    var token;</div>
<div class="line">    <span class="keywordflow">if</span> ((token = this.expect(<span class="charliteral">&#39;+&#39;</span>, <span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;!&#39;</span>))) {</div>
<div class="line">      <span class="keywordflow">return</span> { type: AST.UnaryExpression, <span class="keyword">operator</span>: token.text, prefix: <span class="keyword">true</span>, argument: this.unary() };</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> this.primary();</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  primary: <span class="keyword">function</span>() {</div>
<div class="line">    var primary;</div>
<div class="line">    <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;(&#39;</span>)) {</div>
<div class="line">      primary = this.filterChain();</div>
<div class="line">      this.consume(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;[&#39;</span>)) {</div>
<div class="line">      primary = this.arrayDeclaration();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.expect(<span class="charliteral">&#39;{&#39;</span>)) {</div>
<div class="line">      primary = this.object();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.constants.hasOwnProperty(<span class="keyword">this</span>.peek().text)) {</div>
<div class="line">      primary = copy(this.constants[this.consume().text]);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().identifier) {</div>
<div class="line">      primary = this.identifier();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().constant) {</div>
<div class="line">      primary = this.constant();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;not a primary expression&#39;</span>, this.peek());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var next;</div>
<div class="line">    <span class="keywordflow">while</span> ((next = this.expect(<span class="charliteral">&#39;(&#39;</span>, <span class="charliteral">&#39;[&#39;</span>, <span class="charliteral">&#39;.&#39;</span>))) {</div>
<div class="line">      <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;(&#39;</span>) {</div>
<div class="line">        primary = {type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };</div>
<div class="line">        this.consume(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;[&#39;</span>) {</div>
<div class="line">        primary = { type: AST.MemberExpression, <span class="keywordtype">object</span>: primary, property: this.expression(), computed: <span class="keyword">true</span> };</div>
<div class="line">        this.consume(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next.text === <span class="charliteral">&#39;.&#39;</span>) {</div>
<div class="line">        primary = { type: AST.MemberExpression, <span class="keywordtype">object</span>: primary, property: this.identifier(), computed: <span class="keyword">false</span> };</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.throwError(<span class="stringliteral">&#39;IMPOSSIBLE&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> primary;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filter: <span class="keyword">function</span>(baseExpression) {</div>
<div class="line">    var args = [baseExpression];</div>
<div class="line">    var result = {type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: <span class="keyword">true</span>};</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;:&#39;</span>)) {</div>
<div class="line">      args.push(this.expression());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  parseArguments: <span class="keyword">function</span>() {</div>
<div class="line">    var args = [];</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;)&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        args.push(this.expression());</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> args;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  identifier: <span class="keyword">function</span>() {</div>
<div class="line">    var token = this.consume();</div>
<div class="line">    <span class="keywordflow">if</span> (!token.identifier) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is not a valid identifier&#39;</span>, token);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.Identifier, name: token.text };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  constant: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// TODO check that it is a constant</span></div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.Literal, value: this.consume().value };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  arrayDeclaration: <span class="keyword">function</span>() {</div>
<div class="line">    var elements = [];</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;]&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek(<span class="charliteral">&#39;]&#39;</span>)) {</div>
<div class="line">          <span class="comment">// Support trailing commas per ES5.1.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        elements.push(this.expression());</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    this.consume(<span class="charliteral">&#39;]&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> { type: AST.ArrayExpression, elements: elements };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">object</span>: <span class="keyword">function</span>() {</div>
<div class="line">    var properties = [], property;</div>
<div class="line">    <span class="keywordflow">if</span> (this.peekToken().text !== <span class="charliteral">&#39;}&#39;</span>) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek(<span class="charliteral">&#39;}&#39;</span>)) {</div>
<div class="line">          <span class="comment">// Support trailing commas per ES5.1.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        property = {type: AST.Property, kind: <span class="stringliteral">&#39;init&#39;</span>};</div>
<div class="line">        <span class="keywordflow">if</span> (this.peek().constant) {</div>
<div class="line">          property.key = this.constant();</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.peek().identifier) {</div>
<div class="line">          property.key = this.identifier();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          this.throwError(<span class="stringliteral">&quot;invalid key&quot;</span>, this.peek());</div>
<div class="line">        }</div>
<div class="line">        this.consume(<span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line">        property.value = this.expression();</div>
<div class="line">        properties.push(property);</div>
<div class="line">      } <span class="keywordflow">while</span> (this.expect(<span class="charliteral">&#39;,&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    this.consume(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {type: AST.ObjectExpression, properties: properties };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  throwError: <span class="keyword">function</span>(msg, token) {</div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;syntax&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Syntax Error: Token \&#39;{0}\&#39; {1} at column {2} of the expression [{3}] starting at [{4}].&#39;</span>,</div>
<div class="line">          token.text, msg, (token.index + 1), <span class="keyword">this</span>.text, <span class="keyword">this</span>.text.substring(token.index));</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  consume: <span class="keyword">function</span>(e1) {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length === 0) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;ueoe&#39;</span>, <span class="stringliteral">&#39;Unexpected end of expression: {0}&#39;</span>, this.text);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var token = this.expect(e1);</div>
<div class="line">    <span class="keywordflow">if</span> (!token) {</div>
<div class="line">      this.throwError(<span class="stringliteral">&#39;is unexpected, expecting [&#39;</span> + e1 + <span class="charliteral">&#39;]&#39;</span>, this.peek());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> token;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peekToken: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length === 0) {</div>
<div class="line">      <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;ueoe&#39;</span>, <span class="stringliteral">&#39;Unexpected end of expression: {0}&#39;</span>, this.text);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.tokens[0];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peek: <span class="keyword">function</span>(e1, e2, e3, e4) {</div>
<div class="line">    <span class="keywordflow">return</span> this.peekAhead(0, e1, e2, e3, e4);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  peekAhead: <span class="keyword">function</span>(i, e1, e2, e3, e4) {</div>
<div class="line">    <span class="keywordflow">if</span> (this.tokens.length &gt; i) {</div>
<div class="line">      var token = this.tokens[i];</div>
<div class="line">      var t = token.text;</div>
<div class="line">      <span class="keywordflow">if</span> (t === e1 || t === e2 || t === e3 || t === e4 ||</div>
<div class="line">          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {</div>
<div class="line">        <span class="keywordflow">return</span> token;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  expect: <span class="keyword">function</span>(e1, e2, e3, e4) {</div>
<div class="line">    var token = this.peek(e1, e2, e3, e4);</div>
<div class="line">    <span class="keywordflow">if</span> (token) {</div>
<div class="line">      this.tokens.shift();</div>
<div class="line">      <span class="keywordflow">return</span> token;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* `undefined` is not a constant, it is an identifier,</span></div>
<div class="line"><span class="comment">   * but using it as an identifier is not supported</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  constants: {</div>
<div class="line">    <span class="stringliteral">&#39;true&#39;</span>: { type: AST.Literal, value: <span class="keyword">true</span> },</div>
<div class="line">    <span class="stringliteral">&#39;false&#39;</span>: { type: AST.Literal, value: <span class="keyword">false</span> },</div>
<div class="line">    <span class="stringliteral">&#39;null&#39;</span>: { type: AST.Literal, value: null },</div>
<div class="line">    <span class="stringliteral">&#39;undefined&#39;</span>: {type: AST.Literal, value: undefined },</div>
<div class="line">    <span class="stringliteral">&#39;this&#39;</span>: {type: AST.ThisExpression }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ifDefined(v, d) {</div>
<div class="line">  <span class="keywordflow">return</span> typeof v !== <span class="stringliteral">&#39;undefined&#39;</span> ? v : d;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> plusFn(l, r) {</div>
<div class="line">  <span class="keywordflow">if</span> (typeof l === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> r;</div>
<div class="line">  <span class="keywordflow">if</span> (typeof r === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> l;</div>
<div class="line">  <span class="keywordflow">return</span> l + r;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isStateless($filter, filterName) {</div>
<div class="line">  var fn = $filter(filterName);</div>
<div class="line">  <span class="keywordflow">return</span> !fn.$stateful;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> findConstantAndWatchExpressions(ast, $filter) {</div>
<div class="line">  var allConstants;</div>
<div class="line">  var argsToWatch;</div>
<div class="line">  <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">  <span class="keywordflow">case</span> AST.Program:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    forEach(ast.body, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr.expression, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.expression.constant;</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">    ast.constant = <span class="keyword">true</span>;</div>
<div class="line">    ast.toWatch = [];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.argument, $filter);</div>
<div class="line">    ast.constant = ast.argument.constant;</div>
<div class="line">    ast.toWatch = ast.argument.toWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = ast.constant ? [] : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.test, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.alternate, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.consequent, $filter);</div>
<div class="line">    ast.constant = ast.test.constant &amp;&amp; ast.alternate.constant &amp;&amp; ast.consequent.constant;</div>
<div class="line">    ast.toWatch = ast.constant ? [] : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">    ast.constant = <span class="keyword">false</span>;</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.object, $filter);</div>
<div class="line">    <span class="keywordflow">if</span> (ast.computed) {</div>
<div class="line">      findConstantAndWatchExpressions(ast.property, $filter);</div>
<div class="line">    }</div>
<div class="line">    ast.constant = ast.object.constant &amp;&amp; (!ast.computed || ast.property.constant);</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.constant;</div>
<div class="line">      if (!expr.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, expr.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = ast.filter &amp;&amp; isStateless($filter, ast.callee.name) ? argsToWatch : [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">    findConstantAndWatchExpressions(ast.left, $filter);</div>
<div class="line">    findConstantAndWatchExpressions(ast.right, $filter);</div>
<div class="line">    ast.constant = ast.left.constant &amp;&amp; ast.right.constant;</div>
<div class="line">    ast.toWatch = [ast];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">      findConstantAndWatchExpressions(expr, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; expr.constant;</div>
<div class="line">      if (!expr.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, expr.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = argsToWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">    allConstants = <span class="keyword">true</span>;</div>
<div class="line">    argsToWatch = [];</div>
<div class="line">    forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">      findConstantAndWatchExpressions(property.value, $filter);</div>
<div class="line">      allConstants = allConstants &amp;&amp; property.value.constant;</div>
<div class="line">      if (!property.value.constant) {</div>
<div class="line">        argsToWatch.push.apply(argsToWatch, property.value.toWatch);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">    ast.constant = allConstants;</div>
<div class="line">    ast.toWatch = argsToWatch;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">    ast.constant = <span class="keyword">false</span>;</div>
<div class="line">    ast.toWatch = [];</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getInputs(body) {</div>
<div class="line">  <span class="keywordflow">if</span> (body.length != 1) <span class="keywordflow">return</span>;</div>
<div class="line">  var lastExpression = body[0].expression;</div>
<div class="line">  var candidate = lastExpression.toWatch;</div>
<div class="line">  <span class="keywordflow">if</span> (candidate.length !== 1) <span class="keywordflow">return</span> candidate;</div>
<div class="line">  <span class="keywordflow">return</span> candidate[0] !== lastExpression ? candidate : undefined;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isAssignable(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.type === AST.Identifier || ast.type === AST.MemberExpression;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> assignableAST(ast) {</div>
<div class="line">  <span class="keywordflow">if</span> (ast.body.length === 1 &amp;&amp; isAssignable(ast.body[0].expression)) {</div>
<div class="line">    <span class="keywordflow">return</span> {type: AST.AssignmentExpression, left: ast.body[0].expression, right: {type: AST.NGValueParameter}, <span class="keyword">operator</span>: <span class="charliteral">&#39;=&#39;</span>};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isLiteral(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.body.length === 0 ||</div>
<div class="line">      ast.body.length === 1 &amp;&amp; (</div>
<div class="line">      ast.body[0].expression.type === AST.Literal ||</div>
<div class="line">      ast.body[0].expression.type === AST.ArrayExpression ||</div>
<div class="line">      ast.body[0].expression.type === AST.ObjectExpression);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isConstant(ast) {</div>
<div class="line">  <span class="keywordflow">return</span> ast.constant;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ASTCompiler(astBuilder, $filter) {</div>
<div class="line">  this.astBuilder = astBuilder;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ASTCompiler.prototype = {</div>
<div class="line">  compile: <span class="keyword">function</span>(expression, expensiveChecks) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    var ast = this.astBuilder.ast(expression);</div>
<div class="line">    this.state = {</div>
<div class="line">      nextId: 0,</div>
<div class="line">      filters: {},</div>
<div class="line">      expensiveChecks: expensiveChecks,</div>
<div class="line">      fn: {vars: [], body: [], own: {}},</div>
<div class="line">      assign: {vars: [], body: [], own: {}},</div>
<div class="line">      inputs: []</div>
<div class="line">    };</div>
<div class="line">    findConstantAndWatchExpressions(ast, <span class="keyword">self</span>.$filter);</div>
<div class="line">    var extra = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    var assignable;</div>
<div class="line">    this.stage = <span class="stringliteral">&#39;assign&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> ((assignable = assignableAST(ast))) {</div>
<div class="line">      this.state.computing = <span class="stringliteral">&#39;assign&#39;</span>;</div>
<div class="line">      var result = this.nextId();</div>
<div class="line">      this.recurse(assignable, result);</div>
<div class="line">      extra = <span class="stringliteral">&#39;fn.assign=&#39;</span> + this.generateFunction(<span class="stringliteral">&#39;assign&#39;</span>, <span class="stringliteral">&#39;s,v,l&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    var toWatch = getInputs(ast.body);</div>
<div class="line">    <span class="keyword">self</span>.stage = <span class="stringliteral">&#39;inputs&#39;</span>;</div>
<div class="line">    forEach(toWatch, <span class="keyword">function</span>(watch, key) {</div>
<div class="line">      var fnKey = <span class="stringliteral">&#39;fn&#39;</span> + key;</div>
<div class="line">      <span class="keyword">self</span>.state[fnKey] = {vars: [], body: [], own: {}};</div>
<div class="line">      <span class="keyword">self</span>.state.computing = fnKey;</div>
<div class="line">      var intoId = <span class="keyword">self</span>.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(watch, intoId);</div>
<div class="line">      <span class="keyword">self</span>.return_(intoId);</div>
<div class="line">      <span class="keyword">self</span>.state.inputs.push(fnKey);</div>
<div class="line">      watch.watchId = key;</div>
<div class="line">    });</div>
<div class="line">    this.state.computing = <span class="stringliteral">&#39;fn&#39;</span>;</div>
<div class="line">    this.stage = <span class="stringliteral">&#39;main&#39;</span>;</div>
<div class="line">    this.recurse(ast);</div>
<div class="line">    var fnString =</div>
<div class="line">      <span class="comment">// The build and minification steps remove the string &quot;use strict&quot; from the code, but this is done using a regex.</span></div>
<div class="line">      <span class="comment">// This is a workaround for this until we do a better job at only removing the prefix only when we should.</span></div>
<div class="line">      <span class="charliteral">&#39;&quot;&#39;</span> + this.USE + <span class="charliteral">&#39; &#39;</span> + this.STRICT + <span class="stringliteral">&#39;&quot;;\n&#39;</span> +</div>
<div class="line">      this.filterPrefix() +</div>
<div class="line">      <span class="stringliteral">&#39;var fn=&#39;</span> + this.generateFunction(<span class="stringliteral">&#39;fn&#39;</span>, <span class="stringliteral">&#39;s,l,a,i&#39;</span>) +</div>
<div class="line">      extra +</div>
<div class="line">      this.watchFns() +</div>
<div class="line">      <span class="stringliteral">&#39;return fn;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* jshint -W054 */</span></div>
<div class="line">    var fn = (<span class="keyword">new</span> Function(<span class="stringliteral">&#39;$filter&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeMemberName&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeObject&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ensureSafeFunction&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;ifDefined&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;plus&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;text&#39;</span>,</div>
<div class="line">        fnString))(</div>
<div class="line">          this.$filter,</div>
<div class="line">          ensureSafeMemberName,</div>
<div class="line">          ensureSafeObject,</div>
<div class="line">          ensureSafeFunction,</div>
<div class="line">          ifDefined,</div>
<div class="line">          plusFn,</div>
<div class="line">          expression);</div>
<div class="line">    <span class="comment">/* jshint +W054 */</span></div>
<div class="line">    this.state = this.stage = undefined;</div>
<div class="line">    fn.literal = isLiteral(ast);</div>
<div class="line">    fn.constant = isConstant(ast);</div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  USE: <span class="stringliteral">&#39;use&#39;</span>,</div>
<div class="line"></div>
<div class="line">  STRICT: <span class="stringliteral">&#39;strict&#39;</span>,</div>
<div class="line"></div>
<div class="line">  watchFns: <span class="keyword">function</span>() {</div>
<div class="line">    var result = [];</div>
<div class="line">    var fns = this.state.inputs;</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    forEach(fns, <span class="keyword">function</span>(name) {</div>
<div class="line">      result.push(<span class="stringliteral">&#39;var &#39;</span> + name + <span class="charliteral">&#39;=&#39;</span> + <span class="keyword">self</span>.generateFunction(name, <span class="charliteral">&#39;s&#39;</span>));</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">if</span> (fns.length) {</div>
<div class="line">      result.push(<span class="stringliteral">&#39;fn.inputs=[&#39;</span> + fns.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;];&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  generateFunction: <span class="keyword">function</span>(name, params) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;function(&#39;</span> + params + <span class="stringliteral">&#39;){&#39;</span> +</div>
<div class="line">        this.varsPrefix(name) +</div>
<div class="line">        this.body(name) +</div>
<div class="line">        <span class="stringliteral">&#39;};&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filterPrefix: <span class="keyword">function</span>() {</div>
<div class="line">    var parts = [];</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    forEach(this.state.filters, <span class="keyword">function</span>(<span class="keywordtype">id</span>, filter) {</div>
<div class="line">      parts.push(id + <span class="stringliteral">&#39;=$filter(&#39;</span> + self.escape(filter) + <span class="stringliteral">&#39;)&#39;</span>);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">if</span> (parts.length) <span class="keywordflow">return</span> <span class="stringliteral">&#39;var &#39;</span> + parts.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;;&#39;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  varsPrefix: <span class="keyword">function</span>(section) {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[section].vars.length ? <span class="stringliteral">&#39;var &#39;</span> + this.state[section].vars.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;;&#39;</span> : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  body: <span class="keyword">function</span>(section) {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[section].body.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  recurse: <span class="keyword">function</span>(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {</div>
<div class="line">    var left, right, <span class="keyword">self</span> = <span class="keyword">this</span>, args, expression;</div>
<div class="line">    recursionFn = recursionFn || noop;</div>
<div class="line">    <span class="keywordflow">if</span> (!skipWatchIdCheck &amp;&amp; isDefined(ast.watchId)) {</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      this.if_(<span class="charliteral">&#39;i&#39;</span>,</div>
<div class="line">        this.lazyAssign(intoId, this.computedMember(<span class="charliteral">&#39;i&#39;</span>, ast.watchId)),</div>
<div class="line">        <span class="keyword">this</span>.lazyRecurse(ast, intoId, nameId, recursionFn, create, <span class="keyword">true</span>)</div>
<div class="line">      );</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">    <span class="keywordflow">case</span> AST.Program:</div>
<div class="line">      forEach(ast.body, <span class="keyword">function</span>(expression, pos) {</div>
<div class="line">        self.recurse(expression.expression, undefined, undefined, function(expr) { right = expr; });</div>
<div class="line">        <span class="keywordflow">if</span> (pos !== ast.body.length - 1) {</div>
<div class="line">          <span class="keyword">self</span>.current().body.push(right, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keyword">self</span>.return_(right);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">      expression = this.escape(ast.value);</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">      this.recurse(ast.argument, undefined, undefined, <span class="keyword">function</span>(expr) { right = expr; });</div>
<div class="line">      expression = ast.operator + <span class="charliteral">&#39;(&#39;</span> + this.ifDefined(right, 0) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">      this.recurse(ast.left, undefined, undefined, <span class="keyword">function</span>(expr) { left = expr; });</div>
<div class="line">      this.recurse(ast.right, undefined, undefined, <span class="keyword">function</span>(expr) { right = expr; });</div>
<div class="line">      <span class="keywordflow">if</span> (ast.operator === <span class="charliteral">&#39;+&#39;</span>) {</div>
<div class="line">        expression = this.plus(left, right);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ast.operator === <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        expression = <span class="charliteral">&#39;(&#39;</span> + left + <span class="charliteral">&#39;)&#39;</span> + ast.operator + <span class="charliteral">&#39;(&#39;</span> + right + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.left, intoId);</div>
<div class="line">      <span class="keyword">self</span>.if_(ast.operator === <span class="stringliteral">&#39;&amp;&amp;&#39;</span> ? intoId : <span class="keyword">self</span>.not(intoId), <span class="keyword">self</span>.lazyRecurse(ast.right, intoId));</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.test, intoId);</div>
<div class="line">      <span class="keyword">self</span>.if_(intoId, <span class="keyword">self</span>.lazyRecurse(ast.alternate, intoId), <span class="keyword">self</span>.lazyRecurse(ast.consequent, intoId));</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keywordflow">if</span> (nameId) {</div>
<div class="line">        nameId.context = <span class="keyword">self</span>.stage === <span class="stringliteral">&#39;inputs&#39;</span> ? <span class="charliteral">&#39;s&#39;</span> : this.assign(this.nextId(), this.getHasOwnProperty(<span class="charliteral">&#39;l&#39;</span>, ast.name) + <span class="stringliteral">&#39;?l:s&#39;</span>);</div>
<div class="line">        nameId.computed = <span class="keyword">false</span>;</div>
<div class="line">        nameId.name = ast.name;</div>
<div class="line">      }</div>
<div class="line">      ensureSafeMemberName(ast.name);</div>
<div class="line">      <span class="keyword">self</span>.if_(<span class="keyword">self</span>.stage === <span class="stringliteral">&#39;inputs&#39;</span> || <span class="keyword">self</span>.not(<span class="keyword">self</span>.getHasOwnProperty(<span class="charliteral">&#39;l&#39;</span>, ast.name)),</div>
<div class="line">        <span class="keyword">function</span>() {</div>
<div class="line">          self.if_(self.stage === <span class="stringliteral">&#39;inputs&#39;</span> || <span class="stringliteral">&#39;s&#39;</span>, function() {</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(</div>
<div class="line">                self.not(self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name)),</div>
<div class="line">                self.lazyAssign(self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            self.assign(intoId, self.nonComputedMember(<span class="stringliteral">&#39;s&#39;</span>, ast.name));</div>
<div class="line">          });</div>
<div class="line">        }, intoId &amp;&amp; <span class="keyword">self</span>.lazyAssign(intoId, <span class="keyword">self</span>.nonComputedMember(<span class="charliteral">&#39;l&#39;</span>, ast.name))</div>
<div class="line">        );</div>
<div class="line">      <span class="keywordflow">if</span> (<span class="keyword">self</span>.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {</div>
<div class="line">        <span class="keyword">self</span>.addEnsureSafeObject(intoId);</div>
<div class="line">      }</div>
<div class="line">      recursionFn(intoId);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">      left = nameId &amp;&amp; (nameId.context = this.nextId()) || this.nextId();</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast.object, left, undefined, <span class="keyword">function</span>() {</div>
<div class="line">        self.if_(self.notNull(left), function() {</div>
<div class="line">          if (ast.computed) {</div>
<div class="line">            right = self.nextId();</div>
<div class="line">            self.recurse(ast.property, right);</div>
<div class="line">            self.addEnsureSafeMemberName(right);</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            expression = self.ensureSafeObject(self.computedMember(left, right));</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">            if (nameId) {</div>
<div class="line">              nameId.computed = true;</div>
<div class="line">              nameId.name = right;</div>
<div class="line">            }</div>
<div class="line">          } else {</div>
<div class="line">            ensureSafeMemberName(ast.property.name);</div>
<div class="line">            if (create &amp;&amp; create !== 1) {</div>
<div class="line">              self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), <span class="stringliteral">&#39;{}&#39;</span>));</div>
<div class="line">            }</div>
<div class="line">            expression = self.nonComputedMember(left, ast.property.name);</div>
<div class="line">            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {</div>
<div class="line">              expression = self.ensureSafeObject(expression);</div>
<div class="line">            }</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">            if (nameId) {</div>
<div class="line">              nameId.computed = false;</div>
<div class="line">              nameId.name = ast.property.name;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }, <span class="keyword">function</span>() {</div>
<div class="line">          self.assign(intoId, <span class="stringliteral">&#39;undefined&#39;</span>);</div>
<div class="line">        });</div>
<div class="line">        recursionFn(intoId);</div>
<div class="line">      }, !!create);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">      intoId = intoId || this.nextId();</div>
<div class="line">      <span class="keywordflow">if</span> (ast.filter) {</div>
<div class="line">        right = <span class="keyword">self</span>.filter(ast.callee.name);</div>
<div class="line">        args = [];</div>
<div class="line">        forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">          var argument = self.nextId();</div>
<div class="line">          self.recurse(expr, argument);</div>
<div class="line">          args.push(argument);</div>
<div class="line">        });</div>
<div class="line">        expression = right + <span class="charliteral">&#39;(&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">        <span class="keyword">self</span>.assign(intoId, expression);</div>
<div class="line">        recursionFn(intoId);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        right = <span class="keyword">self</span>.nextId();</div>
<div class="line">        left = {};</div>
<div class="line">        args = [];</div>
<div class="line">        <span class="keyword">self</span>.recurse(ast.callee, right, left, <span class="keyword">function</span>() {</div>
<div class="line">          self.if_(self.notNull(right), function() {</div>
<div class="line">            self.addEnsureSafeFunction(right);</div>
<div class="line">            forEach(ast.arguments, function(expr) {</div>
<div class="line">              self.recurse(expr, self.nextId(), undefined, function(argument) {</div>
<div class="line">                args.push(self.ensureSafeObject(argument));</div>
<div class="line">              });</div>
<div class="line">            });</div>
<div class="line">            if (left.name) {</div>
<div class="line">              if (!self.state.expensiveChecks) {</div>
<div class="line">                self.addEnsureSafeObject(left.context);</div>
<div class="line">              }</div>
<div class="line">              expression = self.member(left.context, left.name, left.computed) + <span class="stringliteral">&#39;(&#39;</span> + args.join(<span class="stringliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;)&#39;</span>;</div>
<div class="line">            } else {</div>
<div class="line">              expression = right + <span class="stringliteral">&#39;(&#39;</span> + args.join(<span class="stringliteral">&#39;,&#39;</span>) + <span class="stringliteral">&#39;)&#39;</span>;</div>
<div class="line">            }</div>
<div class="line">            expression = self.ensureSafeObject(expression);</div>
<div class="line">            self.assign(intoId, expression);</div>
<div class="line">          }, <span class="keyword">function</span>() {</div>
<div class="line">            self.assign(intoId, <span class="stringliteral">&#39;undefined&#39;</span>);</div>
<div class="line">          });</div>
<div class="line">          recursionFn(intoId);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">      right = this.nextId();</div>
<div class="line">      left = {};</div>
<div class="line">      <span class="keywordflow">if</span> (!isAssignable(ast.left)) {</div>
<div class="line">        <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;lval&#39;</span>, <span class="stringliteral">&#39;Trying to assing a value to a non l-value&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">      this.recurse(ast.left, undefined, left, <span class="keyword">function</span>() {</div>
<div class="line">        self.if_(self.notNull(left.context), function() {</div>
<div class="line">          self.recurse(ast.right, right);</div>
<div class="line">          self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));</div>
<div class="line">          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;</div>
<div class="line">          self.assign(intoId, expression);</div>
<div class="line">          recursionFn(intoId || expression);</div>
<div class="line">        });</div>
<div class="line">      }, 1);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">        self.recurse(expr, self.nextId(), undefined, function(argument) {</div>
<div class="line">          args.push(argument);</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      expression = <span class="charliteral">&#39;[&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">        self.recurse(property.value, self.nextId(), undefined, function(expr) {</div>
<div class="line">          args.push(self.escape(</div>
<div class="line">              property.key.type === AST.Identifier ? property.key.name :</div>
<div class="line">                (<span class="stringliteral">&#39;&#39;</span> + property.key.value)) +</div>
<div class="line">              <span class="stringliteral">&#39;:&#39;</span> + expr);</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      expression = <span class="charliteral">&#39;{&#39;</span> + args.join(<span class="charliteral">&#39;,&#39;</span>) + <span class="charliteral">&#39;}&#39;</span>;</div>
<div class="line">      this.assign(intoId, expression);</div>
<div class="line">      recursionFn(expression);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">      this.assign(intoId, <span class="charliteral">&#39;s&#39;</span>);</div>
<div class="line">      recursionFn(<span class="charliteral">&#39;s&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> AST.NGValueParameter:</div>
<div class="line">      this.assign(intoId, <span class="charliteral">&#39;v&#39;</span>);</div>
<div class="line">      recursionFn(<span class="charliteral">&#39;v&#39;</span>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  getHasOwnProperty: <span class="keyword">function</span>(element, property) {</div>
<div class="line">    var key = element + <span class="charliteral">&#39;.&#39;</span> + property;</div>
<div class="line">    var own = this.current().own;</div>
<div class="line">    <span class="keywordflow">if</span> (!own.hasOwnProperty(key)) {</div>
<div class="line">      own[key] = this.nextId(<span class="keyword">false</span>, element + <span class="stringliteral">&#39;&amp;&amp;(&#39;</span> + this.escape(property) + <span class="stringliteral">&#39; in &#39;</span> + element + <span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> own[key];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  assign: <span class="keyword">function</span>(id, value) {</div>
<div class="line">    <span class="keywordflow">if</span> (!<span class="keywordtype">id</span>) <span class="keywordflow">return</span>;</div>
<div class="line">    this.current().body.push(<span class="keywordtype">id</span>, <span class="charliteral">&#39;=&#39;</span>, value, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> id;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  filter: <span class="keyword">function</span>(filterName) {</div>
<div class="line">    <span class="keywordflow">if</span> (!this.state.filters.hasOwnProperty(filterName)) {</div>
<div class="line">      this.state.filters[filterName] = this.nextId(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.state.filters[filterName];</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ifDefined: <span class="keyword">function</span>(id, defaultValue) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ifDefined(&#39;</span> + <span class="keywordtype">id</span> + <span class="charliteral">&#39;,&#39;</span> + this.escape(defaultValue) + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  plus: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;plus(&#39;</span> + left + <span class="charliteral">&#39;,&#39;</span> + right + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  return_: <span class="keyword">function</span>(id) {</div>
<div class="line">    this.current().body.push(<span class="stringliteral">&#39;return &#39;</span>, <span class="keywordtype">id</span>, <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  if_: <span class="keyword">function</span>(test, alternate, consequent) {</div>
<div class="line">    <span class="keywordflow">if</span> (test === <span class="keyword">true</span>) {</div>
<div class="line">      alternate();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      var body = this.current().body;</div>
<div class="line">      body.push(<span class="stringliteral">&#39;if(&#39;</span>, test, <span class="stringliteral">&#39;){&#39;</span>);</div>
<div class="line">      alternate();</div>
<div class="line">      body.push(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (consequent) {</div>
<div class="line">        body.push(<span class="stringliteral">&#39;else{&#39;</span>);</div>
<div class="line">        consequent();</div>
<div class="line">        body.push(<span class="charliteral">&#39;}&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  not: <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;!(&#39;</span> + expression + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  notNull: <span class="keyword">function</span>(expression) {</div>
<div class="line">    <span class="keywordflow">return</span> expression + <span class="stringliteral">&#39;!=null&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  nonComputedMember: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> left + <span class="charliteral">&#39;.&#39;</span> + right;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  computedMember: <span class="keyword">function</span>(left, right) {</div>
<div class="line">    <span class="keywordflow">return</span> left + <span class="charliteral">&#39;[&#39;</span> + right + <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  member: <span class="keyword">function</span>(left, right, computed) {</div>
<div class="line">    <span class="keywordflow">if</span> (computed) <span class="keywordflow">return</span> this.computedMember(left, right);</div>
<div class="line">    <span class="keywordflow">return</span> this.nonComputedMember(left, right);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeObject: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeObject(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeMemberName: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeMemberName(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  addEnsureSafeFunction: <span class="keyword">function</span>(item) {</div>
<div class="line">    this.current().body.push(this.ensureSafeFunction(item), <span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeObject: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeObject(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeMemberName: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeMemberName(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  ensureSafeFunction: <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;ensureSafeFunction(&#39;</span> + item + <span class="stringliteral">&#39;,text)&#39;</span>;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  lazyRecurse: <span class="keyword">function</span>(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">self</span>.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  lazyAssign: <span class="keyword">function</span>(id, value) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keyword">self</span>.assign(<span class="keywordtype">id</span>, value);</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  stringEscapeRegex: /[^ a-zA-Z0-9]/g,</div>
<div class="line"></div>
<div class="line">  stringEscapeFn: <span class="keyword">function</span>(c) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;\\u&#39;</span> + (<span class="stringliteral">&#39;0000&#39;</span> + c.charCodeAt(0).toString(16)).slice(-4);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  escape: <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (isString(value)) <span class="keywordflow">return</span> <span class="stringliteral">&quot;&#39;&quot;</span> + value.replace(<span class="keyword">this</span>.stringEscapeRegex, <span class="keyword">this</span>.stringEscapeFn) + <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(value)) <span class="keywordflow">return</span> value.toString();</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="keyword">true</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;true&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="keyword">false</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;false&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (value === null) <span class="keywordflow">return</span> <span class="stringliteral">&#39;null&#39;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (typeof value === <span class="stringliteral">&#39;undefined&#39;</span>) <span class="keywordflow">return</span> <span class="stringliteral">&#39;undefined&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">throw</span> $parseMinErr(<span class="stringliteral">&#39;esc&#39;</span>, <span class="stringliteral">&#39;IMPOSSIBLE&#39;</span>);</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  nextId: <span class="keyword">function</span>(skip, init) {</div>
<div class="line">    var <span class="keywordtype">id</span> = <span class="charliteral">&#39;v&#39;</span> + (this.state.nextId++);</div>
<div class="line">    <span class="keywordflow">if</span> (!skip) {</div>
<div class="line">      this.current().vars.push(<span class="keywordtype">id</span> + (init ? <span class="charliteral">&#39;=&#39;</span> + init : <span class="stringliteral">&#39;&#39;</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> id;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  current: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.state[this.state.computing];</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ASTInterpreter(astBuilder, $filter) {</div>
<div class="line">  this.astBuilder = astBuilder;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">ASTInterpreter.prototype = {</div>
<div class="line">  compile: <span class="keyword">function</span>(expression, expensiveChecks) {</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    var ast = this.astBuilder.ast(expression);</div>
<div class="line">    this.expression = expression;</div>
<div class="line">    this.expensiveChecks = expensiveChecks;</div>
<div class="line">    findConstantAndWatchExpressions(ast, <span class="keyword">self</span>.$filter);</div>
<div class="line">    var assignable;</div>
<div class="line">    var assign;</div>
<div class="line">    <span class="keywordflow">if</span> ((assignable = assignableAST(ast))) {</div>
<div class="line">      assign = this.recurse(assignable);</div>
<div class="line">    }</div>
<div class="line">    var toWatch = getInputs(ast.body);</div>
<div class="line">    var inputs;</div>
<div class="line">    <span class="keywordflow">if</span> (toWatch) {</div>
<div class="line">      inputs = [];</div>
<div class="line">      forEach(toWatch, <span class="keyword">function</span>(watch, key) {</div>
<div class="line">        var input = <span class="keyword">self</span>.recurse(watch);</div>
<div class="line">        watch.input = input;</div>
<div class="line">        inputs.push(input);</div>
<div class="line">        watch.watchId = key;</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">    var expressions = [];</div>
<div class="line">    forEach(ast.body, <span class="keyword">function</span>(expression) {</div>
<div class="line">      expressions.push(self.recurse(expression.expression));</div>
<div class="line">    });</div>
<div class="line">    var fn = ast.body.length === 0 ? <span class="keyword">function</span>() {} :</div>
<div class="line">             ast.body.length === 1 ? expressions[0] :</div>
<div class="line">             <span class="keyword">function</span>(scope, locals) {</div>
<div class="line">               var lastValue;</div>
<div class="line">               forEach(expressions, <span class="keyword">function</span>(exp) {</div>
<div class="line">                 lastValue = exp(scope, locals);</div>
<div class="line">               });</div>
<div class="line">               <span class="keywordflow">return</span> lastValue;</div>
<div class="line">             };</div>
<div class="line">    <span class="keywordflow">if</span> (assign) {</div>
<div class="line">      fn.assign = <span class="keyword">function</span>(scope, value, locals) {</div>
<div class="line">        <span class="keywordflow">return</span> assign(scope, locals, value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (inputs) {</div>
<div class="line">      fn.inputs = inputs;</div>
<div class="line">    }</div>
<div class="line">    fn.literal = isLiteral(ast);</div>
<div class="line">    fn.constant = isConstant(ast);</div>
<div class="line">    <span class="keywordflow">return</span> fn;</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  recurse: <span class="keyword">function</span>(ast, context, create) {</div>
<div class="line">    var left, right, <span class="keyword">self</span> = <span class="keyword">this</span>, args, expression;</div>
<div class="line">    <span class="keywordflow">if</span> (ast.input) {</div>
<div class="line">      <span class="keywordflow">return</span> this.inputs(ast.input, ast.watchId);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">switch</span> (ast.type) {</div>
<div class="line">    <span class="keywordflow">case</span> AST.Literal:</div>
<div class="line">      <span class="keywordflow">return</span> this.value(ast.value, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.UnaryExpression:</div>
<div class="line">      right = this.recurse(ast.argument);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;unary&#39;</span> + ast.operator](right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.BinaryExpression:</div>
<div class="line">      left = this.recurse(ast.left);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;binary&#39;</span> + ast.operator](left, right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.LogicalExpression:</div>
<div class="line">      left = this.recurse(ast.left);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;binary&#39;</span> + ast.operator](left, right, context);</div>
<div class="line">    <span class="keywordflow">case</span> AST.ConditionalExpression:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>[<span class="stringliteral">&#39;ternary?:&#39;</span>](</div>
<div class="line">        this.recurse(ast.test),</div>
<div class="line">        this.recurse(ast.alternate),</div>
<div class="line">        this.recurse(ast.consequent),</div>
<div class="line">        context</div>
<div class="line">      );</div>
<div class="line">    <span class="keywordflow">case</span> AST.Identifier:</div>
<div class="line">      ensureSafeMemberName(ast.name, <span class="keyword">self</span>.expression);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">self</span>.identifier(ast.name,</div>
<div class="line">                             <span class="keyword">self</span>.expensiveChecks || isPossiblyDangerousMemberName(ast.name),</div>
<div class="line">                             context, create, <span class="keyword">self</span>.expression);</div>
<div class="line">    <span class="keywordflow">case</span> AST.MemberExpression:</div>
<div class="line">      left = this.recurse(ast.object, <span class="keyword">false</span>, !!create);</div>
<div class="line">      <span class="keywordflow">if</span> (!ast.computed) {</div>
<div class="line">        ensureSafeMemberName(ast.property.name, <span class="keyword">self</span>.expression);</div>
<div class="line">        right = ast.property.name;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ast.computed) right = this.recurse(ast.property);</div>
<div class="line">      <span class="keywordflow">return</span> ast.computed ?</div>
<div class="line">        this.computedMember(left, right, context, create, <span class="keyword">self</span>.expression) :</div>
<div class="line">        this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);</div>
<div class="line">    <span class="keywordflow">case</span> AST.CallExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.arguments, <span class="keyword">function</span>(expr) {</div>
<div class="line">        args.push(self.recurse(expr));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (ast.filter) right = this.$filter(ast.callee.name);</div>
<div class="line">      <span class="keywordflow">if</span> (!ast.filter) right = this.recurse(ast.callee, <span class="keyword">true</span>);</div>
<div class="line">      <span class="keywordflow">return</span> ast.filter ?</div>
<div class="line">        <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">          var values = [];</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">            values.push(args[i](scope, locals, assign, inputs));</div>
<div class="line">          }</div>
<div class="line">          var value = right.apply(undefined, values, inputs);</div>
<div class="line">          <span class="keywordflow">return</span> context ? {context: undefined, name: undefined, value: value} : value;</div>
<div class="line">        } :</div>
<div class="line">        <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">          var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">          var value;</div>
<div class="line">          <span class="keywordflow">if</span> (rhs.value != null) {</div>
<div class="line">            ensureSafeObject(rhs.context, <span class="keyword">self</span>.expression);</div>
<div class="line">            ensureSafeFunction(rhs.value, <span class="keyword">self</span>.expression);</div>
<div class="line">            var values = [];</div>
<div class="line">            <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">              values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), <span class="keyword">self</span>.expression));</div>
<div class="line">            }</div>
<div class="line">            value = ensureSafeObject(rhs.value.apply(rhs.context, values), <span class="keyword">self</span>.expression);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">        };</div>
<div class="line">    <span class="keywordflow">case</span> AST.AssignmentExpression:</div>
<div class="line">      left = this.recurse(ast.left, <span class="keyword">true</span>, 1);</div>
<div class="line">      right = this.recurse(ast.right);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">        var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">        ensureSafeObject(lhs.value, <span class="keyword">self</span>.expression);</div>
<div class="line">        lhs.context[lhs.name] = rhs;</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: rhs} : rhs;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ArrayExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.elements, <span class="keyword">function</span>(expr) {</div>
<div class="line">        args.push(self.recurse(expr));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var value = [];</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">          value.push(args[i](scope, locals, assign, inputs));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ObjectExpression:</div>
<div class="line">      args = [];</div>
<div class="line">      forEach(ast.properties, <span class="keyword">function</span>(property) {</div>
<div class="line">        args.push({key: property.key.type === AST.Identifier ?</div>
<div class="line">                        property.key.name :</div>
<div class="line">                        (<span class="stringliteral">&#39;&#39;</span> + property.key.value),</div>
<div class="line">                   value: self.recurse(property.value)</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        var value = {};</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; args.length; ++i) {</div>
<div class="line">          value[args[i].key] = args[i].value(scope, locals, assign, inputs);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: value} : value;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.ThisExpression:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: scope} : scope;</div>
<div class="line">      };</div>
<div class="line">    <span class="keywordflow">case</span> AST.NGValueParameter:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">        <span class="keywordflow">return</span> context ? {value: assign} : assign;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"></div>
<div class="line">  <span class="stringliteral">&#39;unary+&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(arg)) {</div>
<div class="line">        arg = +arg;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        arg = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;unary-&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(arg)) {</div>
<div class="line">        arg = -arg;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        arg = 0;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;unary!&#39;</span>: <span class="keyword">function</span>(argument, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = !argument(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary+&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">      var arg = plusFn(lhs, rhs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary-&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs = right(scope, locals, assign, inputs);</div>
<div class="line">      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary*&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary/&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary%&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary===&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary!==&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary==&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary!=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&lt;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &lt; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&gt;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &gt; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&lt;=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &lt;= right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&gt;=&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &gt;= right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary&amp;&amp;&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) &amp;&amp; right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;binary||&#39;</span>: <span class="keyword">function</span>(left, right, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&#39;ternary?:&#39;</span>: <span class="keyword">function</span>(test, alternate, consequent, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">return</span> context ? {value: arg} : arg;</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  value: <span class="keyword">function</span>(value, context) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() { <span class="keywordflow">return</span> context ? {context: undefined, name: undefined, value: value} : value; };</div>
<div class="line">  },</div>
<div class="line">  identifier: <span class="keyword">function</span>(name, expensiveChecks, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var base = locals &amp;&amp; (name in locals) ? locals : scope;</div>
<div class="line">      <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; base &amp;&amp; !(base[name])) {</div>
<div class="line">        base[name] = {};</div>
<div class="line">      }</div>
<div class="line">      var value = base ? base[name] : undefined;</div>
<div class="line">      <span class="keywordflow">if</span> (expensiveChecks) {</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: base, name: name, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  computedMember: <span class="keyword">function</span>(left, right, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      var rhs;</div>
<div class="line">      var value;</div>
<div class="line">      <span class="keywordflow">if</span> (lhs != null) {</div>
<div class="line">        rhs = right(scope, locals, assign, inputs);</div>
<div class="line">        ensureSafeMemberName(rhs, expression);</div>
<div class="line">        <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; lhs &amp;&amp; !(lhs[rhs])) {</div>
<div class="line">          lhs[rhs] = {};</div>
<div class="line">        }</div>
<div class="line">        value = lhs[rhs];</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: lhs, name: rhs, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  nonComputedMember: <span class="keyword">function</span>(left, right, expensiveChecks, context, create, expression) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, locals, assign, inputs) {</div>
<div class="line">      var lhs = left(scope, locals, assign, inputs);</div>
<div class="line">      <span class="keywordflow">if</span> (create &amp;&amp; create !== 1 &amp;&amp; lhs &amp;&amp; !(lhs[right])) {</div>
<div class="line">        lhs[right] = {};</div>
<div class="line">      }</div>
<div class="line">      var value = lhs != null ? lhs[right] : undefined;</div>
<div class="line">      <span class="keywordflow">if</span> (expensiveChecks || isPossiblyDangerousMemberName(right)) {</div>
<div class="line">        ensureSafeObject(value, expression);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (context) {</div>
<div class="line">        <span class="keywordflow">return</span> {context: lhs, name: right, value: value};</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> value;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  },</div>
<div class="line">  inputs: <span class="keyword">function</span>(input, watchId) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, value, locals, inputs) {</div>
<div class="line">      <span class="keywordflow">if</span> (inputs) <span class="keywordflow">return</span> inputs[watchId];</div>
<div class="line">      <span class="keywordflow">return</span> input(scope, value, locals);</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var Parser = <span class="keyword">function</span>(lexer, $filter, options) {</div>
<div class="line">  this.lexer = lexer;</div>
<div class="line">  this.$filter = $filter;</div>
<div class="line">  this.options = options;</div>
<div class="line">  this.ast = <span class="keyword">new</span> AST(this.lexer);</div>
<div class="line">  this.astCompiler = options.csp ? <span class="keyword">new</span> ASTInterpreter(this.ast, $filter) :</div>
<div class="line">                                   new ASTCompiler(this.ast, $filter);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Parser.prototype = {</div>
<div class="line">  constructor: Parser,</div>
<div class="line"></div>
<div class="line">  parse: <span class="keyword">function</span>(text) {</div>
<div class="line">    <span class="keywordflow">return</span> this.astCompiler.compile(text, this.options.expensiveChecks);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var getterFnCacheDefault = createMap();</div>
<div class="line">var getterFnCacheExpensive = createMap();</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isPossiblyDangerousMemberName(name) {</div>
<div class="line">  <span class="keywordflow">return</span> name == <span class="stringliteral">&#39;constructor&#39;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var objectValueOf = Object.prototype.valueOf;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getValueOf(value) {</div>
<div class="line">  <span class="keywordflow">return</span> isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $ParseProvider() {</div>
<div class="line">  var cacheDefault = createMap();</div>
<div class="line">  var cacheExpensive = createMap();</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$filter&#39;</span>, <span class="keyword">function</span>($filter) {</div>
<div class="line">    var noUnsafeEval = csp().noUnsafeEval;</div>
<div class="line">    var $parseOptions = {</div>
<div class="line">          csp: noUnsafeEval,</div>
<div class="line">          expensiveChecks: <span class="keyword">false</span></div>
<div class="line">        },</div>
<div class="line">        $parseOptionsExpensive = {</div>
<div class="line">          csp: noUnsafeEval,</div>
<div class="line">          expensiveChecks: <span class="keyword">true</span></div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> $parse(exp, interceptorFn, expensiveChecks) {</div>
<div class="line">      var parsedExpression, oneTime, cacheKey;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">switch</span> (typeof exp) {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">          exp = exp.trim();</div>
<div class="line">          cacheKey = exp;</div>
<div class="line"></div>
<div class="line">          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);</div>
<div class="line">          parsedExpression = cache[cacheKey];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!parsedExpression) {</div>
<div class="line">            <span class="keywordflow">if</span> (exp.charAt(0) === <span class="charliteral">&#39;:&#39;</span> &amp;&amp; exp.charAt(1) === <span class="charliteral">&#39;:&#39;</span>) {</div>
<div class="line">              oneTime = <span class="keyword">true</span>;</div>
<div class="line">              exp = exp.substring(2);</div>
<div class="line">            }</div>
<div class="line">            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;</div>
<div class="line">            var lexer = <span class="keyword">new</span> Lexer(parseOptions);</div>
<div class="line">            var parser = <span class="keyword">new</span> Parser(lexer, $filter, parseOptions);</div>
<div class="line">            parsedExpression = parser.parse(exp);</div>
<div class="line">            <span class="keywordflow">if</span> (parsedExpression.constant) {</div>
<div class="line">              parsedExpression.$$watchDelegate = constantWatchDelegate;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oneTime) {</div>
<div class="line">              parsedExpression.$$watchDelegate = parsedExpression.literal ?</div>
<div class="line">                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsedExpression.inputs) {</div>
<div class="line">              parsedExpression.$$watchDelegate = inputsWatchDelegate;</div>
<div class="line">            }</div>
<div class="line">            cache[cacheKey] = parsedExpression;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> addInterceptor(parsedExpression, interceptorFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">          <span class="keywordflow">return</span> addInterceptor(exp, interceptorFn);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">          <span class="keywordflow">return</span> noop;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> expressionInputDirtyCheck(newValue, oldValueOfValue) {</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (newValue == null || oldValueOfValue == null) { <span class="comment">// null/undefined</span></div>
<div class="line">        <span class="keywordflow">return</span> newValue === oldValueOfValue;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (typeof newValue === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// attempt to convert the value to a primitive type</span></div>
<div class="line">        <span class="comment">// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can</span></div>
<div class="line">        <span class="comment">//             be cheaply dirty-checked</span></div>
<div class="line">        newValue = getValueOf(newValue);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (typeof newValue === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">          <span class="comment">// objects/arrays are not supported - deep-watching them would be too expensive</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// fall-through to the primitive equality check</span></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">//Primitive or NaN</span></div>
<div class="line">      <span class="keywordflow">return</span> newValue === oldValueOfValue || (newValue !== newValue &amp;&amp; oldValueOfValue !== oldValueOfValue);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {</div>
<div class="line">      var inputExpressions = parsedExpression.inputs;</div>
<div class="line">      var lastResult;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (inputExpressions.length === 1) {</div>
<div class="line">        var oldInputValueOf = expressionInputDirtyCheck; <span class="comment">// init to something unique so that equals check fails</span></div>
<div class="line">        inputExpressions = inputExpressions[0];</div>
<div class="line">        <span class="keywordflow">return</span> scope.$watch(<span class="keyword">function</span> expressionInputWatch(scope) {</div>
<div class="line">          var newInputValue = inputExpressions(scope);</div>
<div class="line">          <span class="keywordflow">if</span> (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {</div>
<div class="line">            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);</div>
<div class="line">            oldInputValueOf = newInputValue &amp;&amp; getValueOf(newInputValue);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> lastResult;</div>
<div class="line">        }, listener, objectEquality, prettyPrintExpression);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var oldInputValueOfValues = [];</div>
<div class="line">      var oldInputValues = [];</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {</div>
<div class="line">        oldInputValueOfValues[i] = expressionInputDirtyCheck; <span class="comment">// init to something unique so that equals check fails</span></div>
<div class="line">        oldInputValues[i] = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> scope.$watch(<span class="keyword">function</span> expressionInputsWatch(scope) {</div>
<div class="line">        var changed = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {</div>
<div class="line">          var newInputValue = inputExpressions[i](scope);</div>
<div class="line">          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {</div>
<div class="line">            oldInputValues[i] = newInputValue;</div>
<div class="line">            oldInputValueOfValues[i] = newInputValue &amp;&amp; getValueOf(newInputValue);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (changed) {</div>
<div class="line">          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> lastResult;</div>
<div class="line">      }, listener, objectEquality, prettyPrintExpression);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch, lastValue;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> oneTimeWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> oneTimeListener(value, old, scope) {</div>
<div class="line">        lastValue = value;</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (isDefined(value)) {</div>
<div class="line">          scope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isDefined(lastValue)) {</div>
<div class="line">              unwatch();</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      }, objectEquality);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch, lastValue;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> oneTimeWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> oneTimeListener(value, old, scope) {</div>
<div class="line">        lastValue = value;</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.call(<span class="keyword">this</span>, value, old, scope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (isAllDefined(value)) {</div>
<div class="line">          scope.$$postDigest(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isAllDefined(lastValue)) unwatch();</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      }, objectEquality);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> isAllDefined(value) {</div>
<div class="line">        var allDefined = <span class="keyword">true</span>;</div>
<div class="line">        forEach(value, <span class="keyword">function</span>(val) {</div>
<div class="line">          <span class="keywordflow">if</span> (!isDefined(val)) allDefined = <span class="keyword">false</span>;</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> allDefined;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {</div>
<div class="line">      var unwatch;</div>
<div class="line">      <span class="keywordflow">return</span> unwatch = scope.$watch(<span class="keyword">function</span> constantWatch(scope) {</div>
<div class="line">        <span class="keywordflow">return</span> parsedExpression(scope);</div>
<div class="line">      }, <span class="keyword">function</span> constantListener(value, old, scope) {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(listener)) {</div>
<div class="line">          listener.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">        }</div>
<div class="line">        unwatch();</div>
<div class="line">      }, objectEquality);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> addInterceptor(parsedExpression, interceptorFn) {</div>
<div class="line">      <span class="keywordflow">if</span> (!interceptorFn) <span class="keywordflow">return</span> parsedExpression;</div>
<div class="line">      var watchDelegate = parsedExpression.$$watchDelegate;</div>
<div class="line"></div>
<div class="line">      var regularWatch =</div>
<div class="line">          watchDelegate !== oneTimeLiteralWatchDelegate &amp;&amp;</div>
<div class="line">          watchDelegate !== oneTimeWatchDelegate;</div>
<div class="line"></div>
<div class="line">      var fn = regularWatch ? <span class="keyword">function</span> regularInterceptedExpression(scope, locals, assign, inputs) {</div>
<div class="line">        var value = parsedExpression(scope, locals, assign, inputs);</div>
<div class="line">        <span class="keywordflow">return</span> interceptorFn(value, scope, locals);</div>
<div class="line">      } : <span class="keyword">function</span> oneTimeInterceptedExpression(scope, locals, assign, inputs) {</div>
<div class="line">        var value = parsedExpression(scope, locals, assign, inputs);</div>
<div class="line">        var result = interceptorFn(value, scope, locals);</div>
<div class="line">        <span class="comment">// we only return the interceptor&#39;s result if the</span></div>
<div class="line">        <span class="comment">// initial value is defined (for bind-once)</span></div>
<div class="line">        <span class="keywordflow">return</span> isDefined(value) ? result : value;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Propagate $$watchDelegates other then inputsWatchDelegate</span></div>
<div class="line">      <span class="keywordflow">if</span> (parsedExpression.$$watchDelegate &amp;&amp;</div>
<div class="line">          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {</div>
<div class="line">        fn.$$watchDelegate = parsedExpression.$$watchDelegate;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!interceptorFn.$stateful) {</div>
<div class="line">        <span class="comment">// If there is an interceptor, but no watchDelegate then treat the interceptor like</span></div>
<div class="line">        <span class="comment">// we treat filters - it is assumed to be a pure function unless flagged with $stateful</span></div>
<div class="line">        fn.$$watchDelegate = inputsWatchDelegate;</div>
<div class="line">        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> fn;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $QProvider() {</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="keyword">function</span>($rootScope, $exceptionHandler) {</div>
<div class="line">    <span class="keywordflow">return</span> qFactory(<span class="keyword">function</span>(callback) {</div>
<div class="line">      $rootScope.$evalAsync(callback);</div>
<div class="line">    }, $exceptionHandler);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$QProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="keyword">function</span>($browser, $exceptionHandler) {</div>
<div class="line">    <span class="keywordflow">return</span> qFactory(<span class="keyword">function</span>(callback) {</div>
<div class="line">      $browser.defer(callback);</div>
<div class="line">    }, $exceptionHandler);</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> qFactory(nextTick, exceptionHandler) {</div>
<div class="line">  var $qMinErr = minErr(<span class="stringliteral">&#39;$q&#39;</span>, TypeError);</div>
<div class="line">  <span class="keyword">function</span> callOnce(<span class="keyword">self</span>, resolveFn, rejectFn) {</div>
<div class="line">    var called = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">function</span> wrap(fn) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (called) <span class="keywordflow">return</span>;</div>
<div class="line">        called = <span class="keyword">true</span>;</div>
<div class="line">        fn.call(<span class="keyword">self</span>, value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> [wrap(resolveFn), wrap(rejectFn)];</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var defer = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Deferred();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> Promise() {</div>
<div class="line">    this.$$state = { status: 0 };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  extend(Promise.prototype, {</div>
<div class="line">    then: function(onFulfilled, onRejected, progressBack) {</div>
<div class="line">      if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {</div>
<div class="line">        return this;</div>
<div class="line">      }</div>
<div class="line">      var result = new Deferred();</div>
<div class="line"></div>
<div class="line">      this.$$state.pending = this.$$state.pending || [];</div>
<div class="line">      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);</div>
<div class="line">      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);</div>
<div class="line"></div>
<div class="line">      return result.promise;</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="stringliteral">&quot;catch&quot;</span>: <span class="keyword">function</span>(callback) {</div>
<div class="line">      return this.then(null, callback);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    <span class="stringliteral">&quot;finally&quot;</span>: <span class="keyword">function</span>(callback, progressBack) {</div>
<div class="line">      return this.then(function(value) {</div>
<div class="line">        return handleCallback(value, true, callback);</div>
<div class="line">      }, <span class="keyword">function</span>(error) {</div>
<div class="line">        return handleCallback(error, false, callback);</div>
<div class="line">      }, progressBack);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native</span></div>
<div class="line">  <span class="keyword">function</span> simpleBind(context, fn) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(value) {</div>
<div class="line">      fn.call(context, value);</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> processQueue(state) {</div>
<div class="line">    var fn, deferred, pending;</div>
<div class="line"></div>
<div class="line">    pending = state.pending;</div>
<div class="line">    state.processScheduled = <span class="keyword">false</span>;</div>
<div class="line">    state.pending = undefined;</div>
<div class="line">    <span class="keywordflow">for</span> (var i = 0, ii = pending.length; i &lt; ii; ++i) {</div>
<div class="line">      deferred = pending[i][0];</div>
<div class="line">      fn = pending[i][state.status];</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(fn)) {</div>
<div class="line">          deferred.resolve(fn(state.value));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state.status === 1) {</div>
<div class="line">          deferred.resolve(state.value);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          deferred.reject(state.value);</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        deferred.reject(e);</div>
<div class="line">        exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> scheduleProcessQueue(state) {</div>
<div class="line">    <span class="keywordflow">if</span> (state.processScheduled || !state.pending) <span class="keywordflow">return</span>;</div>
<div class="line">    state.processScheduled = <span class="keyword">true</span>;</div>
<div class="line">    nextTick(<span class="keyword">function</span>() { processQueue(state); });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> Deferred() {</div>
<div class="line">    this.promise = <span class="keyword">new</span> Promise();</div>
<div class="line">    <span class="comment">//Necessary to support unbound execution :/</span></div>
<div class="line">    this.resolve = simpleBind(<span class="keyword">this</span>, this.resolve);</div>
<div class="line">    this.reject = simpleBind(<span class="keyword">this</span>, this.reject);</div>
<div class="line">    this.notify = simpleBind(<span class="keyword">this</span>, this.notify);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  extend(Deferred.prototype, {</div>
<div class="line">    resolve: function(val) {</div>
<div class="line">      if (this.promise.$$state.status) return;</div>
<div class="line">      if (val === this.promise) {</div>
<div class="line">        this.$$reject($qMinErr(</div>
<div class="line">          <span class="stringliteral">&#39;qcycle&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&quot;Expected promise to be resolved with value other than itself &#39;{0}&#39;&quot;</span>,</div>
<div class="line">          val));</div>
<div class="line">      } else {</div>
<div class="line">        this.$$resolve(val);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    $$resolve: <span class="keyword">function</span>(val) {</div>
<div class="line">      var then, fns;</div>
<div class="line"></div>
<div class="line">      fns = callOnce(this, this.$$resolve, this.$$reject);</div>
<div class="line">      try {</div>
<div class="line">        if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then;</div>
<div class="line">        if (isFunction(then)) {</div>
<div class="line">          this.promise.$$state.status = -1;</div>
<div class="line">          then.call(val, fns[0], fns[1], this.notify);</div>
<div class="line">        } else {</div>
<div class="line">          this.promise.$$state.value = val;</div>
<div class="line">          this.promise.$$state.status = 1;</div>
<div class="line">          scheduleProcessQueue(this.promise.$$state);</div>
<div class="line">        }</div>
<div class="line">      } catch (e) {</div>
<div class="line">        fns[1](e);</div>
<div class="line">        exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    reject: <span class="keyword">function</span>(reason) {</div>
<div class="line">      <span class="keywordflow">if</span> (this.promise.$$state.status) <span class="keywordflow">return</span>;</div>
<div class="line">      this.$$reject(reason);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    $$reject: <span class="keyword">function</span>(reason) {</div>
<div class="line">      this.promise.$$state.value = reason;</div>
<div class="line">      this.promise.$$state.status = 2;</div>
<div class="line">      scheduleProcessQueue(this.promise.$$state);</div>
<div class="line">    },</div>
<div class="line"></div>
<div class="line">    notify: <span class="keyword">function</span>(progress) {</div>
<div class="line">      var callbacks = this.promise.$$state.pending;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> ((this.promise.$$state.status &lt;= 0) &amp;&amp; callbacks &amp;&amp; callbacks.length) {</div>
<div class="line">        nextTick(<span class="keyword">function</span>() {</div>
<div class="line">          var callback, result;</div>
<div class="line">          <span class="keywordflow">for</span> (var i = 0, ii = callbacks.length; i &lt; ii; i++) {</div>
<div class="line">            result = callbacks[i][0];</div>
<div class="line">            callback = callbacks[i][3];</div>
<div class="line">            try {</div>
<div class="line">              result.notify(isFunction(callback) ? callback(progress) : progress);</div>
<div class="line">            } catch (e) {</div>
<div class="line">              exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  var reject = <span class="keyword">function</span>(reason) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    result.reject(reason);</div>
<div class="line">    <span class="keywordflow">return</span> result.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var makePromise = <span class="keyword">function</span> makePromise(value, resolved) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    <span class="keywordflow">if</span> (resolved) {</div>
<div class="line">      result.resolve(value);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result.reject(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var handleCallback = <span class="keyword">function</span> handleCallback(value, isResolved, callback) {</div>
<div class="line">    var callbackOutput = null;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(callback)) callbackOutput = callback();</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> makePromise(e, <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isPromiseLike(callbackOutput)) {</div>
<div class="line">      <span class="keywordflow">return</span> callbackOutput.then(<span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">return</span> makePromise(value, isResolved);</div>
<div class="line">      }, <span class="keyword">function</span>(error) {</div>
<div class="line">        <span class="keywordflow">return</span> makePromise(error, <span class="keyword">false</span>);</div>
<div class="line">      });</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> makePromise(value, isResolved);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var when = <span class="keyword">function</span>(value, callback, errback, progressBack) {</div>
<div class="line">    var result = <span class="keyword">new</span> Deferred();</div>
<div class="line">    result.resolve(value);</div>
<div class="line">    <span class="keywordflow">return</span> result.promise.then(callback, errback, progressBack);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var resolve = when;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> all(promises) {</div>
<div class="line">    var deferred = <span class="keyword">new</span> Deferred(),</div>
<div class="line">        counter = 0,</div>
<div class="line">        results = isArray(promises) ? [] : {};</div>
<div class="line"></div>
<div class="line">    forEach(promises, <span class="keyword">function</span>(promise, key) {</div>
<div class="line">      counter++;</div>
<div class="line">      when(promise).then(<span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (results.hasOwnProperty(key)) <span class="keywordflow">return</span>;</div>
<div class="line">        results[key] = value;</div>
<div class="line">        <span class="keywordflow">if</span> (!(--counter)) deferred.resolve(results);</div>
<div class="line">      }, <span class="keyword">function</span>(reason) {</div>
<div class="line">        <span class="keywordflow">if</span> (results.hasOwnProperty(key)) <span class="keywordflow">return</span>;</div>
<div class="line">        deferred.reject(reason);</div>
<div class="line">      });</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (counter === 0) {</div>
<div class="line">      deferred.resolve(results);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> deferred.promise;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var $Q = <span class="keyword">function</span> Q(resolver) {</div>
<div class="line">    <span class="keywordflow">if</span> (!isFunction(resolver)) {</div>
<div class="line">      <span class="keywordflow">throw</span> $qMinErr(<span class="stringliteral">&#39;norslvr&#39;</span>, <span class="stringliteral">&quot;Expected resolverFn, got &#39;{0}&#39;&quot;</span>, resolver);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!(<span class="keyword">this</span> instanceof Q)) {</div>
<div class="line">      <span class="comment">// More useful when $Q is the Promise itself.</span></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Q(resolver);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var deferred = <span class="keyword">new</span> Deferred();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> resolveFn(value) {</div>
<div class="line">      deferred.resolve(value);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> rejectFn(reason) {</div>
<div class="line">      deferred.reject(reason);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    resolver(resolveFn, rejectFn);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> deferred.promise;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  $Q.defer = defer;</div>
<div class="line">  $Q.reject = reject;</div>
<div class="line">  $Q.when = when;</div>
<div class="line">  $Q.resolve = resolve;</div>
<div class="line">  $Q.all = all;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> $Q;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$RAFProvider() { <span class="comment">//rAF</span></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$timeout&#39;</span>, <span class="keyword">function</span>($window, $timeout) {</div>
<div class="line">    var requestAnimationFrame = $window.requestAnimationFrame ||</div>
<div class="line">                                $window.webkitRequestAnimationFrame;</div>
<div class="line"></div>
<div class="line">    var cancelAnimationFrame = $window.cancelAnimationFrame ||</div>
<div class="line">                               $window.webkitCancelAnimationFrame ||</div>
<div class="line">                               $window.webkitCancelRequestAnimationFrame;</div>
<div class="line"></div>
<div class="line">    var rafSupported = !!requestAnimationFrame;</div>
<div class="line">    var rafFn = rafSupported</div>
<div class="line">      ? <span class="keyword">function</span>(fn) {</div>
<div class="line">          var <span class="keywordtype">id</span> = requestAnimationFrame(fn);</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            cancelAnimationFrame(<span class="keywordtype">id</span>);</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      : <span class="keyword">function</span>(fn) {</div>
<div class="line">          var timer = $timeout(fn, 16.66, <span class="keyword">false</span>); <span class="comment">// 1000 / 60 = 16.666</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">            $timeout.cancel(timer);</div>
<div class="line">          };</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    queueFn.supported = rafSupported;</div>
<div class="line"></div>
<div class="line">    var cancelLastRAF;</div>
<div class="line">    var taskCount = 0;</div>
<div class="line">    var taskQueue = [];</div>
<div class="line">    <span class="keywordflow">return</span> queueFn;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> flush() {</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; taskQueue.length; i++) {</div>
<div class="line">        var task = taskQueue[i];</div>
<div class="line">        <span class="keywordflow">if</span> (task) {</div>
<div class="line">          taskQueue[i] = null;</div>
<div class="line">          task();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      taskCount = taskQueue.length = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> queueFn(asyncFn) {</div>
<div class="line">      var index = taskQueue.length;</div>
<div class="line"></div>
<div class="line">      taskCount++;</div>
<div class="line">      taskQueue.push(asyncFn);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (index === 0) {</div>
<div class="line">        cancelLastRAF = rafFn(flush);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> cancelQueueFn() {</div>
<div class="line">        <span class="keywordflow">if</span> (index &gt;= 0) {</div>
<div class="line">          taskQueue[index] = null;</div>
<div class="line">          index = null;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (--taskCount === 0 &amp;&amp; cancelLastRAF) {</div>
<div class="line">            cancelLastRAF();</div>
<div class="line">            cancelLastRAF = null;</div>
<div class="line">            taskQueue.length = 0;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $RootScopeProvider() {</div>
<div class="line">  var TTL = 10;</div>
<div class="line">  var $rootScopeMinErr = minErr(<span class="stringliteral">&#39;$rootScope&#39;</span>);</div>
<div class="line">  var lastDirtyWatch = null;</div>
<div class="line">  var applyAsyncId = null;</div>
<div class="line"></div>
<div class="line">  this.digestTtl = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      TTL = value;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> TTL;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> createChildScopeClass(parent) {</div>
<div class="line">    <span class="keyword">function</span> ChildScope() {</div>
<div class="line">      this.$$watchers = this.$$nextSibling =</div>
<div class="line">          this.$$childHead = this.$$childTail = null;</div>
<div class="line">      this.$$listeners = {};</div>
<div class="line">      this.$$listenerCount = {};</div>
<div class="line">      this.$$watchersCount = 0;</div>
<div class="line">      this.$id = nextUid();</div>
<div class="line">      this.$$ChildScope = null;</div>
<div class="line">    }</div>
<div class="line">    ChildScope.prototype = parent;</div>
<div class="line">    <span class="keywordflow">return</span> ChildScope;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($injector, $exceptionHandler, $parse, $browser) {</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> destroyChildScope($event) {</div>
<div class="line">        $event.currentScope.$$destroyed = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> Scope() {</div>
<div class="line">      this.$id = nextUid();</div>
<div class="line">      this.$$phase = this.$parent = this.$$watchers =</div>
<div class="line">                     this.$$nextSibling = this.$$prevSibling =</div>
<div class="line">                     this.$$childHead = this.$$childTail = null;</div>
<div class="line">      this.$root = <span class="keyword">this</span>;</div>
<div class="line">      this.$$destroyed = <span class="keyword">false</span>;</div>
<div class="line">      this.$$listeners = {};</div>
<div class="line">      this.$$listenerCount = {};</div>
<div class="line">      this.$$watchersCount = 0;</div>
<div class="line">      this.$$isolateBindings = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Scope.prototype = {</div>
<div class="line">      constructor: Scope,</div>
<div class="line">      $new: <span class="keyword">function</span>(isolate, parent) {</div>
<div class="line">        var child;</div>
<div class="line"></div>
<div class="line">        parent = parent || <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isolate) {</div>
<div class="line">          child = <span class="keyword">new</span> Scope();</div>
<div class="line">          child.$root = this.$root;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// Only create a child scope class if somebody asks for one,</span></div>
<div class="line">          <span class="comment">// but cache it to allow the VM to optimize lookups.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!this.$$ChildScope) {</div>
<div class="line">            this.$$ChildScope = createChildScopeClass(<span class="keyword">this</span>);</div>
<div class="line">          }</div>
<div class="line">          child = <span class="keyword">new</span> this.$$ChildScope();</div>
<div class="line">        }</div>
<div class="line">        child.$parent = parent;</div>
<div class="line">        child.$$prevSibling = parent.$$childTail;</div>
<div class="line">        <span class="keywordflow">if</span> (parent.$$childHead) {</div>
<div class="line">          parent.$$childTail.$$nextSibling = child;</div>
<div class="line">          parent.$$childTail = child;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          parent.$$childHead = parent.$$childTail = child;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// When the new scope is not isolated or we inherit from `this`, and</span></div>
<div class="line">        <span class="comment">// the parent scope is destroyed, the property `$$destroyed` is inherited</span></div>
<div class="line">        <span class="comment">// prototypically. In all other cases, this property needs to be set</span></div>
<div class="line">        <span class="comment">// when the parent scope is destroyed.</span></div>
<div class="line">        <span class="comment">// The listener needs to be added after the parent is set</span></div>
<div class="line">        <span class="keywordflow">if</span> (isolate || parent != <span class="keyword">this</span>) child.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, destroyChildScope);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> child;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $watch: <span class="keyword">function</span>(watchExp, listener, objectEquality, prettyPrintExpression) {</div>
<div class="line">        var <span class="keyword">get</span> = $parse(watchExp);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">get</span>.$$watchDelegate) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">get</span>.$$watchDelegate(<span class="keyword">this</span>, listener, objectEquality, <span class="keyword">get</span>, watchExp);</div>
<div class="line">        }</div>
<div class="line">        var scope = <span class="keyword">this</span>,</div>
<div class="line">            array = scope.$$watchers,</div>
<div class="line">            watcher = {</div>
<div class="line">              fn: listener,</div>
<div class="line">              last: initWatchVal,</div>
<div class="line">              <span class="keyword">get</span>: <span class="keyword">get</span>,</div>
<div class="line">              exp: prettyPrintExpression || watchExp,</div>
<div class="line">              eq: !!objectEquality</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        lastDirtyWatch = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!isFunction(listener)) {</div>
<div class="line">          watcher.fn = noop;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!array) {</div>
<div class="line">          array = scope.$$watchers = [];</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// we use unshift since we use a while loop in $digest for speed.</span></div>
<div class="line">        <span class="comment">// the while loop reads in reverse order.</span></div>
<div class="line">        array.unshift(watcher);</div>
<div class="line">        incrementWatchersCount(<span class="keyword">this</span>, 1);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatch() {</div>
<div class="line">          <span class="keywordflow">if</span> (arrayRemove(array, watcher) &gt;= 0) {</div>
<div class="line">            incrementWatchersCount(scope, -1);</div>
<div class="line">          }</div>
<div class="line">          lastDirtyWatch = null;</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $watchGroup: <span class="keyword">function</span>(watchExpressions, listener) {</div>
<div class="line">        var oldValues = <span class="keyword">new</span> Array(watchExpressions.length);</div>
<div class="line">        var newValues = <span class="keyword">new</span> Array(watchExpressions.length);</div>
<div class="line">        var deregisterFns = [];</div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        var changeReactionScheduled = <span class="keyword">false</span>;</div>
<div class="line">        var firstRun = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!watchExpressions.length) {</div>
<div class="line">          <span class="comment">// No expressions means we call the listener ASAP</span></div>
<div class="line">          var shouldCall = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keyword">self</span>.$evalAsync(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (shouldCall) listener(newValues, newValues, <span class="keyword">self</span>);</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatchGroup() {</div>
<div class="line">            shouldCall = <span class="keyword">false</span>;</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (watchExpressions.length === 1) {</div>
<div class="line">          <span class="comment">// Special case size of one</span></div>
<div class="line">          <span class="keywordflow">return</span> this.$watch(watchExpressions[0], <span class="keyword">function</span> watchGroupAction(value, oldValue, scope) {</div>
<div class="line">            newValues[0] = value;</div>
<div class="line">            oldValues[0] = oldValue;</div>
<div class="line">            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        forEach(watchExpressions, <span class="keyword">function</span>(expr, i) {</div>
<div class="line">          var unwatchFn = <span class="keyword">self</span>.$watch(expr, <span class="keyword">function</span> watchGroupSubAction(value, oldValue) {</div>
<div class="line">            newValues[i] = value;</div>
<div class="line">            oldValues[i] = oldValue;</div>
<div class="line">            <span class="keywordflow">if</span> (!changeReactionScheduled) {</div>
<div class="line">              changeReactionScheduled = <span class="keyword">true</span>;</div>
<div class="line">              <span class="keyword">self</span>.$evalAsync(watchGroupAction);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          deregisterFns.push(unwatchFn);</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> watchGroupAction() {</div>
<div class="line">          changeReactionScheduled = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (firstRun) {</div>
<div class="line">            firstRun = <span class="keyword">false</span>;</div>
<div class="line">            listener(newValues, newValues, <span class="keyword">self</span>);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            listener(newValues, oldValues, <span class="keyword">self</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> deregisterWatchGroup() {</div>
<div class="line">          <span class="keywordflow">while</span> (deregisterFns.length) {</div>
<div class="line">            deregisterFns.shift()();</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $watchCollection: <span class="keyword">function</span>(obj, listener) {</div>
<div class="line">        $watchCollectionInterceptor.$stateful = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        <span class="comment">// the current value, updated on each dirty-check run</span></div>
<div class="line">        var newValue;</div>
<div class="line">        <span class="comment">// a shallow copy of the newValue from the last dirty-check run,</span></div>
<div class="line">        <span class="comment">// updated to match newValue during dirty-check run</span></div>
<div class="line">        var oldValue;</div>
<div class="line">        <span class="comment">// a shallow copy of the newValue from when the last change happened</span></div>
<div class="line">        var veryOldValue;</div>
<div class="line">        <span class="comment">// only track veryOldValue if the listener is asking for it</span></div>
<div class="line">        var trackVeryOldValue = (listener.length &gt; 1);</div>
<div class="line">        var changeDetected = 0;</div>
<div class="line">        var changeDetector = $parse(obj, $watchCollectionInterceptor);</div>
<div class="line">        var internalArray = [];</div>
<div class="line">        var internalObject = {};</div>
<div class="line">        var initRun = <span class="keyword">true</span>;</div>
<div class="line">        var oldLength = 0;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $watchCollectionInterceptor(_value) {</div>
<div class="line">          newValue = _value;</div>
<div class="line">          var newLength, key, bothNaN, newItem, oldItem;</div>
<div class="line"></div>
<div class="line">          <span class="comment">// If the new value is undefined, then return undefined as the watch may be a one-time watch</span></div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(newValue)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (!isObject(newValue)) { <span class="comment">// if primitive</span></div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== newValue) {</div>
<div class="line">              oldValue = newValue;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArrayLike(newValue)) {</div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== internalArray) {</div>
<div class="line">              <span class="comment">// we are transitioning from something which was not an array into array.</span></div>
<div class="line">              oldValue = internalArray;</div>
<div class="line">              oldLength = oldValue.length = 0;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            newLength = newValue.length;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (oldLength !== newLength) {</div>
<div class="line">              <span class="comment">// if lengths do not match we need to trigger change notification</span></div>
<div class="line">              changeDetected++;</div>
<div class="line">              oldValue.length = oldLength = newLength;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// copy the items to oldValue and look for changes.</span></div>
<div class="line">            <span class="keywordflow">for</span> (var i = 0; i &lt; newLength; i++) {</div>
<div class="line">              oldItem = oldValue[i];</div>
<div class="line">              newItem = newValue[i];</div>
<div class="line"></div>
<div class="line">              bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);</div>
<div class="line">              <span class="keywordflow">if</span> (!bothNaN &amp;&amp; (oldItem !== newItem)) {</div>
<div class="line">                changeDetected++;</div>
<div class="line">                oldValue[i] = newItem;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (oldValue !== internalObject) {</div>
<div class="line">              <span class="comment">// we are transitioning from something which was not an object into object.</span></div>
<div class="line">              oldValue = internalObject = {};</div>
<div class="line">              oldLength = 0;</div>
<div class="line">              changeDetected++;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// copy the items to oldValue and look for changes.</span></div>
<div class="line">            newLength = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (key in newValue) {</div>
<div class="line">              <span class="keywordflow">if</span> (newValue.hasOwnProperty(key)) {</div>
<div class="line">                newLength++;</div>
<div class="line">                newItem = newValue[key];</div>
<div class="line">                oldItem = oldValue[key];</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (key in oldValue) {</div>
<div class="line">                  bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);</div>
<div class="line">                  <span class="keywordflow">if</span> (!bothNaN &amp;&amp; (oldItem !== newItem)) {</div>
<div class="line">                    changeDetected++;</div>
<div class="line">                    oldValue[key] = newItem;</div>
<div class="line">                  }</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  oldLength++;</div>
<div class="line">                  oldValue[key] = newItem;</div>
<div class="line">                  changeDetected++;</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (oldLength &gt; newLength) {</div>
<div class="line">              <span class="comment">// we used to have more keys, need to find them and destroy them.</span></div>
<div class="line">              changeDetected++;</div>
<div class="line">              <span class="keywordflow">for</span> (key in oldValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (!newValue.hasOwnProperty(key)) {</div>
<div class="line">                  oldLength--;</div>
<div class="line">                  <span class="keyword">delete</span> oldValue[key];</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> changeDetected;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $watchCollectionAction() {</div>
<div class="line">          <span class="keywordflow">if</span> (initRun) {</div>
<div class="line">            initRun = <span class="keyword">false</span>;</div>
<div class="line">            listener(newValue, newValue, <span class="keyword">self</span>);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            listener(newValue, veryOldValue, <span class="keyword">self</span>);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// make a copy for the next time a collection is changed</span></div>
<div class="line">          <span class="keywordflow">if</span> (trackVeryOldValue) {</div>
<div class="line">            <span class="keywordflow">if</span> (!isObject(newValue)) {</div>
<div class="line">              <span class="comment">//primitive</span></div>
<div class="line">              veryOldValue = newValue;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArrayLike(newValue)) {</div>
<div class="line">              veryOldValue = <span class="keyword">new</span> Array(newValue.length);</div>
<div class="line">              <span class="keywordflow">for</span> (var i = 0; i &lt; newValue.length; i++) {</div>
<div class="line">                veryOldValue[i] = newValue[i];</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> { <span class="comment">// if object</span></div>
<div class="line">              veryOldValue = {};</div>
<div class="line">              <span class="keywordflow">for</span> (var key in newValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (hasOwnProperty.call(newValue, key)) {</div>
<div class="line">                  veryOldValue[key] = newValue[key];</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> this.$watch(changeDetector, $watchCollectionAction);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $digest: <span class="keyword">function</span>() {</div>
<div class="line">        var watch, value, last,</div>
<div class="line">            watchers,</div>
<div class="line">            length,</div>
<div class="line">            dirty, ttl = TTL,</div>
<div class="line">            next, current, target = <span class="keyword">this</span>,</div>
<div class="line">            watchLog = [],</div>
<div class="line">            logIdx, logMsg, asyncTask;</div>
<div class="line"></div>
<div class="line">        beginPhase(<span class="stringliteral">&#39;$digest&#39;</span>);</div>
<div class="line">        <span class="comment">// Check for changes to browser url that happened in sync before the call to $digest</span></div>
<div class="line">        $browser.$$checkUrlChange();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== null) {</div>
<div class="line">          <span class="comment">// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span></div>
<div class="line">          <span class="comment">// cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span></div>
<div class="line">          $browser.defer.cancel(applyAsyncId);</div>
<div class="line">          flushApplyAsync();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        lastDirtyWatch = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">do</span> { <span class="comment">// &quot;while dirty&quot; loop</span></div>
<div class="line">          dirty = <span class="keyword">false</span>;</div>
<div class="line">          current = target;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">while</span> (asyncQueue.length) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              asyncTask = asyncQueue.shift();</div>
<div class="line">              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">            lastDirtyWatch = null;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          traverseScopesLoop:</div>
<div class="line">          <span class="keywordflow">do</span> { <span class="comment">// &quot;traverse the scopes&quot; loop</span></div>
<div class="line">            <span class="keywordflow">if</span> ((watchers = current.$$watchers)) {</div>
<div class="line">              <span class="comment">// process our watches</span></div>
<div class="line">              length = watchers.length;</div>
<div class="line">              <span class="keywordflow">while</span> (length--) {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                  watch = watchers[length];</div>
<div class="line">                  <span class="comment">// Most common watches are on primitives, in which case we can short</span></div>
<div class="line">                  <span class="comment">// circuit it with === operator, only when === fails do we use .equals</span></div>
<div class="line">                  <span class="keywordflow">if</span> (watch) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</div>
<div class="line">                        !(watch.eq</div>
<div class="line">                            ? equals(value, last)</div>
<div class="line">                            : (typeof value === <span class="stringliteral">&#39;number&#39;</span> &amp;&amp; typeof last === <span class="stringliteral">&#39;number&#39;</span></div>
<div class="line">                               &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) {</div>
<div class="line">                      dirty = <span class="keyword">true</span>;</div>
<div class="line">                      lastDirtyWatch = watch;</div>
<div class="line">                      watch.last = watch.eq ? copy(value, null) : value;</div>
<div class="line">                      watch.fn(value, ((last === initWatchVal) ? value : last), current);</div>
<div class="line">                      <span class="keywordflow">if</span> (ttl &lt; 5) {</div>
<div class="line">                        logIdx = 4 - ttl;</div>
<div class="line">                        <span class="keywordflow">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div>
<div class="line">                        watchLog[logIdx].push({</div>
<div class="line">                          msg: isFunction(watch.exp) ? <span class="stringliteral">&#39;fn: &#39;</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div>
<div class="line">                          newVal: value,</div>
<div class="line">                          oldVal: last</div>
<div class="line">                        });</div>
<div class="line">                      }</div>
<div class="line">                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (watch === lastDirtyWatch) {</div>
<div class="line">                      <span class="comment">// If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span></div>
<div class="line">                      <span class="comment">// have already been tested.</span></div>
<div class="line">                      dirty = <span class="keyword">false</span>;</div>
<div class="line">                      <span class="keywordflow">break</span> traverseScopesLoop;</div>
<div class="line">                    }</div>
<div class="line">                  }</div>
<div class="line">                } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">                  $exceptionHandler(e);</div>
<div class="line">                }</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Insanity Warning: scope depth-first traversal</span></div>
<div class="line">            <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div>
<div class="line">            <span class="comment">// this piece should be kept in sync with the traversal in $broadcast</span></div>
<div class="line">            <span class="keywordflow">if</span> (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||</div>
<div class="line">                (current !== target &amp;&amp; current.$$nextSibling)))) {</div>
<div class="line">              <span class="keywordflow">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) {</div>
<div class="line">                current = current.$parent;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">while</span> ((current = next));</div>
<div class="line"></div>
<div class="line">          <span class="comment">// `break traverseScopesLoop;` takes us to here</span></div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {</div>
<div class="line">            clearPhase();</div>
<div class="line">            <span class="keywordflow">throw</span> $rootScopeMinErr(<span class="stringliteral">&#39;infdig&#39;</span>,</div>
<div class="line">                <span class="stringliteral">&#39;{0} $digest() iterations reached. Aborting!\n&#39;</span> +</div>
<div class="line">                <span class="stringliteral">&#39;Watchers fired in the last 5 iterations: {1}&#39;</span>,</div>
<div class="line">                TTL, watchLog);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">        } <span class="keywordflow">while</span> (dirty || asyncQueue.length);</div>
<div class="line"></div>
<div class="line">        clearPhase();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span> (postDigestQueue.length) {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            postDigestQueue.shift()();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $destroy: <span class="keyword">function</span>() {</div>
<div class="line">        <span class="comment">// We can&#39;t destroy a scope that has been already destroyed.</span></div>
<div class="line">        <span class="keywordflow">if</span> (this.$$destroyed) <span class="keywordflow">return</span>;</div>
<div class="line">        var parent = this.$parent;</div>
<div class="line"></div>
<div class="line">        this.$broadcast(<span class="stringliteral">&#39;$destroy&#39;</span>);</div>
<div class="line">        this.$$destroyed = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">this</span> === $rootScope) {</div>
<div class="line">          <span class="comment">//Remove handlers attached to window when $rootScope is removed</span></div>
<div class="line">          $browser.$$applicationDestroyed();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        incrementWatchersCount(<span class="keyword">this</span>, -this.$$watchersCount);</div>
<div class="line">        <span class="keywordflow">for</span> (var eventName in this.$$listenerCount) {</div>
<div class="line">          decrementListenerCount(<span class="keyword">this</span>, this.$$listenerCount[eventName], eventName);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// sever all the references to parent scopes (after this cleanup, the current scope should</span></div>
<div class="line">        <span class="comment">// not be retained by any of our references and should be eligible for garbage collection)</span></div>
<div class="line">        <span class="keywordflow">if</span> (parent &amp;&amp; parent.$$childHead == <span class="keyword">this</span>) parent.$$childHead = this.$$nextSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (parent &amp;&amp; parent.$$childTail == <span class="keyword">this</span>) parent.$$childTail = this.$$prevSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;</div>
<div class="line">        <span class="keywordflow">if</span> (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Disable listeners, watchers and apply/digest methods</span></div>
<div class="line">        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;</div>
<div class="line">        this.$on = this.$watch = this.$watchGroup = <span class="keyword">function</span>() { <span class="keywordflow">return</span> noop; };</div>
<div class="line">        this.$$listeners = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// All of the code below is bogus code that works around V8&#39;s memory leak via optimized code</span></div>
<div class="line">        <span class="comment">// and inline caches.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// see:</span></div>
<div class="line">        <span class="comment">// - https://code.google.com/p/v8/issues/detail?id=2073#c26</span></div>
<div class="line">        <span class="comment">// - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909</span></div>
<div class="line">        <span class="comment">// - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451</span></div>
<div class="line"></div>
<div class="line">        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =</div>
<div class="line">            this.$$childTail = this.$root = this.$$watchers = null;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $eval: <span class="keyword">function</span>(expr, locals) {</div>
<div class="line">        <span class="keywordflow">return</span> $parse(expr)(<span class="keyword">this</span>, locals);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $evalAsync: <span class="keyword">function</span>(expr, locals) {</div>
<div class="line">        <span class="comment">// if we are outside of an $digest loop and this is the first time we are scheduling async</span></div>
<div class="line">        <span class="comment">// task also schedule async auto-flush</span></div>
<div class="line">        <span class="keywordflow">if</span> (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) {</div>
<div class="line">          $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (asyncQueue.length) {</div>
<div class="line">              $rootScope.$digest();</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        asyncQueue.push({scope: <span class="keyword">this</span>, expression: expr, locals: locals});</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $$postDigest: <span class="keyword">function</span>(fn) {</div>
<div class="line">        postDigestQueue.push(fn);</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $apply: <span class="keyword">function</span>(expr) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          beginPhase(<span class="stringliteral">&#39;$apply&#39;</span>);</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">return</span> this.$eval(expr);</div>
<div class="line">          } <span class="keywordflow">finally</span> {</div>
<div class="line">            clearPhase();</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        } <span class="keywordflow">finally</span> {</div>
<div class="line">          <span class="keywordflow">try</span> {</div>
<div class="line">            $rootScope.$digest();</div>
<div class="line">          } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">            $exceptionHandler(e);</div>
<div class="line">            <span class="keywordflow">throw</span> e;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $applyAsync: <span class="keyword">function</span>(expr) {</div>
<div class="line">        var scope = <span class="keyword">this</span>;</div>
<div class="line">        expr &amp;&amp; applyAsyncQueue.push($applyAsyncExpression);</div>
<div class="line">        scheduleApplyAsync();</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> $applyAsyncExpression() {</div>
<div class="line">          scope.$eval(expr);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line">      $on: <span class="keyword">function</span>(name, listener) {</div>
<div class="line">        var namedListeners = this.$$listeners[name];</div>
<div class="line">        <span class="keywordflow">if</span> (!namedListeners) {</div>
<div class="line">          this.$$listeners[name] = namedListeners = [];</div>
<div class="line">        }</div>
<div class="line">        namedListeners.push(listener);</div>
<div class="line"></div>
<div class="line">        var current = <span class="keyword">this</span>;</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          <span class="keywordflow">if</span> (!current.$$listenerCount[name]) {</div>
<div class="line">            current.$$listenerCount[name] = 0;</div>
<div class="line">          }</div>
<div class="line">          current.$$listenerCount[name]++;</div>
<div class="line">        } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line"></div>
<div class="line">        var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">          var indexOfListener = namedListeners.indexOf(listener);</div>
<div class="line">          <span class="keywordflow">if</span> (indexOfListener !== -1) {</div>
<div class="line">            namedListeners[indexOfListener] = null;</div>
<div class="line">            decrementListenerCount(<span class="keyword">self</span>, 1, name);</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $emit: <span class="keyword">function</span>(name, args) {</div>
<div class="line">        var empty = [],</div>
<div class="line">            namedListeners,</div>
<div class="line">            scope = <span class="keyword">this</span>,</div>
<div class="line">            stopPropagation = <span class="keyword">false</span>,</div>
<div class="line">            event = {</div>
<div class="line">              name: name,</div>
<div class="line">              targetScope: scope,</div>
<div class="line">              stopPropagation: <span class="keyword">function</span>() {stopPropagation = <span class="keyword">true</span>;},</div>
<div class="line">              preventDefault: <span class="keyword">function</span>() {</div>
<div class="line">                event.defaultPrevented = <span class="keyword">true</span>;</div>
<div class="line">              },</div>
<div class="line">              defaultPrevented: <span class="keyword">false</span></div>
<div class="line">            },</div>
<div class="line">            listenerArgs = concat([event], arguments, 1),</div>
<div class="line">            i, length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          namedListeners = scope.$$listeners[name] || empty;</div>
<div class="line">          event.currentScope = scope;</div>
<div class="line">          <span class="keywordflow">for</span> (i = 0, length = namedListeners.length; i &lt; length; i++) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// if listeners were deregistered, defragment the array</span></div>
<div class="line">            <span class="keywordflow">if</span> (!namedListeners[i]) {</div>
<div class="line">              namedListeners.splice(i, 1);</div>
<div class="line">              i--;</div>
<div class="line">              length--;</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              <span class="comment">//allow all listeners attached to the current scope to run</span></div>
<div class="line">              namedListeners[i].apply(null, listenerArgs);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">//if any listener on the current scope stops propagation, prevent bubbling</span></div>
<div class="line">          <span class="keywordflow">if</span> (stopPropagation) {</div>
<div class="line">            event.currentScope = null;</div>
<div class="line">            <span class="keywordflow">return</span> event;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">//traverse upwards</span></div>
<div class="line">          scope = scope.$parent;</div>
<div class="line">        } <span class="keywordflow">while</span> (scope);</div>
<div class="line"></div>
<div class="line">        event.currentScope = null;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> event;</div>
<div class="line">      },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      $broadcast: <span class="keyword">function</span>(name, args) {</div>
<div class="line">        var target = <span class="keyword">this</span>,</div>
<div class="line">            current = target,</div>
<div class="line">            next = target,</div>
<div class="line">            event = {</div>
<div class="line">              name: name,</div>
<div class="line">              targetScope: target,</div>
<div class="line">              preventDefault: <span class="keyword">function</span>() {</div>
<div class="line">                event.defaultPrevented = <span class="keyword">true</span>;</div>
<div class="line">              },</div>
<div class="line">              defaultPrevented: <span class="keyword">false</span></div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!target.$$listenerCount[name]) <span class="keywordflow">return</span> event;</div>
<div class="line"></div>
<div class="line">        var listenerArgs = concat([event], arguments, 1),</div>
<div class="line">            listeners, i, length;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//down while you can, then up and next sibling or up and next sibling until back at root</span></div>
<div class="line">        <span class="keywordflow">while</span> ((current = next)) {</div>
<div class="line">          event.currentScope = current;</div>
<div class="line">          listeners = current.$$listeners[name] || [];</div>
<div class="line">          <span class="keywordflow">for</span> (i = 0, length = listeners.length; i &lt; length; i++) {</div>
<div class="line">            <span class="comment">// if listeners were deregistered, defragment the array</span></div>
<div class="line">            <span class="keywordflow">if</span> (!listeners[i]) {</div>
<div class="line">              listeners.splice(i, 1);</div>
<div class="line">              i--;</div>
<div class="line">              length--;</div>
<div class="line">              <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">              listeners[i].apply(null, listenerArgs);</div>
<div class="line">            } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">              $exceptionHandler(e);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Insanity Warning: scope depth-first traversal</span></div>
<div class="line">          <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div>
<div class="line">          <span class="comment">// this piece should be kept in sync with the traversal in $digest</span></div>
<div class="line">          <span class="comment">// (though it differs due to having the extra check for $$listenerCount)</span></div>
<div class="line">          <span class="keywordflow">if</span> (!(next = ((current.$$listenerCount[name] &amp;&amp; current.$$childHead) ||</div>
<div class="line">              (current !== target &amp;&amp; current.$$nextSibling)))) {</div>
<div class="line">            <span class="keywordflow">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) {</div>
<div class="line">              current = current.$parent;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        event.currentScope = null;</div>
<div class="line">        <span class="keywordflow">return</span> event;</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var $rootScope = <span class="keyword">new</span> Scope();</div>
<div class="line"></div>
<div class="line">    <span class="comment">//The internal queues. Expose them on the $rootScope for debugging/testing purposes.</span></div>
<div class="line">    var asyncQueue = $rootScope.$$asyncQueue = [];</div>
<div class="line">    var postDigestQueue = $rootScope.$$postDigestQueue = [];</div>
<div class="line">    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> $rootScope;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> beginPhase(phase) {</div>
<div class="line">      <span class="keywordflow">if</span> ($rootScope.$$phase) {</div>
<div class="line">        <span class="keywordflow">throw</span> $rootScopeMinErr(<span class="stringliteral">&#39;inprog&#39;</span>, <span class="stringliteral">&#39;{0} already in progress&#39;</span>, $rootScope.$$phase);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      $rootScope.$$phase = phase;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> clearPhase() {</div>
<div class="line">      $rootScope.$$phase = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> incrementWatchersCount(current, count) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        current.$$watchersCount += count;</div>
<div class="line">      } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> decrementListenerCount(current, count, name) {</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        current.$$listenerCount[name] -= count;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (current.$$listenerCount[name] === 0) {</div>
<div class="line">          <span class="keyword">delete</span> current.$$listenerCount[name];</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">while</span> ((current = current.$parent));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> initWatchVal() {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> flushApplyAsync() {</div>
<div class="line">      <span class="keywordflow">while</span> (applyAsyncQueue.length) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          applyAsyncQueue.shift()();</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      applyAsyncId = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> scheduleApplyAsync() {</div>
<div class="line">      <span class="keywordflow">if</span> (applyAsyncId === null) {</div>
<div class="line">        applyAsyncId = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">          $rootScope.$apply(flushApplyAsync);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$SanitizeUriProvider() {</div>
<div class="line">  var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,</div>
<div class="line">    imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;</div>
<div class="line"></div>
<div class="line">  this.aHrefSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      aHrefSanitizationWhitelist = regexp;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> aHrefSanitizationWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  this.imgSrcSanitizationWhitelist = <span class="keyword">function</span>(regexp) {</div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(regexp)) {</div>
<div class="line">      imgSrcSanitizationWhitelist = regexp;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> imgSrcSanitizationWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span> sanitizeUri(uri, isImage) {</div>
<div class="line">      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;</div>
<div class="line">      var normalizedVal;</div>
<div class="line">      normalizedVal = urlResolve(uri).href;</div>
<div class="line">      <span class="keywordflow">if</span> (normalizedVal !== <span class="stringliteral">&#39;&#39;</span> &amp;&amp; !normalizedVal.match(regex)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;unsafe:&#39;</span> + normalizedVal;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> uri;</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span></div>
<div class="line"><span class="comment"> *     Any commits to this file should be reviewed with security in mind.  *</span></div>
<div class="line"><span class="comment"> *   Changes to this file can potentially create security vulnerabilities. *</span></div>
<div class="line"><span class="comment"> *          An approval from 2 Core members with history of modifying      *</span></div>
<div class="line"><span class="comment"> *                         this file is required.                          *</span></div>
<div class="line"><span class="comment"> *                                                                         *</span></div>
<div class="line"><span class="comment"> *  Does the change somehow allow for arbitrary javascript to be executed? *</span></div>
<div class="line"><span class="comment"> *    Or allows for someone to change the prototype of built-in objects?   *</span></div>
<div class="line"><span class="comment"> *     Or gives undesired access to variables likes document or window?    *</span></div>
<div class="line"><span class="comment"> * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span></div>
<div class="line"></div>
<div class="line">var $sceMinErr = minErr(<span class="stringliteral">&#39;$sce&#39;</span>);</div>
<div class="line"></div>
<div class="line">var SCE_CONTEXTS = {</div>
<div class="line">  HTML: <span class="stringliteral">&#39;html&#39;</span>,</div>
<div class="line">  CSS: <span class="stringliteral">&#39;css&#39;</span>,</div>
<div class="line">  URL: <span class="stringliteral">&#39;url&#39;</span>,</div>
<div class="line">  <span class="comment">// RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a</span></div>
<div class="line">  <span class="comment">// url.  (e.g. ng-include, script src, templateUrl)</span></div>
<div class="line">  RESOURCE_URL: <span class="stringliteral">&#39;resourceUrl&#39;</span>,</div>
<div class="line">  JS: <span class="stringliteral">&#39;js&#39;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper functions follow.</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> adjustMatcher(matcher) {</div>
<div class="line">  <span class="keywordflow">if</span> (matcher === <span class="stringliteral">&#39;self&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> matcher;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(matcher)) {</div>
<div class="line">    <span class="comment">// Strings match exactly except for 2 wildcards - &#39;*&#39; and &#39;**&#39;.</span></div>
<div class="line">    <span class="comment">// &#39;*&#39; matches any character except those from the set &#39;:/.?&amp;&#39;.</span></div>
<div class="line">    <span class="comment">// &#39;**&#39; matches any character (like .* in a RegExp).</span></div>
<div class="line">    <span class="comment">// More than 2 *&#39;s raises an error as it&#39;s ill defined.</span></div>
<div class="line">    <span class="keywordflow">if</span> (matcher.indexOf(<span class="stringliteral">&#39;***&#39;</span>) &gt; -1) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;iwcard&#39;</span>,</div>
<div class="line">          <span class="stringliteral">&#39;Illegal sequence *** in string matcher.  String: {0}&#39;</span>, matcher);</div>
<div class="line">    }</div>
<div class="line">    matcher = escapeForRegexp(matcher).</div>
<div class="line">                  replace(<span class="stringliteral">&#39;\\*\\*&#39;</span>, <span class="stringliteral">&#39;.*&#39;</span>).</div>
<div class="line">                  replace(<span class="stringliteral">&#39;\\*&#39;</span>, <span class="stringliteral">&#39;[^:/.?&amp;;]*&#39;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RegExp(<span class="charliteral">&#39;^&#39;</span> + matcher + <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isRegExp(matcher)) {</div>
<div class="line">    <span class="comment">// The only other type of matcher allowed is a Regexp.</span></div>
<div class="line">    <span class="comment">// Match entire URL / disallow partial matches.</span></div>
<div class="line">    <span class="comment">// Flags are reset (i.e. no global, ignoreCase or multiline)</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RegExp(<span class="charliteral">&#39;^&#39;</span> + matcher.source + <span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;imatcher&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Matchers may only be &quot;self&quot;, string patterns or RegExp objects&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> adjustMatchers(matchers) {</div>
<div class="line">  var adjustedMatchers = [];</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(matchers)) {</div>
<div class="line">    forEach(matchers, <span class="keyword">function</span>(matcher) {</div>
<div class="line">      adjustedMatchers.push(adjustMatcher(matcher));</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> adjustedMatchers;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SceDelegateProvider() {</div>
<div class="line">  this.SCE_CONTEXTS = SCE_CONTEXTS;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Resource URLs can also be trusted by policy.</span></div>
<div class="line">  var resourceUrlWhitelist = [<span class="stringliteral">&#39;self&#39;</span>],</div>
<div class="line">      resourceUrlBlacklist = [];</div>
<div class="line"></div>
<div class="line">  this.resourceUrlWhitelist = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      resourceUrlWhitelist = adjustMatchers(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> resourceUrlWhitelist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.resourceUrlBlacklist = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      resourceUrlBlacklist = adjustMatchers(value);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> resourceUrlBlacklist;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line"></div>
<div class="line">    var htmlSanitizer = <span class="keyword">function</span> htmlSanitizer(html) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;unsafe&#39;</span>, <span class="stringliteral">&#39;Attempting to use an unsafe value in a safe context.&#39;</span>);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ($injector.has(<span class="stringliteral">&#39;$sanitize&#39;</span>)) {</div>
<div class="line">      htmlSanitizer = $injector.get(<span class="stringliteral">&#39;$sanitize&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> matchUrl(matcher, parsedUrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (matcher === <span class="stringliteral">&#39;self&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> urlIsSameOrigin(parsedUrl);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// definitely a regex.  See adjustMatchers()</span></div>
<div class="line">        <span class="keywordflow">return</span> !!matcher.exec(parsedUrl.href);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> isResourceUrlAllowedByPolicy(url) {</div>
<div class="line">      var parsedUrl = urlResolve(url.toString());</div>
<div class="line">      var i, n, allowed = <span class="keyword">false</span>;</div>
<div class="line">      <span class="comment">// Ensure that at least one item from the whitelist allows this url.</span></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0, n = resourceUrlWhitelist.length; i &lt; n; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {</div>
<div class="line">          allowed = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (allowed) {</div>
<div class="line">        <span class="comment">// Ensure that no item from the blacklist blocked this url.</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, n = resourceUrlBlacklist.length; i &lt; n; i++) {</div>
<div class="line">          <span class="keywordflow">if</span> (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {</div>
<div class="line">            allowed = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> allowed;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> generateHolderType(Base) {</div>
<div class="line">      var holderType = <span class="keyword">function</span> TrustedValueHolderType(trustedValue) {</div>
<div class="line">        this.$$unwrapTrustedValue = <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">return</span> trustedValue;</div>
<div class="line">        };</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">if</span> (Base) {</div>
<div class="line">        holderType.prototype = <span class="keyword">new</span> Base();</div>
<div class="line">      }</div>
<div class="line">      holderType.prototype.valueOf = <span class="keyword">function</span> sceValueOf() {</div>
<div class="line">        <span class="keywordflow">return</span> this.$$unwrapTrustedValue();</div>
<div class="line">      };</div>
<div class="line">      holderType.prototype.toString = <span class="keyword">function</span> sceToString() {</div>
<div class="line">        <span class="keywordflow">return</span> this.$$unwrapTrustedValue().toString();</div>
<div class="line">      };</div>
<div class="line">      <span class="keywordflow">return</span> holderType;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var trustedValueHolderBase = generateHolderType(),</div>
<div class="line">        byType = {};</div>
<div class="line"></div>
<div class="line">    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);</div>
<div class="line">    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> trustAs(type, trustedValue) {</div>
<div class="line">      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);</div>
<div class="line">      <span class="keywordflow">if</span> (!Constructor) {</div>
<div class="line">        <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;icontext&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Attempted to trust a value in invalid context. Context: {0}; Value: {1}&#39;</span>,</div>
<div class="line">            type, trustedValue);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (trustedValue === null || trustedValue === undefined || trustedValue === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> trustedValue;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting</span></div>
<div class="line">      <span class="comment">// mutable objects, we ensure here that the value passed in is actually a string.</span></div>
<div class="line">      <span class="keywordflow">if</span> (typeof trustedValue !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;itype&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Attempted to trust a non-string value in a content requiring a string: Context: {0}&#39;</span>,</div>
<div class="line">            type);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Constructor(trustedValue);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> valueOf(maybeTrusted) {</div>
<div class="line">      <span class="keywordflow">if</span> (maybeTrusted instanceof trustedValueHolderBase) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted.$$unwrapTrustedValue();</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getTrusted(type, maybeTrusted) {</div>
<div class="line">      <span class="keywordflow">if</span> (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">      }</div>
<div class="line">      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);</div>
<div class="line">      <span class="keywordflow">if</span> (constructor &amp;&amp; maybeTrusted instanceof constructor) {</div>
<div class="line">        <span class="keywordflow">return</span> maybeTrusted.$$unwrapTrustedValue();</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// If we get here, then we may only take one of two actions.</span></div>
<div class="line">      <span class="comment">// 1. sanitize the value for the requested type, or</span></div>
<div class="line">      <span class="comment">// 2. throw an exception.</span></div>
<div class="line">      <span class="keywordflow">if</span> (type === SCE_CONTEXTS.RESOURCE_URL) {</div>
<div class="line">        <span class="keywordflow">if</span> (isResourceUrlAllowedByPolicy(maybeTrusted)) {</div>
<div class="line">          <span class="keywordflow">return</span> maybeTrusted;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;insecurl&#39;</span>,</div>
<div class="line">              <span class="stringliteral">&#39;Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}&#39;</span>,</div>
<div class="line">              maybeTrusted.toString());</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === SCE_CONTEXTS.HTML) {</div>
<div class="line">        <span class="keywordflow">return</span> htmlSanitizer(maybeTrusted);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;unsafe&#39;</span>, <span class="stringliteral">&#39;Attempting to use an unsafe value in a safe context.&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> { trustAs: trustAs,</div>
<div class="line">             getTrusted: getTrusted,</div>
<div class="line">             valueOf: valueOf };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint maxlen: false*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* jshint maxlen: 100 */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SceProvider() {</div>
<div class="line">  var enabled = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">  this.enabled = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (arguments.length) {</div>
<div class="line">      enabled = !!value;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> enabled;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Design notes on the default implementation for SCE.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * The API contract for the SCE delegate</span></div>
<div class="line"><span class="comment">   * -------------------------------------</span></div>
<div class="line"><span class="comment">   * The SCE delegate object must provide the following 3 methods:</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - trustAs(contextEnum, value)</span></div>
<div class="line"><span class="comment">   *     This method is used to tell the SCE service that the provided value is OK to use in the</span></div>
<div class="line"><span class="comment">   *     contexts specified by contextEnum.  It must return an object that will be accepted by</span></div>
<div class="line"><span class="comment">   *     getTrusted() for a compatible contextEnum and return this value.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - valueOf(value)</span></div>
<div class="line"><span class="comment">   *     For values that were not produced by trustAs(), return them as is.  For values that were</span></div>
<div class="line"><span class="comment">   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if</span></div>
<div class="line"><span class="comment">   *     trustAs is wrapping the given values into some type, this operation unwraps it when given</span></div>
<div class="line"><span class="comment">   *     such a value.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * - getTrusted(contextEnum, value)</span></div>
<div class="line"><span class="comment">   *     This function should return the a value that is safe to use in the context specified by</span></div>
<div class="line"><span class="comment">   *     contextEnum or throw and exception otherwise.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be</span></div>
<div class="line"><span class="comment">   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For</span></div>
<div class="line"><span class="comment">   * instance, an implementation could maintain a registry of all trusted objects by context.  In</span></div>
<div class="line"><span class="comment">   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would</span></div>
<div class="line"><span class="comment">   * return the same object passed in if it was found in the registry under a compatible context or</span></div>
<div class="line"><span class="comment">   * throw an exception otherwise.  An implementation might only wrap values some of the time based</span></div>
<div class="line"><span class="comment">   * on some criteria.  getTrusted() might return a value and not throw an exception for special</span></div>
<div class="line"><span class="comment">   * constants or objects even if not wrapped.  All such implementations fulfill this contract.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * A note on the inheritance model for SCE contexts</span></div>
<div class="line"><span class="comment">   * ------------------------------------------------</span></div>
<div class="line"><span class="comment">   * I&#39;ve used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This</span></div>
<div class="line"><span class="comment">   * is purely an implementation details.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * The contract is simply this:</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)</span></div>
<div class="line"><span class="comment">   *     will also succeed.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * Inheritance happens to capture this in a natural way.  In some future, we</span></div>
<div class="line"><span class="comment">   * may not use inheritance anymore.  That is OK because no code outside of</span></div>
<div class="line"><span class="comment">   * sce.js and sceSpecs.js would need to be aware of this detail.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$sceDelegate&#39;</span>, <span class="keyword">function</span>(</div>
<div class="line">                $parse,   $sceDelegate) {</div>
<div class="line">    <span class="comment">// Prereq: Ensure that we&#39;re not running in IE&lt;11 quirks mode.  In that mode, IE &lt; 11 allow</span></div>
<div class="line">    <span class="comment">// the &quot;expression(javascript expression)&quot; syntax which is insecure.</span></div>
<div class="line">    <span class="keywordflow">if</span> (enabled &amp;&amp; msie &lt; 8) {</div>
<div class="line">      <span class="keywordflow">throw</span> $sceMinErr(<span class="stringliteral">&#39;iequirks&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;Strict Contextual Escaping does not support Internet Explorer version &lt; 11 in quirks &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;mode.  You can fix this by adding the text &lt;!doctype html&gt; to the top of your HTML &#39;</span> +</div>
<div class="line">        <span class="stringliteral">&#39;document.  See http://docs.angularjs.org/api/ng.$sce for more information.&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var sce = shallowCopy(SCE_CONTEXTS);</div>
<div class="line"></div>
<div class="line">    sce.isEnabled = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> enabled;</div>
<div class="line">    };</div>
<div class="line">    sce.trustAs = $sceDelegate.trustAs;</div>
<div class="line">    sce.getTrusted = $sceDelegate.getTrusted;</div>
<div class="line">    sce.valueOf = $sceDelegate.valueOf;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!enabled) {</div>
<div class="line">      sce.trustAs = sce.getTrusted = <span class="keyword">function</span>(type, value) { <span class="keywordflow">return</span> value; };</div>
<div class="line">      sce.valueOf = identity;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    sce.parseAs = <span class="keyword">function</span> sceParseAs(type, expr) {</div>
<div class="line">      var parsed = $parse(expr);</div>
<div class="line">      <span class="keywordflow">if</span> (parsed.literal &amp;&amp; parsed.constant) {</div>
<div class="line">        <span class="keywordflow">return</span> parsed;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> $parse(expr, <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> sce.getTrusted(type, value);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shorthand delegations.</span></div>
<div class="line">    var parse = sce.parseAs,</div>
<div class="line">        getTrusted = sce.getTrusted,</div>
<div class="line">        trustAs = sce.trustAs;</div>
<div class="line"></div>
<div class="line">    forEach(SCE_CONTEXTS, <span class="keyword">function</span>(enumValue, name) {</div>
<div class="line">      var lName = lowercase(name);</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;parse_as_&quot;</span> + lName)] = <span class="keyword">function</span>(expr) {</div>
<div class="line">        <span class="keywordflow">return</span> parse(enumValue, expr);</div>
<div class="line">      };</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;get_trusted_&quot;</span> + lName)] = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> getTrusted(enumValue, value);</div>
<div class="line">      };</div>
<div class="line">      sce[camelCase(<span class="stringliteral">&quot;trust_as_&quot;</span> + lName)] = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> trustAs(enumValue, value);</div>
<div class="line">      };</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> sce;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $SnifferProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$window&#39;</span>, <span class="stringliteral">&#39;$document&#39;</span>, <span class="keyword">function</span>($window, $document) {</div>
<div class="line">    var eventSupport = {},</div>
<div class="line">        android =</div>
<div class="line">          toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),</div>
<div class="line">        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),</div>
<div class="line">        document = $document[0] || {},</div>
<div class="line">        vendorPrefix,</div>
<div class="line">        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,</div>
<div class="line">        bodyStyle = document.body &amp;&amp; document.body.style,</div>
<div class="line">        transitions = <span class="keyword">false</span>,</div>
<div class="line">        animations = <span class="keyword">false</span>,</div>
<div class="line">        match;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bodyStyle) {</div>
<div class="line">      <span class="keywordflow">for</span> (var prop in bodyStyle) {</div>
<div class="line">        <span class="keywordflow">if</span> (match = vendorRegex.exec(prop)) {</div>
<div class="line">          vendorPrefix = match[0];</div>
<div class="line">          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!vendorPrefix) {</div>
<div class="line">        vendorPrefix = (<span class="stringliteral">&#39;WebkitOpacity&#39;</span> in bodyStyle) &amp;&amp; <span class="stringliteral">&#39;webkit&#39;</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      transitions = !!((<span class="stringliteral">&#39;transition&#39;</span> in bodyStyle) || (vendorPrefix + <span class="stringliteral">&#39;Transition&#39;</span> in bodyStyle));</div>
<div class="line">      animations  = !!((<span class="stringliteral">&#39;animation&#39;</span> in bodyStyle) || (vendorPrefix + <span class="stringliteral">&#39;Animation&#39;</span> in bodyStyle));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (android &amp;&amp; (!transitions ||  !animations)) {</div>
<div class="line">        transitions = isString(bodyStyle.webkitTransition);</div>
<div class="line">        animations = isString(bodyStyle.webkitAnimation);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      <span class="comment">// Android has history.pushState, but it does not update location correctly</span></div>
<div class="line">      <span class="comment">// so let&#39;s not use the history API at all.</span></div>
<div class="line">      <span class="comment">// http://code.google.com/p/android/issues/detail?id=17471</span></div>
<div class="line">      <span class="comment">// https://github.com/angular/angular.js/issues/904</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// older webkit browser (533.9) on Boxee box has exactly the same problem as Android has</span></div>
<div class="line">      <span class="comment">// so let&#39;s not use the history API also</span></div>
<div class="line">      <span class="comment">// We are purposefully using `!(android &lt; 4)` to cover the case when `android` is undefined</span></div>
<div class="line">      <span class="comment">// jshint -W018</span></div>
<div class="line">      history: !!($window.history &amp;&amp; $window.history.pushState &amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),</div>
<div class="line">      <span class="comment">// jshint +W018</span></div>
<div class="line">      hasEvent: <span class="keyword">function</span>(event) {</div>
<div class="line">        <span class="comment">// IE9 implements &#39;input&#39; event it&#39;s so fubared that we rather pretend that it doesn&#39;t have</span></div>
<div class="line">        <span class="comment">// it. In particular the event is not fired when backspace or delete key are pressed or</span></div>
<div class="line">        <span class="comment">// when cut operation is performed.</span></div>
<div class="line">        <span class="comment">// IE10+ implements &#39;input&#39; event but it erroneously fires under various situations,</span></div>
<div class="line">        <span class="comment">// e.g. when placeholder changes, or a form is focused.</span></div>
<div class="line">        <span class="keywordflow">if</span> (event === <span class="stringliteral">&#39;input&#39;</span> &amp;&amp; msie &lt;= 11) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(eventSupport[event])) {</div>
<div class="line">          var divElm = document.createElement(<span class="stringliteral">&#39;div&#39;</span>);</div>
<div class="line">          eventSupport[event] = <span class="stringliteral">&#39;on&#39;</span> + event in divElm;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> eventSupport[event];</div>
<div class="line">      },</div>
<div class="line">      csp: csp(),</div>
<div class="line">      vendorPrefix: vendorPrefix,</div>
<div class="line">      transitions: transitions,</div>
<div class="line">      animations: animations,</div>
<div class="line">      android: android</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var $compileMinErr = minErr(<span class="stringliteral">&#39;$compile&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TemplateRequestProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$templateCache&#39;</span>, <span class="stringliteral">&#39;$http&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$sce&#39;</span>, <span class="keyword">function</span>($templateCache, $http, $q, $sce) {</div>
<div class="line">    <span class="keyword">function</span> handleRequestFn(tpl, ignoreRequestError) {</div>
<div class="line">      handleRequestFn.totalPendingRequests++;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We consider the template cache holds only trusted templates, so</span></div>
<div class="line">      <span class="comment">// there&#39;s no need to go through whitelisting again for keys that already</span></div>
<div class="line">      <span class="comment">// are included in there. This also makes Angular accept any script</span></div>
<div class="line">      <span class="comment">// directive, no matter its name. However, we still need to unwrap trusted</span></div>
<div class="line">      <span class="comment">// types.</span></div>
<div class="line">      <span class="keywordflow">if</span> (!isString(tpl) || !$templateCache.get(tpl)) {</div>
<div class="line">        tpl = $sce.getTrustedResourceUrl(tpl);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var transformResponse = $http.defaults &amp;&amp; $http.defaults.transformResponse;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isArray(transformResponse)) {</div>
<div class="line">        transformResponse = transformResponse.filter(<span class="keyword">function</span>(transformer) {</div>
<div class="line">          <span class="keywordflow">return</span> transformer !== defaultHttpResponseTransform;</div>
<div class="line">        });</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transformResponse === defaultHttpResponseTransform) {</div>
<div class="line">        transformResponse = null;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var httpOptions = {</div>
<div class="line">        cache: $templateCache,</div>
<div class="line">        transformResponse: transformResponse</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> $http.get(tpl, httpOptions)</div>
<div class="line">        [<span class="stringliteral">&#39;finally&#39;</span>](<span class="keyword">function</span>() {</div>
<div class="line">          handleRequestFn.totalPendingRequests--;</div>
<div class="line">        })</div>
<div class="line">        .then(<span class="keyword">function</span>(response) {</div>
<div class="line">          $templateCache.put(tpl, response.data);</div>
<div class="line">          <span class="keywordflow">return</span> response.data;</div>
<div class="line">        }, handleError);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> handleError(resp) {</div>
<div class="line">        <span class="keywordflow">if</span> (!ignoreRequestError) {</div>
<div class="line">          <span class="keywordflow">throw</span> $compileMinErr(<span class="stringliteral">&#39;tpload&#39;</span>, <span class="stringliteral">&#39;Failed to load template: {0} (HTTP status: {1} {2})&#39;</span>,</div>
<div class="line">            tpl, resp.status, resp.statusText);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> $q.reject(resp);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    handleRequestFn.totalPendingRequests = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> handleRequestFn;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$TestabilityProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$location&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($rootScope,   $browser,   $location) {</div>
<div class="line"></div>
<div class="line">    var testability = {};</div>
<div class="line"></div>
<div class="line">    testability.findBindings = <span class="keyword">function</span>(element, expression, opt_exactMatch) {</div>
<div class="line">      var bindings = element.getElementsByClassName(<span class="stringliteral">&#39;ng-binding&#39;</span>);</div>
<div class="line">      var matches = [];</div>
<div class="line">      forEach(bindings, <span class="keyword">function</span>(binding) {</div>
<div class="line">        var dataBinding = angular.element(binding).data(<span class="stringliteral">&#39;$binding&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (dataBinding) {</div>
<div class="line">          forEach(dataBinding, <span class="keyword">function</span>(bindingName) {</div>
<div class="line">            <span class="keywordflow">if</span> (opt_exactMatch) {</div>
<div class="line">              var matcher = <span class="keyword">new</span> RegExp(<span class="stringliteral">&#39;(^|\\s)&#39;</span> + escapeForRegexp(expression) + <span class="stringliteral">&#39;(\\s|\\||$)&#39;</span>);</div>
<div class="line">              <span class="keywordflow">if</span> (matcher.test(bindingName)) {</div>
<div class="line">                matches.push(binding);</div>
<div class="line">              }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="keywordflow">if</span> (bindingName.indexOf(expression) != -1) {</div>
<div class="line">                matches.push(binding);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> matches;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.findModels = <span class="keyword">function</span>(element, expression, opt_exactMatch) {</div>
<div class="line">      var prefixes = [<span class="stringliteral">&#39;ng-&#39;</span>, <span class="stringliteral">&#39;data-ng-&#39;</span>, <span class="stringliteral">&#39;ng\\:&#39;</span>];</div>
<div class="line">      <span class="keywordflow">for</span> (var p = 0; p &lt; prefixes.length; ++p) {</div>
<div class="line">        var attributeEquals = opt_exactMatch ? <span class="charliteral">&#39;=&#39;</span> : <span class="stringliteral">&#39;*=&#39;</span>;</div>
<div class="line">        var selector = <span class="charliteral">&#39;[&#39;</span> + prefixes[p] + <span class="stringliteral">&#39;model&#39;</span> + attributeEquals + <span class="charliteral">&#39;&quot;&#39;</span> + expression + <span class="stringliteral">&#39;&quot;]&#39;</span>;</div>
<div class="line">        var elements = element.querySelectorAll(selector);</div>
<div class="line">        <span class="keywordflow">if</span> (elements.length) {</div>
<div class="line">          <span class="keywordflow">return</span> elements;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.getLocation = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> $location.url();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.setLocation = <span class="keyword">function</span>(url) {</div>
<div class="line">      <span class="keywordflow">if</span> (url !== $location.url()) {</div>
<div class="line">        $location.url(url);</div>
<div class="line">        $rootScope.$digest();</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    testability.whenStable = <span class="keyword">function</span>(callback) {</div>
<div class="line">      $browser.notifyWhenNoOutstandingRequests(callback);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> testability;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $TimeoutProvider() {</div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$$q&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>,</div>
<div class="line">       <span class="keyword">function</span>($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) {</div>
<div class="line"></div>
<div class="line">    var deferreds = {};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> timeout(fn, delay, invokeApply) {</div>
<div class="line">      <span class="keywordflow">if</span> (!isFunction(fn)) {</div>
<div class="line">        invokeApply = delay;</div>
<div class="line">        delay = fn;</div>
<div class="line">        fn = noop;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var args = sliceArgs(arguments, 3),</div>
<div class="line">          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),</div>
<div class="line">          deferred = (skipApply ? $$q : $q).defer(),</div>
<div class="line">          promise = deferred.promise,</div>
<div class="line">          timeoutId;</div>
<div class="line"></div>
<div class="line">      timeoutId = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          deferred.resolve(fn.apply(null, args));</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          deferred.reject(e);</div>
<div class="line">          $exceptionHandler(e);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">finally</span> {</div>
<div class="line">          <span class="keyword">delete</span> deferreds[promise.$$timeoutId];</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!skipApply) $rootScope.$apply();</div>
<div class="line">      }, delay);</div>
<div class="line"></div>
<div class="line">      promise.$$timeoutId = timeoutId;</div>
<div class="line">      deferreds[timeoutId] = deferred;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> promise;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    timeout.cancel = <span class="keyword">function</span>(promise) {</div>
<div class="line">      <span class="keywordflow">if</span> (promise &amp;&amp; promise.$$timeoutId in deferreds) {</div>
<div class="line">        deferreds[promise.$$timeoutId].reject(<span class="stringliteral">&#39;canceled&#39;</span>);</div>
<div class="line">        <span class="keyword">delete</span> deferreds[promise.$$timeoutId];</div>
<div class="line">        <span class="keywordflow">return</span> $browser.defer.cancel(promise.$$timeoutId);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> timeout;</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// NOTE:  The usage of window and document instead of $window and $document here is</span></div>
<div class="line"><span class="comment">// deliberate.  This service depends on the specific behavior of anchor nodes created by the</span></div>
<div class="line"><span class="comment">// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and</span></div>
<div class="line"><span class="comment">// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it</span></div>
<div class="line"><span class="comment">// doesn&#39;t know about mocked locations and resolves URLs to the real document - which is</span></div>
<div class="line"><span class="comment">// exactly the behavior needed here.  There is little value is mocking these out for this</span></div>
<div class="line"><span class="comment">// service.</span></div>
<div class="line">var urlParsingNode = document.createElement(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">var originUrl = urlResolve(window.location.href);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlResolve(url) {</div>
<div class="line">  var href = url;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (msie) {</div>
<div class="line">    <span class="comment">// Normalize before parse.  Refer Implementation Notes on why this is</span></div>
<div class="line">    <span class="comment">// done in two steps on IE.</span></div>
<div class="line">    urlParsingNode.setAttribute(<span class="stringliteral">&quot;href&quot;</span>, href);</div>
<div class="line">    href = urlParsingNode.href;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  urlParsingNode.setAttribute(<span class="stringliteral">&#39;href&#39;</span>, href);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils</span></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    href: urlParsingNode.href,</div>
<div class="line">    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    host: urlParsingNode.host,</div>
<div class="line">    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, <span class="stringliteral">&#39;&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    hostname: urlParsingNode.hostname,</div>
<div class="line">    port: urlParsingNode.port,</div>
<div class="line">    pathname: (urlParsingNode.pathname.charAt(0) === <span class="charliteral">&#39;/&#39;</span>)</div>
<div class="line">      ? urlParsingNode.pathname</div>
<div class="line">      : <span class="charliteral">&#39;/&#39;</span> + urlParsingNode.pathname</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlIsSameOrigin(requestUrl) {</div>
<div class="line">  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;</div>
<div class="line">  <span class="keywordflow">return</span> (parsed.protocol === originUrl.protocol &amp;&amp;</div>
<div class="line">          parsed.host === originUrl.host);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $WindowProvider() {</div>
<div class="line">  this.$get = valueFn(window);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$CookieReader($document) {</div>
<div class="line">  var rawDocument = $document[0] || {};</div>
<div class="line">  var lastCookies = {};</div>
<div class="line">  var lastCookieString = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> safeDecodeURIComponent(str) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      <span class="keywordflow">return</span> decodeURIComponent(str);</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      <span class="keywordflow">return</span> str;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    var cookieArray, cookie, i, index, name;</div>
<div class="line">    var currentCookieString = rawDocument.cookie || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (currentCookieString !== lastCookieString) {</div>
<div class="line">      lastCookieString = currentCookieString;</div>
<div class="line">      cookieArray = lastCookieString.split(<span class="stringliteral">&#39;; &#39;</span>);</div>
<div class="line">      lastCookies = {};</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; cookieArray.length; i++) {</div>
<div class="line">        cookie = cookieArray[i];</div>
<div class="line">        index = cookie.indexOf(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (index &gt; 0) { <span class="comment">//ignore nameless cookies</span></div>
<div class="line">          name = safeDecodeURIComponent(cookie.substring(0, index));</div>
<div class="line">          <span class="comment">// the first value that is seen for a cookie is the most</span></div>
<div class="line">          <span class="comment">// specific one.  values for the same cookie name that</span></div>
<div class="line">          <span class="comment">// follow are for less specific paths.</span></div>
<div class="line">          <span class="keywordflow">if</span> (lastCookies[name] === undefined) {</div>
<div class="line">            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> lastCookies;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">$$CookieReader.$inject = [<span class="stringliteral">&#39;$document&#39;</span>];</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> $$CookieReaderProvider() {</div>
<div class="line">  this.$get = $$CookieReader;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global currencyFilter: true,</span></div>
<div class="line"><span class="comment"> dateFilter: true,</span></div>
<div class="line"><span class="comment"> filterFilter: true,</span></div>
<div class="line"><span class="comment"> jsonFilter: true,</span></div>
<div class="line"><span class="comment"> limitToFilter: true,</span></div>
<div class="line"><span class="comment"> lowercaseFilter: true,</span></div>
<div class="line"><span class="comment"> numberFilter: true,</span></div>
<div class="line"><span class="comment"> orderByFilter: true,</span></div>
<div class="line"><span class="comment"> uppercaseFilter: true,</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line">$FilterProvider.$inject = [<span class="stringliteral">&#39;$provide&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> $FilterProvider($provide) {</div>
<div class="line">  var suffix = <span class="stringliteral">&#39;Filter&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> <span class="keyword">register</span>(name, factory) {</div>
<div class="line">    <span class="keywordflow">if</span> (isObject(name)) {</div>
<div class="line">      var filters = {};</div>
<div class="line">      forEach(name, <span class="keyword">function</span>(filter, key) {</div>
<div class="line">        filters[key] = <span class="keyword">register</span>(key, filter);</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> filters;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> $provide.factory(name + suffix, factory);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  this.<span class="keyword">register</span> = <span class="keyword">register</span>;</div>
<div class="line"></div>
<div class="line">  this.$get = [<span class="stringliteral">&#39;$injector&#39;</span>, <span class="keyword">function</span>($injector) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>(name) {</div>
<div class="line">      <span class="keywordflow">return</span> $injector.get(name + suffix);</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* global</span></div>
<div class="line"><span class="comment">    currencyFilter: false,</span></div>
<div class="line"><span class="comment">    dateFilter: false,</span></div>
<div class="line"><span class="comment">    filterFilter: false,</span></div>
<div class="line"><span class="comment">    jsonFilter: false,</span></div>
<div class="line"><span class="comment">    limitToFilter: false,</span></div>
<div class="line"><span class="comment">    lowercaseFilter: false,</span></div>
<div class="line"><span class="comment">    numberFilter: false,</span></div>
<div class="line"><span class="comment">    orderByFilter: false,</span></div>
<div class="line"><span class="comment">    uppercaseFilter: false,</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line"></div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;currency&#39;</span>, currencyFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;date&#39;</span>, dateFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;filter&#39;</span>, filterFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;json&#39;</span>, jsonFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;limitTo&#39;</span>, limitToFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;lowercase&#39;</span>, lowercaseFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;number&#39;</span>, numberFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;orderBy&#39;</span>, orderByFilter);</div>
<div class="line">  <span class="keyword">register</span>(<span class="stringliteral">&#39;uppercase&#39;</span>, uppercaseFilter);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> filterFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(array, expression, comparator) {</div>
<div class="line">    <span class="keywordflow">if</span> (!isArrayLike(array)) {</div>
<div class="line">      <span class="keywordflow">if</span> (array == null) {</div>
<div class="line">        <span class="keywordflow">return</span> array;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;filter&#39;</span>)(<span class="stringliteral">&#39;notarray&#39;</span>, <span class="stringliteral">&#39;Expected array but received: {0}&#39;</span>, array);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var expressionType = getTypeForFilter(expression);</div>
<div class="line">    var predicateFn;</div>
<div class="line">    var matchAgainstAnyProp;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (expressionType) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">        predicateFn = expression;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;boolean&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;null&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;number&#39;</span>:</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">        matchAgainstAnyProp = <span class="keyword">true</span>;</div>
<div class="line">        <span class="comment">//jshint -W086</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;object&#39;</span>:</div>
<div class="line">        <span class="comment">//jshint +W086</span></div>
<div class="line">        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> array;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> Array.prototype.filter.call(array, predicateFn);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper functions for `filterFilter`</span></div>
<div class="line"><span class="keyword">function</span> createPredicateFn(expression, comparator, matchAgainstAnyProp) {</div>
<div class="line">  var shouldMatchPrimitives = isObject(expression) &amp;&amp; (<span class="charliteral">&#39;$&#39;</span> in expression);</div>
<div class="line">  var predicateFn;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (comparator === <span class="keyword">true</span>) {</div>
<div class="line">    comparator = equals;</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isFunction(comparator)) {</div>
<div class="line">    comparator = <span class="keyword">function</span>(actual, expected) {</div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(actual)) {</div>
<div class="line">        <span class="comment">// No substring matching against `undefined`</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> ((actual === null) || (expected === null)) {</div>
<div class="line">        <span class="comment">// No substring matching against `null`; only match against `null`</span></div>
<div class="line">        <span class="keywordflow">return</span> actual === expected;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isObject(expected) || (isObject(actual) &amp;&amp; !hasCustomToString(actual))) {</div>
<div class="line">        <span class="comment">// Should not compare primitives against objects, unless they have custom `toString` method</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      actual = lowercase(<span class="stringliteral">&#39;&#39;</span> + actual);</div>
<div class="line">      expected = lowercase(<span class="stringliteral">&#39;&#39;</span> + expected);</div>
<div class="line">      <span class="keywordflow">return</span> actual.indexOf(expected) !== -1;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  predicateFn = <span class="keyword">function</span>(item) {</div>
<div class="line">    <span class="keywordflow">if</span> (shouldMatchPrimitives &amp;&amp; !isObject(item)) {</div>
<div class="line">      <span class="keywordflow">return</span> deepCompare(item, expression.$, comparator, <span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> deepCompare(item, expression, comparator, matchAgainstAnyProp);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> predicateFn;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {</div>
<div class="line">  var actualType = getTypeForFilter(actual);</div>
<div class="line">  var expectedType = getTypeForFilter(expected);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> ((expectedType === <span class="stringliteral">&#39;string&#39;</span>) &amp;&amp; (expected.charAt(0) === <span class="charliteral">&#39;!&#39;</span>)) {</div>
<div class="line">    <span class="keywordflow">return</span> !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isArray(actual)) {</div>
<div class="line">    <span class="comment">// In case `actual` is an array, consider it a match</span></div>
<div class="line">    <span class="comment">// if ANY of it&#39;s items matches `expected`</span></div>
<div class="line">    <span class="keywordflow">return</span> actual.some(<span class="keyword">function</span>(item) {</div>
<div class="line">      <span class="keywordflow">return</span> deepCompare(item, expected, comparator, matchAgainstAnyProp);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">switch</span> (actualType) {</div>
<div class="line">    <span class="keywordflow">case</span> <span class="stringliteral">&#39;object&#39;</span>:</div>
<div class="line">      var key;</div>
<div class="line">      <span class="keywordflow">if</span> (matchAgainstAnyProp) {</div>
<div class="line">        <span class="keywordflow">for</span> (key in actual) {</div>
<div class="line">          <span class="keywordflow">if</span> ((key.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) &amp;&amp; deepCompare(actual[key], expected, comparator, <span class="keyword">true</span>)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> dontMatchWholeObject ? <span class="keyword">false</span> : deepCompare(actual, expected, comparator, <span class="keyword">false</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (expectedType === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">        <span class="keywordflow">for</span> (key in expected) {</div>
<div class="line">          var expectedVal = expected[key];</div>
<div class="line">          <span class="keywordflow">if</span> (isFunction(expectedVal) || isUndefined(expectedVal)) {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          var matchAnyProperty = key === <span class="charliteral">&#39;$&#39;</span>;</div>
<div class="line">          var actualVal = matchAnyProperty ? actual : actual[key];</div>
<div class="line">          <span class="keywordflow">if</span> (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> comparator(actual, expected);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <span class="stringliteral">&#39;function&#39;</span>:</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">      <span class="keywordflow">return</span> comparator(actual, expected);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Used for easily differentiating between `null` and actual `object`</span></div>
<div class="line"><span class="keyword">function</span> getTypeForFilter(val) {</div>
<div class="line">  <span class="keywordflow">return</span> (val === null) ? <span class="stringliteral">&#39;null&#39;</span> : typeof val;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">currencyFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> currencyFilter($locale) {</div>
<div class="line">  var formats = $locale.NUMBER_FORMATS;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(amount, currencySymbol, fractionSize) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(currencySymbol)) {</div>
<div class="line">      currencySymbol = formats.CURRENCY_SYM;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(fractionSize)) {</div>
<div class="line">      fractionSize = formats.PATTERNS[1].maxFrac;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if null or undefined pass it through</span></div>
<div class="line">    <span class="keywordflow">return</span> (amount == null)</div>
<div class="line">        ? amount</div>
<div class="line">        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).</div>
<div class="line">            replace(/\u00A4/g, currencySymbol);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">numberFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> numberFilter($locale) {</div>
<div class="line">  var formats = $locale.NUMBER_FORMATS;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(number, fractionSize) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if null or undefined pass it through</span></div>
<div class="line">    <span class="keywordflow">return</span> (number == null)</div>
<div class="line">        ? number</div>
<div class="line">        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,</div>
<div class="line">                       fractionSize);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var DECIMAL_SEP = <span class="charliteral">&#39;.&#39;</span>;</div>
<div class="line"><span class="keyword">function</span> formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {</div>
<div class="line">  <span class="keywordflow">if</span> (isObject(number)) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  var isNegative = number &lt; 0;</div>
<div class="line">  number = Math.abs(number);</div>
<div class="line"></div>
<div class="line">  var isInfinity = number === Infinity;</div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; !isFinite(number)) <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">  var numStr = number + <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      formatedText = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">      hasExponent = <span class="keyword">false</span>,</div>
<div class="line">      parts = [];</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isInfinity) formatedText = <span class="stringliteral">&#39;\u221e&#39;</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; numStr.indexOf(<span class="charliteral">&#39;e&#39;</span>) !== -1) {</div>
<div class="line">    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);</div>
<div class="line">    <span class="keywordflow">if</span> (match &amp;&amp; match[2] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; match[3] &gt; fractionSize + 1) {</div>
<div class="line">      number = 0;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      formatedText = numStr;</div>
<div class="line">      hasExponent = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!isInfinity &amp;&amp; !hasExponent) {</div>
<div class="line">    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || <span class="stringliteral">&#39;&#39;</span>).length;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// determine fractionSize if it is not specified</span></div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(fractionSize)) {</div>
<div class="line">      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// safely round numbers in JS without hitting imprecisions of floating-point arithmetics</span></div>
<div class="line">    <span class="comment">// inspired by:</span></div>
<div class="line">    <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round</span></div>
<div class="line">    number = +(Math.round(+(number.toString() + <span class="charliteral">&#39;e&#39;</span> + fractionSize)).toString() + <span class="charliteral">&#39;e&#39;</span> + -fractionSize);</div>
<div class="line"></div>
<div class="line">    var fraction = (<span class="stringliteral">&#39;&#39;</span> + number).split(DECIMAL_SEP);</div>
<div class="line">    var whole = fraction[0];</div>
<div class="line">    fraction = fraction[1] || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    var i, pos = 0,</div>
<div class="line">        lgroup = pattern.lgSize,</div>
<div class="line">        group = pattern.gSize;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (whole.length &gt;= (lgroup + group)) {</div>
<div class="line">      pos = whole.length - lgroup;</div>
<div class="line">      <span class="keywordflow">for</span> (i = 0; i &lt; pos; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> ((pos - i) % group === 0 &amp;&amp; i !== 0) {</div>
<div class="line">          formatedText += groupSep;</div>
<div class="line">        }</div>
<div class="line">        formatedText += whole.charAt(i);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = pos; i &lt; whole.length; i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((whole.length - i) % lgroup === 0 &amp;&amp; i !== 0) {</div>
<div class="line">        formatedText += groupSep;</div>
<div class="line">      }</div>
<div class="line">      formatedText += whole.charAt(i);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// format fraction part.</span></div>
<div class="line">    <span class="keywordflow">while</span> (fraction.length &lt; fractionSize) {</div>
<div class="line">      fraction += <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fractionSize &amp;&amp; fractionSize !== <span class="stringliteral">&quot;0&quot;</span>) formatedText += decimalSep + fraction.substr(0, fractionSize);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (fractionSize &gt; 0 &amp;&amp; number &lt; 1) {</div>
<div class="line">      formatedText = number.toFixed(fractionSize);</div>
<div class="line">      number = parseFloat(formatedText);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (number === 0) {</div>
<div class="line">    isNegative = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  parts.push(isNegative ? pattern.negPre : pattern.posPre,</div>
<div class="line">             formatedText,</div>
<div class="line">             isNegative ? pattern.negSuf : pattern.posSuf);</div>
<div class="line">  <span class="keywordflow">return</span> parts.join(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> padNumber(num, digits, trim) {</div>
<div class="line">  var neg = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (num &lt; 0) {</div>
<div class="line">    neg =  <span class="charliteral">&#39;-&#39;</span>;</div>
<div class="line">    num = -num;</div>
<div class="line">  }</div>
<div class="line">  num = <span class="stringliteral">&#39;&#39;</span> + num;</div>
<div class="line">  <span class="keywordflow">while</span> (num.length &lt; digits) num = <span class="charliteral">&#39;0&#39;</span> + num;</div>
<div class="line">  <span class="keywordflow">if</span> (trim) {</div>
<div class="line">    num = num.substr(num.length - digits);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> neg + num;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> dateGetter(name, size, offset, trim) {</div>
<div class="line">  offset = offset || 0;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date) {</div>
<div class="line">    var value = date[<span class="stringliteral">&#39;get&#39;</span> + name]();</div>
<div class="line">    <span class="keywordflow">if</span> (offset &gt; 0 || value &gt; -offset) {</div>
<div class="line">      value += offset;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (value === 0 &amp;&amp; offset == -12) value = 12;</div>
<div class="line">    <span class="keywordflow">return</span> padNumber(value, size, trim);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> dateStrGetter(name, shortForm) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date, formats) {</div>
<div class="line">    var value = date[<span class="stringliteral">&#39;get&#39;</span> + name]();</div>
<div class="line">    var <span class="keyword">get</span> = uppercase(shortForm ? (<span class="stringliteral">&#39;SHORT&#39;</span> + name) : name);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> formats[<span class="keyword">get</span>][value];</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> timeZoneGetter(date, formats, offset) {</div>
<div class="line">  var zone = -1 * offset;</div>
<div class="line">  var paddedZone = (zone &gt;= 0) ? <span class="stringliteral">&quot;+&quot;</span> : <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">  paddedZone += padNumber(Math[zone &gt; 0 ? <span class="stringliteral">&#39;floor&#39;</span> : <span class="stringliteral">&#39;ceil&#39;</span>](zone / 60), 2) +</div>
<div class="line">                padNumber(Math.abs(zone % 60), 2);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> paddedZone;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getFirstThursdayOfYear(year) {</div>
<div class="line">    <span class="comment">// 0 = index of January</span></div>
<div class="line">    var dayOfWeekOnFirst = (<span class="keyword">new</span> Date(year, 0, 1)).getDay();</div>
<div class="line">    <span class="comment">// 4 = index of Thursday (+1 to account for 1st = 5)</span></div>
<div class="line">    <span class="comment">// 11 = index of *next* Thursday (+1 account for 1st = 12)</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Date(year, 0, ((dayOfWeekOnFirst &lt;= 4) ? 5 : 12) - dayOfWeekOnFirst);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getThursdayThisWeek(datetime) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Date(datetime.getFullYear(), datetime.getMonth(),</div>
<div class="line">      <span class="comment">// 4 = index of Thursday</span></div>
<div class="line">      datetime.getDate() + (4 - datetime.getDay()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> weekGetter(size) {</div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">function</span>(date) {</div>
<div class="line">      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),</div>
<div class="line">         thisThurs = getThursdayThisWeek(date);</div>
<div class="line"></div>
<div class="line">      var diff = +thisThurs - +firstThurs,</div>
<div class="line">         result = 1 + Math.round(diff / 6.048e8); <span class="comment">// 6.048e8 ms per week</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> padNumber(result, size);</div>
<div class="line">   };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ampmGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> eraGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getFullYear() &lt;= 0 ? formats.ERAS[0] : formats.ERAS[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> longEraGetter(date, formats) {</div>
<div class="line">  <span class="keywordflow">return</span> date.getFullYear() &lt;= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var DATE_FORMATS = {</div>
<div class="line">  yyyy: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 4),</div>
<div class="line">    yy: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 2, 0, <span class="keyword">true</span>),</div>
<div class="line">     y: dateGetter(<span class="stringliteral">&#39;FullYear&#39;</span>, 1),</div>
<div class="line">  MMMM: dateStrGetter(<span class="stringliteral">&#39;Month&#39;</span>),</div>
<div class="line">   MMM: dateStrGetter(<span class="stringliteral">&#39;Month&#39;</span>, <span class="keyword">true</span>),</div>
<div class="line">    MM: dateGetter(<span class="stringliteral">&#39;Month&#39;</span>, 2, 1),</div>
<div class="line">     M: dateGetter(<span class="stringliteral">&#39;Month&#39;</span>, 1, 1),</div>
<div class="line">    dd: dateGetter(<span class="stringliteral">&#39;Date&#39;</span>, 2),</div>
<div class="line">     d: dateGetter(<span class="stringliteral">&#39;Date&#39;</span>, 1),</div>
<div class="line">    HH: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 2),</div>
<div class="line">     H: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 1),</div>
<div class="line">    hh: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 2, -12),</div>
<div class="line">     h: dateGetter(<span class="stringliteral">&#39;Hours&#39;</span>, 1, -12),</div>
<div class="line">    mm: dateGetter(<span class="stringliteral">&#39;Minutes&#39;</span>, 2),</div>
<div class="line">     m: dateGetter(<span class="stringliteral">&#39;Minutes&#39;</span>, 1),</div>
<div class="line">    ss: dateGetter(<span class="stringliteral">&#39;Seconds&#39;</span>, 2),</div>
<div class="line">     s: dateGetter(<span class="stringliteral">&#39;Seconds&#39;</span>, 1),</div>
<div class="line">     <span class="comment">// while ISO 8601 requires fractions to be prefixed with `.` or `,`</span></div>
<div class="line">     <span class="comment">// we can be just safely rely on using `sss` since we currently don&#39;t support single or two digit fractions</span></div>
<div class="line">   sss: dateGetter(<span class="stringliteral">&#39;Milliseconds&#39;</span>, 3),</div>
<div class="line">  EEEE: dateStrGetter(<span class="stringliteral">&#39;Day&#39;</span>),</div>
<div class="line">   EEE: dateStrGetter(<span class="stringliteral">&#39;Day&#39;</span>, <span class="keyword">true</span>),</div>
<div class="line">     a: ampmGetter,</div>
<div class="line">     Z: timeZoneGetter,</div>
<div class="line">    ww: weekGetter(2),</div>
<div class="line">     w: weekGetter(1),</div>
<div class="line">     G: eraGetter,</div>
<div class="line">     GG: eraGetter,</div>
<div class="line">     GGG: eraGetter,</div>
<div class="line">     GGGG: longEraGetter</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG<span class="stringliteral">&#39;]+)|(?:&#39;</span>(?:[^<span class="stringliteral">&#39;]|&#39;</span><span class="stringliteral">&#39;)*&#39;</span>)|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,</div>
<div class="line">    NUMBER_STRING = /^\-?\d+$/;</div>
<div class="line"></div>
<div class="line">dateFilter.$inject = [<span class="stringliteral">&#39;$locale&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> dateFilter($locale) {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;</div>
<div class="line">                     <span class="comment">// 1        2       3         4          5          6          7          8  9     10      11</span></div>
<div class="line">  <span class="keyword">function</span> jsonStringToDate(<span class="keywordtype">string</span>) {</div>
<div class="line">    var match;</div>
<div class="line">    <span class="keywordflow">if</span> (match = <span class="keywordtype">string</span>.match(R_ISO8601_STR)) {</div>
<div class="line">      var date = <span class="keyword">new</span> Date(0),</div>
<div class="line">          tzHour = 0,</div>
<div class="line">          tzMin  = 0,</div>
<div class="line">          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,</div>
<div class="line">          timeSetter = match[8] ? date.setUTCHours : date.setHours;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (match[9]) {</div>
<div class="line">        tzHour = toInt(match[9] + match[10]);</div>
<div class="line">        tzMin = toInt(match[9] + match[11]);</div>
<div class="line">      }</div>
<div class="line">      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));</div>
<div class="line">      var h = toInt(match[4] || 0) - tzHour;</div>
<div class="line">      var m = toInt(match[5] || 0) - tzMin;</div>
<div class="line">      var s = toInt(match[6] || 0);</div>
<div class="line">      var ms = Math.round(parseFloat(<span class="stringliteral">&#39;0.&#39;</span> + (match[7] || 0)) * 1000);</div>
<div class="line">      timeSetter.call(date, h, m, s, ms);</div>
<div class="line">      <span class="keywordflow">return</span> date;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> string;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(date, format, timezone) {</div>
<div class="line">    var text = <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">        parts = [],</div>
<div class="line">        fn, match;</div>
<div class="line"></div>
<div class="line">    format = format || <span class="stringliteral">&#39;mediumDate&#39;</span>;</div>
<div class="line">    format = $locale.DATETIME_FORMATS[format] || format;</div>
<div class="line">    <span class="keywordflow">if</span> (isString(date)) {</div>
<div class="line">      date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(date)) {</div>
<div class="line">      date = <span class="keyword">new</span> Date(date);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isDate(date) || !isFinite(date.getTime())) {</div>
<div class="line">      <span class="keywordflow">return</span> date;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (format) {</div>
<div class="line">      match = DATE_FORMATS_SPLIT.exec(format);</div>
<div class="line">      <span class="keywordflow">if</span> (match) {</div>
<div class="line">        parts = concat(parts, match, 1);</div>
<div class="line">        format = parts.pop();</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        parts.push(format);</div>
<div class="line">        format = null;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var dateTimezoneOffset = date.getTimezoneOffset();</div>
<div class="line">    <span class="keywordflow">if</span> (timezone) {</div>
<div class="line">      dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());</div>
<div class="line">      date = convertTimezoneToLocal(date, timezone, <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line">    forEach(parts, <span class="keyword">function</span>(value) {</div>
<div class="line">      fn = DATE_FORMATS[value];</div>
<div class="line">      text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset)</div>
<div class="line">                 : value.replace(/(^<span class="stringliteral">&#39;|&#39;</span>$)/g, <span class="stringliteral">&#39;&#39;</span>).replace(/<span class="stringliteral">&#39;&#39;</span>/g, <span class="stringliteral">&quot;&#39;&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> text;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> jsonFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(object, spacing) {</div>
<div class="line">    <span class="keywordflow">if</span> (isUndefined(spacing)) {</div>
<div class="line">        spacing = 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> toJson(<span class="keywordtype">object</span>, spacing);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var lowercaseFilter = valueFn(lowercase);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var uppercaseFilter = valueFn(uppercase);</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> limitToFilter() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(input, limit, begin) {</div>
<div class="line">    <span class="keywordflow">if</span> (Math.abs(Number(limit)) === Infinity) {</div>
<div class="line">      limit = Number(limit);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      limit = toInt(limit);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isNaN(limit)) <span class="keywordflow">return</span> input;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(input)) input = input.toString();</div>
<div class="line">    <span class="keywordflow">if</span> (!isArray(input) &amp;&amp; !isString(input)) <span class="keywordflow">return</span> input;</div>
<div class="line"></div>
<div class="line">    begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);</div>
<div class="line">    begin = (begin &lt; 0 &amp;&amp; begin &gt;= -input.length) ? input.length + begin : begin;</div>
<div class="line"></div>
<div class="line">    if (limit &gt;= 0) {</div>
<div class="line">      <span class="keywordflow">return</span> input.slice(begin, begin + limit);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (begin === 0) {</div>
<div class="line">        <span class="keywordflow">return</span> input.slice(limit, input.length);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> input.slice(Math.max(0, begin + limit), begin);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">orderByFilter.$inject = [<span class="stringliteral">&#39;$parse&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> orderByFilter($parse) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(array, sortPredicate, reverseOrder) {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!(isArrayLike(array))) <span class="keywordflow">return</span> array;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!isArray(sortPredicate)) { sortPredicate = [sortPredicate]; }</div>
<div class="line">    <span class="keywordflow">if</span> (sortPredicate.length === 0) { sortPredicate = [<span class="charliteral">&#39;+&#39;</span>]; }</div>
<div class="line"></div>
<div class="line">    var predicates = processPredicates(sortPredicate, reverseOrder);</div>
<div class="line">    <span class="comment">// Add a predicate at the end that evaluates to the element index. This makes the</span></div>
<div class="line">    <span class="comment">// sort stable as it works as a tie-breaker when all the input predicates cannot</span></div>
<div class="line">    <span class="comment">// distinguish between two elements.</span></div>
<div class="line">    predicates.push({ <span class="keyword">get</span>: <span class="keyword">function</span>() { <span class="keywordflow">return</span> {}; }, descending: reverseOrder ? -1 : 1});</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The next three lines are a version of a Swartzian Transform idiom from Perl</span></div>
<div class="line">    <span class="comment">// (sometimes called the Decorate-Sort-Undecorate idiom)</span></div>
<div class="line">    <span class="comment">// See https://en.wikipedia.org/wiki/Schwartzian_transform</span></div>
<div class="line">    var compareValues = Array.prototype.map.call(array, getComparisonObject);</div>
<div class="line">    compareValues.sort(doComparison);</div>
<div class="line">    array = compareValues.map(<span class="keyword">function</span>(item) { <span class="keywordflow">return</span> item.value; });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> array;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getComparisonObject(value, index) {</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        value: value,</div>
<div class="line">        predicateValues: predicates.map(<span class="keyword">function</span>(predicate) {</div>
<div class="line">          <span class="keywordflow">return</span> getPredicateValue(predicate.get(value), index);</div>
<div class="line">        })</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> doComparison(v1, v2) {</div>
<div class="line">      var result = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (var index=0, length = predicates.length; index &lt; length; ++index) {</div>
<div class="line">        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;</div>
<div class="line">        <span class="keywordflow">if</span> (result) <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> processPredicates(sortPredicate, reverseOrder) {</div>
<div class="line">    reverseOrder = reverseOrder ? -1 : 1;</div>
<div class="line">    <span class="keywordflow">return</span> sortPredicate.map(<span class="keyword">function</span>(predicate) {</div>
<div class="line">      var descending = 1, <span class="keyword">get</span> = identity;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (isFunction(predicate)) {</div>
<div class="line">        <span class="keyword">get</span> = predicate;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(predicate)) {</div>
<div class="line">        <span class="keywordflow">if</span> ((predicate.charAt(0) == <span class="charliteral">&#39;+&#39;</span> || predicate.charAt(0) == <span class="charliteral">&#39;-&#39;</span>)) {</div>
<div class="line">          descending = predicate.charAt(0) == <span class="charliteral">&#39;-&#39;</span> ? -1 : 1;</div>
<div class="line">          predicate = predicate.substring(1);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (predicate !== <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          <span class="keyword">get</span> = $parse(predicate);</div>
<div class="line">          <span class="keywordflow">if</span> (<span class="keyword">get</span>.constant) {</div>
<div class="line">            var key = <span class="keyword">get</span>();</div>
<div class="line">            <span class="keyword">get</span> = <span class="keyword">function</span>(value) { <span class="keywordflow">return</span> value[key]; };</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> { <span class="keyword">get</span>: <span class="keyword">get</span>, descending: descending * reverseOrder };</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> isPrimitive(value) {</div>
<div class="line">    <span class="keywordflow">switch</span> (typeof value) {</div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;number&#39;</span>: <span class="comment">/* falls through */</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;boolean&#39;</span>: <span class="comment">/* falls through */</span></div>
<div class="line">      <span class="keywordflow">case</span> <span class="stringliteral">&#39;string&#39;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> objectValue(value, index) {</div>
<div class="line">    <span class="comment">// If `valueOf` is a valid function use that</span></div>
<div class="line">    <span class="keywordflow">if</span> (typeof value.valueOf === <span class="stringliteral">&#39;function&#39;</span>) {</div>
<div class="line">      value = value.valueOf();</div>
<div class="line">      <span class="keywordflow">if</span> (isPrimitive(value)) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// If `toString` is a valid function and not the one from `Object.prototype` use that</span></div>
<div class="line">    <span class="keywordflow">if</span> (hasCustomToString(value)) {</div>
<div class="line">      value = value.toString();</div>
<div class="line">      <span class="keywordflow">if</span> (isPrimitive(value)) <span class="keywordflow">return</span> value;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// We have a basic object so we use the position of the object in the collection</span></div>
<div class="line">    <span class="keywordflow">return</span> index;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> getPredicateValue(value, index) {</div>
<div class="line">    var type = typeof value;</div>
<div class="line">    <span class="keywordflow">if</span> (value === null) {</div>
<div class="line">      type = <span class="stringliteral">&#39;string&#39;</span>;</div>
<div class="line">      value = <span class="stringliteral">&#39;null&#39;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">      value = value.toLowerCase();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type === <span class="stringliteral">&#39;object&#39;</span>) {</div>
<div class="line">      value = objectValue(value, index);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> { value: value, type: type };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> compare(v1, v2) {</div>
<div class="line">    var result = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (v1.type === v2.type) {</div>
<div class="line">      <span class="keywordflow">if</span> (v1.value !== v2.value) {</div>
<div class="line">        result = v1.value &lt; v2.value ? -1 : 1;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      result = v1.type &lt; v2.type ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> ngDirective(directive) {</div>
<div class="line">  <span class="keywordflow">if</span> (isFunction(directive)) {</div>
<div class="line">    directive = {</div>
<div class="line">      link: directive</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">  directive.restrict = directive.restrict || <span class="stringliteral">&#39;AC&#39;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> valueFn(directive);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var htmlAnchorDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">  compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">    <span class="keywordflow">if</span> (!attr.href &amp;&amp; !attr.xlinkHref) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element) {</div>
<div class="line">        <span class="comment">// If the linked element is not an anchor tag anymore, do nothing</span></div>
<div class="line">        <span class="keywordflow">if</span> (element[0].nodeName.toLowerCase() !== <span class="charliteral">&#39;a&#39;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// SVGAElement does not use the href attribute, but rather the &#39;xlinkHref&#39; attribute.</span></div>
<div class="line">        var href = toString.call(element.prop(<span class="stringliteral">&#39;href&#39;</span>)) === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span> ?</div>
<div class="line">                   <span class="stringliteral">&#39;xlink:href&#39;</span> : <span class="stringliteral">&#39;href&#39;</span>;</div>
<div class="line">        element.on(<span class="stringliteral">&#39;click&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">          <span class="comment">// if we have no href url, then don&#39;t navigate anywhere.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!element.attr(href)) {</div>
<div class="line">            event.preventDefault();</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngAttributeAliasDirectives = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// boolean attrs are evaluated</span></div>
<div class="line">forEach(BOOLEAN_ATTR, <span class="keyword">function</span>(propName, attrName) {</div>
<div class="line">  <span class="comment">// binding to multiple is not supported</span></div>
<div class="line">  <span class="keywordflow">if</span> (propName == <span class="stringliteral">&quot;multiple&quot;</span>) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> defaultLinkFn(scope, element, attr) {</div>
<div class="line">    scope.$watch(attr[normalized], <span class="keyword">function</span> ngBooleanAttrWatchAction(value) {</div>
<div class="line">      attr.$set(attrName, !!value);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var normalized = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + attrName);</div>
<div class="line">  var linkFn = defaultLinkFn;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (propName === <span class="stringliteral">&#39;checked&#39;</span>) {</div>
<div class="line">    linkFn = <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      <span class="comment">// ensuring ngChecked doesn&#39;t interfere with ngModel when both are set on the same input</span></div>
<div class="line">      <span class="keywordflow">if</span> (attr.ngModel !== attr[normalized]) {</div>
<div class="line">        defaultLinkFn(scope, element, attr);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  ngAttributeAliasDirectives[normalized] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">      priority: 100,</div>
<div class="line">      link: linkFn</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// aliased input attrs are evaluated</span></div>
<div class="line">forEach(ALIASED_ATTR, <span class="keyword">function</span>(htmlAttr, ngAttr) {</div>
<div class="line">  ngAttributeAliasDirectives[ngAttr] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      priority: 100,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        <span class="comment">//special case ngPattern when a literal regular expression value</span></div>
<div class="line">        <span class="comment">//is used as the expression (this way we don&#39;t have to watch anything).</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngAttr === <span class="stringliteral">&quot;ngPattern&quot;</span> &amp;&amp; attr.ngPattern.charAt(0) == <span class="stringliteral">&quot;/&quot;</span>) {</div>
<div class="line">          var match = attr.ngPattern.match(REGEX_STRING_REGEXP);</div>
<div class="line">          <span class="keywordflow">if</span> (match) {</div>
<div class="line">            attr.$set(<span class="stringliteral">&quot;ngPattern&quot;</span>, <span class="keyword">new</span> RegExp(match[1], match[2]));</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        scope.$watch(attr[ngAttr], <span class="keyword">function</span> ngAttrAliasWatchAction(value) {</div>
<div class="line">          attr.$set(ngAttr, value);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// ng-src, ng-srcset, ng-href are interpolated</span></div>
<div class="line">forEach([<span class="stringliteral">&#39;src&#39;</span>, <span class="stringliteral">&#39;srcset&#39;</span>, <span class="stringliteral">&#39;href&#39;</span>], <span class="keyword">function</span>(attrName) {</div>
<div class="line">  var normalized = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + attrName);</div>
<div class="line">  ngAttributeAliasDirectives[normalized] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      priority: 99, <span class="comment">// it needs to run after the attributes are interpolated</span></div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        var propName = attrName,</div>
<div class="line">            name = attrName;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (attrName === <span class="stringliteral">&#39;href&#39;</span> &amp;&amp;</div>
<div class="line">            toString.call(element.prop(<span class="stringliteral">&#39;href&#39;</span>)) === <span class="stringliteral">&#39;[object SVGAnimatedString]&#39;</span>) {</div>
<div class="line">          name = <span class="stringliteral">&#39;xlinkHref&#39;</span>;</div>
<div class="line">          attr.$attr[name] = <span class="stringliteral">&#39;xlink:href&#39;</span>;</div>
<div class="line">          propName = null;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        attr.$observe(normalized, <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">if</span> (!value) {</div>
<div class="line">            <span class="keywordflow">if</span> (attrName === <span class="stringliteral">&#39;href&#39;</span>) {</div>
<div class="line">              attr.$set(name, null);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          attr.$set(name, value);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// on IE, if &quot;ng:src&quot; directive declaration is used and &quot;src&quot; attribute doesn&#39;t exist</span></div>
<div class="line">          <span class="comment">// then calling element.setAttribute(&#39;src&#39;, &#39;foo&#39;) doesn&#39;t do anything, so we need</span></div>
<div class="line">          <span class="comment">// to set the property as well to achieve the desired effect.</span></div>
<div class="line">          <span class="comment">// we use attr[attrName] value since $set can sanitize the url.</span></div>
<div class="line">          <span class="keywordflow">if</span> (msie &amp;&amp; propName) element.prop(propName, attr[name]);</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">var nullFormCtrl = {</div>
<div class="line">  $addControl: noop,</div>
<div class="line">  $$renameControl: nullFormRenameControl,</div>
<div class="line">  $removeControl: noop,</div>
<div class="line">  $setValidity: noop,</div>
<div class="line">  $setDirty: noop,</div>
<div class="line">  $setPristine: noop,</div>
<div class="line">  $setSubmitted: noop</div>
<div class="line">},</div>
<div class="line">SUBMITTED_CLASS = <span class="stringliteral">&#39;ng-submitted&#39;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> nullFormRenameControl(control, name) {</div>
<div class="line">  control.$name = name;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//asks for $scope to fool the BC controller module</span></div>
<div class="line">FormController.$inject = [<span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>];</div>
<div class="line"><span class="keyword">function</span> FormController(element, attrs, $scope, $animate, $interpolate) {</div>
<div class="line">  var form = <span class="keyword">this</span>,</div>
<div class="line">      controls = [];</div>
<div class="line"></div>
<div class="line">  var parentForm = form.$$parentForm = element.parent().controller(<span class="stringliteral">&#39;form&#39;</span>) || nullFormCtrl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// init state</span></div>
<div class="line">  form.$error = {};</div>
<div class="line">  form.$$success = {};</div>
<div class="line">  form.$pending = undefined;</div>
<div class="line">  form.$name = $interpolate(attrs.name || attrs.ngForm || <span class="stringliteral">&#39;&#39;</span>)($scope);</div>
<div class="line">  form.$dirty = <span class="keyword">false</span>;</div>
<div class="line">  form.$pristine = <span class="keyword">true</span>;</div>
<div class="line">  form.$valid = <span class="keyword">true</span>;</div>
<div class="line">  form.$invalid = <span class="keyword">false</span>;</div>
<div class="line">  form.$submitted = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">  parentForm.$addControl(form);</div>
<div class="line"></div>
<div class="line">  form.$rollbackViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$rollbackViewValue();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$commitViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$commitViewValue();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$addControl = <span class="keyword">function</span>(control) {</div>
<div class="line">    <span class="comment">// Breaking change - before, inputs whose name was &quot;hasOwnProperty&quot; were quietly ignored</span></div>
<div class="line">    <span class="comment">// and not added to the scope.  Now we throw an error.</span></div>
<div class="line">    assertNotHasOwnProperty(control.$name, <span class="stringliteral">&#39;input&#39;</span>);</div>
<div class="line">    controls.push(control);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (control.$name) {</div>
<div class="line">      form[control.$name] = control;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Private API: rename a form control</span></div>
<div class="line">  form.$$renameControl = <span class="keyword">function</span>(control, newName) {</div>
<div class="line">    var oldName = control.$name;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (form[oldName] === control) {</div>
<div class="line">      <span class="keyword">delete</span> form[oldName];</div>
<div class="line">    }</div>
<div class="line">    form[newName] = control;</div>
<div class="line">    control.$name = newName;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$removeControl = <span class="keyword">function</span>(control) {</div>
<div class="line">    <span class="keywordflow">if</span> (control.$name &amp;&amp; form[control.$name] === control) {</div>
<div class="line">      <span class="keyword">delete</span> form[control.$name];</div>
<div class="line">    }</div>
<div class="line">    forEach(form.$pending, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line">    forEach(form.$error, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line">    forEach(form.$$success, <span class="keyword">function</span>(value, name) {</div>
<div class="line">      form.$setValidity(name, null, control);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    arrayRemove(controls, control);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  addSetValidityMethod({</div>
<div class="line">    ctrl: <span class="keyword">this</span>,</div>
<div class="line">    $element: element,</div>
<div class="line">    set: <span class="keyword">function</span>(object, property, controller) {</div>
<div class="line">      var list = <span class="keywordtype">object</span>[property];</div>
<div class="line">      <span class="keywordflow">if</span> (!list) {</div>
<div class="line">        <span class="keywordtype">object</span>[property] = [controller];</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        var index = list.indexOf(controller);</div>
<div class="line">        <span class="keywordflow">if</span> (index === -1) {</div>
<div class="line">          list.push(controller);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    unset: <span class="keyword">function</span>(object, property, controller) {</div>
<div class="line">      var list = <span class="keywordtype">object</span>[property];</div>
<div class="line">      <span class="keywordflow">if</span> (!list) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      arrayRemove(list, controller);</div>
<div class="line">      <span class="keywordflow">if</span> (list.length === 0) {</div>
<div class="line">        <span class="keyword">delete</span> <span class="keywordtype">object</span>[property];</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    parentForm: parentForm,</div>
<div class="line">    $animate: $animate</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  form.$setDirty = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.removeClass(element, PRISTINE_CLASS);</div>
<div class="line">    $animate.addClass(element, DIRTY_CLASS);</div>
<div class="line">    form.$dirty = <span class="keyword">true</span>;</div>
<div class="line">    form.$pristine = <span class="keyword">false</span>;</div>
<div class="line">    parentForm.$setDirty();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setPristine = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + <span class="charliteral">&#39; &#39;</span> + SUBMITTED_CLASS);</div>
<div class="line">    form.$dirty = <span class="keyword">false</span>;</div>
<div class="line">    form.$pristine = <span class="keyword">true</span>;</div>
<div class="line">    form.$submitted = <span class="keyword">false</span>;</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$setPristine();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setUntouched = <span class="keyword">function</span>() {</div>
<div class="line">    forEach(controls, <span class="keyword">function</span>(control) {</div>
<div class="line">      control.$setUntouched();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  form.$setSubmitted = <span class="keyword">function</span>() {</div>
<div class="line">    $animate.addClass(element, SUBMITTED_CLASS);</div>
<div class="line">    form.$submitted = <span class="keyword">true</span>;</div>
<div class="line">    parentForm.$setSubmitted();</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var formDirectiveFactory = <span class="keyword">function</span>(isNgForm) {</div>
<div class="line">  <span class="keywordflow">return</span> [<span class="stringliteral">&#39;$timeout&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="keyword">function</span>($timeout, $parse) {</div>
<div class="line">    var formDirective = {</div>
<div class="line">      name: <span class="stringliteral">&#39;form&#39;</span>,</div>
<div class="line">      restrict: isNgForm ? <span class="stringliteral">&#39;EAC&#39;</span> : <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">      controller: FormController,</div>
<div class="line">      compile: <span class="keyword">function</span> ngFormCompile(formElement, attr) {</div>
<div class="line">        <span class="comment">// Setup initial state of the control</span></div>
<div class="line">        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);</div>
<div class="line"></div>
<div class="line">        var nameAttr = attr.name ? <span class="stringliteral">&#39;name&#39;</span> : (isNgForm &amp;&amp; attr.ngForm ? <span class="stringliteral">&#39;ngForm&#39;</span> : <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">          pre: <span class="keyword">function</span> ngFormPreLink(scope, formElement, attr, controller) {</div>
<div class="line">            <span class="comment">// if `action` attr is not present on the form, prevent the default action (submission)</span></div>
<div class="line">            <span class="keywordflow">if</span> (!(<span class="stringliteral">&#39;action&#39;</span> in attr)) {</div>
<div class="line">              <span class="comment">// we can&#39;t use jq events because if a form is destroyed during submission the default</span></div>
<div class="line">              <span class="comment">// action is not prevented. see #1238</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// IE 9 is not affected because it doesn&#39;t fire a submit event and try to do a full</span></div>
<div class="line">              <span class="comment">// page reload if the form was destroyed by submission of the form via a click handler</span></div>
<div class="line">              <span class="comment">// on a button in the form. Looks like an IE9 specific bug.</span></div>
<div class="line">              var handleFormSubmission = <span class="keyword">function</span>(event) {</div>
<div class="line">                scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">                  controller.$commitViewValue();</div>
<div class="line">                  controller.$setSubmitted();</div>
<div class="line">                });</div>
<div class="line"></div>
<div class="line">                event.preventDefault();</div>
<div class="line">              };</div>
<div class="line"></div>
<div class="line">              addEventListenerFn(formElement[0], <span class="stringliteral">&#39;submit&#39;</span>, handleFormSubmission);</div>
<div class="line"></div>
<div class="line">              <span class="comment">// unregister the preventDefault listener so that we don&#39;t not leak memory but in a</span></div>
<div class="line">              <span class="comment">// way that will achieve the prevention of the default action.</span></div>
<div class="line">              formElement.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">                $timeout(<span class="keyword">function</span>() {</div>
<div class="line">                  removeEventListenerFn(formElement[0], <span class="stringliteral">&#39;submit&#39;</span>, handleFormSubmission);</div>
<div class="line">                }, 0, <span class="keyword">false</span>);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            var parentFormCtrl = controller.$$parentForm;</div>
<div class="line">            var setter = nameAttr ? getSetter(controller.$name) : noop;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (nameAttr) {</div>
<div class="line">              setter(scope, controller);</div>
<div class="line">              attr.$observe(nameAttr, <span class="keyword">function</span>(newValue) {</div>
<div class="line">                <span class="keywordflow">if</span> (controller.$name === newValue) <span class="keywordflow">return</span>;</div>
<div class="line">                setter(scope, undefined);</div>
<div class="line">                parentFormCtrl.$$renameControl(controller, newValue);</div>
<div class="line">                setter = getSetter(controller.$name);</div>
<div class="line">                setter(scope, controller);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">            formElement.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">              parentFormCtrl.$removeControl(controller);</div>
<div class="line">              setter(scope, undefined);</div>
<div class="line">              extend(controller, nullFormCtrl); <span class="comment">//stop propagating child destruction handlers upwards</span></div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> formDirective;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getSetter(expression) {</div>
<div class="line">      <span class="keywordflow">if</span> (expression === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">        <span class="comment">//create an assignable expression, so forms with an empty name can be renamed later</span></div>
<div class="line">        <span class="keywordflow">return</span> $parse(<span class="stringliteral">&#39;this[&quot;&quot;]&#39;</span>).assign;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> $parse(expression).assign || noop;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var formDirective = formDirectiveFactory();</div>
<div class="line">var ngFormDirective = formDirectiveFactory(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global VALID_CLASS: false,</span></div>
<div class="line"><span class="comment">  INVALID_CLASS: false,</span></div>
<div class="line"><span class="comment">  PRISTINE_CLASS: false,</span></div>
<div class="line"><span class="comment">  DIRTY_CLASS: false,</span></div>
<div class="line"><span class="comment">  UNTOUCHED_CLASS: false,</span></div>
<div class="line"><span class="comment">  TOUCHED_CLASS: false,</span></div>
<div class="line"><span class="comment">  ngModelMinErr: false,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Regex code is obtained from SO: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231</span></div>
<div class="line">var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;</div>
<div class="line">var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/;</div>
<div class="line">var EMAIL_REGEXP = /^[a-z0-9!#$%&amp;<span class="stringliteral">&#39;*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;</span></div>
<div class="line"><span class="stringliteral">var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;</span></div>
<div class="line"><span class="stringliteral">var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;</span></div>
<div class="line"><span class="stringliteral">var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;</span></div>
<div class="line"><span class="stringliteral">var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;</span></div>
<div class="line"><span class="stringliteral">var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;</span></div>
<div class="line"><span class="stringliteral">var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">var inputType = {</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>text<span class="stringliteral">&#39;: textInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>date<span class="stringliteral">&#39;: createDateInputType(&#39;</span>date<span class="stringliteral">&#39;, DATE_REGEXP,</span></div>
<div class="line"><span class="stringliteral">         createDateParser(DATE_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;, &#39;</span>dd<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">         &#39;</span>yyyy-MM-dd<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>datetime-local<span class="stringliteral">&#39;: createDateInputType(&#39;</span>datetimelocal<span class="stringliteral">&#39;, DATETIMELOCAL_REGEXP,</span></div>
<div class="line"><span class="stringliteral">      createDateParser(DATETIMELOCAL_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;, &#39;</span>dd<span class="stringliteral">&#39;, &#39;</span>HH<span class="stringliteral">&#39;, &#39;</span>mm<span class="stringliteral">&#39;, &#39;</span>ss<span class="stringliteral">&#39;, &#39;</span>sss<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">      &#39;</span>yyyy-MM-ddTHH:mm:ss.sss<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>time<span class="stringliteral">&#39;: createDateInputType(&#39;</span>time<span class="stringliteral">&#39;, TIME_REGEXP,</span></div>
<div class="line"><span class="stringliteral">      createDateParser(TIME_REGEXP, [&#39;</span>HH<span class="stringliteral">&#39;, &#39;</span>mm<span class="stringliteral">&#39;, &#39;</span>ss<span class="stringliteral">&#39;, &#39;</span>sss<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">     &#39;</span>HH:mm:ss.sss<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>week<span class="stringliteral">&#39;: createDateInputType(&#39;</span>week<span class="stringliteral">&#39;, WEEK_REGEXP, weekParser, &#39;</span>yyyy-Www<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>month<span class="stringliteral">&#39;: createDateInputType(&#39;</span>month<span class="stringliteral">&#39;, MONTH_REGEXP,</span></div>
<div class="line"><span class="stringliteral">     createDateParser(MONTH_REGEXP, [&#39;</span>yyyy<span class="stringliteral">&#39;, &#39;</span>MM<span class="stringliteral">&#39;]),</span></div>
<div class="line"><span class="stringliteral">     &#39;</span>yyyy-MM<span class="stringliteral">&#39;),</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>number<span class="stringliteral">&#39;: numberInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>url<span class="stringliteral">&#39;: urlInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>email<span class="stringliteral">&#39;: emailInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>radio<span class="stringliteral">&#39;: radioInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>checkbox<span class="stringliteral">&#39;: checkboxInputType,</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  &#39;</span>hidden<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>button<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>submit<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>reset<span class="stringliteral">&#39;: noop,</span></div>
<div class="line"><span class="stringliteral">  &#39;</span>file<span class="stringliteral">&#39;: noop</span></div>
<div class="line"><span class="stringliteral">};</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function stringBasedInputType(ctrl) {</span></div>
<div class="line"><span class="stringliteral">  ctrl.$formatters.push(function(value) {</span></div>
<div class="line"><span class="stringliteral">    return ctrl.$isEmpty(value) ? value : value.toString();</span></div>
<div class="line"><span class="stringliteral">  });</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {</span></div>
<div class="line"><span class="stringliteral">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</span></div>
<div class="line"><span class="stringliteral">  stringBasedInputType(ctrl);</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {</span></div>
<div class="line"><span class="stringliteral">  var type = lowercase(element[0].type);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  // In composition mode, users are still inputing intermediate text buffer,</span></div>
<div class="line"><span class="stringliteral">  // hold the listener until composition is done.</span></div>
<div class="line"><span class="stringliteral">  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent</span></div>
<div class="line"><span class="stringliteral">  if (!$sniffer.android) {</span></div>
<div class="line"><span class="stringliteral">    var composing = false;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    element.on(&#39;</span>compositionstart<span class="stringliteral">&#39;, function(data) {</span></div>
<div class="line"><span class="stringliteral">      composing = true;</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    element.on(&#39;</span>compositionend<span class="stringliteral">&#39;, function() {</span></div>
<div class="line"><span class="stringliteral">      composing = false;</span></div>
<div class="line"><span class="stringliteral">      listener();</span></div>
<div class="line"><span class="stringliteral">    });</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">  var listener = function(ev) {</span></div>
<div class="line"><span class="stringliteral">    if (timeout) {</span></div>
<div class="line"><span class="stringliteral">      $browser.defer.cancel(timeout);</span></div>
<div class="line"><span class="stringliteral">      timeout = null;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">    if (composing) return;</span></div>
<div class="line"><span class="stringliteral">    var value = element.val(),</span></div>
<div class="line"><span class="stringliteral">        event = ev &amp;&amp; ev.type;</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // By default we will trim the value</span></div>
<div class="line"><span class="stringliteral">    // If the attribute ng-trim exists we will avoid trimming</span></div>
<div class="line"><span class="stringliteral">    // If input type is &#39;</span>password<span class="stringliteral">&#39;, the value is never trimmed</span></div>
<div class="line"><span class="stringliteral">    if (type !== &#39;</span>password<span class="stringliteral">&#39; &amp;&amp; (!attr.ngTrim || attr.ngTrim !== &#39;</span><span class="keyword">false</span><span class="stringliteral">&#39;)) {</span></div>
<div class="line"><span class="stringliteral">      value = trim(value);</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    // If a control is suffering from bad input (due to native validators), browsers discard its</span></div>
<div class="line"><span class="stringliteral">    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the</span></div>
<div class="line"><span class="stringliteral">    // control&#39;</span>s value is the same empty value twice in a row.</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$viewValue !== value || (value === <span class="stringliteral">&#39;&#39;</span> &amp;&amp; ctrl.$$hasNativeValidators)) {</div>
<div class="line">      ctrl.$setViewValue(value, event);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if the browser does support &quot;input&quot; event, we are fine - except on IE9 which doesn&#39;t fire the</span></div>
<div class="line">  <span class="comment">// input event on backspace, delete or cut</span></div>
<div class="line">  <span class="keywordflow">if</span> ($sniffer.hasEvent(<span class="stringliteral">&#39;input&#39;</span>)) {</div>
<div class="line">    element.on(<span class="stringliteral">&#39;input&#39;</span>, listener);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    var timeout;</div>
<div class="line"></div>
<div class="line">    var deferListener = <span class="keyword">function</span>(ev, input, origValue) {</div>
<div class="line">      <span class="keywordflow">if</span> (!timeout) {</div>
<div class="line">        timeout = $browser.defer(<span class="keyword">function</span>() {</div>
<div class="line">          timeout = null;</div>
<div class="line">          <span class="keywordflow">if</span> (!input || input.value !== origValue) {</div>
<div class="line">            listener(ev);</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    element.on(<span class="stringliteral">&#39;keydown&#39;</span>, <span class="keyword">function</span>(event) {</div>
<div class="line">      var key = event.keyCode;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// ignore</span></div>
<div class="line">      <span class="comment">//    command            modifiers                   arrows</span></div>
<div class="line">      <span class="keywordflow">if</span> (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      deferListener(event, <span class="keyword">this</span>, this.value);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if user modifies input value using context menu in IE, we need &quot;paste&quot; and &quot;cut&quot; events to catch it</span></div>
<div class="line">    <span class="keywordflow">if</span> ($sniffer.hasEvent(<span class="stringliteral">&#39;paste&#39;</span>)) {</div>
<div class="line">      element.on(<span class="stringliteral">&#39;paste cut&#39;</span>, deferListener);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if user paste into input using mouse on older browser</span></div>
<div class="line">  <span class="comment">// or form autocomplete on newer browser, we need &quot;change&quot; event to catch it</span></div>
<div class="line">  element.on(<span class="stringliteral">&#39;change&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// Workaround for Firefox validation #12102.</span></div>
<div class="line">    var value = ctrl.$isEmpty(ctrl.$viewValue) ? <span class="stringliteral">&#39;&#39;</span> : ctrl.$viewValue;</div>
<div class="line">    <span class="keywordflow">if</span> (element.val() !== value) {</div>
<div class="line">      element.val(value);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> weekParser(isoWeek, existingDate) {</div>
<div class="line">  <span class="keywordflow">if</span> (isDate(isoWeek)) {</div>
<div class="line">    <span class="keywordflow">return</span> isoWeek;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isString(isoWeek)) {</div>
<div class="line">    WEEK_REGEXP.lastIndex = 0;</div>
<div class="line">    var parts = WEEK_REGEXP.exec(isoWeek);</div>
<div class="line">    <span class="keywordflow">if</span> (parts) {</div>
<div class="line">      var year = +parts[1],</div>
<div class="line">          week = +parts[2],</div>
<div class="line">          hours = 0,</div>
<div class="line">          minutes = 0,</div>
<div class="line">          seconds = 0,</div>
<div class="line">          milliseconds = 0,</div>
<div class="line">          firstThurs = getFirstThursdayOfYear(year),</div>
<div class="line">          addDays = (week - 1) * 7;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (existingDate) {</div>
<div class="line">        hours = existingDate.getHours();</div>
<div class="line">        minutes = existingDate.getMinutes();</div>
<div class="line">        seconds = existingDate.getSeconds();</div>
<div class="line">        milliseconds = existingDate.getMilliseconds();</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">new</span> Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> NaN;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createDateParser(regexp, mapping) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(iso, date) {</div>
<div class="line">    var parts, map;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDate(iso)) {</div>
<div class="line">      <span class="keywordflow">return</span> iso;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isString(iso)) {</div>
<div class="line">      <span class="comment">// When a date is JSON&#39;ified to wraps itself inside of an extra</span></div>
<div class="line">      <span class="comment">// set of double quotes. This makes the date parsing code unable</span></div>
<div class="line">      <span class="comment">// to match the date string and parse it as a date.</span></div>
<div class="line">      <span class="keywordflow">if</span> (iso.charAt(0) == <span class="charliteral">&#39;&quot;&#39;</span> &amp;&amp; iso.charAt(iso.length - 1) == <span class="charliteral">&#39;&quot;&#39;</span>) {</div>
<div class="line">        iso = iso.substring(1, iso.length - 1);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ISO_DATE_REGEXP.test(iso)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Date(iso);</div>
<div class="line">      }</div>
<div class="line">      regexp.lastIndex = 0;</div>
<div class="line">      parts = regexp.exec(iso);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (parts) {</div>
<div class="line">        parts.shift();</div>
<div class="line">        <span class="keywordflow">if</span> (date) {</div>
<div class="line">          map = {</div>
<div class="line">            yyyy: date.getFullYear(),</div>
<div class="line">            MM: date.getMonth() + 1,</div>
<div class="line">            dd: date.getDate(),</div>
<div class="line">            HH: date.getHours(),</div>
<div class="line">            mm: date.getMinutes(),</div>
<div class="line">            ss: date.getSeconds(),</div>
<div class="line">            sss: date.getMilliseconds() / 1000</div>
<div class="line">          };</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        forEach(parts, <span class="keyword">function</span>(part, index) {</div>
<div class="line">          <span class="keywordflow">if</span> (index &lt; mapping.length) {</div>
<div class="line">            map[mapping[index]] = +part;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> NaN;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> createDateInputType(type, regexp, parseDate, format) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span> dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {</div>
<div class="line">    badInputChecker(scope, element, attr, ctrl);</div>
<div class="line">    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">    var timezone = ctrl &amp;&amp; ctrl.$options &amp;&amp; ctrl.$options.timezone;</div>
<div class="line">    var previousDate;</div>
<div class="line"></div>
<div class="line">    ctrl.$$parserName = type;</div>
<div class="line">    ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$isEmpty(value)) <span class="keywordflow">return</span> null;</div>
<div class="line">      <span class="keywordflow">if</span> (regexp.test(value)) {</div>
<div class="line">        <span class="comment">// Note: We cannot read ctrl.$modelValue, as there might be a different</span></div>
<div class="line">        <span class="comment">// parser/formatter in the processing chain so that the model</span></div>
<div class="line">        <span class="comment">// contains some different data format!</span></div>
<div class="line">        var parsedDate = parseDate(value, previousDate);</div>
<div class="line">        <span class="keywordflow">if</span> (timezone) {</div>
<div class="line">          parsedDate = convertTimezoneToLocal(parsedDate, timezone);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> parsedDate;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> undefined;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">if</span> (value &amp;&amp; !isDate(value)) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;datefmt&#39;</span>, <span class="stringliteral">&#39;Expected `{0}` to be a date&#39;</span>, value);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (isValidDate(value)) {</div>
<div class="line">        previousDate = value;</div>
<div class="line">        <span class="keywordflow">if</span> (previousDate &amp;&amp; timezone) {</div>
<div class="line">          previousDate = convertTimezoneToLocal(previousDate, timezone, <span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> $filter(<span class="stringliteral">&#39;date&#39;</span>)(value, format, timezone);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        previousDate = null;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(attr.min) || attr.ngMin) {</div>
<div class="line">      var minVal;</div>
<div class="line">      ctrl.$validators.min = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !isValidDate(value) || isUndefined(minVal) || parseDate(value) &gt;= minVal;</div>
<div class="line">      };</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;min&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">        minVal = parseObservedDateValue(val);</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (isDefined(attr.max) || attr.ngMax) {</div>
<div class="line">      var maxVal;</div>
<div class="line">      ctrl.$validators.max = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !isValidDate(value) || isUndefined(maxVal) || parseDate(value) &lt;= maxVal;</div>
<div class="line">      };</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;max&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">        maxVal = parseObservedDateValue(val);</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> isValidDate(value) {</div>
<div class="line">      <span class="comment">// Invalid Date: getTime() returns NaN</span></div>
<div class="line">      <span class="keywordflow">return</span> value &amp;&amp; !(value.getTime &amp;&amp; value.getTime() !== value.getTime());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> parseObservedDateValue(val) {</div>
<div class="line">      <span class="keywordflow">return</span> isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> badInputChecker(scope, element, attr, ctrl) {</div>
<div class="line">  var node = element[0];</div>
<div class="line">  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);</div>
<div class="line">  <span class="keywordflow">if</span> (nativeValidation) {</div>
<div class="line">    ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">      var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};</div>
<div class="line">      <span class="comment">// Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):</span></div>
<div class="line">      <span class="comment">// - also sets validity.badInput (should only be validity.typeMismatch).</span></div>
<div class="line">      <span class="comment">// - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)</span></div>
<div class="line">      <span class="comment">// - can ignore this case as we can still read out the erroneous email...</span></div>
<div class="line">      <span class="keywordflow">return</span> validity.badInput &amp;&amp; !validity.typeMismatch ? undefined : value;</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  badInputChecker(scope, element, attr, ctrl);</div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;number&#39;</span>;</div>
<div class="line">  ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$isEmpty(value))      <span class="keywordflow">return</span> null;</div>
<div class="line">    <span class="keywordflow">if</span> (NUMBER_REGEXP.test(value)) <span class="keywordflow">return</span> parseFloat(value);</div>
<div class="line">    <span class="keywordflow">return</span> undefined;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl.$isEmpty(value)) {</div>
<div class="line">      <span class="keywordflow">if</span> (!isNumber(value)) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;numfmt&#39;</span>, <span class="stringliteral">&#39;Expected `{0}` to be a number&#39;</span>, value);</div>
<div class="line">      }</div>
<div class="line">      value = value.toString();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(attr.min) || attr.ngMin) {</div>
<div class="line">    var minVal;</div>
<div class="line">    ctrl.$validators.min = <span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(minVal) || value &gt;= minVal;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    attr.$observe(<span class="stringliteral">&#39;min&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(val) &amp;&amp; !isNumber(val)) {</div>
<div class="line">        val = parseFloat(val, 10);</div>
<div class="line">      }</div>
<div class="line">      minVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;</div>
<div class="line">      <span class="comment">// TODO(matsko): implement validateLater to reduce number of validations</span></div>
<div class="line">      ctrl.$validate();</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(attr.max) || attr.ngMax) {</div>
<div class="line">    var maxVal;</div>
<div class="line">    ctrl.$validators.max = <span class="keyword">function</span>(value) {</div>
<div class="line">      <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(maxVal) || value &lt;= maxVal;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    attr.$observe(<span class="stringliteral">&#39;max&#39;</span>, <span class="keyword">function</span>(val) {</div>
<div class="line">      <span class="keywordflow">if</span> (isDefined(val) &amp;&amp; !isNumber(val)) {</div>
<div class="line">        val = parseFloat(val, 10);</div>
<div class="line">      }</div>
<div class="line">      maxVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;</div>
<div class="line">      <span class="comment">// TODO(matsko): implement validateLater to reduce number of validations</span></div>
<div class="line">      ctrl.$validate();</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  <span class="comment">// Note: no badInputChecker here by purpose as `url` is only a validation</span></div>
<div class="line">  <span class="comment">// in browsers, i.e. we can always read out input.value even if it is not valid!</span></div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">  stringBasedInputType(ctrl);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;url&#39;</span>;</div>
<div class="line">  ctrl.$validators.url = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">    var value = modelValue || viewValue;</div>
<div class="line">    <span class="keywordflow">return</span> ctrl.$isEmpty(value) || URL_REGEXP.test(value);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {</div>
<div class="line">  <span class="comment">// Note: no badInputChecker here by purpose as `url` is only a validation</span></div>
<div class="line">  <span class="comment">// in browsers, i.e. we can always read out input.value even if it is not valid!</span></div>
<div class="line">  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);</div>
<div class="line">  stringBasedInputType(ctrl);</div>
<div class="line"></div>
<div class="line">  ctrl.$$parserName = <span class="stringliteral">&#39;email&#39;</span>;</div>
<div class="line">  ctrl.$validators.email = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">    var value = modelValue || viewValue;</div>
<div class="line">    <span class="keywordflow">return</span> ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> radioInputType(scope, element, attr, ctrl) {</div>
<div class="line">  <span class="comment">// make the name unique, if not defined</span></div>
<div class="line">  <span class="keywordflow">if</span> (isUndefined(attr.name)) {</div>
<div class="line">    element.attr(<span class="stringliteral">&#39;name&#39;</span>, nextUid());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var listener = <span class="keyword">function</span>(ev) {</div>
<div class="line">    <span class="keywordflow">if</span> (element[0].checked) {</div>
<div class="line">      ctrl.$setViewValue(attr.value, ev &amp;&amp; ev.type);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  element.on(<span class="stringliteral">&#39;click&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    var value = attr.value;</div>
<div class="line">    element[0].checked = (value == ctrl.$viewValue);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  attr.$observe(<span class="stringliteral">&#39;value&#39;</span>, ctrl.$render);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> parseConstantExpr($parse, context, name, expression, fallback) {</div>
<div class="line">  var parseFn;</div>
<div class="line">  <span class="keywordflow">if</span> (isDefined(expression)) {</div>
<div class="line">    parseFn = $parse(expression);</div>
<div class="line">    <span class="keywordflow">if</span> (!parseFn.constant) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;constexpr&#39;</span>, <span class="stringliteral">&#39;Expected constant expression for `{0}`, but saw &#39;</span> +</div>
<div class="line">                                   <span class="stringliteral">&#39;`{1}`.&#39;</span>, name, expression);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> parseFn(context);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> fallback;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {</div>
<div class="line">  var trueValue = parseConstantExpr($parse, scope, <span class="stringliteral">&#39;ngTrueValue&#39;</span>, attr.ngTrueValue, <span class="keyword">true</span>);</div>
<div class="line">  var falseValue = parseConstantExpr($parse, scope, <span class="stringliteral">&#39;ngFalseValue&#39;</span>, attr.ngFalseValue, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">  var listener = <span class="keyword">function</span>(ev) {</div>
<div class="line">    ctrl.$setViewValue(element[0].checked, ev &amp;&amp; ev.type);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  element.on(<span class="stringliteral">&#39;click&#39;</span>, listener);</div>
<div class="line"></div>
<div class="line">  ctrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">    element[0].checked = ctrl.$viewValue;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`</span></div>
<div class="line">  <span class="comment">// This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert</span></div>
<div class="line">  <span class="comment">// it to a boolean.</span></div>
<div class="line">  ctrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> value === <span class="keyword">false</span>;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> equals(value, trueValue);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  ctrl.$parsers.push(<span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> value ? trueValue : falseValue;</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var inputDirective = [<span class="stringliteral">&#39;$browser&#39;</span>, <span class="stringliteral">&#39;$sniffer&#39;</span>, <span class="stringliteral">&#39;$filter&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($browser, $sniffer, $filter, $parse) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    link: {</div>
<div class="line">      pre: <span class="keyword">function</span>(scope, element, attr, ctrls) {</div>
<div class="line">        <span class="keywordflow">if</span> (ctrls[0]) {</div>
<div class="line">          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,</div>
<div class="line">                                                              $browser, $filter, $parse);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var CONSTANT_VALUE_REGEXP = /^(<span class="keyword">true</span>|<span class="keyword">false</span>|\d+)$/;</div>
<div class="line">var ngValueDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    compile: <span class="keyword">function</span>(tpl, tplAttr) {</div>
<div class="line">      <span class="keywordflow">if</span> (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> ngValueConstantLink(scope, elm, attr) {</div>
<div class="line">          attr.$set(<span class="stringliteral">&#39;value&#39;</span>, scope.$eval(attr.ngValue));</div>
<div class="line">        };</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">function</span> ngValueLink(scope, elm, attr) {</div>
<div class="line">          scope.$watch(attr.ngValue, <span class="keyword">function</span> valueWatchAction(value) {</div>
<div class="line">            attr.$set(<span class="stringliteral">&#39;value&#39;</span>, value);</div>
<div class="line">          });</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var ngBindDirective = [<span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="stringliteral">&#39;AC&#39;</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindCompile(templateElement) {</div>
<div class="line">      $compile.$$addBindingClass(templateElement);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindLink(scope, element, attr) {</div>
<div class="line">        $compile.$$addBindingInfo(element, attr.ngBind);</div>
<div class="line">        element = element[0];</div>
<div class="line">        scope.$watch(attr.ngBind, <span class="keyword">function</span> ngBindWatchAction(value) {</div>
<div class="line">          element.textContent = value === undefined ? <span class="stringliteral">&#39;&#39;</span> : value;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngBindTemplateDirective = [<span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($interpolate, $compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindTemplateCompile(templateElement) {</div>
<div class="line">      $compile.$$addBindingClass(templateElement);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindTemplateLink(scope, element, attr) {</div>
<div class="line">        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));</div>
<div class="line">        $compile.$$addBindingInfo(element, interpolateFn.expressions);</div>
<div class="line">        element = element[0];</div>
<div class="line">        attr.$observe(<span class="stringliteral">&#39;ngBindTemplate&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">          element.textContent = value === undefined ? <span class="stringliteral">&#39;&#39;</span> : value;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngBindHtmlDirective = [<span class="stringliteral">&#39;$sce&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$compile&#39;</span>, <span class="keyword">function</span>($sce, $parse, $compile) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngBindHtmlCompile(tElement, tAttrs) {</div>
<div class="line">      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);</div>
<div class="line">      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, <span class="keyword">function</span> getStringValue(value) {</div>
<div class="line">        <span class="keywordflow">return</span> (value || <span class="stringliteral">&#39;&#39;</span>).toString();</div>
<div class="line">      });</div>
<div class="line">      $compile.$$addBindingClass(tElement);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngBindHtmlLink(scope, element, attr) {</div>
<div class="line">        $compile.$$addBindingInfo(element, attr.ngBindHtml);</div>
<div class="line"></div>
<div class="line">        scope.$watch(ngBindHtmlWatch, <span class="keyword">function</span> ngBindHtmlWatchAction() {</div>
<div class="line">          <span class="comment">// we re-evaluate the expr because we want a TrustedValueHolderType</span></div>
<div class="line">          <span class="comment">// for $sce, not a string</span></div>
<div class="line">          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngChangeDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">  require: <span class="stringliteral">&#39;ngModel&#39;</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attr, ctrl) {</div>
<div class="line">    ctrl.$viewChangeListeners.push(<span class="keyword">function</span>() {</div>
<div class="line">      scope.$eval(attr.ngChange);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> classDirective(name, selector) {</div>
<div class="line">  name = <span class="stringliteral">&#39;ngClass&#39;</span> + name;</div>
<div class="line">  <span class="keywordflow">return</span> [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="stringliteral">&#39;AC&#39;</span>,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">        var oldVal;</div>
<div class="line"></div>
<div class="line">        scope.$watch(attr[name], ngClassWatchAction, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">        attr.$observe(<span class="stringliteral">&#39;class&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">          ngClassWatchAction(scope.$eval(attr[name]));</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (name !== <span class="stringliteral">&#39;ngClass&#39;</span>) {</div>
<div class="line">          scope.$watch(<span class="stringliteral">&#39;$index&#39;</span>, <span class="keyword">function</span>($index, old$index) {</div>
<div class="line">            <span class="comment">// jshint bitwise: false</span></div>
<div class="line">            var mod = $index &amp; 1;</div>
<div class="line">            <span class="keywordflow">if</span> (mod !== (old$index &amp; 1)) {</div>
<div class="line">              var classes = arrayClasses(scope.$eval(attr[name]));</div>
<div class="line">              mod === selector ?</div>
<div class="line">                addClasses(classes) :</div>
<div class="line">                removeClasses(classes);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> addClasses(classes) {</div>
<div class="line">          var newClasses = digestClassCounts(classes, 1);</div>
<div class="line">          attr.$addClass(newClasses);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> removeClasses(classes) {</div>
<div class="line">          var newClasses = digestClassCounts(classes, -1);</div>
<div class="line">          attr.$removeClass(newClasses);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> digestClassCounts(classes, count) {</div>
<div class="line">          <span class="comment">// Use createMap() to prevent class assumptions involving property</span></div>
<div class="line">          <span class="comment">// names in Object.prototype</span></div>
<div class="line">          var classCounts = element.data(<span class="stringliteral">&#39;$classCounts&#39;</span>) || createMap();</div>
<div class="line">          var classesToUpdate = [];</div>
<div class="line">          forEach(classes, <span class="keyword">function</span>(className) {</div>
<div class="line">            <span class="keywordflow">if</span> (count &gt; 0 || classCounts[className]) {</div>
<div class="line">              classCounts[className] = (classCounts[className] || 0) + count;</div>
<div class="line">              <span class="keywordflow">if</span> (classCounts[className] === +(count &gt; 0)) {</div>
<div class="line">                classesToUpdate.push(className);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          element.data(<span class="stringliteral">&#39;$classCounts&#39;</span>, classCounts);</div>
<div class="line">          <span class="keywordflow">return</span> classesToUpdate.join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> updateClasses(oldClasses, newClasses) {</div>
<div class="line">          var toAdd = arrayDifference(newClasses, oldClasses);</div>
<div class="line">          var toRemove = arrayDifference(oldClasses, newClasses);</div>
<div class="line">          toAdd = digestClassCounts(toAdd, 1);</div>
<div class="line">          toRemove = digestClassCounts(toRemove, -1);</div>
<div class="line">          <span class="keywordflow">if</span> (toAdd &amp;&amp; toAdd.length) {</div>
<div class="line">            $animate.addClass(element, toAdd);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (toRemove &amp;&amp; toRemove.length) {</div>
<div class="line">            $animate.removeClass(element, toRemove);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">function</span> ngClassWatchAction(newVal) {</div>
<div class="line">          <span class="keywordflow">if</span> (selector === <span class="keyword">true</span> || scope.$index % 2 === selector) {</div>
<div class="line">            var newClasses = arrayClasses(newVal || []);</div>
<div class="line">            <span class="keywordflow">if</span> (!oldVal) {</div>
<div class="line">              addClasses(newClasses);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!equals(newVal,oldVal)) {</div>
<div class="line">              var oldClasses = arrayClasses(oldVal);</div>
<div class="line">              updateClasses(oldClasses, newClasses);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          oldVal = shallowCopy(newVal);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> arrayDifference(tokens1, tokens2) {</div>
<div class="line">      var values = [];</div>
<div class="line"></div>
<div class="line">      outer:</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; tokens1.length; i++) {</div>
<div class="line">        var token = tokens1[i];</div>
<div class="line">        <span class="keywordflow">for</span> (var j = 0; j &lt; tokens2.length; j++) {</div>
<div class="line">          <span class="keywordflow">if</span> (token == tokens2[j]) <span class="keywordflow">continue</span> outer;</div>
<div class="line">        }</div>
<div class="line">        values.push(token);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> values;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> arrayClasses(classVal) {</div>
<div class="line">      var classes = [];</div>
<div class="line">      <span class="keywordflow">if</span> (isArray(classVal)) {</div>
<div class="line">        forEach(classVal, <span class="keyword">function</span>(v) {</div>
<div class="line">          classes = classes.concat(arrayClasses(v));</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> classes;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isString(classVal)) {</div>
<div class="line">        <span class="keywordflow">return</span> classVal.split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isObject(classVal)) {</div>
<div class="line">        forEach(classVal, <span class="keyword">function</span>(v, k) {</div>
<div class="line">          <span class="keywordflow">if</span> (v) {</div>
<div class="line">            classes = classes.concat(k.split(<span class="charliteral">&#39; &#39;</span>));</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> classes;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> classVal;</div>
<div class="line">    }</div>
<div class="line">  }];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngClassDirective = classDirective(<span class="stringliteral">&#39;&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">var ngClassOddDirective = classDirective(<span class="stringliteral">&#39;Odd&#39;</span>, 0);</div>
<div class="line"></div>
<div class="line">var ngClassEvenDirective = classDirective(<span class="stringliteral">&#39;Even&#39;</span>, 1);</div>
<div class="line"></div>
<div class="line">var ngCloakDirective = ngDirective({</div>
<div class="line">  compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">    attr.$set(<span class="stringliteral">&#39;ngCloak&#39;</span>, undefined);</div>
<div class="line">    element.removeClass(<span class="stringliteral">&#39;ng-cloak&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngControllerDirective = [<span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    scope: <span class="keyword">true</span>,</div>
<div class="line">    controller: <span class="charliteral">&#39;@&#39;</span>,</div>
<div class="line">    priority: 500</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"><span class="comment">// ngCsp is not implemented as a proper directive any more, because we need it be processed while we</span></div>
<div class="line"><span class="comment">// bootstrap the system (before $parse is instantiated), for this reason we just have</span></div>
<div class="line"><span class="comment">// the csp() fn that looks for the `ng-csp` attribute anywhere in the current doc</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * A collection of directives that allows creation of custom event handlers that are defined as</span></div>
<div class="line"><span class="comment"> * angular expressions and are compiled and executed within the current scope.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">var ngEventDirectives = {};</div>
<div class="line"></div>
<div class="line"><span class="comment">// For events that might fire synchronously during DOM manipulation</span></div>
<div class="line"><span class="comment">// we need to execute their event handlers asynchronously using $evalAsync,</span></div>
<div class="line"><span class="comment">// so that they are not executed in an inconsistent state.</span></div>
<div class="line">var forceAsyncEvents = {</div>
<div class="line">  <span class="stringliteral">&#39;blur&#39;</span>: <span class="keyword">true</span>,</div>
<div class="line">  <span class="stringliteral">&#39;focus&#39;</span>: <span class="keyword">true</span></div>
<div class="line">};</div>
<div class="line">forEach(</div>
<div class="line">  <span class="stringliteral">&#39;click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste&#39;</span>.split(<span class="charliteral">&#39; &#39;</span>),</div>
<div class="line">  <span class="keyword">function</span>(eventName) {</div>
<div class="line">    var directiveName = directiveNormalize(<span class="stringliteral">&#39;ng-&#39;</span> + eventName);</div>
<div class="line">    ngEventDirectives[directiveName] = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($parse, $rootScope) {</div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">        compile: <span class="keyword">function</span>($element, attr) {</div>
<div class="line">          <span class="comment">// We expose the powerful $event object on the scope that provides access to the Window,</span></div>
<div class="line">          <span class="comment">// etc. that isn&#39;t protected by the fast paths in $parse.  We explicitly request better</span></div>
<div class="line">          <span class="comment">// checks at the cost of speed since event handler expressions are not executed as</span></div>
<div class="line">          <span class="comment">// frequently as regular change detection.</span></div>
<div class="line">          var fn = $parse(attr[directiveName], <span class="comment">/* interceptorFn */</span> null, <span class="comment">/* expensiveChecks */</span> <span class="keyword">true</span>);</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span> ngEventHandler(scope, element) {</div>
<div class="line">            element.on(eventName, <span class="keyword">function</span>(event) {</div>
<div class="line">              var callback = <span class="keyword">function</span>() {</div>
<div class="line">                fn(scope, {$event:event});</div>
<div class="line">              };</div>
<div class="line">              <span class="keywordflow">if</span> (forceAsyncEvents[eventName] &amp;&amp; $rootScope.$$phase) {</div>
<div class="line">                scope.$evalAsync(callback);</div>
<div class="line">              } <span class="keywordflow">else</span> {</div>
<div class="line">                scope.$apply(callback);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }];</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">var ngIfDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    priority: 600,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    $$tlb: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>($scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line">        var block, childScope, previousElements;</div>
<div class="line">        $scope.$watch($attr.ngIf, <span class="keyword">function</span> ngIfWatchAction(value) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (value) {</div>
<div class="line">            <span class="keywordflow">if</span> (!childScope) {</div>
<div class="line">              $transclude(<span class="keyword">function</span>(clone, newScope) {</div>
<div class="line">                childScope = newScope;</div>
<div class="line">                clone[clone.length++] = document.createComment(<span class="stringliteral">&#39; end ngIf: &#39;</span> + $attr.ngIf + <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">                <span class="comment">// Note: We only need the first/last node of the cloned nodes.</span></div>
<div class="line">                <span class="comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span></div>
<div class="line">                <span class="comment">// by a directive with templateUrl when its template arrives.</span></div>
<div class="line">                block = {</div>
<div class="line">                  clone: clone</div>
<div class="line">                };</div>
<div class="line">                $animate.enter(clone, $element.parent(), $element);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (previousElements) {</div>
<div class="line">              previousElements.remove();</div>
<div class="line">              previousElements = null;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (childScope) {</div>
<div class="line">              childScope.$destroy();</div>
<div class="line">              childScope = null;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (block) {</div>
<div class="line">              previousElements = getBlockNodes(block.clone);</div>
<div class="line">              $animate.leave(previousElements).then(<span class="keyword">function</span>() {</div>
<div class="line">                previousElements = null;</div>
<div class="line">              });</div>
<div class="line">              block = null;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngIncludeDirective = [<span class="stringliteral">&#39;$templateRequest&#39;</span>, <span class="stringliteral">&#39;$anchorScroll&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>,</div>
<div class="line">                  <span class="keyword">function</span>($templateRequest,   $anchorScroll,   $animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="stringliteral">&#39;ECA&#39;</span>,</div>
<div class="line">    priority: 400,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    controller: angular.noop,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">      var srcExp = attr.ngInclude || attr.src,</div>
<div class="line">          onloadExp = attr.onload || <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">          autoScrollExp = attr.autoscroll;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line">        var changeCounter = 0,</div>
<div class="line">            currentScope,</div>
<div class="line">            previousElement,</div>
<div class="line">            currentElement;</div>
<div class="line"></div>
<div class="line">        var cleanupLastIncludeContent = <span class="keyword">function</span>() {</div>
<div class="line">          <span class="keywordflow">if</span> (previousElement) {</div>
<div class="line">            previousElement.remove();</div>
<div class="line">            previousElement = null;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (currentScope) {</div>
<div class="line">            currentScope.$destroy();</div>
<div class="line">            currentScope = null;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (currentElement) {</div>
<div class="line">            $animate.leave(currentElement).then(<span class="keyword">function</span>() {</div>
<div class="line">              previousElement = null;</div>
<div class="line">            });</div>
<div class="line">            previousElement = currentElement;</div>
<div class="line">            currentElement = null;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        scope.$watch(srcExp, <span class="keyword">function</span> ngIncludeWatchAction(src) {</div>
<div class="line">          var afterAnimation = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) {</div>
<div class="line">              $anchorScroll();</div>
<div class="line">            }</div>
<div class="line">          };</div>
<div class="line">          var thisChangeId = ++changeCounter;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (src) {</div>
<div class="line">            <span class="comment">//set the 2nd param to true to ignore the template request error so that the inner</span></div>
<div class="line">            <span class="comment">//contents and scope can be cleaned up.</span></div>
<div class="line">            $templateRequest(src, <span class="keyword">true</span>).then(<span class="keyword">function</span>(response) {</div>
<div class="line">              <span class="keywordflow">if</span> (thisChangeId !== changeCounter) <span class="keywordflow">return</span>;</div>
<div class="line">              var newScope = scope.$new();</div>
<div class="line">              ctrl.template = response;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Note: This will also link all children of ng-include that were contained in the original</span></div>
<div class="line">              <span class="comment">// html. If that content contains controllers, ... they could pollute/change the scope.</span></div>
<div class="line">              <span class="comment">// However, using ng-include on an element with additional content does not make sense...</span></div>
<div class="line">              <span class="comment">// Note: We can&#39;t remove them in the cloneAttchFn of $transclude as that</span></div>
<div class="line">              <span class="comment">// function is called before linking the content, which would apply child</span></div>
<div class="line">              <span class="comment">// directives to non existing elements.</span></div>
<div class="line">              var clone = $transclude(newScope, <span class="keyword">function</span>(clone) {</div>
<div class="line">                cleanupLastIncludeContent();</div>
<div class="line">                $animate.enter(clone, null, $element).then(afterAnimation);</div>
<div class="line">              });</div>
<div class="line"></div>
<div class="line">              currentScope = newScope;</div>
<div class="line">              currentElement = clone;</div>
<div class="line"></div>
<div class="line">              currentScope.$emit(<span class="stringliteral">&#39;$includeContentLoaded&#39;</span>, src);</div>
<div class="line">              scope.$eval(onloadExp);</div>
<div class="line">            }, <span class="keyword">function</span>() {</div>
<div class="line">              <span class="keywordflow">if</span> (thisChangeId === changeCounter) {</div>
<div class="line">                cleanupLastIncludeContent();</div>
<div class="line">                scope.$emit(<span class="stringliteral">&#39;$includeContentError&#39;</span>, src);</div>
<div class="line">              }</div>
<div class="line">            });</div>
<div class="line">            scope.$emit(<span class="stringliteral">&#39;$includeContentRequested&#39;</span>, src);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            cleanupLastIncludeContent();</div>
<div class="line">            ctrl.template = null;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"><span class="comment">// This directive is called during the $transclude call of the first `ngInclude` directive.</span></div>
<div class="line"><span class="comment">// It will replace and compile the content of the element with the loaded template.</span></div>
<div class="line"><span class="comment">// We need this directive so that the element content is already filled when</span></div>
<div class="line"><span class="comment">// the link function of another directive on the same element as ngInclude</span></div>
<div class="line"><span class="comment">// is called.</span></div>
<div class="line">var ngIncludeFillContentDirective = [<span class="stringliteral">&#39;$compile&#39;</span>,</div>
<div class="line">  <span class="keyword">function</span>($compile) {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      restrict: <span class="stringliteral">&#39;ECA&#39;</span>,</div>
<div class="line">      priority: -400,</div>
<div class="line">      require: <span class="stringliteral">&#39;ngInclude&#39;</span>,</div>
<div class="line">      link: <span class="keyword">function</span>(scope, $element, $attr, ctrl) {</div>
<div class="line">        <span class="keywordflow">if</span> (/SVG/.test($element[0].toString())) {</div>
<div class="line">          <span class="comment">// WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not</span></div>
<div class="line">          <span class="comment">// support innerHTML, so detect this here and try to generate the contents</span></div>
<div class="line">          <span class="comment">// specially.</span></div>
<div class="line">          $element.empty();</div>
<div class="line">          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,</div>
<div class="line">              <span class="keyword">function</span> namespaceAdaptedClone(clone) {</div>
<div class="line">            $element.append(clone);</div>
<div class="line">          }, {futureParentElement: $element});</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        $element.html(ctrl.template);</div>
<div class="line">        $compile($element.contents())(scope);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }];</div>
<div class="line"></div>
<div class="line">var ngInitDirective = ngDirective({</div>
<div class="line">  priority: 450,</div>
<div class="line">  compile: <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      pre: <span class="keyword">function</span>(scope, element, attrs) {</div>
<div class="line">        scope.$eval(attrs.ngInit);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngListDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    require: <span class="stringliteral">&#39;ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ctrl) {</div>
<div class="line">      <span class="comment">// We want to control whitespace trimming so we use this convoluted approach</span></div>
<div class="line">      <span class="comment">// to access the ngList attribute, which doesn&#39;t pre-trim the attribute</span></div>
<div class="line">      var ngList = element.attr(attr.$attr.ngList) || <span class="stringliteral">&#39;, &#39;</span>;</div>
<div class="line">      var trimValues = attr.ngTrim !== <span class="stringliteral">&#39;false&#39;</span>;</div>
<div class="line">      var separator = trimValues ? trim(ngList) : ngList;</div>
<div class="line"></div>
<div class="line">      var parse = <span class="keyword">function</span>(viewValue) {</div>
<div class="line">        <span class="comment">// If the viewValue is invalid (say required but empty) it will be `undefined`</span></div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(viewValue)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        var list = [];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (viewValue) {</div>
<div class="line">          forEach(viewValue.split(separator), <span class="keyword">function</span>(value) {</div>
<div class="line">            <span class="keywordflow">if</span> (value) list.push(trimValues ? trim(value) : value);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> list;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      ctrl.$parsers.push(parse);</div>
<div class="line">      ctrl.$formatters.push(<span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">if</span> (isArray(value)) {</div>
<div class="line">          <span class="keywordflow">return</span> value.join(ngList);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> undefined;</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Override the standard $isEmpty because an empty array means the input is empty.</span></div>
<div class="line">      ctrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> !value || !value.length;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global VALID_CLASS: true,</span></div>
<div class="line"><span class="comment">  INVALID_CLASS: true,</span></div>
<div class="line"><span class="comment">  PRISTINE_CLASS: true,</span></div>
<div class="line"><span class="comment">  DIRTY_CLASS: true,</span></div>
<div class="line"><span class="comment">  UNTOUCHED_CLASS: true,</span></div>
<div class="line"><span class="comment">  TOUCHED_CLASS: true,</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line">var VALID_CLASS = <span class="stringliteral">&#39;ng-valid&#39;</span>,</div>
<div class="line">    INVALID_CLASS = <span class="stringliteral">&#39;ng-invalid&#39;</span>,</div>
<div class="line">    PRISTINE_CLASS = <span class="stringliteral">&#39;ng-pristine&#39;</span>,</div>
<div class="line">    DIRTY_CLASS = <span class="stringliteral">&#39;ng-dirty&#39;</span>,</div>
<div class="line">    UNTOUCHED_CLASS = <span class="stringliteral">&#39;ng-untouched&#39;</span>,</div>
<div class="line">    TOUCHED_CLASS = <span class="stringliteral">&#39;ng-touched&#39;</span>,</div>
<div class="line">    PENDING_CLASS = <span class="stringliteral">&#39;ng-pending&#39;</span>;</div>
<div class="line"></div>
<div class="line">var ngModelMinErr = minErr(<span class="stringliteral">&#39;ngModel&#39;</span>);</div>
<div class="line"></div>
<div class="line">var NgModelController = [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$exceptionHandler&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="stringliteral">&#39;$timeout&#39;</span>, <span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="stringliteral">&#39;$q&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>,</div>
<div class="line">    <span class="keyword">function</span>($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {</div>
<div class="line">  this.$viewValue = Number.NaN;</div>
<div class="line">  this.$modelValue = Number.NaN;</div>
<div class="line">  this.$$rawModelValue = undefined; <span class="comment">// stores the parsed modelValue / model set from scope regardless of validity.</span></div>
<div class="line">  this.$validators = {};</div>
<div class="line">  this.$asyncValidators = {};</div>
<div class="line">  this.$parsers = [];</div>
<div class="line">  this.$formatters = [];</div>
<div class="line">  this.$viewChangeListeners = [];</div>
<div class="line">  this.$untouched = <span class="keyword">true</span>;</div>
<div class="line">  this.$touched = <span class="keyword">false</span>;</div>
<div class="line">  this.$pristine = <span class="keyword">true</span>;</div>
<div class="line">  this.$dirty = <span class="keyword">false</span>;</div>
<div class="line">  this.$valid = <span class="keyword">true</span>;</div>
<div class="line">  this.$invalid = <span class="keyword">false</span>;</div>
<div class="line">  this.$error = {}; <span class="comment">// keep invalid keys here</span></div>
<div class="line">  this.$$success = {}; <span class="comment">// keep valid keys here</span></div>
<div class="line">  this.$pending = undefined; <span class="comment">// keep pending keys here</span></div>
<div class="line">  this.$name = $interpolate($attr.name || <span class="stringliteral">&#39;&#39;</span>, <span class="keyword">false</span>)($scope);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  var parsedNgModel = $parse($attr.ngModel),</div>
<div class="line">      parsedNgModelAssign = parsedNgModel.assign,</div>
<div class="line">      ngModelGet = parsedNgModel,</div>
<div class="line">      ngModelSet = parsedNgModelAssign,</div>
<div class="line">      pendingDebounce = null,</div>
<div class="line">      parserValid,</div>
<div class="line">      ctrl = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.$$setOptions = <span class="keyword">function</span>(options) {</div>
<div class="line">    ctrl.$options = options;</div>
<div class="line">    <span class="keywordflow">if</span> (options &amp;&amp; options.getterSetter) {</div>
<div class="line">      var invokeModelGetter = $parse($attr.ngModel + <span class="stringliteral">&#39;()&#39;</span>),</div>
<div class="line">          invokeModelSetter = $parse($attr.ngModel + <span class="stringliteral">&#39;($$$p)&#39;</span>);</div>
<div class="line"></div>
<div class="line">      ngModelGet = <span class="keyword">function</span>($scope) {</div>
<div class="line">        var modelValue = parsedNgModel($scope);</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(modelValue)) {</div>
<div class="line">          modelValue = invokeModelGetter($scope);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> modelValue;</div>
<div class="line">      };</div>
<div class="line">      ngModelSet = <span class="keyword">function</span>($scope, newValue) {</div>
<div class="line">        <span class="keywordflow">if</span> (isFunction(parsedNgModel($scope))) {</div>
<div class="line">          invokeModelSetter($scope, {$$$p: ctrl.$modelValue});</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          parsedNgModelAssign($scope, ctrl.$modelValue);</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!parsedNgModel.assign) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngModelMinErr(<span class="stringliteral">&#39;nonassign&#39;</span>, <span class="stringliteral">&quot;Expression &#39;{0}&#39; is non-assignable. Element: {1}&quot;</span>,</div>
<div class="line">          $attr.ngModel, startingTag($element));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$render = noop;</div>
<div class="line"></div>
<div class="line">  this.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> isUndefined(value) || value === <span class="stringliteral">&#39;&#39;</span> || value === null || value !== value;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var parentForm = $element.inheritedData(<span class="stringliteral">&#39;$formController&#39;</span>) || nullFormCtrl,</div>
<div class="line">      currentValidationRunId = 0;</div>
<div class="line"></div>
<div class="line">  addSetValidityMethod({</div>
<div class="line">    ctrl: <span class="keyword">this</span>,</div>
<div class="line">    $element: $element,</div>
<div class="line">    set: <span class="keyword">function</span>(object, property) {</div>
<div class="line">      <span class="keywordtype">object</span>[property] = <span class="keyword">true</span>;</div>
<div class="line">    },</div>
<div class="line">    unset: <span class="keyword">function</span>(object, property) {</div>
<div class="line">      <span class="keyword">delete</span> <span class="keywordtype">object</span>[property];</div>
<div class="line">    },</div>
<div class="line">    parentForm: parentForm,</div>
<div class="line">    $animate: $animate</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  this.$setPristine = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$dirty = <span class="keyword">false</span>;</div>
<div class="line">    ctrl.$pristine = <span class="keyword">true</span>;</div>
<div class="line">    $animate.removeClass($element, DIRTY_CLASS);</div>
<div class="line">    $animate.addClass($element, PRISTINE_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setDirty = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$dirty = <span class="keyword">true</span>;</div>
<div class="line">    ctrl.$pristine = <span class="keyword">false</span>;</div>
<div class="line">    $animate.removeClass($element, PRISTINE_CLASS);</div>
<div class="line">    $animate.addClass($element, DIRTY_CLASS);</div>
<div class="line">    parentForm.$setDirty();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setUntouched = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$touched = <span class="keyword">false</span>;</div>
<div class="line">    ctrl.$untouched = <span class="keyword">true</span>;</div>
<div class="line">    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setTouched = <span class="keyword">function</span>() {</div>
<div class="line">    ctrl.$touched = <span class="keyword">true</span>;</div>
<div class="line">    ctrl.$untouched = <span class="keyword">false</span>;</div>
<div class="line">    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$rollbackViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line">    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    ctrl.$render();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$validate = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// ignore $validate before model is initialized</span></div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    <span class="comment">// Note: we use the $$rawModelValue as $modelValue might have been</span></div>
<div class="line">    <span class="comment">// set to undefined during a view -&gt; model update that found validation</span></div>
<div class="line">    <span class="comment">// errors. We can&#39;t parse the view here, since that could change</span></div>
<div class="line">    <span class="comment">// the model although neither viewValue nor the model on the scope changed</span></div>
<div class="line">    var modelValue = ctrl.$$rawModelValue;</div>
<div class="line"></div>
<div class="line">    var prevValid = ctrl.$valid;</div>
<div class="line">    var prevModelValue = ctrl.$modelValue;</div>
<div class="line"></div>
<div class="line">    var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;</div>
<div class="line"></div>
<div class="line">    ctrl.$$runValidators(modelValue, viewValue, <span class="keyword">function</span>(allValid) {</div>
<div class="line">      <span class="comment">// If there was no change in validity, don&#39;t update the model</span></div>
<div class="line">      <span class="comment">// This prevents changing an invalid modelValue to undefined</span></div>
<div class="line">      <span class="keywordflow">if</span> (!allowInvalid &amp;&amp; prevValid !== allValid) {</div>
<div class="line">        <span class="comment">// Note: Don&#39;t check ctrl.$valid here, as we could have</span></div>
<div class="line">        <span class="comment">// external validators (e.g. calculated on the server),</span></div>
<div class="line">        <span class="comment">// that just call $setValidity and need the model value</span></div>
<div class="line">        <span class="comment">// to calculate their validity.</span></div>
<div class="line">        ctrl.$modelValue = allValid ? modelValue : undefined;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (ctrl.$modelValue !== prevModelValue) {</div>
<div class="line">          ctrl.$$writeModelToScope();</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$runValidators = <span class="keyword">function</span>(modelValue, viewValue, doneCallback) {</div>
<div class="line">    currentValidationRunId++;</div>
<div class="line">    var localValidationRunId = currentValidationRunId;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check parser error</span></div>
<div class="line">    <span class="keywordflow">if</span> (!processParseErrors()) {</div>
<div class="line">      validationDone(<span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!processSyncValidators()) {</div>
<div class="line">      validationDone(<span class="keyword">false</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    processAsyncValidators();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processParseErrors() {</div>
<div class="line">      var errorKey = ctrl.$$parserName || <span class="stringliteral">&#39;parse&#39;</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (parserValid === undefined) {</div>
<div class="line">        setValidity(errorKey, null);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (!parserValid) {</div>
<div class="line">          forEach(ctrl.$validators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">            setValidity(name, null);</div>
<div class="line">          });</div>
<div class="line">          forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">            setValidity(name, null);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Set the parse error last, to prevent unsetting it, should a $validators key == parserName</span></div>
<div class="line">        setValidity(errorKey, parserValid);</div>
<div class="line">        <span class="keywordflow">return</span> parserValid;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processSyncValidators() {</div>
<div class="line">      var syncValidatorsValid = <span class="keyword">true</span>;</div>
<div class="line">      forEach(ctrl.$validators, <span class="keyword">function</span>(validator, name) {</div>
<div class="line">        var result = validator(modelValue, viewValue);</div>
<div class="line">        syncValidatorsValid = syncValidatorsValid &amp;&amp; result;</div>
<div class="line">        setValidity(name, result);</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!syncValidatorsValid) {</div>
<div class="line">        forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(v, name) {</div>
<div class="line">          setValidity(name, null);</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> processAsyncValidators() {</div>
<div class="line">      var validatorPromises = [];</div>
<div class="line">      var allValid = <span class="keyword">true</span>;</div>
<div class="line">      forEach(ctrl.$asyncValidators, <span class="keyword">function</span>(validator, name) {</div>
<div class="line">        var promise = validator(modelValue, viewValue);</div>
<div class="line">        if (!isPromiseLike(promise)) {</div>
<div class="line">          throw ngModelMinErr(<span class="stringliteral">&quot;$asyncValidators&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Expected asynchronous validator to return a promise but got &#39;{0}&#39; instead.&quot;</span>, promise);</div>
<div class="line">        }</div>
<div class="line">        setValidity(name, undefined);</div>
<div class="line">        validatorPromises.push(promise.then(<span class="keyword">function</span>() {</div>
<div class="line">          setValidity(name, true);</div>
<div class="line">        }, <span class="keyword">function</span>(error) {</div>
<div class="line">          allValid = false;</div>
<div class="line">          setValidity(name, false);</div>
<div class="line">        }));</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">if</span> (!validatorPromises.length) {</div>
<div class="line">        validationDone(<span class="keyword">true</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        $q.all(validatorPromises).then(<span class="keyword">function</span>() {</div>
<div class="line">          validationDone(allValid);</div>
<div class="line">        }, noop);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> setValidity(name, isValid) {</div>
<div class="line">      <span class="keywordflow">if</span> (localValidationRunId === currentValidationRunId) {</div>
<div class="line">        ctrl.$setValidity(name, isValid);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> validationDone(allValid) {</div>
<div class="line">      <span class="keywordflow">if</span> (localValidationRunId === currentValidationRunId) {</div>
<div class="line"></div>
<div class="line">        doneCallback(allValid);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$commitViewValue = <span class="keyword">function</span>() {</div>
<div class="line">    var viewValue = ctrl.$viewValue;</div>
<div class="line"></div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If the view value has not changed then we should just exit, except in the case where there is</span></div>
<div class="line">    <span class="comment">// a native validator on the element. In this case the validation state may have changed even though</span></div>
<div class="line">    <span class="comment">// the viewValue has stayed empty.</span></div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$$lastCommittedViewValue === viewValue &amp;&amp; (viewValue !== <span class="stringliteral">&#39;&#39;</span> || !ctrl.$$hasNativeValidators)) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    ctrl.$$lastCommittedViewValue = viewValue;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// change to dirty</span></div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pristine) {</div>
<div class="line">      this.$setDirty();</div>
<div class="line">    }</div>
<div class="line">    this.$$parseAndValidate();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$parseAndValidate = <span class="keyword">function</span>() {</div>
<div class="line">    var viewValue = ctrl.$$lastCommittedViewValue;</div>
<div class="line">    var modelValue = viewValue;</div>
<div class="line">    parserValid = isUndefined(modelValue) ? undefined : <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (parserValid) {</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0; i &lt; ctrl.$parsers.length; i++) {</div>
<div class="line">        modelValue = ctrl.$parsers[i](modelValue);</div>
<div class="line">        <span class="keywordflow">if</span> (isUndefined(modelValue)) {</div>
<div class="line">          parserValid = <span class="keyword">false</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {</div>
<div class="line">      <span class="comment">// ctrl.$modelValue has not been touched yet...</span></div>
<div class="line">      ctrl.$modelValue = ngModelGet($scope);</div>
<div class="line">    }</div>
<div class="line">    var prevModelValue = ctrl.$modelValue;</div>
<div class="line">    var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;</div>
<div class="line">    ctrl.$$rawModelValue = modelValue;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (allowInvalid) {</div>
<div class="line">      ctrl.$modelValue = modelValue;</div>
<div class="line">      writeToModelIfNeeded();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.</span></div>
<div class="line">    <span class="comment">// This can happen if e.g. $setViewValue is called from inside a parser</span></div>
<div class="line">    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, <span class="keyword">function</span>(allValid) {</div>
<div class="line">      if (!allowInvalid) {</div>
<div class="line">        <span class="comment">// Note: Don&#39;t check ctrl.$valid here, as we could have</span></div>
<div class="line">        <span class="comment">// external validators (e.g. calculated on the server),</span></div>
<div class="line">        <span class="comment">// that just call $setValidity and need the model value</span></div>
<div class="line">        <span class="comment">// to calculate their validity.</span></div>
<div class="line">        ctrl.$modelValue = allValid ? modelValue : undefined;</div>
<div class="line">        writeToModelIfNeeded();</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> writeToModelIfNeeded() {</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$modelValue !== prevModelValue) {</div>
<div class="line">        ctrl.$$writeModelToScope();</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$writeModelToScope = <span class="keyword">function</span>() {</div>
<div class="line">    ngModelSet($scope, ctrl.$modelValue);</div>
<div class="line">    forEach(ctrl.$viewChangeListeners, <span class="keyword">function</span>(listener) {</div>
<div class="line">      try {</div>
<div class="line">        listener();</div>
<div class="line">      } catch (e) {</div>
<div class="line">        $exceptionHandler(e);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$setViewValue = <span class="keyword">function</span>(value, trigger) {</div>
<div class="line">    ctrl.$viewValue = value;</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl.$options || ctrl.$options.updateOnDefault) {</div>
<div class="line">      ctrl.$$debounceViewValueCommit(trigger);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  this.$$debounceViewValueCommit = <span class="keyword">function</span>(trigger) {</div>
<div class="line">    var debounceDelay = 0,</div>
<div class="line">        options = ctrl.$options,</div>
<div class="line">        debounce;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (options &amp;&amp; isDefined(options.debounce)) {</div>
<div class="line">      debounce = options.debounce;</div>
<div class="line">      <span class="keywordflow">if</span> (isNumber(debounce)) {</div>
<div class="line">        debounceDelay = debounce;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNumber(debounce[trigger])) {</div>
<div class="line">        debounceDelay = debounce[trigger];</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNumber(debounce[<span class="stringliteral">&#39;default&#39;</span>])) {</div>
<div class="line">        debounceDelay = debounce[<span class="stringliteral">&#39;default&#39;</span>];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $timeout.cancel(pendingDebounce);</div>
<div class="line">    <span class="keywordflow">if</span> (debounceDelay) {</div>
<div class="line">      pendingDebounce = $timeout(<span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$commitViewValue();</div>
<div class="line">      }, debounceDelay);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ($rootScope.$$phase) {</div>
<div class="line">      ctrl.$commitViewValue();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      $scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$commitViewValue();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// model -&gt; value</span></div>
<div class="line">  <span class="comment">// Note: we cannot use a normal scope.$watch as we want to detect the following:</span></div>
<div class="line">  <span class="comment">// 1. scope value is &#39;a&#39;</span></div>
<div class="line">  <span class="comment">// 2. user enters &#39;b&#39;</span></div>
<div class="line">  <span class="comment">// 3. ng-change kicks in and reverts scope value to &#39;a&#39;</span></div>
<div class="line">  <span class="comment">//    -&gt; scope value did not change since the last digest as</span></div>
<div class="line">  <span class="comment">//       ng-change executes in apply phase</span></div>
<div class="line">  <span class="comment">// 4. view should be changed back to &#39;a&#39;</span></div>
<div class="line">  $scope.$watch(<span class="keyword">function</span> ngModelWatch() {</div>
<div class="line">    var modelValue = ngModelGet($scope);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// if scope model value and ngModel value are out of sync</span></div>
<div class="line">    <span class="comment">// TODO(perf): why not move this to the action fn?</span></div>
<div class="line">    <span class="keywordflow">if</span> (modelValue !== ctrl.$modelValue &amp;&amp;</div>
<div class="line">       <span class="comment">// checks for NaN is needed to allow setting the model to NaN when there&#39;s an asyncValidator</span></div>
<div class="line">       (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)</div>
<div class="line">    ) {</div>
<div class="line">      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;</div>
<div class="line">      parserValid = undefined;</div>
<div class="line"></div>
<div class="line">      var formatters = ctrl.$formatters,</div>
<div class="line">          idx = formatters.length;</div>
<div class="line"></div>
<div class="line">      var viewValue = modelValue;</div>
<div class="line">      <span class="keywordflow">while</span> (idx--) {</div>
<div class="line">        viewValue = formatters[idx](viewValue);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (ctrl.$viewValue !== viewValue) {</div>
<div class="line">        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;</div>
<div class="line">        ctrl.$render();</div>
<div class="line"></div>
<div class="line">        ctrl.$$runValidators(modelValue, viewValue, noop);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> modelValue;</div>
<div class="line">  });</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngModelDirective = [<span class="stringliteral">&#39;$rootScope&#39;</span>, <span class="keyword">function</span>($rootScope) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;ngModel&#39;</span>, <span class="stringliteral">&#39;^?form&#39;</span>, <span class="stringliteral">&#39;^?ngModelOptions&#39;</span>],</div>
<div class="line">    controller: NgModelController,</div>
<div class="line">    <span class="comment">// Prelink needs to run before any input directive</span></div>
<div class="line">    <span class="comment">// so that we can set the NgModelOptions in NgModelController</span></div>
<div class="line">    <span class="comment">// before anyone else uses it.</span></div>
<div class="line">    priority: 1,</div>
<div class="line">    compile: <span class="keyword">function</span> ngModelCompile(element) {</div>
<div class="line">      <span class="comment">// Setup initial state of the control</span></div>
<div class="line">      element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> {</div>
<div class="line">        pre: <span class="keyword">function</span> ngModelPreLink(scope, element, attr, ctrls) {</div>
<div class="line">          var modelCtrl = ctrls[0],</div>
<div class="line">              formCtrl = ctrls[1] || nullFormCtrl;</div>
<div class="line"></div>
<div class="line">          modelCtrl.$$setOptions(ctrls[2] &amp;&amp; ctrls[2].$options);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// notify others, especially parent forms</span></div>
<div class="line">          formCtrl.$addControl(modelCtrl);</div>
<div class="line"></div>
<div class="line">          attr.$observe(<span class="stringliteral">&#39;name&#39;</span>, <span class="keyword">function</span>(newValue) {</div>
<div class="line">            <span class="keywordflow">if</span> (modelCtrl.$name !== newValue) {</div>
<div class="line">              formCtrl.$$renameControl(modelCtrl, newValue);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          scope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">            formCtrl.$removeControl(modelCtrl);</div>
<div class="line">          });</div>
<div class="line">        },</div>
<div class="line">        post: <span class="keyword">function</span> ngModelPostLink(scope, element, attr, ctrls) {</div>
<div class="line">          var modelCtrl = ctrls[0];</div>
<div class="line">          <span class="keywordflow">if</span> (modelCtrl.$options &amp;&amp; modelCtrl.$options.updateOn) {</div>
<div class="line">            element.on(modelCtrl.$options.updateOn, <span class="keyword">function</span>(ev) {</div>
<div class="line">              modelCtrl.$$debounceViewValueCommit(ev &amp;&amp; ev.type);</div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          element.on(<span class="stringliteral">&#39;blur&#39;</span>, <span class="keyword">function</span>(ev) {</div>
<div class="line">            <span class="keywordflow">if</span> (modelCtrl.$touched) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">            if ($rootScope.$$phase) {</div>
<div class="line">              scope.$evalAsync(modelCtrl.$setTouched);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              scope.$apply(modelCtrl.$setTouched);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var DEFAULT_REGEXP = /(\s+|^)<span class="keywordflow">default</span>(\s+|$)/;</div>
<div class="line"></div>
<div class="line">var ngModelOptionsDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    controller: [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="keyword">function</span>($scope, $attrs) {</div>
<div class="line">      var that = <span class="keyword">this</span>;</div>
<div class="line">      this.$options = copy($scope.$eval($attrs.ngModelOptions));</div>
<div class="line">      <span class="comment">// Allow adding/overriding bound events</span></div>
<div class="line">      <span class="keywordflow">if</span> (this.$options.updateOn !== undefined) {</div>
<div class="line">        this.$options.updateOnDefault = <span class="keyword">false</span>;</div>
<div class="line">        <span class="comment">// extract &quot;default&quot; pseudo-event from list of events that can trigger a model update</span></div>
<div class="line">        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, <span class="keyword">function</span>() {</div>
<div class="line">          that.$options.updateOnDefault = true;</div>
<div class="line">          return <span class="stringliteral">&#39; &#39;</span>;</div>
<div class="line">        }));</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        this.$options.updateOnDefault = <span class="keyword">true</span>;</div>
<div class="line">      }</div>
<div class="line">    }]</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// helper methods</span></div>
<div class="line"><span class="keyword">function</span> addSetValidityMethod(context) {</div>
<div class="line">  var ctrl = context.ctrl,</div>
<div class="line">      $element = context.$element,</div>
<div class="line">      classCache = {},</div>
<div class="line">      set = context.set,</div>
<div class="line">      unset = context.unset,</div>
<div class="line">      parentForm = context.parentForm,</div>
<div class="line">      $animate = context.$animate;</div>
<div class="line"></div>
<div class="line">  classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));</div>
<div class="line"></div>
<div class="line">  ctrl.$setValidity = setValidity;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> setValidity(validationErrorKey, state, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (state === undefined) {</div>
<div class="line">      createAndSet(<span class="stringliteral">&#39;$pending&#39;</span>, validationErrorKey, controller);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      unsetAndCleanup(<span class="stringliteral">&#39;$pending&#39;</span>, validationErrorKey, controller);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!isBoolean(state)) {</div>
<div class="line">      unset(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">      unset(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (state) {</div>
<div class="line">        unset(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">        set(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        set(ctrl.$error, validationErrorKey, controller);</div>
<div class="line">        unset(ctrl.$$success, validationErrorKey, controller);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pending) {</div>
<div class="line">      cachedToggleClass(PENDING_CLASS, <span class="keyword">true</span>);</div>
<div class="line">      ctrl.$valid = ctrl.$invalid = undefined;</div>
<div class="line">      toggleValidationCss(<span class="stringliteral">&#39;&#39;</span>, null);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      cachedToggleClass(PENDING_CLASS, <span class="keyword">false</span>);</div>
<div class="line">      ctrl.$valid = isObjectEmpty(ctrl.$error);</div>
<div class="line">      ctrl.$invalid = !ctrl.$valid;</div>
<div class="line">      toggleValidationCss(<span class="stringliteral">&#39;&#39;</span>, ctrl.$valid);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// re-read the state as the set/unset methods could have</span></div>
<div class="line">    <span class="comment">// combined state in ctrl.$error[validationError] (used for forms),</span></div>
<div class="line">    <span class="comment">// where setting/unsetting only increments/decrements the value,</span></div>
<div class="line">    <span class="comment">// and does not replace it.</span></div>
<div class="line">    var combinedState;</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl.$pending &amp;&amp; ctrl.$pending[validationErrorKey]) {</div>
<div class="line">      combinedState = undefined;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctrl.$error[validationErrorKey]) {</div>
<div class="line">      combinedState = <span class="keyword">false</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctrl.$$success[validationErrorKey]) {</div>
<div class="line">      combinedState = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      combinedState = null;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    toggleValidationCss(validationErrorKey, combinedState);</div>
<div class="line">    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> createAndSet(name, value, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (!ctrl[name]) {</div>
<div class="line">      ctrl[name] = {};</div>
<div class="line">    }</div>
<div class="line">    set(ctrl[name], value, controller);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> unsetAndCleanup(name, value, controller) {</div>
<div class="line">    <span class="keywordflow">if</span> (ctrl[name]) {</div>
<div class="line">      unset(ctrl[name], value, controller);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (isObjectEmpty(ctrl[name])) {</div>
<div class="line">      ctrl[name] = undefined;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> cachedToggleClass(className, switchValue) {</div>
<div class="line">    <span class="keywordflow">if</span> (switchValue &amp;&amp; !classCache[className]) {</div>
<div class="line">      $animate.addClass($element, className);</div>
<div class="line">      classCache[className] = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!switchValue &amp;&amp; classCache[className]) {</div>
<div class="line">      $animate.removeClass($element, className);</div>
<div class="line">      classCache[className] = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> toggleValidationCss(validationErrorKey, isValid) {</div>
<div class="line">    validationErrorKey = validationErrorKey ? <span class="charliteral">&#39;-&#39;</span> + snake_case(validationErrorKey, <span class="charliteral">&#39;-&#39;</span>) : <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line"></div>
<div class="line">    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === <span class="keyword">true</span>);</div>
<div class="line">    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> isObjectEmpty(obj) {</div>
<div class="line">  <span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keywordflow">for</span> (var prop in obj) {</div>
<div class="line">      <span class="keywordflow">if</span> (obj.hasOwnProperty(prop)) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">var ngNonBindableDirective = ngDirective({ terminal: <span class="keyword">true</span>, priority: 1000 });</div>
<div class="line"></div>
<div class="line"><span class="comment">/* global jqLiteRemove */</span></div>
<div class="line"></div>
<div class="line">var ngOptionsMinErr = minErr(<span class="stringliteral">&#39;ngOptions&#39;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// jshint maxlen: false</span></div>
<div class="line"><span class="comment">//                     //00001111111111000000000002222222222000000000000000000000333333333300000000000000000000000004444444444400000000000005555555555555550000000006666666666666660000000777777777777777000000000000000888888888800000000000000000009999999999</span></div>
<div class="line">var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+<span class="keywordflow">for</span>\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;</div>
<div class="line">                        <span class="comment">// 1: value expression (valueFn)</span></div>
<div class="line">                        <span class="comment">// 2: label expression (displayFn)</span></div>
<div class="line">                        <span class="comment">// 3: group by expression (groupByFn)</span></div>
<div class="line">                        <span class="comment">// 4: disable when expression (disableWhenFn)</span></div>
<div class="line">                        <span class="comment">// 5: array item variable name</span></div>
<div class="line">                        <span class="comment">// 6: object item key variable name</span></div>
<div class="line">                        <span class="comment">// 7: object item value variable name</span></div>
<div class="line">                        <span class="comment">// 8: collection expression</span></div>
<div class="line">                        <span class="comment">// 9: track by expression</span></div>
<div class="line"><span class="comment">// jshint maxlen: 100</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngOptionsDirective = [<span class="stringliteral">&#39;$compile&#39;</span>, <span class="stringliteral">&#39;$parse&#39;</span>, <span class="keyword">function</span>($compile, $parse) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> parseOptionsExpression(optionsExp, selectElement, scope) {</div>
<div class="line"></div>
<div class="line">    var match = optionsExp.match(NG_OPTIONS_REGEXP);</div>
<div class="line">    <span class="keywordflow">if</span> (!(match)) {</div>
<div class="line">      <span class="keywordflow">throw</span> ngOptionsMinErr(<span class="stringliteral">&#39;iexp&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;Expected expression in form of &quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot;&#39;_select_ (as _label_)? for (_key_,)?_value_ in _collection_&#39;&quot;</span> +</div>
<div class="line">        <span class="stringliteral">&quot; but got &#39;{0}&#39;. Element: {1}&quot;</span>,</div>
<div class="line">        optionsExp, startingTag(selectElement));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Extract the parts from the ngOptions expression</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// The variable name for the value of the item in the collection</span></div>
<div class="line">    var valueName = match[5] || match[7];</div>
<div class="line">    <span class="comment">// The variable name for the key of the item in the collection</span></div>
<div class="line">    var keyName = match[6];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// An expression that generates the viewValue for an option if there is a label expression</span></div>
<div class="line">    var selectAs = / as /.test(match[0]) &amp;&amp; match[1];</div>
<div class="line">    <span class="comment">// An expression that is used to track the id of each object in the options collection</span></div>
<div class="line">    var trackBy = match[9];</div>
<div class="line">    <span class="comment">// An expression that generates the viewValue for an option if there is no label expression</span></div>
<div class="line">    var valueFn = $parse(match[2] ? match[1] : valueName);</div>
<div class="line">    var selectAsFn = selectAs &amp;&amp; $parse(selectAs);</div>
<div class="line">    var viewValueFn = selectAsFn || valueFn;</div>
<div class="line">    var trackByFn = trackBy &amp;&amp; $parse(trackBy);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the value by which we are going to track the option</span></div>
<div class="line">    <span class="comment">// if we have a trackFn then use that (passing scope and locals)</span></div>
<div class="line">    <span class="comment">// otherwise just hash the given viewValue</span></div>
<div class="line">    var getTrackByValueFn = trackBy ?</div>
<div class="line">                              <span class="keyword">function</span>(value, locals) { <span class="keywordflow">return</span> trackByFn(scope, locals); } :</div>
<div class="line">                              <span class="keyword">function</span> getHashOfValue(value) { <span class="keywordflow">return</span> hashKey(value); };</div>
<div class="line">    var getTrackByValue = <span class="keyword">function</span>(value, key) {</div>
<div class="line">      <span class="keywordflow">return</span> getTrackByValueFn(value, getLocals(value, key));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    var displayFn = $parse(match[2] || match[1]);</div>
<div class="line">    var groupByFn = $parse(match[3] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    var disableWhenFn = $parse(match[4] || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    var valuesFn = $parse(match[8]);</div>
<div class="line"></div>
<div class="line">    var locals = {};</div>
<div class="line">    var getLocals = keyName ? <span class="keyword">function</span>(value, key) {</div>
<div class="line">      locals[keyName] = key;</div>
<div class="line">      locals[valueName] = value;</div>
<div class="line">      <span class="keywordflow">return</span> locals;</div>
<div class="line">    } : <span class="keyword">function</span>(value) {</div>
<div class="line">      locals[valueName] = value;</div>
<div class="line">      <span class="keywordflow">return</span> locals;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> Option(selectValue, viewValue, label, group, disabled) {</div>
<div class="line">      this.selectValue = selectValue;</div>
<div class="line">      this.viewValue = viewValue;</div>
<div class="line">      this.label = label;</div>
<div class="line">      this.group = group;</div>
<div class="line">      this.disabled = disabled;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">function</span> getOptionValuesKeys(optionValues) {</div>
<div class="line">      var optionValuesKeys;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!keyName &amp;&amp; isArrayLike(optionValues)) {</div>
<div class="line">        optionValuesKeys = optionValues;</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// if object, extract keys, in enumeration order, unsorted</span></div>
<div class="line">        optionValuesKeys = [];</div>
<div class="line">        <span class="keywordflow">for</span> (var itemKey in optionValues) {</div>
<div class="line">          <span class="keywordflow">if</span> (optionValues.hasOwnProperty(itemKey) &amp;&amp; itemKey.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">            optionValuesKeys.push(itemKey);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> optionValuesKeys;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">      trackBy: trackBy,</div>
<div class="line">      getTrackByValue: getTrackByValue,</div>
<div class="line">      getWatchables: $parse(valuesFn, <span class="keyword">function</span>(optionValues) {</div>
<div class="line">        <span class="comment">// Create a collection of things that we would like to watch (watchedArray)</span></div>
<div class="line">        <span class="comment">// so that they can all be watched using a single $watchCollection</span></div>
<div class="line">        <span class="comment">// that only runs the handler once if anything changes</span></div>
<div class="line">        var watchedArray = [];</div>
<div class="line">        optionValues = optionValues || [];</div>
<div class="line"></div>
<div class="line">        var optionValuesKeys = getOptionValuesKeys(optionValues);</div>
<div class="line">        var optionValuesLength = optionValuesKeys.length;</div>
<div class="line">        <span class="keywordflow">for</span> (var index = 0; index &lt; optionValuesLength; index++) {</div>
<div class="line">          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];</div>
<div class="line">          var value = optionValues[key];</div>
<div class="line"></div>
<div class="line">          var locals = getLocals(optionValues[key], key);</div>
<div class="line">          var selectValue = getTrackByValueFn(optionValues[key], locals);</div>
<div class="line">          watchedArray.push(selectValue);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Only need to watch the displayFn if there is a specific label expression</span></div>
<div class="line">          <span class="keywordflow">if</span> (match[2] || match[1]) {</div>
<div class="line">            var label = displayFn(scope, locals);</div>
<div class="line">            watchedArray.push(label);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Only need to watch the disableWhenFn if there is a specific disable expression</span></div>
<div class="line">          <span class="keywordflow">if</span> (match[4]) {</div>
<div class="line">            var disableWhen = disableWhenFn(scope, locals);</div>
<div class="line">            watchedArray.push(disableWhen);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> watchedArray;</div>
<div class="line">      }),</div>
<div class="line"></div>
<div class="line">      getOptions: <span class="keyword">function</span>() {</div>
<div class="line"></div>
<div class="line">        var optionItems = [];</div>
<div class="line">        var selectValueMap = {};</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The option values were already computed in the `getWatchables` fn,</span></div>
<div class="line">        <span class="comment">// which must have been called to trigger `getOptions`</span></div>
<div class="line">        var optionValues = valuesFn(scope) || [];</div>
<div class="line">        var optionValuesKeys = getOptionValuesKeys(optionValues);</div>
<div class="line">        var optionValuesLength = optionValuesKeys.length;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (var index = 0; index &lt; optionValuesLength; index++) {</div>
<div class="line">          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];</div>
<div class="line">          var value = optionValues[key];</div>
<div class="line">          var locals = getLocals(value, key);</div>
<div class="line">          var viewValue = viewValueFn(scope, locals);</div>
<div class="line">          var selectValue = getTrackByValueFn(viewValue, locals);</div>
<div class="line">          var label = displayFn(scope, locals);</div>
<div class="line">          var group = groupByFn(scope, locals);</div>
<div class="line">          var disabled = disableWhenFn(scope, locals);</div>
<div class="line">          var optionItem = <span class="keyword">new</span> Option(selectValue, viewValue, label, group, disabled);</div>
<div class="line"></div>
<div class="line">          optionItems.push(optionItem);</div>
<div class="line">          selectValueMap[selectValue] = optionItem;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">          items: optionItems,</div>
<div class="line">          selectValueMap: selectValueMap,</div>
<div class="line">          getOptionFromViewValue: <span class="keyword">function</span>(value) {</div>
<div class="line">            <span class="keywordflow">return</span> selectValueMap[getTrackByValue(value)];</div>
<div class="line">          },</div>
<div class="line">          getViewValueFromOption: <span class="keyword">function</span>(option) {</div>
<div class="line">            <span class="comment">// If the viewValue could be an object that may be mutated by the application,</span></div>
<div class="line">            <span class="comment">// we need to make a copy and not return the reference to the value on the option.</span></div>
<div class="line">            <span class="keywordflow">return</span> trackBy ? angular.copy(option.viewValue) : option.viewValue;</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// we can&#39;t just jqLite(&#39;&lt;option&gt;&#39;) since jqLite is not smart enough</span></div>
<div class="line">  <span class="comment">// to create it in &lt;select&gt; and IE barfs otherwise.</span></div>
<div class="line">  var optionTemplate = document.createElement(<span class="stringliteral">&#39;option&#39;</span>),</div>
<div class="line">      optGroupTemplate = document.createElement(<span class="stringliteral">&#39;optgroup&#39;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;select&#39;</span>, <span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    link: <span class="keyword">function</span>(scope, selectElement, attr, ctrls) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if ngModel is not defined, we don&#39;t need to do anything</span></div>
<div class="line">      var ngModelCtrl = ctrls[1];</div>
<div class="line">      <span class="keywordflow">if</span> (!ngModelCtrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var selectCtrl = ctrls[0];</div>
<div class="line">      var multiple = attr.multiple;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The emptyOption allows the application developer to provide their own custom &quot;empty&quot;</span></div>
<div class="line">      <span class="comment">// option when the viewValue does not match any of the option values.</span></div>
<div class="line">      var emptyOption;</div>
<div class="line">      <span class="keywordflow">for</span> (var i = 0, children = selectElement.children(), ii = children.length; i &lt; ii; i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (children[i].value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          emptyOption = children.eq(i);</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var providedEmptyOption = !!emptyOption;</div>
<div class="line"></div>
<div class="line">      var unknownOption = jqLite(optionTemplate.cloneNode(<span class="keyword">false</span>));</div>
<div class="line">      unknownOption.val(<span class="charliteral">&#39;?&#39;</span>);</div>
<div class="line"></div>
<div class="line">      var options;</div>
<div class="line">      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      var renderEmptyOption = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!providedEmptyOption) {</div>
<div class="line">          selectElement.prepend(emptyOption);</div>
<div class="line">        }</div>
<div class="line">        selectElement.val(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        emptyOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// needed for IE</span></div>
<div class="line">        emptyOption.attr(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var removeEmptyOption = <span class="keyword">function</span>() {</div>
<div class="line">        <span class="keywordflow">if</span> (!providedEmptyOption) {</div>
<div class="line">          emptyOption.remove();</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      var renderUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">        selectElement.prepend(unknownOption);</div>
<div class="line">        selectElement.val(<span class="charliteral">&#39;?&#39;</span>);</div>
<div class="line">        unknownOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// needed for IE</span></div>
<div class="line">        unknownOption.attr(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      var removeUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">        unknownOption.remove();</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="comment">// Update the controller methods for multiple selectable options</span></div>
<div class="line">      <span class="keywordflow">if</span> (!multiple) {</div>
<div class="line"></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeNgOptionsValue(value) {</div>
<div class="line">          var option = options.getOptionFromViewValue(value);</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) {</div>
<div class="line">            <span class="keywordflow">if</span> (selectElement[0].value !== option.selectValue) {</div>
<div class="line">              removeUnknownOption();</div>
<div class="line">              removeEmptyOption();</div>
<div class="line"></div>
<div class="line">              selectElement[0].value = option.selectValue;</div>
<div class="line">              option.element.selected = <span class="keyword">true</span>;</div>
<div class="line">              option.element.setAttribute(<span class="stringliteral">&#39;selected&#39;</span>, <span class="stringliteral">&#39;selected&#39;</span>);</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">if</span> (value === null || providedEmptyOption) {</div>
<div class="line">              removeUnknownOption();</div>
<div class="line">              renderEmptyOption();</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              removeEmptyOption();</div>
<div class="line">              renderUnknownOption();</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readNgOptionsValue() {</div>
<div class="line"></div>
<div class="line">          var selectedOption = options.selectValueMap[selectElement.val()];</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (selectedOption &amp;&amp; !selectedOption.disabled) {</div>
<div class="line">            removeEmptyOption();</div>
<div class="line">            removeUnknownOption();</div>
<div class="line">            <span class="keywordflow">return</span> options.getViewValueFromOption(selectedOption);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">return</span> null;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are using `track by` then we must watch the tracked value on the model</span></div>
<div class="line">        <span class="comment">// since ngModel only watches for object identity change</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngOptions.trackBy) {</div>
<div class="line">          scope.$watch(</div>
<div class="line">            <span class="keyword">function</span>() { <span class="keywordflow">return</span> ngOptions.getTrackByValue(ngModelCtrl.$viewValue); },</div>
<div class="line">            <span class="keyword">function</span>() { ngModelCtrl.$render(); }</div>
<div class="line">          );</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">        ngModelCtrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> !value || value.length === 0;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeNgOptionsMultiple(value) {</div>
<div class="line">          options.items.forEach(<span class="keyword">function</span>(option) {</div>
<div class="line">            option.element.selected = <span class="keyword">false</span>;</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (value) {</div>
<div class="line">            value.forEach(<span class="keyword">function</span>(item) {</div>
<div class="line">              var option = options.getOptionFromViewValue(item);</div>
<div class="line">              <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) option.element.selected = <span class="keyword">true</span>;</div>
<div class="line">            });</div>
<div class="line">          }</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readNgOptionsMultiple() {</div>
<div class="line">          var selectedValues = selectElement.val() || [],</div>
<div class="line">              selections = [];</div>
<div class="line"></div>
<div class="line">          forEach(selectedValues, <span class="keyword">function</span>(value) {</div>
<div class="line">            var option = options.selectValueMap[value];</div>
<div class="line">            <span class="keywordflow">if</span> (option &amp;&amp; !option.disabled) selections.push(options.getViewValueFromOption(option));</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">return</span> selections;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are using `track by` then we must watch these tracked values on the model</span></div>
<div class="line">        <span class="comment">// since ngModel only watches for object identity change</span></div>
<div class="line">        <span class="keywordflow">if</span> (ngOptions.trackBy) {</div>
<div class="line"></div>
<div class="line">          scope.$watchCollection(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">if</span> (isArray(ngModelCtrl.$viewValue)) {</div>
<div class="line">              return ngModelCtrl.$viewValue.map(function(value) {</div>
<div class="line">                return ngOptions.getTrackByValue(value);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          }, <span class="keyword">function</span>() {</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (providedEmptyOption) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we need to remove it before calling selectElement.empty() because otherwise IE will</span></div>
<div class="line">        <span class="comment">// remove the label from the element. wtf?</span></div>
<div class="line">        emptyOption.remove();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// compile the element since there might be bindings in it</span></div>
<div class="line">        $compile(emptyOption)(scope);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// remove the class, which is added automatically because we recompile the element and it</span></div>
<div class="line">        <span class="comment">// becomes the compilation root</span></div>
<div class="line">        emptyOption.removeClass(<span class="stringliteral">&#39;ng-scope&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        emptyOption = jqLite(optionTemplate.cloneNode(<span class="keyword">false</span>));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We need to do this here to ensure that the options object is defined</span></div>
<div class="line">      <span class="comment">// when we first hit it in writeNgOptionsValue</span></div>
<div class="line">      updateOptions();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We will re-render the option elements if the option values or labels change</span></div>
<div class="line">      scope.$watchCollection(ngOptions.getWatchables, updateOptions);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// ------------------------------------------------------------------ //</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateOptionElement(option, element) {</div>
<div class="line">        option.element = element;</div>
<div class="line">        element.disabled = option.disabled;</div>
<div class="line">        <span class="keywordflow">if</span> (option.value !== element.value) element.value = option.selectValue;</div>
<div class="line">        <span class="keywordflow">if</span> (option.label !== element.label) {</div>
<div class="line">          element.label = option.label;</div>
<div class="line">          element.textContent = option.label;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> addOrReuseElement(parent, current, type, templateElement) {</div>
<div class="line">        var element;</div>
<div class="line">        <span class="comment">// Check whether we can reuse the next element</span></div>
<div class="line">        <span class="keywordflow">if</span> (current &amp;&amp; lowercase(current.nodeName) === type) {</div>
<div class="line">          <span class="comment">// The next element is the right type so reuse it</span></div>
<div class="line">          element = current;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// The next element is not the right type so create a new one</span></div>
<div class="line">          element = templateElement.cloneNode(<span class="keyword">false</span>);</div>
<div class="line">          <span class="keywordflow">if</span> (!current) {</div>
<div class="line">            <span class="comment">// There are no more elements so just append it to the select</span></div>
<div class="line">            parent.appendChild(element);</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// The next element is not a group so insert the new one</span></div>
<div class="line">            parent.insertBefore(element, current);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> element;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> removeExcessElements(current) {</div>
<div class="line">        var next;</div>
<div class="line">        <span class="keywordflow">while</span> (current) {</div>
<div class="line">          next = current.nextSibling;</div>
<div class="line">          jqLiteRemove(current);</div>
<div class="line">          current = next;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> skipEmptyAndUnknownOptions(current) {</div>
<div class="line">        var emptyOption_ = emptyOption &amp;&amp; emptyOption[0];</div>
<div class="line">        var unknownOption_ = unknownOption &amp;&amp; unknownOption[0];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (emptyOption_ || unknownOption_) {</div>
<div class="line">          <span class="keywordflow">while</span> (current &amp;&amp;</div>
<div class="line">                (current === emptyOption_ ||</div>
<div class="line">                current === unknownOption_)) {</div>
<div class="line">            current = current.nextSibling;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> current;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateOptions() {</div>
<div class="line"></div>
<div class="line">        var previousValue = options &amp;&amp; selectCtrl.readValue();</div>
<div class="line"></div>
<div class="line">        options = ngOptions.getOptions();</div>
<div class="line"></div>
<div class="line">        var groupMap = {};</div>
<div class="line">        var currentElement = selectElement[0].firstChild;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Ensure that the empty option is always there if it was explicitly provided</span></div>
<div class="line">        <span class="keywordflow">if</span> (providedEmptyOption) {</div>
<div class="line">          selectElement.prepend(emptyOption);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        currentElement = skipEmptyAndUnknownOptions(currentElement);</div>
<div class="line"></div>
<div class="line">        options.items.forEach(<span class="keyword">function</span> updateOption(option) {</div>
<div class="line">          var group;</div>
<div class="line">          var groupElement;</div>
<div class="line">          var optionElement;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (option.group) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This option is to live in a group</span></div>
<div class="line">            <span class="comment">// See if we have already created this group</span></div>
<div class="line">            group = groupMap[option.group];</div>
<div class="line"></div>
<div class="line">            if (!group) {</div>
<div class="line"></div>
<div class="line">              <span class="comment">// We have not already created this group</span></div>
<div class="line">              groupElement = addOrReuseElement(selectElement[0],</div>
<div class="line">                                               currentElement,</div>
<div class="line">                                               <span class="stringliteral">&#39;optgroup&#39;</span>,</div>
<div class="line">                                               optGroupTemplate);</div>
<div class="line">              <span class="comment">// Move to the next element</span></div>
<div class="line">              currentElement = groupElement.nextSibling;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Update the label on the group element</span></div>
<div class="line">              groupElement.label = option.group;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// Store it for use later</span></div>
<div class="line">              group = groupMap[option.group] = {</div>
<div class="line">                groupElement: groupElement,</div>
<div class="line">                currentOptionElement: groupElement.firstChild</div>
<div class="line">              };</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// So now we have a group for this option we add the option to the group</span></div>
<div class="line">            optionElement = addOrReuseElement(group.groupElement,</div>
<div class="line">                                              group.currentOptionElement,</div>
<div class="line">                                              <span class="stringliteral">&#39;option&#39;</span>,</div>
<div class="line">                                              optionTemplate);</div>
<div class="line">            updateOptionElement(option, optionElement);</div>
<div class="line">            <span class="comment">// Move to the next element</span></div>
<div class="line">            group.currentOptionElement = optionElement.nextSibling;</div>
<div class="line"></div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// This option is not in a group</span></div>
<div class="line">            optionElement = addOrReuseElement(selectElement[0],</div>
<div class="line">                                              currentElement,</div>
<div class="line">                                              <span class="stringliteral">&#39;option&#39;</span>,</div>
<div class="line">                                              optionTemplate);</div>
<div class="line">            updateOptionElement(option, optionElement);</div>
<div class="line">            <span class="comment">// Move to the next element</span></div>
<div class="line">            currentElement = optionElement.nextSibling;</div>
<div class="line">          }</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Now remove all excess options and group</span></div>
<div class="line">        Object.keys(groupMap).forEach(<span class="keyword">function</span>(key) {</div>
<div class="line">          removeExcessElements(groupMap[key].currentOptionElement);</div>
<div class="line">        });</div>
<div class="line">        removeExcessElements(currentElement);</div>
<div class="line"></div>
<div class="line">        ngModelCtrl.$render();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check to see if the value has changed due to the update to the options</span></div>
<div class="line">        <span class="keywordflow">if</span> (!ngModelCtrl.$isEmpty(previousValue)) {</div>
<div class="line">          var nextValue = selectCtrl.readValue();</div>
<div class="line">          <span class="keywordflow">if</span> (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {</div>
<div class="line">            ngModelCtrl.$setViewValue(nextValue);</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngPluralizeDirective = [<span class="stringliteral">&#39;$locale&#39;</span>, <span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="stringliteral">&#39;$log&#39;</span>, <span class="keyword">function</span>($locale, $interpolate, $log) {</div>
<div class="line">  var BRACE = /{}/g,</div>
<div class="line">      IS_WHEN = /^when(Minus)?(.+)$/;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      var numberExp = attr.count,</div>
<div class="line">          whenExp = attr.$attr.when &amp;&amp; element.attr(attr.$attr.when), <span class="comment">// we have {{}} in attrs</span></div>
<div class="line">          offset = attr.offset || 0,</div>
<div class="line">          whens = scope.$eval(whenExp) || {},</div>
<div class="line">          whensExpFns = {},</div>
<div class="line">          startSymbol = $interpolate.startSymbol(),</div>
<div class="line">          endSymbol = $interpolate.endSymbol(),</div>
<div class="line">          braceReplacement = startSymbol + numberExp + <span class="charliteral">&#39;-&#39;</span> + offset + endSymbol,</div>
<div class="line">          watchRemover = angular.noop,</div>
<div class="line">          lastCount;</div>
<div class="line"></div>
<div class="line">      forEach(attr, <span class="keyword">function</span>(expression, attributeName) {</div>
<div class="line">        var tmpMatch = IS_WHEN.exec(attributeName);</div>
<div class="line">        <span class="keywordflow">if</span> (tmpMatch) {</div>
<div class="line">          var whenKey = (tmpMatch[1] ? <span class="charliteral">&#39;-&#39;</span> : <span class="stringliteral">&#39;&#39;</span>) + lowercase(tmpMatch[2]);</div>
<div class="line">          whens[whenKey] = element.attr(attr.$attr[attributeName]);</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      forEach(whens, <span class="keyword">function</span>(expression, key) {</div>
<div class="line">        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));</div>
<div class="line"></div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      scope.$watch(numberExp, <span class="keyword">function</span> ngPluralizeWatchAction(newVal) {</div>
<div class="line">        var count = parseFloat(newVal);</div>
<div class="line">        var countIsNaN = isNaN(count);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!countIsNaN &amp;&amp; !(count in whens)) {</div>
<div class="line">          <span class="comment">// If an explicit number rule such as 1, 2, 3... is defined, just use it.</span></div>
<div class="line">          <span class="comment">// Otherwise, check it against pluralization rules in $locale service.</span></div>
<div class="line">          count = $locale.pluralCat(count - offset);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If both `count` and `lastCount` are NaN, we don&#39;t need to re-register a watch.</span></div>
<div class="line">        <span class="comment">// In JS `NaN !== NaN`, so we have to exlicitly check.</span></div>
<div class="line">        <span class="keywordflow">if</span> ((count !== lastCount) &amp;&amp; !(countIsNaN &amp;&amp; isNumber(lastCount) &amp;&amp; isNaN(lastCount))) {</div>
<div class="line">          watchRemover();</div>
<div class="line">          var whenExpFn = whensExpFns[count];</div>
<div class="line">          <span class="keywordflow">if</span> (isUndefined(whenExpFn)) {</div>
<div class="line">            <span class="keywordflow">if</span> (newVal != null) {</div>
<div class="line">              $log.debug(<span class="stringliteral">&quot;ngPluralize: no rule defined for &#39;&quot;</span> + count + <span class="stringliteral">&quot;&#39; in &quot;</span> + whenExp);</div>
<div class="line">            }</div>
<div class="line">            watchRemover = noop;</div>
<div class="line">            updateElementText();</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            watchRemover = scope.$watch(whenExpFn, updateElementText);</div>
<div class="line">          }</div>
<div class="line">          lastCount = count;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> updateElementText(newText) {</div>
<div class="line">        element.text(newText || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngRepeatDirective = [<span class="stringliteral">&#39;$parse&#39;</span>, <span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($parse, $animate) {</div>
<div class="line">  var NG_REMOVED = <span class="stringliteral">&#39;$$NG_REMOVED&#39;</span>;</div>
<div class="line">  var ngRepeatMinErr = minErr(<span class="stringliteral">&#39;ngRepeat&#39;</span>);</div>
<div class="line"></div>
<div class="line">  var updateScope = <span class="keyword">function</span>(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {</div>
<div class="line">    <span class="comment">// TODO(perf): generate setters to shave off ~40ms or 1-1.5%</span></div>
<div class="line">    scope[valueIdentifier] = value;</div>
<div class="line">    <span class="keywordflow">if</span> (keyIdentifier) scope[keyIdentifier] = key;</div>
<div class="line">    scope.$index = index;</div>
<div class="line">    scope.$first = (index === 0);</div>
<div class="line">    scope.$last = (index === (arrayLength - 1));</div>
<div class="line">    scope.$middle = !(scope.$first || scope.$last);</div>
<div class="line">    <span class="comment">// jshint bitwise: false</span></div>
<div class="line">    scope.$odd = !(scope.$even = (index&amp;1) === 0);</div>
<div class="line">    <span class="comment">// jshint bitwise: true</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var getBlockStart = <span class="keyword">function</span>(block) {</div>
<div class="line">    <span class="keywordflow">return</span> block.clone[0];</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var getBlockEnd = <span class="keyword">function</span>(block) {</div>
<div class="line">    <span class="keywordflow">return</span> block.clone[block.clone.length - 1];</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">    priority: 1000,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    $$tlb: <span class="keyword">true</span>,</div>
<div class="line">    compile: <span class="keyword">function</span> ngRepeatCompile($element, $attr) {</div>
<div class="line">      var expression = $attr.ngRepeat;</div>
<div class="line">      var ngRepeatEndComment = document.createComment(<span class="stringliteral">&#39; end ngRepeat: &#39;</span> + expression + <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"></div>
<div class="line">      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;iexp&#39;</span>, <span class="stringliteral">&quot;Expected expression in form of &#39;_item_ in _collection_[ track by _id_]&#39; but got &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">            expression);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var lhs = match[1];</div>
<div class="line">      var rhs = match[2];</div>
<div class="line">      var aliasAs = match[3];</div>
<div class="line">      var trackByExp = match[4];</div>
<div class="line"></div>
<div class="line">      match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (!match) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;iidexp&#39;</span>, <span class="stringliteral">&quot;&#39;_item_&#39; in &#39;_item_ in _collection_&#39; should be an identifier or &#39;(_key_, _value_)&#39; expression, but got &#39;{0}&#39;.&quot;</span>,</div>
<div class="line">            lhs);</div>
<div class="line">      }</div>
<div class="line">      var valueIdentifier = match[3] || match[1];</div>
<div class="line">      var keyIdentifier = match[2];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (aliasAs &amp;&amp; (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||</div>
<div class="line">          /^(null|undefined|<span class="keyword">this</span>|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {</div>
<div class="line">        <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;badident&#39;</span>, <span class="stringliteral">&quot;alias &#39;{0}&#39; is invalid --- must be a valid JS identifier which is not a reserved name.&quot;</span>,</div>
<div class="line">          aliasAs);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;</div>
<div class="line">      var hashFnLocals = {$id: hashKey};</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (trackByExp) {</div>
<div class="line">        trackByExpGetter = $parse(trackByExp);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        trackByIdArrayFn = <span class="keyword">function</span>(key, value) {</div>
<div class="line">          <span class="keywordflow">return</span> hashKey(value);</div>
<div class="line">        };</div>
<div class="line">        trackByIdObjFn = <span class="keyword">function</span>(key) {</div>
<div class="line">          <span class="keywordflow">return</span> key;</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span> ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (trackByExpGetter) {</div>
<div class="line">          trackByIdExpFn = <span class="keyword">function</span>(key, value, index) {</div>
<div class="line">            <span class="comment">// assign key, value, and $index to the locals so that they can be used in hash functions</span></div>
<div class="line">            <span class="keywordflow">if</span> (keyIdentifier) hashFnLocals[keyIdentifier] = key;</div>
<div class="line">            hashFnLocals[valueIdentifier] = value;</div>
<div class="line">            hashFnLocals.$index = index;</div>
<div class="line">            <span class="keywordflow">return</span> trackByExpGetter($scope, hashFnLocals);</div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Store a list of elements from previous run. This is a hash where key is the item from the</span></div>
<div class="line">        <span class="comment">// iterator, and the value is objects with following properties.</span></div>
<div class="line">        <span class="comment">//   - scope: bound scope</span></div>
<div class="line">        <span class="comment">//   - element: previous element.</span></div>
<div class="line">        <span class="comment">//   - index: position</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// We are using no-proto object so that we don&#39;t need to guard against inherited props via</span></div>
<div class="line">        <span class="comment">// hasOwnProperty.</span></div>
<div class="line">        var lastBlockMap = createMap();</div>
<div class="line"></div>
<div class="line">        <span class="comment">//watch props</span></div>
<div class="line">        $scope.$watchCollection(rhs, <span class="keyword">function</span> ngRepeatAction(collection) {</div>
<div class="line">          var index, length,</div>
<div class="line">              previousNode = $element[0],     <span class="comment">// node that cloned nodes should be inserted after</span></div>
<div class="line">                                              <span class="comment">// initialized to the comment node anchor</span></div>
<div class="line">              nextNode,</div>
<div class="line">              <span class="comment">// Same as lastBlockMap but it has the current state. It will become the</span></div>
<div class="line">              <span class="comment">// lastBlockMap on the next iteration.</span></div>
<div class="line">              nextBlockMap = createMap(),</div>
<div class="line">              collectionLength,</div>
<div class="line">              key, value, <span class="comment">// key/value of iteration</span></div>
<div class="line">              trackById,</div>
<div class="line">              trackByIdFn,</div>
<div class="line">              collectionKeys,</div>
<div class="line">              block,       <span class="comment">// last object information {scope, element, id}</span></div>
<div class="line">              nextBlockOrder,</div>
<div class="line">              elementsToRemove;</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (aliasAs) {</div>
<div class="line">            $scope[aliasAs] = collection;</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (isArrayLike(collection)) {</div>
<div class="line">            collectionKeys = collection;</div>
<div class="line">            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            trackByIdFn = trackByIdExpFn || trackByIdObjFn;</div>
<div class="line">            <span class="comment">// if object, extract keys, in enumeration order, unsorted</span></div>
<div class="line">            collectionKeys = [];</div>
<div class="line">            <span class="keywordflow">for</span> (var itemKey in collection) {</div>
<div class="line">              <span class="keywordflow">if</span> (collection.hasOwnProperty(itemKey) &amp;&amp; itemKey.charAt(0) !== <span class="charliteral">&#39;$&#39;</span>) {</div>
<div class="line">                collectionKeys.push(itemKey);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          collectionLength = collectionKeys.length;</div>
<div class="line">          nextBlockOrder = <span class="keyword">new</span> Array(collectionLength);</div>
<div class="line"></div>
<div class="line">          <span class="comment">// locate existing items</span></div>
<div class="line">          <span class="keywordflow">for</span> (index = 0; index &lt; collectionLength; index++) {</div>
<div class="line">            key = (collection === collectionKeys) ? index : collectionKeys[index];</div>
<div class="line">            value = collection[key];</div>
<div class="line">            trackById = trackByIdFn(key, value, index);</div>
<div class="line">            <span class="keywordflow">if</span> (lastBlockMap[trackById]) {</div>
<div class="line">              <span class="comment">// found previously seen block</span></div>
<div class="line">              block = lastBlockMap[trackById];</div>
<div class="line">              <span class="keyword">delete</span> lastBlockMap[trackById];</div>
<div class="line">              nextBlockMap[trackById] = block;</div>
<div class="line">              nextBlockOrder[index] = block;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nextBlockMap[trackById]) {</div>
<div class="line">              <span class="comment">// if collision detected. restore lastBlockMap and throw an error</span></div>
<div class="line">              forEach(nextBlockOrder, <span class="keyword">function</span>(block) {</div>
<div class="line">                <span class="keywordflow">if</span> (block &amp;&amp; block.scope) lastBlockMap[block.id] = block;</div>
<div class="line">              });</div>
<div class="line">              <span class="keywordflow">throw</span> ngRepeatMinErr(<span class="stringliteral">&#39;dupes&#39;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;Duplicates in a repeater are not allowed. Use &#39;track by&#39; expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}&quot;</span>,</div>
<div class="line">                  expression, trackById, value);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// new never before seen block</span></div>
<div class="line">              nextBlockOrder[index] = {<span class="keywordtype">id</span>: trackById, scope: undefined, clone: undefined};</div>
<div class="line">              nextBlockMap[trackById] = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// remove leftover items</span></div>
<div class="line">          <span class="keywordflow">for</span> (var blockKey in lastBlockMap) {</div>
<div class="line">            block = lastBlockMap[blockKey];</div>
<div class="line">            elementsToRemove = getBlockNodes(block.clone);</div>
<div class="line">            $animate.leave(elementsToRemove);</div>
<div class="line">            <span class="keywordflow">if</span> (elementsToRemove[0].parentNode) {</div>
<div class="line">              <span class="comment">// if the element was not removed yet because of pending animation, mark it as deleted</span></div>
<div class="line">              <span class="comment">// so that we can ignore it later</span></div>
<div class="line">              <span class="keywordflow">for</span> (index = 0, length = elementsToRemove.length; index &lt; length; index++) {</div>
<div class="line">                elementsToRemove[index][NG_REMOVED] = <span class="keyword">true</span>;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">            block.scope.$destroy();</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          <span class="comment">// we are not using forEach for perf reasons (trying to avoid #call)</span></div>
<div class="line">          <span class="keywordflow">for</span> (index = 0; index &lt; collectionLength; index++) {</div>
<div class="line">            key = (collection === collectionKeys) ? index : collectionKeys[index];</div>
<div class="line">            value = collection[key];</div>
<div class="line">            block = nextBlockOrder[index];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (block.scope) {</div>
<div class="line">              <span class="comment">// if we have already seen this object, then we need to reuse the</span></div>
<div class="line">              <span class="comment">// associated scope/element</span></div>
<div class="line"></div>
<div class="line">              nextNode = previousNode;</div>
<div class="line"></div>
<div class="line">              <span class="comment">// skip nodes that are already pending removal via leave animation</span></div>
<div class="line">              <span class="keywordflow">do</span> {</div>
<div class="line">                nextNode = nextNode.nextSibling;</div>
<div class="line">              } <span class="keywordflow">while</span> (nextNode &amp;&amp; nextNode[NG_REMOVED]);</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">if</span> (getBlockStart(block) != nextNode) {</div>
<div class="line">                <span class="comment">// existing item which got moved</span></div>
<div class="line">                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));</div>
<div class="line">              }</div>
<div class="line">              previousNode = getBlockEnd(block);</div>
<div class="line">              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// new item which we don&#39;t know about</span></div>
<div class="line">              $transclude(<span class="keyword">function</span> ngRepeatTransclude(clone, scope) {</div>
<div class="line">                block.scope = scope;</div>
<div class="line">                <span class="comment">// http://jsperf.com/clone-vs-createcomment</span></div>
<div class="line">                var endNode = ngRepeatEndComment.cloneNode(<span class="keyword">false</span>);</div>
<div class="line">                clone[clone.length++] = endNode;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?</span></div>
<div class="line">                $animate.enter(clone, null, jqLite(previousNode));</div>
<div class="line">                previousNode = endNode;</div>
<div class="line">                <span class="comment">// Note: We only need the first/last node of the cloned nodes.</span></div>
<div class="line">                <span class="comment">// However, we need to keep the reference to the jqlite wrapper as it might be changed later</span></div>
<div class="line">                <span class="comment">// by a directive with templateUrl when its template arrives.</span></div>
<div class="line">                block.clone = clone;</div>
<div class="line">                nextBlockMap[block.id] = block;</div>
<div class="line">                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);</div>
<div class="line">              });</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          lastBlockMap = nextBlockMap;</div>
<div class="line">        });</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var NG_HIDE_CLASS = <span class="stringliteral">&#39;ng-hide&#39;</span>;</div>
<div class="line">var NG_HIDE_IN_PROGRESS_CLASS = <span class="stringliteral">&#39;ng-hide-animate&#39;</span>;</div>
<div class="line">var ngShowDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      scope.$watch(attr.ngShow, <span class="keyword">function</span> ngShowWatchAction(value) {</div>
<div class="line">        <span class="comment">// we&#39;re adding a temporary, animation-specific class for ng-hide since this way</span></div>
<div class="line">        <span class="comment">// we can control when the element is actually displayed on screen without having</span></div>
<div class="line">        <span class="comment">// to have a global/greedy CSS selector that breaks when other animations are run.</span></div>
<div class="line">        <span class="comment">// Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845</span></div>
<div class="line">        $animate[value ? <span class="stringliteral">&#39;removeClass&#39;</span> : <span class="stringliteral">&#39;addClass&#39;</span>](element, NG_HIDE_CLASS, {</div>
<div class="line">          tempClasses: NG_HIDE_IN_PROGRESS_CLASS</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var ngHideDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    multiElement: <span class="keyword">true</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">      scope.$watch(attr.ngHide, <span class="keyword">function</span> ngHideWatchAction(value) {</div>
<div class="line">        <span class="comment">// The comment inside of the ngShowDirective explains why we add and</span></div>
<div class="line">        <span class="comment">// remove a temporary class for the show/hide animation</span></div>
<div class="line">        $animate[value ? <span class="stringliteral">&#39;addClass&#39;</span> : <span class="stringliteral">&#39;removeClass&#39;</span>](element,NG_HIDE_CLASS, {</div>
<div class="line">          tempClasses: NG_HIDE_IN_PROGRESS_CLASS</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngStyleDirective = ngDirective(<span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line">  scope.$watch(attr.ngStyle, <span class="keyword">function</span> ngStyleWatchAction(newStyles, oldStyles) {</div>
<div class="line">    <span class="keywordflow">if</span> (oldStyles &amp;&amp; (newStyles !== oldStyles)) {</div>
<div class="line">      forEach(oldStyles, <span class="keyword">function</span>(val, style) { element.css(style, <span class="stringliteral">&#39;&#39;</span>);});</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (newStyles) element.css(newStyles);</div>
<div class="line">  }, <span class="keyword">true</span>);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngSwitchDirective = [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    require: <span class="stringliteral">&#39;ngSwitch&#39;</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// asks for $scope to fool the BC controller module</span></div>
<div class="line">    controller: [<span class="stringliteral">&#39;$scope&#39;</span>, <span class="keyword">function</span> ngSwitchController() {</div>
<div class="line">     this.cases = {};</div>
<div class="line">    }],</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ngSwitchController) {</div>
<div class="line">      var watchExpr = attr.ngSwitch || attr.on,</div>
<div class="line">          selectedTranscludes = [],</div>
<div class="line">          selectedElements = [],</div>
<div class="line">          previousLeaveAnimations = [],</div>
<div class="line">          selectedScopes = [];</div>
<div class="line"></div>
<div class="line">      var spliceFactory = <span class="keyword">function</span>(array, index) {</div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">function</span>() { array.splice(index, 1); };</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      scope.$watch(watchExpr, <span class="keyword">function</span> ngSwitchWatchAction(value) {</div>
<div class="line">        var i, ii;</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0, ii = previousLeaveAnimations.length; i &lt; ii; ++i) {</div>
<div class="line">          $animate.cancel(previousLeaveAnimations[i]);</div>
<div class="line">        }</div>
<div class="line">        previousLeaveAnimations.length = 0;</div>
<div class="line"></div>
<div class="line">        for (i = 0, ii = selectedScopes.length; i &lt; ii; ++i) {</div>
<div class="line">          var selected = getBlockNodes(selectedElements[i].clone);</div>
<div class="line">          selectedScopes[i].$destroy();</div>
<div class="line">          var promise = previousLeaveAnimations[i] = $animate.leave(selected);</div>
<div class="line">          promise.then(spliceFactory(previousLeaveAnimations, i));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        selectedElements.length = 0;</div>
<div class="line">        selectedScopes.length = 0;</div>
<div class="line"></div>
<div class="line">        if ((selectedTranscludes = ngSwitchController.cases[<span class="charliteral">&#39;!&#39;</span> + value] || ngSwitchController.cases[<span class="charliteral">&#39;?&#39;</span>])) {</div>
<div class="line">          forEach(selectedTranscludes, function(selectedTransclude) {</div>
<div class="line">            selectedTransclude.transclude(function(caseElement, selectedScope) {</div>
<div class="line">              selectedScopes.push(selectedScope);</div>
<div class="line">              var anchor = selectedTransclude.element;</div>
<div class="line">              caseElement[caseElement.length++] = document.createComment(<span class="stringliteral">&#39; end ngSwitchWhen: &#39;</span>);</div>
<div class="line">              var block = { clone: caseElement };</div>
<div class="line"></div>
<div class="line">              selectedElements.push(block);</div>
<div class="line">              $animate.enter(caseElement, anchor.parent(), anchor);</div>
<div class="line">            });</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var ngSwitchWhenDirective = ngDirective({</div>
<div class="line">  transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">  priority: 1200,</div>
<div class="line">  require: <span class="stringliteral">&#39;^ngSwitch&#39;</span>,</div>
<div class="line">  multiElement: <span class="keyword">true</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attrs, ctrl, $transclude) {</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen] = (ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen] || []);</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;!&#39;</span> + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngSwitchDefaultDirective = ngDirective({</div>
<div class="line">  transclude: <span class="stringliteral">&#39;element&#39;</span>,</div>
<div class="line">  priority: 1200,</div>
<div class="line">  require: <span class="stringliteral">&#39;^ngSwitch&#39;</span>,</div>
<div class="line">  multiElement: <span class="keyword">true</span>,</div>
<div class="line">  link: <span class="keyword">function</span>(scope, element, attr, ctrl, $transclude) {</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;?&#39;</span>] = (ctrl.cases[<span class="charliteral">&#39;?&#39;</span>] || []);</div>
<div class="line">    ctrl.cases[<span class="charliteral">&#39;?&#39;</span>].push({ transclude: $transclude, element: element });</div>
<div class="line">   }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var ngTranscludeDirective = ngDirective({</div>
<div class="line">  restrict: <span class="stringliteral">&#39;EAC&#39;</span>,</div>
<div class="line">  link: <span class="keyword">function</span>($scope, $element, $attrs, controller, $transclude) {</div>
<div class="line">    <span class="keywordflow">if</span> (!$transclude) {</div>
<div class="line">      <span class="keywordflow">throw</span> minErr(<span class="stringliteral">&#39;ngTransclude&#39;</span>)(<span class="stringliteral">&#39;orphan&#39;</span>,</div>
<div class="line">       <span class="stringliteral">&#39;Illegal use of ngTransclude directive in the template! &#39;</span> +</div>
<div class="line">       <span class="stringliteral">&#39;No parent directive that requires a transclusion found. &#39;</span> +</div>
<div class="line">       <span class="stringliteral">&#39;Element: {0}&#39;</span>,</div>
<div class="line">       startingTag($element));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    $transclude(<span class="keyword">function</span>(clone) {</div>
<div class="line">      $element.empty();</div>
<div class="line">      $element.append(clone);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var scriptDirective = [<span class="stringliteral">&#39;$templateCache&#39;</span>, <span class="keyword">function</span>($templateCache) {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    terminal: <span class="keyword">true</span>,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line">      <span class="keywordflow">if</span> (attr.type == <span class="stringliteral">&#39;text/ng-template&#39;</span>) {</div>
<div class="line">        var templateUrl = attr.id,</div>
<div class="line">            text = element[0].text;</div>
<div class="line"></div>
<div class="line">        $templateCache.put(templateUrl, text);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var noopNgModelController = { $setViewValue: noop, $render: noop };</div>
<div class="line"></div>
<div class="line">var SelectController =</div>
<div class="line">        [<span class="stringliteral">&#39;$element&#39;</span>, <span class="stringliteral">&#39;$scope&#39;</span>, <span class="stringliteral">&#39;$attrs&#39;</span>, <span class="keyword">function</span>($element, $scope, $attrs) {</div>
<div class="line"></div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">      optionsMap = <span class="keyword">new</span> HashMap();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If the ngModel doesn&#39;t get provided then provide a dummy noop version to prevent errors</span></div>
<div class="line">  <span class="keyword">self</span>.ngModelCtrl = noopNgModelController;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The &quot;unknown&quot; option is one that is prepended to the list if the viewValue</span></div>
<div class="line">  <span class="comment">// does not match any of the options. When it is rendered the value of the unknown</span></div>
<div class="line">  <span class="comment">// option is &#39;? XXX ?&#39; where XXX is the hashKey of the value that is not known.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// We can&#39;t just jqLite(&#39;&lt;option&gt;&#39;) since jqLite is not smart enough</span></div>
<div class="line">  <span class="comment">// to create it in &lt;select&gt; and IE barfs otherwise.</span></div>
<div class="line">  <span class="keyword">self</span>.unknownOption = jqLite(document.createElement(<span class="stringliteral">&#39;option&#39;</span>));</div>
<div class="line">  <span class="keyword">self</span>.renderUnknownOption = <span class="keyword">function</span>(val) {</div>
<div class="line">    var unknownVal = <span class="stringliteral">&#39;? &#39;</span> + hashKey(val) + <span class="stringliteral">&#39; ?&#39;</span>;</div>
<div class="line">    <span class="keyword">self</span>.unknownOption.val(unknownVal);</div>
<div class="line">    $element.prepend(<span class="keyword">self</span>.unknownOption);</div>
<div class="line">    $element.val(unknownVal);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  $scope.$on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">// disable unknown option so that we don&#39;t do work when the whole select is being destroyed</span></div>
<div class="line">    <span class="keyword">self</span>.renderUnknownOption = noop;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keyword">self</span>.removeUnknownOption = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">self</span>.unknownOption.parent()) <span class="keyword">self</span>.unknownOption.remove();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Read the value of the select control, the implementation of this changes depending</span></div>
<div class="line">  <span class="comment">// upon whether the select can have multiple values and whether ngOptions is at work.</span></div>
<div class="line">  <span class="keyword">self</span>.readValue = <span class="keyword">function</span> readSingleValue() {</div>
<div class="line">    <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">    <span class="keywordflow">return</span> $element.val();</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Write the value to the select control, the implementation of this changes depending</span></div>
<div class="line">  <span class="comment">// upon whether the select can have multiple values and whether ngOptions is at work.</span></div>
<div class="line">  <span class="keyword">self</span>.writeValue = <span class="keyword">function</span> writeSingleValue(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">self</span>.hasOption(value)) {</div>
<div class="line">      <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">      $element.val(value);</div>
<div class="line">      <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) <span class="keyword">self</span>.emptyOption.prop(<span class="stringliteral">&#39;selected&#39;</span>, <span class="keyword">true</span>); <span class="comment">// to make IE9 happy</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (value == null &amp;&amp; <span class="keyword">self</span>.emptyOption) {</div>
<div class="line">        <span class="keyword">self</span>.removeUnknownOption();</div>
<div class="line">        $element.val(<span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">self</span>.renderUnknownOption(value);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Tell the select control that an option, with the given value, has been added</span></div>
<div class="line">  <span class="keyword">self</span>.addOption = <span class="keyword">function</span>(value, element) {</div>
<div class="line">    assertNotHasOwnProperty(value, <span class="stringliteral">&#39;&quot;option value&quot;&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">      <span class="keyword">self</span>.emptyOption = element;</div>
<div class="line">    }</div>
<div class="line">    var count = optionsMap.get(value) || 0;</div>
<div class="line">    optionsMap.put(value, count + 1);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Tell the select control that an option, with the given value, has been removed</span></div>
<div class="line">  <span class="keyword">self</span>.removeOption = <span class="keyword">function</span>(value) {</div>
<div class="line">    var count = optionsMap.get(value);</div>
<div class="line">    <span class="keywordflow">if</span> (count) {</div>
<div class="line">      <span class="keywordflow">if</span> (count === 1) {</div>
<div class="line">        optionsMap.remove(value);</div>
<div class="line">        <span class="keywordflow">if</span> (value === <span class="stringliteral">&#39;&#39;</span>) {</div>
<div class="line">          <span class="keyword">self</span>.emptyOption = undefined;</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        optionsMap.put(value, count - 1);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Check whether the select control has an option matching the given value</span></div>
<div class="line">  <span class="keyword">self</span>.hasOption = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> !!optionsMap.get(value);</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var selectDirective = <span class="keyword">function</span>() {</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    require: [<span class="stringliteral">&#39;select&#39;</span>, <span class="stringliteral">&#39;?ngModel&#39;</span>],</div>
<div class="line">    controller: SelectController,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, element, attr, ctrls) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if ngModel is not defined, we don&#39;t need to do anything</span></div>
<div class="line">      var ngModelCtrl = ctrls[1];</div>
<div class="line">      <span class="keywordflow">if</span> (!ngModelCtrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var selectCtrl = ctrls[0];</div>
<div class="line"></div>
<div class="line">      selectCtrl.ngModelCtrl = ngModelCtrl;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// We delegate rendering to the `writeValue` method, which can be changed</span></div>
<div class="line">      <span class="comment">// if the select can have multiple selected values or if the options are being</span></div>
<div class="line">      <span class="comment">// generated by `ngOptions`</span></div>
<div class="line">      ngModelCtrl.$render = <span class="keyword">function</span>() {</div>
<div class="line">        selectCtrl.writeValue(ngModelCtrl.$viewValue);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// When the selected item(s) changes we delegate getting the value of the select control</span></div>
<div class="line">      <span class="comment">// to the `readValue` method, which can be changed if the select can have multiple</span></div>
<div class="line">      <span class="comment">// selected values or if the options are being generated by `ngOptions`</span></div>
<div class="line">      element.on(<span class="stringliteral">&#39;change&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">        scope.$apply(<span class="keyword">function</span>() {</div>
<div class="line">          ngModelCtrl.$setViewValue(selectCtrl.readValue());</div>
<div class="line">        });</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If the select allows multiple values then we need to modify how we read and write</span></div>
<div class="line">      <span class="comment">// values from and to the control; also what it means for the value to be empty and</span></div>
<div class="line">      <span class="comment">// we have to add an extra watch since ngModel doesn&#39;t work well with arrays - it</span></div>
<div class="line">      <span class="comment">// doesn&#39;t trigger rendering if only an item in the array changes.</span></div>
<div class="line">      <span class="keywordflow">if</span> (attr.multiple) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Read value now needs to check each option to see if it is selected</span></div>
<div class="line">        selectCtrl.readValue = <span class="keyword">function</span> readMultipleValue() {</div>
<div class="line">          var array = [];</div>
<div class="line">          forEach(element.find(<span class="stringliteral">&#39;option&#39;</span>), <span class="keyword">function</span>(option) {</div>
<div class="line">            <span class="keywordflow">if</span> (option.selected) {</div>
<div class="line">              array.push(option.value);</div>
<div class="line">            }</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">return</span> array;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Write value now needs to set the selected property of each matching option</span></div>
<div class="line">        selectCtrl.writeValue = <span class="keyword">function</span> writeMultipleValue(value) {</div>
<div class="line">          var items = <span class="keyword">new</span> HashMap(value);</div>
<div class="line">          forEach(element.find(<span class="stringliteral">&#39;option&#39;</span>), <span class="keyword">function</span>(option) {</div>
<div class="line">            option.selected = isDefined(items.get(option.value));</div>
<div class="line">          });</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// we have to do it on each watch since ngModel watches reference, but</span></div>
<div class="line">        <span class="comment">// we need to work of an array, so we need to see if anything was inserted/removed</span></div>
<div class="line">        var lastView, lastViewRef = NaN;</div>
<div class="line">        scope.$watch(<span class="keyword">function</span> selectMultipleWatch() {</div>
<div class="line">          <span class="keywordflow">if</span> (lastViewRef === ngModelCtrl.$viewValue &amp;&amp; !equals(lastView, ngModelCtrl.$viewValue)) {</div>
<div class="line">            lastView = shallowCopy(ngModelCtrl.$viewValue);</div>
<div class="line">            ngModelCtrl.$render();</div>
<div class="line">          }</div>
<div class="line">          lastViewRef = ngModelCtrl.$viewValue;</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// If we are a multiple select then value is now a collection</span></div>
<div class="line">        <span class="comment">// so the meaning of $isEmpty changes</span></div>
<div class="line">        ngModelCtrl.$isEmpty = <span class="keyword">function</span>(value) {</div>
<div class="line">          <span class="keywordflow">return</span> !value || value.length === 0;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The option directive is purely designed to communicate the existence (or lack of)</span></div>
<div class="line"><span class="comment">// of dynamically created (and destroyed) option elements to their containing select</span></div>
<div class="line"><span class="comment">// directive via its controller.</span></div>
<div class="line">var optionDirective = [<span class="stringliteral">&#39;$interpolate&#39;</span>, <span class="keyword">function</span>($interpolate) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> chromeHack(optionElement) {</div>
<div class="line">    <span class="comment">// Workaround for https://code.google.com/p/chromium/issues/detail?id=381459</span></div>
<div class="line">    <span class="comment">// Adding an &lt;option selected=&quot;selected&quot;&gt; element to a &lt;select required=&quot;required&quot;&gt; should</span></div>
<div class="line">    <span class="comment">// automatically select the new element</span></div>
<div class="line">    <span class="keywordflow">if</span> (optionElement[0].hasAttribute(<span class="stringliteral">&#39;selected&#39;</span>)) {</div>
<div class="line">      optionElement[0].selected = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">    priority: 100,</div>
<div class="line">    compile: <span class="keyword">function</span>(element, attr) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">// If the value attribute is not defined then we fall back to the</span></div>
<div class="line">      <span class="comment">// text content of the option element, which may be interpolated</span></div>
<div class="line">      <span class="keywordflow">if</span> (isUndefined(attr.value)) {</div>
<div class="line">        var interpolateFn = $interpolate(element.text(), <span class="keyword">true</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (!interpolateFn) {</div>
<div class="line">          attr.$set(<span class="stringliteral">&#39;value&#39;</span>, element.text());</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">function</span>(scope, element, attr) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This is an optimization over using ^^ since we don&#39;t want to have to search</span></div>
<div class="line">        <span class="comment">// all the way to the root of the DOM for every single option element</span></div>
<div class="line">        var selectCtrlName = <span class="stringliteral">&#39;$selectController&#39;</span>,</div>
<div class="line">            parent = element.parent(),</div>
<div class="line">            selectCtrl = parent.data(selectCtrlName) ||</div>
<div class="line">              parent.parent().data(selectCtrlName); <span class="comment">// in case we are in optgroup</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Only update trigger option updates if this is an option within a `select`</span></div>
<div class="line">        <span class="comment">// that also has `ngModel` attached</span></div>
<div class="line">        <span class="keywordflow">if</span> (selectCtrl &amp;&amp; selectCtrl.ngModelCtrl) {</div>
<div class="line"></div>
<div class="line">          <span class="keywordflow">if</span> (interpolateFn) {</div>
<div class="line">            scope.$watch(interpolateFn, <span class="keyword">function</span> interpolateWatchAction(newVal, oldVal) {</div>
<div class="line">              attr.$set(<span class="stringliteral">&#39;value&#39;</span>, newVal);</div>
<div class="line">              <span class="keywordflow">if</span> (oldVal !== newVal) {</div>
<div class="line">                selectCtrl.removeOption(oldVal);</div>
<div class="line">              }</div>
<div class="line">              selectCtrl.addOption(newVal, element);</div>
<div class="line">              selectCtrl.ngModelCtrl.$render();</div>
<div class="line">              chromeHack(element);</div>
<div class="line">            });</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            selectCtrl.addOption(attr.value, element);</div>
<div class="line">            selectCtrl.ngModelCtrl.$render();</div>
<div class="line">            chromeHack(element);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          element.on(<span class="stringliteral">&#39;$destroy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">            selectCtrl.removeOption(attr.value);</div>
<div class="line">            selectCtrl.ngModelCtrl.$render();</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}];</div>
<div class="line"></div>
<div class="line">var styleDirective = valueFn({</div>
<div class="line">  restrict: <span class="charliteral">&#39;E&#39;</span>,</div>
<div class="line">  terminal: <span class="keyword">false</span></div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">var requiredDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line">      attr.required = <span class="keyword">true</span>; <span class="comment">// force truthy in case we are on non input element</span></div>
<div class="line"></div>
<div class="line">      ctrl.$validators.required = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> !attr.required || !ctrl.$isEmpty(viewValue);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;required&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var patternDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var regexp, patternExp = attr.ngPattern || attr.pattern;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;pattern&#39;</span>, <span class="keyword">function</span>(regex) {</div>
<div class="line">        <span class="keywordflow">if</span> (isString(regex) &amp;&amp; regex.length &gt; 0) {</div>
<div class="line">          regex = new RegExp(<span class="stringliteral">&#39;^&#39;</span> + regex + <span class="stringliteral">&#39;$&#39;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        if (regex &amp;&amp; !regex.test) {</div>
<div class="line">          throw minErr(<span class="stringliteral">&#39;ngPattern&#39;</span>)(<span class="stringliteral">&#39;noregexp&#39;</span>,</div>
<div class="line">            <span class="stringliteral">&#39;Expected {0} to be a RegExp but was {1}. Element: {2}&#39;</span>, patternExp,</div>
<div class="line">            regex, startingTag(elm));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        regexp = regex || undefined;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      ctrl.$validators.pattern = <span class="keyword">function</span>(value) {</div>
<div class="line">        <span class="keywordflow">return</span> ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">var maxlengthDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var maxlength = -1;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;maxlength&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">        var intVal = toInt(value);</div>
<div class="line">        maxlength = isNaN(intVal) ? -1 : intVal;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">      ctrl.$validators.maxlength = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> (maxlength &lt; 0) || ctrl.$isEmpty(viewValue) || (viewValue.length &lt;= maxlength);</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">var minlengthDirective = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    restrict: <span class="charliteral">&#39;A&#39;</span>,</div>
<div class="line">    require: <span class="stringliteral">&#39;?ngModel&#39;</span>,</div>
<div class="line">    link: <span class="keyword">function</span>(scope, elm, attr, ctrl) {</div>
<div class="line">      <span class="keywordflow">if</span> (!ctrl) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">      var minlength = 0;</div>
<div class="line">      attr.$observe(<span class="stringliteral">&#39;minlength&#39;</span>, <span class="keyword">function</span>(value) {</div>
<div class="line">        minlength = toInt(value) || 0;</div>
<div class="line">        ctrl.$validate();</div>
<div class="line">      });</div>
<div class="line">      ctrl.$validators.minlength = <span class="keyword">function</span>(modelValue, viewValue) {</div>
<div class="line">        <span class="keywordflow">return</span> ctrl.$isEmpty(viewValue) || viewValue.length &gt;= minlength;</div>
<div class="line">      };</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (window.angular.bootstrap) {</div>
<div class="line">  <span class="comment">//AngularJS is already loaded, so we can return here...</span></div>
<div class="line">  console.log(<span class="stringliteral">&#39;WARNING: Tried to load angular more than once.&#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//try to bind to jquery now so that one can write jqLite(document).ready()</span></div>
<div class="line"><span class="comment">//but we will rebind on bootstrap again.</span></div>
<div class="line">bindJQuery();</div>
<div class="line"></div>
<div class="line">publishExternalAPI(angular);</div>
<div class="line"></div>
<div class="line">angular.module(<span class="stringliteral">&quot;ngLocale&quot;</span>, [], [<span class="stringliteral">&quot;$provide&quot;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">var PLURAL_CATEGORY = {ZERO: <span class="stringliteral">&quot;zero&quot;</span>, ONE: <span class="stringliteral">&quot;one&quot;</span>, TWO: <span class="stringliteral">&quot;two&quot;</span>, FEW: <span class="stringliteral">&quot;few&quot;</span>, MANY: <span class="stringliteral">&quot;many&quot;</span>, OTHER: <span class="stringliteral">&quot;other&quot;</span>};</div>
<div class="line"><span class="keyword">function</span> getDecimals(n) {</div>
<div class="line">  n = n + <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  var i = n.indexOf(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> (i == -1) ? 0 : n.length - i - 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> getVF(n, opt_precision) {</div>
<div class="line">  var v = opt_precision;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (undefined === v) {</div>
<div class="line">    v = Math.min(getDecimals(n), 3);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var base = Math.pow(10, v);</div>
<div class="line">  var f = ((n * base) | 0) % base;</div>
<div class="line">  <span class="keywordflow">return</span> {v: v, f: f};</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">$provide.value(<span class="stringliteral">&quot;$locale&quot;</span>, {</div>
<div class="line">  <span class="stringliteral">&quot;DATETIME_FORMATS&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;AMPMS&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;AM&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;PM&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;DAY&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Sunday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Monday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Tuesday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Wednesday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Thursday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Friday&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Saturday&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;ERANAMES&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Before Christ&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Anno Domini&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;ERAS&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;BC&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;AD&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;FIRSTDAYOFWEEK&quot;</span>: 6,</div>
<div class="line">    <span class="stringliteral">&quot;MONTH&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;January&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;February&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;March&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;April&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;May&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;June&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;July&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;August&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;September&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;October&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;November&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;December&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;SHORTDAY&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Sun&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Mon&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Tue&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Wed&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Thu&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Fri&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Sat&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;SHORTMONTH&quot;</span>: [</div>
<div class="line">      <span class="stringliteral">&quot;Jan&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Feb&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Mar&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Apr&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;May&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Jun&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Jul&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Aug&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Sep&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Oct&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Nov&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;Dec&quot;</span></div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;WEEKENDRANGE&quot;</span>: [</div>
<div class="line">      5,</div>
<div class="line">      6</div>
<div class="line">    ],</div>
<div class="line">    <span class="stringliteral">&quot;fullDate&quot;</span>: <span class="stringliteral">&quot;EEEE, MMMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;longDate&quot;</span>: <span class="stringliteral">&quot;MMMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;medium&quot;</span>: <span class="stringliteral">&quot;MMM d, y h:mm:ss a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;mediumDate&quot;</span>: <span class="stringliteral">&quot;MMM d, y&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;mediumTime&quot;</span>: <span class="stringliteral">&quot;h:mm:ss a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;short&quot;</span>: <span class="stringliteral">&quot;M/d/yy h:mm a&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;shortDate&quot;</span>: <span class="stringliteral">&quot;M/d/yy&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;shortTime&quot;</span>: <span class="stringliteral">&quot;h:mm a&quot;</span></div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;NUMBER_FORMATS&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;CURRENCY_SYM&quot;</span>: <span class="stringliteral">&quot;$&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;DECIMAL_SEP&quot;</span>: <span class="stringliteral">&quot;.&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;GROUP_SEP&quot;</span>: <span class="stringliteral">&quot;,&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;PATTERNS&quot;</span>: [</div>
<div class="line">      {</div>
<div class="line">        <span class="stringliteral">&quot;gSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;lgSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;maxFrac&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;minFrac&quot;</span>: 0,</div>
<div class="line">        <span class="stringliteral">&quot;minInt&quot;</span>: 1,</div>
<div class="line">        <span class="stringliteral">&quot;negPre&quot;</span>: <span class="stringliteral">&quot;-&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;negSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posPre&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">      },</div>
<div class="line">      {</div>
<div class="line">        <span class="stringliteral">&quot;gSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;lgSize&quot;</span>: 3,</div>
<div class="line">        <span class="stringliteral">&quot;maxFrac&quot;</span>: 2,</div>
<div class="line">        <span class="stringliteral">&quot;minFrac&quot;</span>: 2,</div>
<div class="line">        <span class="stringliteral">&quot;minInt&quot;</span>: 1,</div>
<div class="line">        <span class="stringliteral">&quot;negPre&quot;</span>: <span class="stringliteral">&quot;-\u00a4&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;negSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posPre&quot;</span>: <span class="stringliteral">&quot;\u00a4&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;posSuf&quot;</span>: <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;id&quot;</span>: <span class="stringliteral">&quot;en-us&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;pluralCat&quot;</span>: <span class="keyword">function</span>(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  <span class="keywordflow">if</span> (i == 1 &amp;&amp; vf.v == 0) {    <span class="keywordflow">return</span> PLURAL_CATEGORY.ONE;  }  <span class="keywordflow">return</span> PLURAL_CATEGORY.OTHER;}</div>
<div class="line">});</div>
<div class="line">}]);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Public namespace</span></div>
<div class="line">angular.scenario = angular.scenario || {};</div>
<div class="line"></div>
<div class="line">angular.scenario.jQuery = _jQuery;</div>
<div class="line"></div>
<div class="line">angular.scenario.output = angular.scenario.output || <span class="keyword">function</span>(name, fn) {</div>
<div class="line">  angular.scenario.output[name] = fn;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl = angular.scenario.dsl || <span class="keyword">function</span>(name, fn) {</div>
<div class="line">  angular.scenario.dsl[name] = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="comment">/* jshint -W040 */</span><span class="comment">/* The dsl binds `this` for us when calling chained functions */</span></div>
<div class="line">    <span class="keyword">function</span> executeStatement(statement, args) {</div>
<div class="line">      var result = statement.apply(<span class="keyword">this</span>, args);</div>
<div class="line">      <span class="keywordflow">if</span> (angular.isFunction(result) || result instanceof angular.scenario.Future) {</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">      }</div>
<div class="line">      var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">      var chain = angular.extend({}, result);</div>
<div class="line">      angular.forEach(chain, <span class="keyword">function</span>(value, name) {</div>
<div class="line">        <span class="keywordflow">if</span> (angular.isFunction(value)) {</div>
<div class="line">          chain[name] = <span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> executeStatement.call(<span class="keyword">self</span>, value, arguments);</div>
<div class="line">          };</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          chain[name] = value;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> chain;</div>
<div class="line">    }</div>
<div class="line">    var statement = fn.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> executeStatement.call(<span class="keyword">this</span>, statement, arguments);</div>
<div class="line">    };</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher = angular.scenario.matcher || <span class="keyword">function</span>(name, fn) {</div>
<div class="line">  angular.scenario.matcher[name] = <span class="keyword">function</span>(expected) {</div>
<div class="line">    var description = this.future.name +</div>
<div class="line">                      (this.inverse ? <span class="stringliteral">&#39; not &#39;</span> : <span class="charliteral">&#39; &#39;</span>) + name +</div>
<div class="line">                      <span class="charliteral">&#39; &#39;</span> + angular.toJson(expected);</div>
<div class="line">    var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">    this.addFuture(<span class="stringliteral">&#39;expect &#39;</span> + description,</div>
<div class="line">      <span class="keyword">function</span>(done) {</div>
<div class="line">        var error;</div>
<div class="line">        <span class="keyword">self</span>.actual = <span class="keyword">self</span>.future.value;</div>
<div class="line">        <span class="keywordflow">if</span> ((<span class="keyword">self</span>.inverse &amp;&amp; fn.call(<span class="keyword">self</span>, expected)) ||</div>
<div class="line">            (!<span class="keyword">self</span>.inverse &amp;&amp; !fn.call(<span class="keyword">self</span>, expected))) {</div>
<div class="line">          error = <span class="stringliteral">&#39;expected &#39;</span> + description +</div>
<div class="line">            <span class="stringliteral">&#39; but was &#39;</span> + angular.toJson(<span class="keyword">self</span>.actual);</div>
<div class="line">        }</div>
<div class="line">        done(error);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.setUpAndRun = <span class="keyword">function</span>(config) {</div>
<div class="line">  var href = window.location.href;</div>
<div class="line">  var body = _jQuery(document.body);</div>
<div class="line">  var output = [];</div>
<div class="line">  var objModel = <span class="keyword">new</span> angular.scenario.ObjectModel($runner);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (config &amp;&amp; config.scenario_output) {</div>
<div class="line">    output = config.scenario_output.split(<span class="charliteral">&#39;,&#39;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  angular.forEach(angular.scenario.output, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">    if (!output.length || output.indexOf(name) != -1) {</div>
<div class="line">      var context = body.append(<span class="stringliteral">&#39;&lt;div&gt;&lt;/div&gt;&#39;</span>).find(<span class="stringliteral">&#39;div:last&#39;</span>);</div>
<div class="line">      context.attr(<span class="stringliteral">&#39;id&#39;</span>, name);</div>
<div class="line">      fn.call({}, context, $runner, objModel);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!/^http/.test(href) &amp;&amp; !/^https/.test(href)) {</div>
<div class="line">    body.append(<span class="stringliteral">&#39;&lt;p id=&quot;system-error&quot;&gt;&lt;/p&gt;&#39;</span>);</div>
<div class="line">    body.find(<span class="stringliteral">&#39;#system-error&#39;</span>).text(</div>
<div class="line">      <span class="stringliteral">&#39;Scenario runner must be run using http or https. The protocol &#39;</span> +</div>
<div class="line">      href.split(<span class="charliteral">&#39;:&#39;</span>)[0] + <span class="stringliteral">&#39;:// is not supported.&#39;</span></div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var appFrame = body.append(<span class="stringliteral">&#39;&lt;div id=&quot;application&quot;&gt;&lt;/div&gt;&#39;</span>).find(<span class="stringliteral">&#39;#application&#39;</span>);</div>
<div class="line">  var application = <span class="keyword">new</span> angular.scenario.Application(appFrame);</div>
<div class="line"></div>
<div class="line">  $runner.on(<span class="stringliteral">&#39;RunnerEnd&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    appFrame.css(<span class="stringliteral">&#39;display&#39;</span>, <span class="stringliteral">&#39;none&#39;</span>);</div>
<div class="line">    appFrame.find(<span class="stringliteral">&#39;iframe&#39;</span>).attr(<span class="stringliteral">&#39;src&#39;</span>, <span class="stringliteral">&#39;about:blank&#39;</span>);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  $runner.on(<span class="stringliteral">&#39;RunnerError&#39;</span>, <span class="keyword">function</span>(error) {</div>
<div class="line">    <span class="keywordflow">if</span> (window.console) {</div>
<div class="line">      console.log(formatException(error));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Do something for IE</span></div>
<div class="line">      alert(error);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  $runner.run(application);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> asyncForEach(list, iterator, done) {</div>
<div class="line">  var i = 0;</div>
<div class="line">  <span class="keyword">function</span> loop(error, index) {</div>
<div class="line">    <span class="keywordflow">if</span> (index &amp;&amp; index &gt; i) {</div>
<div class="line">      i = index;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (error || i &gt;= list.length) {</div>
<div class="line">      done(error);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        iterator(list[i++], loop);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        done(e);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  loop();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> formatException(error, maxStackLines) {</div>
<div class="line">  maxStackLines = maxStackLines || 5;</div>
<div class="line">  var message = error.toString();</div>
<div class="line">  <span class="keywordflow">if</span> (error.stack) {</div>
<div class="line">    var stack = error.stack.split(<span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (stack[0].indexOf(message) === -1) {</div>
<div class="line">      maxStackLines++;</div>
<div class="line">      stack.unshift(error.message);</div>
<div class="line">    }</div>
<div class="line">    message = stack.slice(0, maxStackLines).join(<span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> message;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">function</span> callerFile(offset) {</div>
<div class="line">  var error = <span class="keyword">new</span> Error();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    var line = (error.stack || <span class="stringliteral">&#39;&#39;</span>).split(<span class="charliteral">&#39;\n&#39;</span>)[offset];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Clean up the stack trace line</span></div>
<div class="line">    <span class="keywordflow">if</span> (line) {</div>
<div class="line">      <span class="keywordflow">if</span> (line.indexOf(<span class="charliteral">&#39;@&#39;</span>) !== -1) {</div>
<div class="line">        <span class="comment">// Firefox</span></div>
<div class="line">        line = line.substring(line.indexOf(<span class="charliteral">&#39;@&#39;</span>) + 1);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Chrome</span></div>
<div class="line">        line = line.substring(line.indexOf(<span class="charliteral">&#39;(&#39;</span>) + 1).replace(<span class="charliteral">&#39;)&#39;</span>, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> line || <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>(fn) {</div>
<div class="line">  <span class="comment">// We need a handle to the original trigger function for input tests.</span></div>
<div class="line">  var parentTrigger = fn._originalTrigger = fn.trigger;</div>
<div class="line">  fn.trigger = <span class="keyword">function</span>(type) {</div>
<div class="line">    <span class="keywordflow">if</span> (/(click|change|keydown|blur|input|mousedown|mouseup)/.test(type)) {</div>
<div class="line">      var processDefaults = [];</div>
<div class="line">      this.each(<span class="keyword">function</span>(index, node) {</div>
<div class="line">        processDefaults.push(browserTrigger(node, type));</div>
<div class="line">      });</div>
<div class="line"></div>
<div class="line">      <span class="comment">// this is not compatible with jQuery - we return an array of returned values,</span></div>
<div class="line">      <span class="comment">// so that scenario runner know whether JS code has preventDefault() of the event or not...</span></div>
<div class="line">      <span class="keywordflow">return</span> processDefaults;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> parentTrigger.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">  };</div>
<div class="line">})(_jQuery.fn);</div>
<div class="line"></div>
<div class="line">_jQuery.fn.bindings = <span class="keyword">function</span>(windowJquery, bindExp) {</div>
<div class="line">  var result = [], match,</div>
<div class="line">      bindSelector = <span class="stringliteral">&#39;.ng-binding:visible&#39;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (angular.isString(bindExp)) {</div>
<div class="line">    bindExp = bindExp.replace(/\s/g, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">    match = <span class="keyword">function</span>(actualExp) {</div>
<div class="line">      <span class="keywordflow">if</span> (actualExp) {</div>
<div class="line">        actualExp = actualExp.replace(/\s/g, <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (actualExp == bindExp) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (actualExp.indexOf(bindExp) === 0) {</div>
<div class="line">          <span class="keywordflow">return</span> actualExp.charAt(bindExp.length) == <span class="charliteral">&#39;|&#39;</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bindExp) {</div>
<div class="line">    match = <span class="keyword">function</span>(actualExp) {</div>
<div class="line">      <span class="keywordflow">return</span> actualExp &amp;&amp; bindExp.exec(actualExp);</div>
<div class="line">    };</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    match = <span class="keyword">function</span>(actualExp) {</div>
<div class="line">      <span class="keywordflow">return</span> !!actualExp;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">  var selection = this.find(bindSelector);</div>
<div class="line">  <span class="keywordflow">if</span> (this.is(bindSelector)) {</div>
<div class="line">    selection = selection.add(<span class="keyword">this</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> push(value) {</div>
<div class="line">    <span class="keywordflow">if</span> (value === undefined) {</div>
<div class="line">      value = <span class="stringliteral">&#39;&#39;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (typeof value !== <span class="stringliteral">&#39;string&#39;</span>) {</div>
<div class="line">      value = angular.toJson(value);</div>
<div class="line">    }</div>
<div class="line">    result.push(<span class="stringliteral">&#39;&#39;</span> + value);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  selection.each(<span class="keyword">function</span>() {</div>
<div class="line">    var element = windowJquery(<span class="keyword">this</span>),</div>
<div class="line">        bindings;</div>
<div class="line">    <span class="keywordflow">if</span> (bindings = element.data(<span class="stringliteral">&#39;$binding&#39;</span>)) {</div>
<div class="line">      <span class="keywordflow">for</span> (var expressions = [], binding, j=0, jj=bindings.length; j &lt; jj; j++) {</div>
<div class="line">        binding = bindings[j];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (binding.expressions) {</div>
<div class="line">          expressions = binding.expressions;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          expressions = [binding];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">for</span> (var scope, expression, i = 0, ii = expressions.length; i &lt; ii; i++) {</div>
<div class="line">          expression = expressions[i];</div>
<div class="line">          <span class="keywordflow">if</span> (match(expression)) {</div>
<div class="line">            scope = scope || element.scope();</div>
<div class="line">            push(scope.$eval(expression));</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">(<span class="keyword">function</span>() {</div>
<div class="line">  window.browserTrigger = <span class="keyword">function</span> browserTrigger(element, eventType, eventData) {</div>
<div class="line">    <span class="keywordflow">if</span> (element &amp;&amp; !element.nodeName) element = element[0];</div>
<div class="line">    <span class="keywordflow">if</span> (!element) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    eventData = eventData || {};</div>
<div class="line">    var keys = eventData.keys;</div>
<div class="line">    var x = eventData.x;</div>
<div class="line">    var y = eventData.y;</div>
<div class="line"></div>
<div class="line">    var inputType = (element.type) ? element.type.toLowerCase() : null,</div>
<div class="line">        nodeName = element.nodeName.toLowerCase();</div>
<div class="line">    <span class="keywordflow">if</span> (!eventType) {</div>
<div class="line">      eventType = {</div>
<div class="line">        <span class="stringliteral">&#39;text&#39;</span>:            <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;textarea&#39;</span>:        <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;hidden&#39;</span>:          <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;password&#39;</span>:        <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;button&#39;</span>:          <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;submit&#39;</span>:          <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;reset&#39;</span>:           <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;image&#39;</span>:           <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;checkbox&#39;</span>:        <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;radio&#39;</span>:           <span class="stringliteral">&#39;click&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;select-one&#39;</span>:      <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;select-multiple&#39;</span>: <span class="stringliteral">&#39;change&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;_default_&#39;</span>:       <span class="stringliteral">&#39;click&#39;</span></div>
<div class="line">      }[inputType || <span class="stringliteral">&#39;_default_&#39;</span>];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (nodeName == <span class="stringliteral">&#39;option&#39;</span>) {</div>
<div class="line">      element.parentNode.value = element.value;</div>
<div class="line">      element = element.parentNode;</div>
<div class="line">      eventType = <span class="stringliteral">&#39;change&#39;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    keys = keys || [];</div>
<div class="line">    <span class="keyword">function</span> pressed(key) {</div>
<div class="line">      <span class="keywordflow">return</span> keys.indexOf(key) !== -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    var evnt;</div>
<div class="line">    <span class="keywordflow">if</span> (/transitionend/.test(eventType)) {</div>
<div class="line">      <span class="keywordflow">if</span> (window.WebKitTransitionEvent) {</div>
<div class="line">        evnt = <span class="keyword">new</span> WebKitTransitionEvent(eventType, eventData);</div>
<div class="line">        evnt.initEvent(eventType, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          evnt = <span class="keyword">new</span> TransitionEvent(eventType, eventData);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          evnt = document.createEvent(<span class="stringliteral">&#39;TransitionEvent&#39;</span>);</div>
<div class="line">          evnt.initTransitionEvent(eventType, null, null, null, eventData.elapsedTime || 0);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (/animationend/.test(eventType)) {</div>
<div class="line">      <span class="keywordflow">if</span> (window.WebKitAnimationEvent) {</div>
<div class="line">        evnt = <span class="keyword">new</span> WebKitAnimationEvent(eventType, eventData);</div>
<div class="line">        evnt.initEvent(eventType, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          evnt = <span class="keyword">new</span> AnimationEvent(eventType, eventData);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          evnt = document.createEvent(<span class="stringliteral">&#39;AnimationEvent&#39;</span>);</div>
<div class="line">          evnt.initAnimationEvent(eventType, null, null, null, eventData.elapsedTime || 0);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (/touch/.test(eventType) &amp;&amp; supportsTouchEvents()) {</div>
<div class="line">      evnt = createTouchEvent(element, eventType, x, y);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      evnt = document.createEvent(<span class="stringliteral">&#39;MouseEvents&#39;</span>);</div>
<div class="line">      x = x || 0;</div>
<div class="line">      y = y || 0;</div>
<div class="line">      evnt.initMouseEvent(eventType, <span class="keyword">true</span>, <span class="keyword">true</span>, window, 0, x, y, x, y, pressed(<span class="stringliteral">&#39;ctrl&#39;</span>),</div>
<div class="line">          pressed(<span class="stringliteral">&#39;alt&#39;</span>), pressed(<span class="stringliteral">&#39;shift&#39;</span>), pressed(<span class="stringliteral">&#39;meta&#39;</span>), 0, element);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* we&#39;re unable to change the timeStamp value directly so this</span></div>
<div class="line"><span class="comment">     * is only here to allow for testing where the timeStamp value is</span></div>
<div class="line"><span class="comment">     * read */</span></div>
<div class="line">    evnt.$manualTimeStamp = eventData.timeStamp;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!evnt) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    var originalPreventDefault = evnt.preventDefault,</div>
<div class="line">        appWindow = element.ownerDocument.defaultView,</div>
<div class="line">        fakeProcessDefault = <span class="keyword">true</span>,</div>
<div class="line">        finalProcessDefault,</div>
<div class="line">        angular = appWindow.angular || {};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// igor: temporary fix for https://bugzilla.mozilla.org/show_bug.cgi?id=684208</span></div>
<div class="line">    angular[<span class="stringliteral">&#39;ff-684208-preventDefault&#39;</span>] = <span class="keyword">false</span>;</div>
<div class="line">    evnt.preventDefault = <span class="keyword">function</span>() {</div>
<div class="line">      fakeProcessDefault = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">return</span> originalPreventDefault.apply(evnt, arguments);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    element.dispatchEvent(evnt);</div>
<div class="line">    finalProcessDefault = !(angular[<span class="stringliteral">&#39;ff-684208-preventDefault&#39;</span>] || !fakeProcessDefault);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">delete</span> angular[<span class="stringliteral">&#39;ff-684208-preventDefault&#39;</span>];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> finalProcessDefault;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> supportsTouchEvents() {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="stringliteral">&#39;_cached&#39;</span> in supportsTouchEvents) {</div>
<div class="line">      <span class="keywordflow">return</span> supportsTouchEvents._cached;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!document.createTouch || !document.createTouchList) {</div>
<div class="line">      supportsTouchEvents._cached = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      document.createEvent(<span class="stringliteral">&#39;TouchEvent&#39;</span>);</div>
<div class="line">    } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">      supportsTouchEvents._cached = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    supportsTouchEvents._cached = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> createTouchEvent(element, eventType, x, y) {</div>
<div class="line">    var evnt = <span class="keyword">new</span> Event(eventType);</div>
<div class="line">    x = x || 0;</div>
<div class="line">    y = y || 0;</div>
<div class="line"></div>
<div class="line">    var touch = document.createTouch(window, element, Date.now(), x, y, x, y);</div>
<div class="line">    var touches = document.createTouchList(touch);</div>
<div class="line"></div>
<div class="line">    evnt.touches = touches;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> evnt;</div>
<div class="line">  }</div>
<div class="line">}());</div>
<div class="line"></div>
<div class="line">angular.scenario.Application = <span class="keyword">function</span>(context) {</div>
<div class="line">  this.context = context;</div>
<div class="line">  context.append(</div>
<div class="line">    <span class="stringliteral">&#39;&lt;h2&gt;Current URL: &lt;a href=&quot;about:blank&quot;&gt;None&lt;/a&gt;&lt;/h2&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;&lt;div id=&quot;test-frames&quot;&gt;&lt;/div&gt;&#39;</span></div>
<div class="line">  );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Application.prototype.getFrame_ = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.context.find(<span class="stringliteral">&#39;#test-frames iframe:last&#39;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Application.prototype.getWindow_ = <span class="keyword">function</span>() {</div>
<div class="line">  var contentWindow = this.getFrame_().prop(<span class="stringliteral">&#39;contentWindow&#39;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (!contentWindow) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="stringliteral">&#39;Frame window is not accessible.&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> contentWindow;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Application.prototype.navigateTo = <span class="keyword">function</span>(url, loadFn, errorFn) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  var frame = <span class="keyword">self</span>.getFrame_();</div>
<div class="line">  <span class="comment">//TODO(esprehn): Refactor to use rethrow()</span></div>
<div class="line">  errorFn = errorFn || <span class="keyword">function</span>(e) { <span class="keywordflow">throw</span> e; };</div>
<div class="line">  <span class="keywordflow">if</span> (url === <span class="stringliteral">&#39;about:blank&#39;</span>) {</div>
<div class="line">    errorFn(<span class="stringliteral">&#39;Sandbox Error: Navigating to about:blank is not allowed.&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (url.charAt(0) === <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">    url = frame.attr(<span class="stringliteral">&#39;src&#39;</span>).split(<span class="charliteral">&#39;#&#39;</span>)[0] + url;</div>
<div class="line">    frame.attr(<span class="stringliteral">&#39;src&#39;</span>, url);</div>
<div class="line">    <span class="keyword">self</span>.executeAction(loadFn);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    frame.remove();</div>
<div class="line">    <span class="keyword">self</span>.context.find(<span class="stringliteral">&#39;#test-frames&#39;</span>).append(<span class="stringliteral">&#39;&lt;iframe&gt;&#39;</span>);</div>
<div class="line">    frame = <span class="keyword">self</span>.getFrame_();</div>
<div class="line"></div>
<div class="line">    frame.load(<span class="keyword">function</span>() {</div>
<div class="line">      frame.off();</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        var $window = <span class="keyword">self</span>.getWindow_();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!$window.angular) {</div>
<div class="line">          <span class="keyword">self</span>.executeAction(loadFn);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!$window.angular.resumeBootstrap) {</div>
<div class="line">          $window.angular.resumeDeferredBootstrap = resumeDeferredBootstrap;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          resumeDeferredBootstrap();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        errorFn(e);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keyword">function</span> resumeDeferredBootstrap() {</div>
<div class="line">        <span class="comment">// Disable animations</span></div>
<div class="line">        var $injector = $window.angular.resumeBootstrap([[<span class="stringliteral">&#39;$provide&#39;</span>, <span class="keyword">function</span>($provide) {</div>
<div class="line">          <span class="keywordflow">return</span> [<span class="stringliteral">&#39;$animate&#39;</span>, <span class="keyword">function</span>($animate) {</div>
<div class="line">            $animate.enabled(<span class="keyword">false</span>);</div>
<div class="line">          }];</div>
<div class="line">        }]]);</div>
<div class="line">        <span class="keyword">self</span>.rootElement = $injector.get(<span class="stringliteral">&#39;$rootElement&#39;</span>)[0];</div>
<div class="line">        <span class="keyword">self</span>.executeAction(loadFn);</div>
<div class="line">      }</div>
<div class="line">    }).attr(<span class="stringliteral">&#39;src&#39;</span>, url);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// for IE compatibility set the name *after* setting the frame url</span></div>
<div class="line">    frame[0].contentWindow.name = <span class="stringliteral">&quot;NG_DEFER_BOOTSTRAP!&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">self</span>.context.find(<span class="stringliteral">&#39;&gt; h2 a&#39;</span>).attr(<span class="stringliteral">&#39;href&#39;</span>, url).text(url);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Application.prototype.executeAction = <span class="keyword">function</span>(action) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  var $window = this.getWindow_();</div>
<div class="line">  <span class="keywordflow">if</span> (!$window.document) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="stringliteral">&#39;Sandbox Error: Application document not accessible.&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!$window.angular) {</div>
<div class="line">    <span class="keywordflow">return</span> action.call(<span class="keyword">this</span>, $window, _jQuery($window.document));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!!this.rootElement) {</div>
<div class="line">    executeWithElement(this.rootElement);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    angularInit($window.document, angular.bind(<span class="keyword">this</span>, executeWithElement));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> executeWithElement(element) {</div>
<div class="line">    var $injector = $window.angular.element(element).injector();</div>
<div class="line">    var $element = _jQuery(element);</div>
<div class="line"></div>
<div class="line">    $element.injector = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> $injector;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    $injector.invoke(<span class="keyword">function</span>($browser) {</div>
<div class="line">      $browser.notifyWhenNoOutstandingRequests(<span class="keyword">function</span>() {</div>
<div class="line">        action.call(<span class="keyword">self</span>, $window, $element);</div>
<div class="line">      });</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe = <span class="keyword">function</span>(descName, parent) {</div>
<div class="line">  this.only = parent &amp;&amp; parent.only;</div>
<div class="line">  this.beforeEachFns = [];</div>
<div class="line">  this.afterEachFns = [];</div>
<div class="line">  this.its = [];</div>
<div class="line">  this.children = [];</div>
<div class="line">  this.name = descName;</div>
<div class="line">  this.parent = parent;</div>
<div class="line">  this.<span class="keywordtype">id</span> = angular.scenario.Describe.id++;</div>
<div class="line"></div>
<div class="line">  var beforeEachFns = this.beforeEachFns;</div>
<div class="line">  this.setupBefore = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">if</span> (parent) parent.setupBefore.call(<span class="keyword">this</span>);</div>
<div class="line">    angular.forEach(beforeEachFns, <span class="keyword">function</span>(fn) { fn.call(<span class="keyword">this</span>); }, <span class="keyword">this</span>);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  var afterEachFns = this.afterEachFns;</div>
<div class="line">  this.setupAfter  = <span class="keyword">function</span>() {</div>
<div class="line">    angular.forEach(afterEachFns, <span class="keyword">function</span>(fn) { fn.call(<span class="keyword">this</span>); }, <span class="keyword">this</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (parent) parent.setupAfter.call(<span class="keyword">this</span>);</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Shared Unique ID generator for every describe block</span></div>
<div class="line">angular.scenario.Describe.id = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Shared Unique ID generator for every it (spec)</span></div>
<div class="line">angular.scenario.Describe.specId = 0;</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.beforeEach = <span class="keyword">function</span>(body) {</div>
<div class="line">  this.beforeEachFns.push(body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.afterEach = <span class="keyword">function</span>(body) {</div>
<div class="line">  this.afterEachFns.push(body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.describe = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  var child = <span class="keyword">new</span> angular.scenario.Describe(name, <span class="keyword">this</span>);</div>
<div class="line">  this.children.push(child);</div>
<div class="line">  body.call(child);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.ddescribe = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  var child = <span class="keyword">new</span> angular.scenario.Describe(name, <span class="keyword">this</span>);</div>
<div class="line">  child.only = <span class="keyword">true</span>;</div>
<div class="line">  this.children.push(child);</div>
<div class="line">  body.call(child);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.xdescribe = angular.noop;</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.it = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  this.its.push({</div>
<div class="line">    <span class="keywordtype">id</span>: angular.scenario.Describe.specId++,</div>
<div class="line">    definition: <span class="keyword">this</span>,</div>
<div class="line">    only: this.only,</div>
<div class="line">    name: name,</div>
<div class="line">    before: this.setupBefore,</div>
<div class="line">    body: body,</div>
<div class="line">    after: this.setupAfter</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.iit = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  this.it.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">  this.its[this.its.length - 1].only = <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.xit = angular.noop;</div>
<div class="line"></div>
<div class="line">angular.scenario.Describe.prototype.getSpecs = <span class="keyword">function</span>() {</div>
<div class="line">  var specs = arguments[0] || [];</div>
<div class="line">  angular.forEach(this.children, <span class="keyword">function</span>(child) {</div>
<div class="line">    child.getSpecs(specs);</div>
<div class="line">  });</div>
<div class="line">  angular.forEach(this.its, <span class="keyword">function</span>(it) {</div>
<div class="line">    specs.push(it);</div>
<div class="line">  });</div>
<div class="line">  var only = [];</div>
<div class="line">  angular.forEach(specs, <span class="keyword">function</span>(it) {</div>
<div class="line">    <span class="keywordflow">if</span> (it.only) {</div>
<div class="line">      only.push(it);</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> (only.length &amp;&amp; only) || specs;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Future = <span class="keyword">function</span>(name, behavior, line) {</div>
<div class="line">  this.name = name;</div>
<div class="line">  this.behavior = behavior;</div>
<div class="line">  this.fulfilled = <span class="keyword">false</span>;</div>
<div class="line">  this.value = undefined;</div>
<div class="line">  this.parser = angular.identity;</div>
<div class="line">  this.line = line || <span class="keyword">function</span>() { <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;</span>; };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Future.prototype.execute = <span class="keyword">function</span>(doneFn) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  this.behavior(<span class="keyword">function</span>(error, result) {</div>
<div class="line">    <span class="keyword">self</span>.fulfilled = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (result) {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        result = <span class="keyword">self</span>.parser(result);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        error = e;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">self</span>.value = error || result;</div>
<div class="line">    doneFn(error, result);</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Future.prototype.parsedWith = <span class="keyword">function</span>(fn) {</div>
<div class="line">  this.parser = fn;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Future.prototype.fromJson = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.parsedWith(angular.fromJson);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Future.prototype.toJson = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.parsedWith(angular.toJson);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel = <span class="keyword">function</span>(runner) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line"></div>
<div class="line">  this.specMap = {};</div>
<div class="line">  this.listeners = [];</div>
<div class="line">  this.value = {</div>
<div class="line">    name: <span class="stringliteral">&#39;&#39;</span>,</div>
<div class="line">    children: {}</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecBegin&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var block = <span class="keyword">self</span>.value,</div>
<div class="line">        definitions = [];</div>
<div class="line"></div>
<div class="line">    angular.forEach(<span class="keyword">self</span>.getDefinitionPath(spec), <span class="keyword">function</span>(def) {</div>
<div class="line">      <span class="keywordflow">if</span> (!block.children[def.name]) {</div>
<div class="line">        block.children[def.name] = {</div>
<div class="line">          id: def.id,</div>
<div class="line">          name: def.name,</div>
<div class="line">          children: {},</div>
<div class="line">          specs: {}</div>
<div class="line">        };</div>
<div class="line">      }</div>
<div class="line">      block = block.children[def.name];</div>
<div class="line">      definitions.push(def.name);</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    var it = <span class="keyword">self</span>.specMap[spec.id] =</div>
<div class="line">             block.specs[spec.name] =</div>
<div class="line">             <span class="keyword">new</span> angular.scenario.ObjectModel.Spec(spec.id, spec.name, definitions);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;SpecBegin&#39;</span>, it);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecError&#39;</span>, <span class="keyword">function</span>(spec, error) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id);</div>
<div class="line">    it.status = <span class="stringliteral">&#39;error&#39;</span>;</div>
<div class="line">    it.error = error;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;SpecError&#39;</span>, it, error);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecEnd&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id);</div>
<div class="line">    complete(it);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;SpecEnd&#39;</span>, it);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepBegin&#39;</span>, <span class="keyword">function</span>(spec, step) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id);</div>
<div class="line">    step = <span class="keyword">new</span> angular.scenario.ObjectModel.Step(step.name);</div>
<div class="line">    it.steps.push(step);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepBegin&#39;</span>, it, step);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepEnd&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id);</div>
<div class="line">    var step = it.getLastStep();</div>
<div class="line">    <span class="keywordflow">if</span> (step.name !== step.name) {</div>
<div class="line">      <span class="keywordflow">throw</span> <span class="stringliteral">&#39;Events fired in the wrong order. Step names don\&#39;t match.&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">    complete(step);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepEnd&#39;</span>, it, step);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepFailure&#39;</span>, <span class="keyword">function</span>(spec, step, error) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id),</div>
<div class="line">        modelStep = it.getLastStep();</div>
<div class="line"></div>
<div class="line">    modelStep.setErrorStatus(<span class="stringliteral">&#39;failure&#39;</span>, error, step.line());</div>
<div class="line">    it.setStatusFromStep(modelStep);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepFailure&#39;</span>, it, modelStep, error);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepError&#39;</span>, <span class="keyword">function</span>(spec, step, error) {</div>
<div class="line">    var it = <span class="keyword">self</span>.getSpec(spec.id),</div>
<div class="line">        modelStep = it.getLastStep();</div>
<div class="line"></div>
<div class="line">    modelStep.setErrorStatus(<span class="stringliteral">&#39;error&#39;</span>, error, step.line());</div>
<div class="line">    it.setStatusFromStep(modelStep);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// forward the event</span></div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepError&#39;</span>, it, modelStep, error);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;RunnerBegin&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;RunnerBegin&#39;</span>);</div>
<div class="line">  });</div>
<div class="line">  runner.on(<span class="stringliteral">&#39;RunnerEnd&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;RunnerEnd&#39;</span>);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> complete(item) {</div>
<div class="line">    item.endTime = Date.now();</div>
<div class="line">    item.duration = item.endTime - item.startTime;</div>
<div class="line">    item.status = item.status || <span class="stringliteral">&#39;success&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.prototype.on = <span class="keyword">function</span>(eventName, listener) {</div>
<div class="line">  eventName = eventName.toLowerCase();</div>
<div class="line">  this.listeners[eventName] = this.listeners[eventName] || [];</div>
<div class="line">  this.listeners[eventName].push(listener);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.prototype.emit = <span class="keyword">function</span>(eventName) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>,</div>
<div class="line">      args = Array.prototype.slice.call(arguments, 1);</div>
<div class="line"></div>
<div class="line">  eventName = eventName.toLowerCase();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (this.listeners[eventName]) {</div>
<div class="line">    angular.forEach(this.listeners[eventName], <span class="keyword">function</span>(listener) {</div>
<div class="line">      listener.apply(<span class="keyword">self</span>, args);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.prototype.getDefinitionPath = <span class="keyword">function</span>(spec) {</div>
<div class="line">  var path = [];</div>
<div class="line">  var currentDefinition = spec.definition;</div>
<div class="line">  <span class="keywordflow">while</span> (currentDefinition &amp;&amp; currentDefinition.name) {</div>
<div class="line">    path.unshift(currentDefinition);</div>
<div class="line">    currentDefinition = currentDefinition.parent;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> path;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.prototype.getSpec = <span class="keyword">function</span>(id) {</div>
<div class="line">  <span class="keywordflow">return</span> this.specMap[id];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Spec = <span class="keyword">function</span>(id, name, definitionNames) {</div>
<div class="line">  this.<span class="keywordtype">id</span> = id;</div>
<div class="line">  this.name = name;</div>
<div class="line">  this.startTime = Date.now();</div>
<div class="line">  this.steps = [];</div>
<div class="line">  this.fullDefinitionName = (definitionNames || []).join(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Spec.prototype.addStep = <span class="keyword">function</span>(name) {</div>
<div class="line">  var step = <span class="keyword">new</span> angular.scenario.ObjectModel.Step(name);</div>
<div class="line">  this.steps.push(step);</div>
<div class="line">  <span class="keywordflow">return</span> step;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Spec.prototype.getLastStep = <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.steps[this.steps.length - 1];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Spec.prototype.setStatusFromStep = <span class="keyword">function</span>(step) {</div>
<div class="line">  <span class="keywordflow">if</span> (!this.status || step.status == <span class="stringliteral">&#39;error&#39;</span>) {</div>
<div class="line">    this.status = step.status;</div>
<div class="line">    this.error = step.error;</div>
<div class="line">    this.line = step.line;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Step = <span class="keyword">function</span>(name) {</div>
<div class="line">  this.name = name;</div>
<div class="line">  this.startTime = Date.now();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.ObjectModel.Step.prototype.setErrorStatus = <span class="keyword">function</span>(status, error, line) {</div>
<div class="line">  this.status = status;</div>
<div class="line">  this.error = error;</div>
<div class="line">  this.line = line;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner = <span class="keyword">function</span>($window) {</div>
<div class="line">  this.listeners = [];</div>
<div class="line">  this.$window = $window;</div>
<div class="line">  this.rootDescribe = <span class="keyword">new</span> angular.scenario.Describe();</div>
<div class="line">  this.currentDescribe = this.rootDescribe;</div>
<div class="line">  this.api = {</div>
<div class="line">    it: this.it,</div>
<div class="line">    iit: this.iit,</div>
<div class="line">    xit: angular.noop,</div>
<div class="line">    describe: this.describe,</div>
<div class="line">    ddescribe: this.ddescribe,</div>
<div class="line">    xdescribe: angular.noop,</div>
<div class="line">    beforeEach: this.beforeEach,</div>
<div class="line">    afterEach: this.afterEach</div>
<div class="line">  };</div>
<div class="line">  angular.forEach(this.api, angular.bind(<span class="keyword">this</span>, <span class="keyword">function</span>(fn, key) {</div>
<div class="line">    this.$window[key] = angular.bind(this, fn);</div>
<div class="line">  }));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.emit = <span class="keyword">function</span>(eventName) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  var args = Array.prototype.slice.call(arguments, 1);</div>
<div class="line">  eventName = eventName.toLowerCase();</div>
<div class="line">  <span class="keywordflow">if</span> (!this.listeners[eventName]) {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  angular.forEach(this.listeners[eventName], <span class="keyword">function</span>(listener) {</div>
<div class="line">    listener.apply(<span class="keyword">self</span>, args);</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.on = <span class="keyword">function</span>(eventName, listener) {</div>
<div class="line">  eventName = eventName.toLowerCase();</div>
<div class="line">  this.listeners[eventName] = this.listeners[eventName] || [];</div>
<div class="line">  this.listeners[eventName].push(listener);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.describe = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  this.currentDescribe.describe(name, <span class="keyword">function</span>() {</div>
<div class="line">    var parentDescribe = <span class="keyword">self</span>.currentDescribe;</div>
<div class="line">    <span class="keyword">self</span>.currentDescribe = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      body.call(<span class="keyword">this</span>);</div>
<div class="line">    } <span class="keywordflow">finally</span> {</div>
<div class="line">      <span class="keyword">self</span>.currentDescribe = parentDescribe;</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.ddescribe = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  this.currentDescribe.ddescribe(name, <span class="keyword">function</span>() {</div>
<div class="line">    var parentDescribe = <span class="keyword">self</span>.currentDescribe;</div>
<div class="line">    <span class="keyword">self</span>.currentDescribe = <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">      body.call(<span class="keyword">this</span>);</div>
<div class="line">    } <span class="keywordflow">finally</span> {</div>
<div class="line">      <span class="keyword">self</span>.currentDescribe = parentDescribe;</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.it = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  this.currentDescribe.it(name, body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.iit = <span class="keyword">function</span>(name, body) {</div>
<div class="line">  this.currentDescribe.iit(name, body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.beforeEach = <span class="keyword">function</span>(body) {</div>
<div class="line">  this.currentDescribe.beforeEach(body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.afterEach = <span class="keyword">function</span>(body) {</div>
<div class="line">  this.currentDescribe.afterEach(body);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.createSpecRunner_ = <span class="keyword">function</span>(scope) {</div>
<div class="line">  var child = scope.$new();</div>
<div class="line">  var Cls = angular.scenario.SpecRunner;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Export all the methods to child scope manually as now we don&#39;t mess controllers with scopes</span></div>
<div class="line">  <span class="comment">// TODO(vojta): refactor scenario runner so that these objects are not tightly coupled as current</span></div>
<div class="line">  <span class="keywordflow">for</span> (var name in Cls.prototype) {</div>
<div class="line">    child[name] = angular.bind(child, Cls.prototype[name]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  Cls.call(child);</div>
<div class="line">  <span class="keywordflow">return</span> child;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.Runner.prototype.run = <span class="keyword">function</span>(application) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  var $root = angular.injector([<span class="stringliteral">&#39;ng&#39;</span>]).get(<span class="stringliteral">&#39;$rootScope&#39;</span>);</div>
<div class="line">  angular.extend($root, <span class="keyword">this</span>);</div>
<div class="line">  angular.forEach(angular.scenario.Runner.prototype, <span class="keyword">function</span>(fn, name) {</div>
<div class="line">    $root[name] = angular.bind(self, fn);</div>
<div class="line">  });</div>
<div class="line">  $root.application = application;</div>
<div class="line">  $root.emit(<span class="stringliteral">&#39;RunnerBegin&#39;</span>);</div>
<div class="line">  asyncForEach(this.rootDescribe.getSpecs(), <span class="keyword">function</span>(spec, specDone) {</div>
<div class="line">    var dslCache = {};</div>
<div class="line">    var runner = <span class="keyword">self</span>.createSpecRunner_($root);</div>
<div class="line">    angular.forEach(angular.scenario.dsl, <span class="keyword">function</span>(fn, key) {</div>
<div class="line">      dslCache[key] = fn.call($root);</div>
<div class="line">    });</div>
<div class="line">    angular.forEach(angular.scenario.dsl, <span class="keyword">function</span>(fn, key) {</div>
<div class="line">      self.$window[key] = function() {</div>
<div class="line">        var line = callerFile(3);</div>
<div class="line">        var scope = runner.$new();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make the dsl accessible on the current chain</span></div>
<div class="line">        scope.dsl = {};</div>
<div class="line">        angular.forEach(dslCache, function(fn, key) {</div>
<div class="line">          scope.dsl[key] = function() {</div>
<div class="line">            return dslCache[key].apply(scope, arguments);</div>
<div class="line">          };</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Make these methods work on the current chain</span></div>
<div class="line">        scope.addFuture = function() {</div>
<div class="line">          Array.prototype.push.call(arguments, line);</div>
<div class="line">          return angular.scenario.SpecRunner.</div>
<div class="line">            prototype.addFuture.apply(scope, arguments);</div>
<div class="line">        };</div>
<div class="line">        scope.addFutureAction = function() {</div>
<div class="line">          Array.prototype.push.call(arguments, line);</div>
<div class="line">          return angular.scenario.SpecRunner.</div>
<div class="line">            prototype.addFutureAction.apply(scope, arguments);</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        return scope.dsl[key].apply(scope, arguments);</div>
<div class="line">      };</div>
<div class="line">    });</div>
<div class="line">    runner.run(spec, <span class="keyword">function</span>() {</div>
<div class="line">      runner.$destroy();</div>
<div class="line">      specDone.apply(<span class="keyword">this</span>, arguments);</div>
<div class="line">    });</div>
<div class="line">  },</div>
<div class="line">  <span class="keyword">function</span>(error) {</div>
<div class="line">    <span class="keywordflow">if</span> (error) {</div>
<div class="line">      <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;RunnerError&#39;</span>, error);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;RunnerEnd&#39;</span>);</div>
<div class="line">  });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.SpecRunner = <span class="keyword">function</span>() {</div>
<div class="line">  this.futures = [];</div>
<div class="line">  this.afterIndex = 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.SpecRunner.prototype.run = <span class="keyword">function</span>(spec, specDone) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  this.spec = spec;</div>
<div class="line"></div>
<div class="line">  this.emit(<span class="stringliteral">&#39;SpecBegin&#39;</span>, spec);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    spec.before.call(<span class="keyword">this</span>);</div>
<div class="line">    spec.body.call(<span class="keyword">this</span>);</div>
<div class="line">    this.afterIndex = this.futures.length;</div>
<div class="line">    spec.after.call(<span class="keyword">this</span>);</div>
<div class="line">  } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">    this.emit(<span class="stringliteral">&#39;SpecError&#39;</span>, spec, e);</div>
<div class="line">    this.emit(<span class="stringliteral">&#39;SpecEnd&#39;</span>, spec);</div>
<div class="line">    specDone();</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  var handleError = <span class="keyword">function</span>(error, done) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">self</span>.error) {</div>
<div class="line">      <span class="keywordflow">return</span> done();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">self</span>.error = <span class="keyword">true</span>;</div>
<div class="line">    done(null, <span class="keyword">self</span>.afterIndex);</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  asyncForEach(</div>
<div class="line">    this.futures,</div>
<div class="line">    <span class="keyword">function</span>(future, futureDone) {</div>
<div class="line">      <span class="keyword">self</span>.step = future;</div>
<div class="line">      <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepBegin&#39;</span>, spec, future);</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        future.execute(<span class="keyword">function</span>(error) {</div>
<div class="line">          <span class="keywordflow">if</span> (error) {</div>
<div class="line">            <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepFailure&#39;</span>, spec, future, error);</div>
<div class="line">            <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepEnd&#39;</span>, spec, future);</div>
<div class="line">            <span class="keywordflow">return</span> handleError(error, futureDone);</div>
<div class="line">          }</div>
<div class="line">          <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepEnd&#39;</span>, spec, future);</div>
<div class="line">          <span class="keyword">self</span>.$window.setTimeout(<span class="keyword">function</span>() { futureDone(); }, 0);</div>
<div class="line">        });</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepError&#39;</span>, spec, future, e);</div>
<div class="line">        <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;StepEnd&#39;</span>, spec, future);</div>
<div class="line">        handleError(e, futureDone);</div>
<div class="line">      }</div>
<div class="line">    },</div>
<div class="line">    <span class="keyword">function</span>(e) {</div>
<div class="line">      <span class="keywordflow">if</span> (e) {</div>
<div class="line">        <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;SpecError&#39;</span>, spec, e);</div>
<div class="line">      }</div>
<div class="line">      <span class="keyword">self</span>.emit(<span class="stringliteral">&#39;SpecEnd&#39;</span>, spec);</div>
<div class="line">      <span class="comment">// Call done in a timeout so exceptions don&#39;t recursively</span></div>
<div class="line">      <span class="comment">// call this function</span></div>
<div class="line">      <span class="keyword">self</span>.$window.setTimeout(<span class="keyword">function</span>() { specDone(); }, 0);</div>
<div class="line">    }</div>
<div class="line">  );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.SpecRunner.prototype.addFuture = <span class="keyword">function</span>(name, behavior, line) {</div>
<div class="line">  var future = <span class="keyword">new</span> angular.scenario.Future(name, angular.bind(<span class="keyword">this</span>, behavior), line);</div>
<div class="line">  this.futures.push(future);</div>
<div class="line">  <span class="keywordflow">return</span> future;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.SpecRunner.prototype.addFutureAction = <span class="keyword">function</span>(name, behavior, line) {</div>
<div class="line">  var <span class="keyword">self</span> = <span class="keyword">this</span>;</div>
<div class="line">  var NG = /\[ng\\\:/;</div>
<div class="line">  <span class="keywordflow">return</span> this.addFuture(name, <span class="keyword">function</span>(done) {</div>
<div class="line">    this.application.executeAction(<span class="keyword">function</span>($window, $document) {</div>
<div class="line"></div>
<div class="line">      <span class="comment">//TODO(esprehn): Refactor this so it doesn&#39;t need to be in here.</span></div>
<div class="line">      $document.elements = <span class="keyword">function</span>(selector) {</div>
<div class="line">        var args = Array.prototype.slice.call(arguments, 1);</div>
<div class="line">        selector = (<span class="keyword">self</span>.selector || <span class="stringliteral">&#39;&#39;</span>) + <span class="charliteral">&#39; &#39;</span> + (selector || <span class="stringliteral">&#39;&#39;</span>);</div>
<div class="line">        selector = _jQuery.trim(selector) || <span class="charliteral">&#39;*&#39;</span>;</div>
<div class="line">        angular.forEach(args, <span class="keyword">function</span>(value, index) {</div>
<div class="line">          selector = selector.replace(<span class="charliteral">&#39;$&#39;</span> + (index + 1), value);</div>
<div class="line">        });</div>
<div class="line">        var result = $document.find(selector);</div>
<div class="line">        <span class="keywordflow">if</span> (selector.match(NG)) {</div>
<div class="line">          angular.forEach([<span class="stringliteral">&#39;[ng-&#39;</span>,<span class="stringliteral">&#39;[data-ng-&#39;</span>,<span class="stringliteral">&#39;[x-ng-&#39;</span>], <span class="keyword">function</span>(value, index) {</div>
<div class="line">            result = result.add(selector.replace(NG, value), $document);</div>
<div class="line">          });</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (!result.length) {</div>
<div class="line">          <span class="keywordflow">throw</span> {</div>
<div class="line">            type: <span class="stringliteral">&#39;selector&#39;</span>,</div>
<div class="line">            message: <span class="stringliteral">&#39;Selector &#39;</span> + selector + <span class="stringliteral">&#39; did not match any elements.&#39;</span></div>
<div class="line">          };</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        behavior.call(<span class="keyword">self</span>, $window, $document, done);</div>
<div class="line">      } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">        <span class="keywordflow">if</span> (e.type &amp;&amp; e.type === <span class="stringliteral">&#39;selector&#39;</span>) {</div>
<div class="line">          done(e.message);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keywordflow">throw</span> e;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line">  }, line);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;pause&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFuture(<span class="stringliteral">&#39;pausing for you to resume&#39;</span>, <span class="keyword">function</span>(done) {</div>
<div class="line">      this.emit(<span class="stringliteral">&#39;InteractivePause&#39;</span>, this.spec, this.step);</div>
<div class="line">      this.$window.resume = <span class="keyword">function</span>() { done(); };</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;sleep&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(time) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFuture(<span class="stringliteral">&#39;sleep for &#39;</span> + time + <span class="stringliteral">&#39; seconds&#39;</span>, <span class="keyword">function</span>(done) {</div>
<div class="line">      this.$window.setTimeout(<span class="keyword">function</span>() { done(null, time * 1000); }, time * 1000);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;browser&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var chain = {};</div>
<div class="line"></div>
<div class="line">  chain.navigateTo = <span class="keyword">function</span>(url, delegate) {</div>
<div class="line">    var application = this.application;</div>
<div class="line">    <span class="keywordflow">return</span> this.addFuture(<span class="stringliteral">&quot;browser navigate to &#39;&quot;</span> + url + <span class="stringliteral">&quot;&#39;&quot;</span>, <span class="keyword">function</span>(done) {</div>
<div class="line">      <span class="keywordflow">if</span> (delegate) {</div>
<div class="line">        url = delegate.call(<span class="keyword">this</span>, url);</div>
<div class="line">      }</div>
<div class="line">      application.navigateTo(url, <span class="keyword">function</span>() {</div>
<div class="line">        done(null, url);</div>
<div class="line">      }, done);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.reload = <span class="keyword">function</span>() {</div>
<div class="line">    var application = this.application;</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;browser reload&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">      var href = $window.location.href;</div>
<div class="line">      application.navigateTo(href, <span class="keyword">function</span>() {</div>
<div class="line">        done(null, href);</div>
<div class="line">      }, done);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.window = <span class="keyword">function</span>() {</div>
<div class="line">    var api = {};</div>
<div class="line"></div>
<div class="line">    api.href = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;window.location.href&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $window.location.href);</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.path = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;window.location.path&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $window.location.pathname);</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.search = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;window.location.search&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $window.location.search);</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.hash = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;window.location.hash&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $window.location.hash.replace(<span class="charliteral">&#39;#&#39;</span>, <span class="stringliteral">&#39;&#39;</span>));</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> api;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.location = <span class="keyword">function</span>() {</div>
<div class="line">    var api = {};</div>
<div class="line"></div>
<div class="line">    api.url = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;$location.url()&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $document.injector().get(<span class="stringliteral">&#39;$location&#39;</span>).url());</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.path = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;$location.path()&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $document.injector().get(<span class="stringliteral">&#39;$location&#39;</span>).path());</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.search = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;$location.search()&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $document.injector().get(<span class="stringliteral">&#39;$location&#39;</span>).search());</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    api.hash = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;$location.hash()&#39;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $document.injector().get(<span class="stringliteral">&#39;$location&#39;</span>).hash());</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> api;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;expect&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var chain = angular.extend({}, angular.scenario.matcher);</div>
<div class="line"></div>
<div class="line">  chain.not = <span class="keyword">function</span>() {</div>
<div class="line">    this.inverse = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(future) {</div>
<div class="line">    this.future = future;</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;using&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(selector, label) {</div>
<div class="line">    this.selector = _jQuery.trim((this.selector || <span class="stringliteral">&#39;&#39;</span>) + <span class="charliteral">&#39; &#39;</span> + selector);</div>
<div class="line">    <span class="keywordflow">if</span> (angular.isString(label) &amp;&amp; label.length) {</div>
<div class="line">      this.label = label + <span class="stringliteral">&#39; ( &#39;</span> + this.selector + <span class="stringliteral">&#39; )&#39;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      this.label = this.selector;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> this.dsl;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;binding&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(name) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;select binding &#39;&quot;</span> + name + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var values = $document.elements().bindings($window.angular.element, name);</div>
<div class="line">        <span class="keywordflow">if</span> (!values.length) {</div>
<div class="line">          <span class="keywordflow">return</span> done(<span class="stringliteral">&quot;Binding selector &#39;&quot;</span> + name + <span class="stringliteral">&quot;&#39; did not match.&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        done(null, values[0]);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;input&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var chain = {};</div>
<div class="line">  var supportInputEvent = <span class="stringliteral">&#39;oninput&#39;</span> in document.createElement(<span class="stringliteral">&#39;div&#39;</span>) &amp;&amp; !(msie &amp;&amp; msie &lt;= 11);</div>
<div class="line"></div>
<div class="line">  chain.enter = <span class="keyword">function</span>(value, event) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;input &#39;&quot;</span> + this.name + <span class="stringliteral">&quot;&#39; enter &#39;&quot;</span> + value + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var input = $document.elements(<span class="stringliteral">&#39;[ng\\:model=&quot;$1&quot;]&#39;</span>, this.name).filter(<span class="stringliteral">&#39;:input&#39;</span>);</div>
<div class="line">        input.val(value);</div>
<div class="line">        input.trigger(event || (supportInputEvent ? <span class="stringliteral">&#39;input&#39;</span> : <span class="stringliteral">&#39;change&#39;</span>));</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.check = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;checkbox &#39;&quot;</span> + this.name + <span class="stringliteral">&quot;&#39; toggle&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var input = $document.elements(<span class="stringliteral">&#39;[ng\\:model=&quot;$1&quot;]&#39;</span>, this.name).filter(<span class="stringliteral">&#39;:checkbox&#39;</span>);</div>
<div class="line">        input.trigger(<span class="stringliteral">&#39;click&#39;</span>);</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.select = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;radio button &#39;&quot;</span> + this.name + <span class="stringliteral">&quot;&#39; toggle &#39;&quot;</span> + value + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var input = $document.</div>
<div class="line">          elements(<span class="stringliteral">&#39;[ng\\:model=&quot;$1&quot;][value=&quot;$2&quot;]&#39;</span>, this.name, value).filter(<span class="stringliteral">&#39;:radio&#39;</span>);</div>
<div class="line">        input.trigger(<span class="stringliteral">&#39;click&#39;</span>);</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.val = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;return input val&quot;</span>, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">      var input = $document.elements(<span class="stringliteral">&#39;[ng\\:model=&quot;$1&quot;]&#39;</span>, this.name).filter(<span class="stringliteral">&#39;:input&#39;</span>);</div>
<div class="line">      done(null,input.val());</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(name) {</div>
<div class="line">    this.name = name;</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;repeater&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var chain = {};</div>
<div class="line"></div>
<div class="line">  chain.count = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;repeater &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; count&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          done(null, $document.elements().length);</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          done(null, 0);</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.column = <span class="keyword">function</span>(binding) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;repeater &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; column &#39;&quot;</span> + binding + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        done(null, $document.elements().bindings($window.angular.element, binding));</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.row = <span class="keyword">function</span>(index) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;repeater &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; row &#39;&quot;</span> + index + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var matches = $document.elements().slice(index, index + 1);</div>
<div class="line">        <span class="keywordflow">if</span> (!matches.length) {</div>
<div class="line">          <span class="keywordflow">return</span> done(<span class="stringliteral">&#39;row &#39;</span> + index + <span class="stringliteral">&#39; out of bounds&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">        done(null, matches.bindings($window.angular.element));</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(selector, label) {</div>
<div class="line">    this.dsl.using(selector, label);</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;select&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var chain = {};</div>
<div class="line"></div>
<div class="line">  chain.option = <span class="keyword">function</span>(value) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;select &#39;&quot;</span> + this.name + <span class="stringliteral">&quot;&#39; option &#39;&quot;</span> + value + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var select = $document.elements(<span class="stringliteral">&#39;select[ng\\:model=&quot;$1&quot;]&#39;</span>, this.name);</div>
<div class="line">        var option = select.find(<span class="stringliteral">&#39;option[value=&quot;&#39;</span> + value + <span class="stringliteral">&#39;&quot;]&#39;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (option.length) {</div>
<div class="line">          select.val(value);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          option = select.find(<span class="stringliteral">&#39;option&#39;</span>).filter(<span class="keyword">function</span>() {</div>
<div class="line">            <span class="keywordflow">return</span> _jQuery(<span class="keyword">this</span>).text() === value;</div>
<div class="line">          });</div>
<div class="line">          <span class="keywordflow">if</span> (!option.length) {</div>
<div class="line">            option = select.find(<span class="stringliteral">&#39;option:contains(&quot;&#39;</span> + value + <span class="stringliteral">&#39;&quot;)&#39;</span>);</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> (option.length) {</div>
<div class="line">            select.val(option.val());</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="keywordflow">return</span> done(<span class="stringliteral">&quot;option &#39;&quot;</span> + value + <span class="stringliteral">&quot;&#39; not found&quot;</span>);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">        select.trigger(<span class="stringliteral">&#39;change&#39;</span>);</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.options = <span class="keyword">function</span>() {</div>
<div class="line">    var values = arguments;</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;select &#39;&quot;</span> + this.name + <span class="stringliteral">&quot;&#39; options &#39;&quot;</span> + values + <span class="stringliteral">&quot;&#39;&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var select = $document.elements(<span class="stringliteral">&#39;select[multiple][ng\\:model=&quot;$1&quot;]&#39;</span>, this.name);</div>
<div class="line">        select.val(values);</div>
<div class="line">        select.trigger(<span class="stringliteral">&#39;change&#39;</span>);</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(name) {</div>
<div class="line">    this.name = name;</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.dsl(<span class="stringliteral">&#39;element&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  var KEY_VALUE_METHODS = [<span class="stringliteral">&#39;attr&#39;</span>, <span class="stringliteral">&#39;css&#39;</span>, <span class="stringliteral">&#39;prop&#39;</span>];</div>
<div class="line">  var VALUE_METHODS = [</div>
<div class="line">    <span class="stringliteral">&#39;val&#39;</span>, <span class="stringliteral">&#39;text&#39;</span>, <span class="stringliteral">&#39;html&#39;</span>, <span class="stringliteral">&#39;height&#39;</span>, <span class="stringliteral">&#39;innerHeight&#39;</span>, <span class="stringliteral">&#39;outerHeight&#39;</span>, <span class="stringliteral">&#39;width&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;innerWidth&#39;</span>, <span class="stringliteral">&#39;outerWidth&#39;</span>, <span class="stringliteral">&#39;position&#39;</span>, <span class="stringliteral">&#39;scrollLeft&#39;</span>, <span class="stringliteral">&#39;scrollTop&#39;</span>, <span class="stringliteral">&#39;offset&#39;</span></div>
<div class="line">  ];</div>
<div class="line">  var chain = {};</div>
<div class="line"></div>
<div class="line">  chain.count = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; count&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          done(null, $document.elements().length);</div>
<div class="line">        } <span class="keywordflow">catch</span> (e) {</div>
<div class="line">          done(null, 0);</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.click = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; click&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var elements = $document.elements();</div>
<div class="line">        var href = elements.attr(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">        var eventProcessDefault = elements.trigger(<span class="stringliteral">&#39;click&#39;</span>)[0];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (href &amp;&amp; elements[0].nodeName.toLowerCase() === <span class="charliteral">&#39;a&#39;</span> &amp;&amp; eventProcessDefault) {</div>
<div class="line">          this.application.navigateTo(href, <span class="keyword">function</span>() {</div>
<div class="line">            done();</div>
<div class="line">          }, done);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          done();</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.dblclick = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; dblclick&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var elements = $document.elements();</div>
<div class="line">        var href = elements.attr(<span class="stringliteral">&#39;href&#39;</span>);</div>
<div class="line">        var eventProcessDefault = elements.trigger(<span class="stringliteral">&#39;dblclick&#39;</span>)[0];</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (href &amp;&amp; elements[0].nodeName.toLowerCase() === <span class="charliteral">&#39;a&#39;</span> &amp;&amp; eventProcessDefault) {</div>
<div class="line">          this.application.navigateTo(href, <span class="keyword">function</span>() {</div>
<div class="line">            done();</div>
<div class="line">          }, done);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          done();</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.mouseover = <span class="keyword">function</span>() {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; mouseover&quot;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var elements = $document.elements();</div>
<div class="line">        elements.trigger(<span class="stringliteral">&#39;mouseover&#39;</span>);</div>
<div class="line">        done();</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  chain.mousedown = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; mousedown&quot;</span>,</div>
<div class="line">        <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">          var elements = $document.elements();</div>
<div class="line">          elements.trigger(<span class="stringliteral">&#39;mousedown&#39;</span>);</div>
<div class="line">          done();</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">  chain.mouseup = <span class="keyword">function</span>() {</div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; mouseup&quot;</span>,</div>
<div class="line">        <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">          var elements = $document.elements();</div>
<div class="line">          elements.trigger(<span class="stringliteral">&#39;mouseup&#39;</span>);</div>
<div class="line">          done();</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">  chain.query = <span class="keyword">function</span>(fn) {</div>
<div class="line">    <span class="keywordflow">return</span> this.addFutureAction(<span class="stringliteral">&#39;element &#39;</span> + this.label + <span class="stringliteral">&#39; custom query&#39;</span>,</div>
<div class="line">      <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        fn.call(<span class="keyword">this</span>, $document.elements(), done);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  angular.forEach(KEY_VALUE_METHODS, <span class="keyword">function</span>(methodName) {</div>
<div class="line">    chain[methodName] = <span class="keyword">function</span>(name, value) {</div>
<div class="line">      var args = arguments,</div>
<div class="line">          futureName = (args.length == 1)</div>
<div class="line">              ? <span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; get &quot;</span> + methodName + <span class="stringliteral">&quot; &#39;&quot;</span> + name + <span class="stringliteral">&quot;&#39;&quot;</span></div>
<div class="line">              : <span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; set &quot;</span> + methodName + <span class="stringliteral">&quot; &#39;&quot;</span> + name + <span class="stringliteral">&quot;&#39; to &quot;</span> + <span class="stringliteral">&quot;&#39;&quot;</span> +</div>
<div class="line">                value + <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(futureName, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var element = $document.elements();</div>
<div class="line">        done(null, element[methodName].apply(element, args));</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  angular.forEach(VALUE_METHODS, <span class="keyword">function</span>(methodName) {</div>
<div class="line">    chain[methodName] = <span class="keyword">function</span>(value) {</div>
<div class="line">      var args = arguments,</div>
<div class="line">          futureName = (args.length === 0)</div>
<div class="line">              ? <span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; &quot;</span> + methodName</div>
<div class="line">              : <span class="stringliteral">&quot;element &#39;&quot;</span> + this.label + <span class="stringliteral">&quot;&#39; set &quot;</span> + methodName + <span class="stringliteral">&quot; to &#39;&quot;</span> + value + <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> this.addFutureAction(futureName, <span class="keyword">function</span>($window, $document, done) {</div>
<div class="line">        var element = $document.elements();</div>
<div class="line">        done(null, element[methodName].apply(element, args));</div>
<div class="line">      });</div>
<div class="line">    };</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">function</span>(selector, label) {</div>
<div class="line">    this.dsl.using(selector, label);</div>
<div class="line">    <span class="keywordflow">return</span> chain;</div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toEqual&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> angular.equals(this.actual, expected);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBe&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> this.actual === expected;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeDefined&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> angular.isDefined(this.actual);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeTruthy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.actual;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeFalsy&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> !this.actual;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toMatch&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">new</span> RegExp(expected).test(this.actual);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeNull&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">  <span class="keywordflow">return</span> this.actual === null;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toContain&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> includes(this.actual, expected);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeLessThan&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> this.actual &lt; expected;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.matcher(<span class="stringliteral">&#39;toBeGreaterThan&#39;</span>, <span class="keyword">function</span>(expected) {</div>
<div class="line">  <span class="keywordflow">return</span> this.actual &gt; expected;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.output(<span class="stringliteral">&#39;html&#39;</span>, <span class="keyword">function</span>(context, runner, model) {</div>
<div class="line">  var specUiMap = {},</div>
<div class="line">      lastStepUiMap = {};</div>
<div class="line"></div>
<div class="line">  context.append(</div>
<div class="line">    <span class="stringliteral">&#39;&lt;div id=&quot;header&quot;&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;  &lt;h1&gt;&lt;span class=&quot;angular&quot;&gt;AngularJS&lt;/span&gt;: Scenario Test Runner&lt;/h1&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;  &lt;ul id=&quot;status-legend&quot; class=&quot;status-display&quot;&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;    &lt;li class=&quot;status-error&quot;&gt;0 Errors&lt;/li&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;    &lt;li class=&quot;status-failure&quot;&gt;0 Failures&lt;/li&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;    &lt;li class=&quot;status-success&quot;&gt;0 Passed&lt;/li&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;  &lt;/ul&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;&lt;/div&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;&lt;div id=&quot;specs&quot;&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;  &lt;div class=&quot;test-children&quot;&gt;&lt;/div&gt;&#39;</span> +</div>
<div class="line">    <span class="stringliteral">&#39;&lt;/div&gt;&#39;</span></div>
<div class="line">  );</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;InteractivePause&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var ui = lastStepUiMap[spec.id];</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;.test-title&#39;</span>).</div>
<div class="line">      html(<span class="stringliteral">&#39;paused... &lt;a href=&quot;javascript:resume()&quot;&gt;resume&lt;/a&gt; when ready.&#39;</span>);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecBegin&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var ui = findContext(spec);</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;&gt; .tests&#39;</span>).append(</div>
<div class="line">      <span class="stringliteral">&#39;&lt;li class=&quot;status-pending test-it&quot;&gt;&lt;/li&gt;&#39;</span></div>
<div class="line">    );</div>
<div class="line">    ui = ui.find(<span class="stringliteral">&#39;&gt; .tests li:last&#39;</span>);</div>
<div class="line">    ui.append(</div>
<div class="line">      <span class="stringliteral">&#39;&lt;div class=&quot;test-info&quot;&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;  &lt;p class=&quot;test-title&quot;&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;    &lt;span class=&quot;timer-result&quot;&gt;&lt;/span&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;    &lt;span class=&quot;test-name&quot;&gt;&lt;/span&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;  &lt;/p&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;&lt;/div&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;&lt;div class=&quot;scrollpane&quot;&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;  &lt;ol class=&quot;test-actions&quot;&gt;&lt;/ol&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;&lt;/div&gt;&#39;</span></div>
<div class="line">    );</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;&gt; .test-info .test-name&#39;</span>).text(spec.name);</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;&gt; .test-info&#39;</span>).click(<span class="keyword">function</span>() {</div>
<div class="line">      var scrollpane = ui.find(<span class="stringliteral">&#39;&gt; .scrollpane&#39;</span>);</div>
<div class="line">      var actions = scrollpane.find(<span class="stringliteral">&#39;&gt; .test-actions&#39;</span>);</div>
<div class="line">      var name = context.find(<span class="stringliteral">&#39;&gt; .test-info .test-name&#39;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (actions.find(<span class="stringliteral">&#39;:visible&#39;</span>).length) {</div>
<div class="line">        actions.hide();</div>
<div class="line">        name.removeClass(<span class="stringliteral">&#39;open&#39;</span>).addClass(<span class="stringliteral">&#39;closed&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        actions.show();</div>
<div class="line">        scrollpane.attr(<span class="stringliteral">&#39;scrollTop&#39;</span>, scrollpane.attr(<span class="stringliteral">&#39;scrollHeight&#39;</span>));</div>
<div class="line">        name.removeClass(<span class="stringliteral">&#39;closed&#39;</span>).addClass(<span class="stringliteral">&#39;open&#39;</span>);</div>
<div class="line">      }</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    specUiMap[spec.id] = ui;</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecError&#39;</span>, <span class="keyword">function</span>(spec, error) {</div>
<div class="line">    var ui = specUiMap[spec.id];</div>
<div class="line">    ui.append(<span class="stringliteral">&#39;&lt;pre&gt;&lt;/pre&gt;&#39;</span>);</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;&gt; pre&#39;</span>).text(formatException(error));</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;SpecEnd&#39;</span>, <span class="keyword">function</span>(spec) {</div>
<div class="line">    var ui = specUiMap[spec.id];</div>
<div class="line">    spec = model.getSpec(spec.id);</div>
<div class="line">    ui.removeClass(<span class="stringliteral">&#39;status-pending&#39;</span>);</div>
<div class="line">    ui.addClass(<span class="stringliteral">&#39;status-&#39;</span> + spec.status);</div>
<div class="line">    ui.find(<span class="stringliteral">&quot;&gt; .test-info .timer-result&quot;</span>).text(spec.duration + <span class="stringliteral">&quot;ms&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (spec.status === <span class="stringliteral">&#39;success&#39;</span>) {</div>
<div class="line">      ui.find(<span class="stringliteral">&#39;&gt; .test-info .test-name&#39;</span>).addClass(<span class="stringliteral">&#39;closed&#39;</span>);</div>
<div class="line">      ui.find(<span class="stringliteral">&#39;&gt; .scrollpane .test-actions&#39;</span>).hide();</div>
<div class="line">    }</div>
<div class="line">    updateTotals(spec.status);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepBegin&#39;</span>, <span class="keyword">function</span>(spec, step) {</div>
<div class="line">    var ui = specUiMap[spec.id];</div>
<div class="line">    spec = model.getSpec(spec.id);</div>
<div class="line">    step = spec.getLastStep();</div>
<div class="line">    ui.find(<span class="stringliteral">&#39;&gt; .scrollpane .test-actions&#39;</span>).append(<span class="stringliteral">&#39;&lt;li class=&quot;status-pending&quot;&gt;&lt;/li&gt;&#39;</span>);</div>
<div class="line">    var stepUi = lastStepUiMap[spec.id] = ui.find(<span class="stringliteral">&#39;&gt; .scrollpane .test-actions li:last&#39;</span>);</div>
<div class="line">    stepUi.append(</div>
<div class="line">      <span class="stringliteral">&#39;&lt;div class=&quot;timer-result&quot;&gt;&lt;/div&gt;&#39;</span> +</div>
<div class="line">      <span class="stringliteral">&#39;&lt;div class=&quot;test-title&quot;&gt;&lt;/div&gt;&#39;</span></div>
<div class="line">    );</div>
<div class="line">    stepUi.find(<span class="stringliteral">&#39;&gt; .test-title&#39;</span>).text(step.name);</div>
<div class="line">    var scrollpane = stepUi.parents(<span class="stringliteral">&#39;.scrollpane&#39;</span>);</div>
<div class="line">    scrollpane.attr(<span class="stringliteral">&#39;scrollTop&#39;</span>, scrollpane.attr(<span class="stringliteral">&#39;scrollHeight&#39;</span>));</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepFailure&#39;</span>, <span class="keyword">function</span>(spec, step, error) {</div>
<div class="line">    var ui = lastStepUiMap[spec.id];</div>
<div class="line">    addError(ui, step.line, error);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepError&#39;</span>, <span class="keyword">function</span>(spec, step, error) {</div>
<div class="line">    var ui = lastStepUiMap[spec.id];</div>
<div class="line">    addError(ui, step.line, error);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  runner.on(<span class="stringliteral">&#39;StepEnd&#39;</span>, <span class="keyword">function</span>(spec, step) {</div>
<div class="line">    var stepUi = lastStepUiMap[spec.id];</div>
<div class="line">    spec = model.getSpec(spec.id);</div>
<div class="line">    step = spec.getLastStep();</div>
<div class="line">    stepUi.find(<span class="stringliteral">&#39;.timer-result&#39;</span>).text(step.duration + <span class="stringliteral">&#39;ms&#39;</span>);</div>
<div class="line">    stepUi.removeClass(<span class="stringliteral">&#39;status-pending&#39;</span>);</div>
<div class="line">    stepUi.addClass(<span class="stringliteral">&#39;status-&#39;</span> + step.status);</div>
<div class="line">    var scrollpane = specUiMap[spec.id].find(<span class="stringliteral">&#39;&gt; .scrollpane&#39;</span>);</div>
<div class="line">    scrollpane.attr(<span class="stringliteral">&#39;scrollTop&#39;</span>, scrollpane.attr(<span class="stringliteral">&#39;scrollHeight&#39;</span>));</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> findContext(spec) {</div>
<div class="line">    var currentContext = context.find(<span class="stringliteral">&#39;#specs&#39;</span>);</div>
<div class="line">    angular.forEach(model.getDefinitionPath(spec), <span class="keyword">function</span>(defn) {</div>
<div class="line">      var <span class="keywordtype">id</span> = <span class="stringliteral">&#39;describe-&#39;</span> + defn.id;</div>
<div class="line">      <span class="keywordflow">if</span> (!context.find(<span class="charliteral">&#39;#&#39;</span> + <span class="keywordtype">id</span>).length) {</div>
<div class="line">        currentContext.find(<span class="stringliteral">&#39;&gt; .test-children&#39;</span>).append(</div>
<div class="line">          <span class="stringliteral">&#39;&lt;div class=&quot;test-describe&quot; id=&quot;&#39;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&#39;&quot;&gt;&#39;</span> +</div>
<div class="line">          <span class="stringliteral">&#39;  &lt;h2&gt;&lt;/h2&gt;&#39;</span> +</div>
<div class="line">          <span class="stringliteral">&#39;  &lt;div class=&quot;test-children&quot;&gt;&lt;/div&gt;&#39;</span> +</div>
<div class="line">          <span class="stringliteral">&#39;  &lt;ul class=&quot;tests&quot;&gt;&lt;/ul&gt;&#39;</span> +</div>
<div class="line">          <span class="stringliteral">&#39;&lt;/div&gt;&#39;</span></div>
<div class="line">        );</div>
<div class="line">        context.find(<span class="charliteral">&#39;#&#39;</span> + <span class="keywordtype">id</span>).find(<span class="stringliteral">&#39;&gt; h2&#39;</span>).text(<span class="stringliteral">&#39;describe: &#39;</span> + defn.name);</div>
<div class="line">      }</div>
<div class="line">      currentContext = context.find(<span class="charliteral">&#39;#&#39;</span> + <span class="keywordtype">id</span>);</div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> context.find(<span class="stringliteral">&#39;#describe-&#39;</span> + spec.definition.id);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> updateTotals(status) {</div>
<div class="line">    var legend = context.find(<span class="stringliteral">&#39;#status-legend .status-&#39;</span> + status);</div>
<div class="line">    var parts = legend.text().split(<span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">    var value = (parts[0] * 1) + 1;</div>
<div class="line">    legend.text(value + <span class="charliteral">&#39; &#39;</span> + parts[1]);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> addError(context, line, error) {</div>
<div class="line">    context.find(<span class="stringliteral">&#39;.test-title&#39;</span>).append(<span class="stringliteral">&#39;&lt;pre&gt;&lt;/pre&gt;&#39;</span>);</div>
<div class="line">    var message = _jQuery.trim(line() + <span class="stringliteral">&#39;\n\n&#39;</span> + formatException(error));</div>
<div class="line">    context.find(<span class="stringliteral">&#39;.test-title pre:last&#39;</span>).text(message);</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.output(<span class="stringliteral">&#39;json&#39;</span>, <span class="keyword">function</span>(context, runner, model) {</div>
<div class="line">  model.on(<span class="stringliteral">&#39;RunnerEnd&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    context.text(angular.toJson(model.value));</div>
<div class="line">  });</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.output(<span class="stringliteral">&#39;xml&#39;</span>, <span class="keyword">function</span>(context, runner, model) {</div>
<div class="line">  var $ = <span class="keyword">function</span>(args) {<span class="keywordflow">return</span> <span class="keyword">new</span> context.init(args);};</div>
<div class="line">  model.on(<span class="stringliteral">&#39;RunnerEnd&#39;</span>, <span class="keyword">function</span>() {</div>
<div class="line">    var scenario = $(<span class="stringliteral">&#39;&lt;scenario&gt;&lt;/scenario&gt;&#39;</span>);</div>
<div class="line">    context.append(scenario);</div>
<div class="line">    serializeXml(scenario, model.value);</div>
<div class="line">  });</div>
<div class="line"></div>
<div class="line">  <span class="keyword">function</span> serializeXml(context, tree) {</div>
<div class="line">     angular.forEach(tree.children, <span class="keyword">function</span>(child) {</div>
<div class="line">       var describeContext = $(<span class="stringliteral">&#39;&lt;describe&gt;&lt;/describe&gt;&#39;</span>);</div>
<div class="line">       describeContext.attr(<span class="stringliteral">&#39;id&#39;</span>, child.id);</div>
<div class="line">       describeContext.attr(<span class="stringliteral">&#39;name&#39;</span>, child.name);</div>
<div class="line">       context.append(describeContext);</div>
<div class="line">       serializeXml(describeContext, child);</div>
<div class="line">     });</div>
<div class="line">     var its = $(<span class="stringliteral">&#39;&lt;its&gt;&lt;/its&gt;&#39;</span>);</div>
<div class="line">     context.append(its);</div>
<div class="line">     angular.forEach(tree.specs, <span class="keyword">function</span>(spec) {</div>
<div class="line">       var it = $(<span class="stringliteral">&#39;&lt;it&gt;&lt;/it&gt;&#39;</span>);</div>
<div class="line">       it.attr(<span class="stringliteral">&#39;id&#39;</span>, spec.id);</div>
<div class="line">       it.attr(<span class="stringliteral">&#39;name&#39;</span>, spec.name);</div>
<div class="line">       it.attr(<span class="stringliteral">&#39;duration&#39;</span>, spec.duration);</div>
<div class="line">       it.attr(<span class="stringliteral">&#39;status&#39;</span>, spec.status);</div>
<div class="line">       its.append(it);</div>
<div class="line">       angular.forEach(spec.steps, function(step) {</div>
<div class="line">         var stepContext = $(<span class="stringliteral">&#39;&lt;step&gt;&lt;/step&gt;&#39;</span>);</div>
<div class="line">         stepContext.attr(<span class="stringliteral">&#39;name&#39;</span>, step.name);</div>
<div class="line">         stepContext.attr(<span class="stringliteral">&#39;duration&#39;</span>, step.duration);</div>
<div class="line">         stepContext.attr(<span class="stringliteral">&#39;status&#39;</span>, step.status);</div>
<div class="line">         it.append(stepContext);</div>
<div class="line">         if (step.error) {</div>
<div class="line">           var error = $(<span class="stringliteral">&#39;&lt;error&gt;&lt;/error&gt;&#39;</span>);</div>
<div class="line">           stepContext.append(error);</div>
<div class="line">           error.text(formatException(step.error));</div>
<div class="line">         }</div>
<div class="line">       });</div>
<div class="line">     });</div>
<div class="line">   }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">angular.scenario.output(<span class="stringliteral">&#39;object&#39;</span>, <span class="keyword">function</span>(context, runner, model) {</div>
<div class="line">  runner.$window.$result = model.value;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line">bindJQuery();</div>
<div class="line">publishExternalAPI(angular);</div>
<div class="line"></div>
<div class="line">var $runner = <span class="keyword">new</span> angular.scenario.Runner(window),</div>
<div class="line">    scripts = document.getElementsByTagName(<span class="stringliteral">&#39;script&#39;</span>),</div>
<div class="line">    script = scripts[scripts.length - 1],</div>
<div class="line">    config = {};</div>
<div class="line"></div>
<div class="line">angular.forEach(script.attributes, <span class="keyword">function</span>(attr) {</div>
<div class="line">  var match = attr.name.match(/ng[:\-](.*)/);</div>
<div class="line">  if (match) {</div>
<div class="line">    config[match[1]] = attr.value || true;</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (config.autotest) {</div>
<div class="line">  JQLite(document).ready(<span class="keyword">function</span>() {</div>
<div class="line">    angular.scenario.setUpAndRun(config);</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line">})(window, document);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">!window.angular.$$csp().noInlineStyle &amp;&amp; window.angular.element(document.head).prepend(<span class="stringliteral">&#39;&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;\n\n[ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak],\n.ng-cloak, .x-ng-cloak,\n.ng-hide:not(.ng-hide-animate) {\n  display: none !important;\n}\n\nng\\:form {\n  display: block;\n}\n\n.ng-animate-shim {\n  visibility:hidden;\n}\n\n.ng-anchor {\n  position:absolute;\n}\n&lt;/style&gt;&#39;</span>);</div>
<div class="line">!window.angular.$$csp().noInlineStyle &amp;&amp; window.angular.element(document.head).prepend(<span class="stringliteral">&#39;&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;\n/* CSS Document */\n\n/** Structure */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  font-size: 14px;\n}\n\n#system-error {\n  font-size: 1.5em;\n  text-align: center;\n}\n\n#json, #xml {\n  display: none;\n}\n\n#header {\n  position: fixed;\n  width: 100%;\n}\n\n#specs {\n  padding-top: 50px;\n}\n\n#header .angular {\n  font-family: Courier New, monospace;\n  font-weight: bold;\n}\n\n#header h1 {\n  font-weight: normal;\n  float: left;\n  font-size: 30px;\n  line-height: 30px;\n  margin: 0;\n  padding: 10px 10px;\n  height: 30px;\n}\n\n#application h2,\n#specs h2 {\n  margin: 0;\n  padding: 0.5em;\n  font-size: 1.1em;\n}\n\n#status-legend {\n  margin-top: 10px;\n  margin-right: 10px;\n}\n\n#header,\n#application,\n.test-info,\n.test-actions li {\n  overflow: hidden;\n}\n\n#application {\n  margin: 10px;\n}\n\n#application iframe {\n  width: 100%;\n  height: 758px;\n}\n\n#application .popout {\n  float: right;\n}\n\n#application iframe {\n  border: none;\n}\n\n.tests li,\n.test-actions li,\n.test-it li,\n.test-it ol,\n.status-display {\n  list-style-type: none;\n}\n\n.tests,\n.test-it ol,\n.status-display {\n  margin: 0;\n  padding: 0;\n}\n\n.test-info {\n  margin-left: 1em;\n  margin-top: 0.5em;\n  border-radius: 8px 0 0 8px;\n  -webkit-border-radius: 8px 0 0 8px;\n  -moz-border-radius: 8px 0 0 8px;\n  cursor: pointer;\n}\n\n.test-info:hover .test-name {\n  text-decoration: underline;\n}\n\n.test-info .closed:before {\n  content: \&#39;\\25b8\\00A0\&#39;;\n}\n\n.test-info .open:before {\n  content: \&#39;\\25be\\00A0\&#39;;\n  font-weight: bold;\n}\n\n.test-it ol {\n  margin-left: 2.5em;\n}\n\n.status-display,\n.status-display li {\n  float: right;\n}\n\n.status-display li {\n  padding: 5px 10px;\n}\n\n.timer-result,\n.test-title {\n  display: inline-block;\n  margin: 0;\n  padding: 4px;\n}\n\n.test-actions .test-title,\n.test-actions .test-result {\n  display: table-cell;\n  padding-left: 0.5em;\n  padding-right: 0.5em;\n}\n\n.test-actions {\n  display: table;\n}\n\n.test-actions li {\n  display: table-row;\n}\n\n.timer-result {\n  width: 4em;\n  padding: 0 10px;\n  text-align: right;\n  font-family: monospace;\n}\n\n.test-it pre,\n.test-actions pre {\n  clear: left;\n  color: black;\n  margin-left: 6em;\n}\n\n.test-describe {\n  padding-bottom: 0.5em;\n}\n\n.test-describe .test-describe {\n  margin: 5px 5px 10px 2em;\n}\n\n.test-actions .status-pending .test-title:before {\n  content: \&#39;\\00bb\\00A0\&#39;;\n}\n\n.scrollpane {\n   max-height: 20em;\n   overflow: auto;\n}\n\n/** Colors */\n\n#header {\n  background-color: #F2C200;\n}\n\n#specs h2 {\n  border-top: 2px solid #BABAD1;\n}\n\n#specs h2,\n#application h2 {\n  background-color: #efefef;\n}\n\n#application {\n  border: 1px solid #BABAD1;\n}\n\n.test-describe .test-describe {\n  border-left: 1px solid #BABAD1;\n  border-right: 1px solid #BABAD1;\n  border-bottom: 1px solid #BABAD1;\n}\n\n.status-display {\n  border: 1px solid #777;\n}\n\n.status-display .status-pending,\n.status-pending .test-info {\n  background-color: #F9EEBC;\n}\n\n.status-display .status-success,\n.status-success .test-info {\n  background-color: #B1D7A1;\n}\n\n.status-display .status-failure,\n.status-failure .test-info {\n  background-color: #FF8286;\n}\n\n.status-display .status-error,\n.status-error .test-info {\n  background-color: black;\n  color: white;\n}\n\n.test-actions .status-success .test-title {\n  color: #30B30A;\n}\n\n.test-actions .status-failure .test-title {\n  color: #DF0000;\n}\n\n.test-actions .status-error .test-title {\n  color: black;\n}\n\n.test-actions .timer-result {\n  color: #888;\n}\n&lt;/style&gt;&#39;</span>);</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
